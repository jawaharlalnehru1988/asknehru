<!-- <pre>
    <code class="language-javascript" codeHighlight>
        {{code}}
    </code>
</pre> -->

@switch (topicId){ 
@case (1){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">TypeScript Key Features</h1>

  <p class="text-lg text-gray-700 mb-4">
    TypeScript is a strongly typed superset of JavaScript that adds optional
    static typing and other features to enhance the development experience. Here
    are the key features of TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Static Typing
      </h2>
      <p class="text-gray-700">
        TypeScript allows developers to assign specific data types (e.g.,
        number, string, boolean, array, etc.) to variables, function parameters,
        and return types. This helps catch type-related errors at compile time,
        improving code safety and maintainability.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Type Inference
      </h2>
      <p class="text-gray-700">
        TypeScript can automatically infer types based on the assigned values,
        which means you don't have to explicitly annotate types in every case,
        making the code cleaner while still maintaining type safety.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Interfaces and Type Aliases
      </h2>
      <p class="text-gray-700">
        TypeScript provides interfaces to define the structure of objects and
        ensure that they have a consistent shape. Type aliases can be used to
        define custom types, making the code more expressive and reusable.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Classes and Object-Oriented Programming (OOP)
      </h2>
      <p class="text-gray-700">
        TypeScript supports OOP concepts like classes, inheritance, access
        modifiers (public, private, protected), and abstract classes. This
        brings a more structured, traditional approach to JavaScript
        development.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">5. Generics</h2>
      <p class="text-gray-700">
        TypeScript supports generics, allowing you to write reusable and
        flexible code that can work with different data types while maintaining
        type safety.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Type Checking and Compile-Time Error Detection
      </h2>
      <p class="text-gray-700">
        TypeScript performs type checking at compile time, helping developers
        catch potential errors early in the development process, reducing
        runtime issues in production.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Union and Intersection Types
      </h2>
      <p class="text-gray-700">
        Union types allow variables to hold multiple possible types (e.g.,
        number | string), and intersection types let you combine multiple types
        into one, offering more flexibility in defining data structures.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">8. Enums</h2>
      <p class="text-gray-700">
        Enums provide a way to define a set of named constants, improving the
        readability and maintainability of code by representing a collection of
        related values more clearly.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Advanced IDE Support
      </h2>
      <p class="text-gray-700">
        TypeScript integrates well with modern IDEs like VS Code, offering
        powerful tooling such as autocompletion, refactoring tools, and inline
        type hints, which significantly improve developer productivity.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        10. Modules and Namespaces
      </h2>
      <p class="text-gray-700">
        TypeScript supports both ES modules and its own module system, making it
        easy to organize code into reusable components. Namespaces help organize
        large codebases by grouping related code under a common namespace.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        11. Compatibility with JavaScript
      </h2>
      <p class="text-gray-700">
        Since TypeScript is a superset of JavaScript, all valid JavaScript code
        is also valid TypeScript code. This makes it easy to gradually adopt
        TypeScript in existing JavaScript projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        12. Decorators (Experimental)
      </h2>
      <p class="text-gray-700">
        TypeScript supports decorators, which are special annotations used for
        adding metadata to classes and methods. They are commonly used in
        frameworks like Angular to define behaviors like routing, services, or
        component metadata.
      </p>
    </li>
  </ul>
</div>

} @case (2){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">
    Benefits of Using TypeScript
  </h1>

  <p class="text-lg text-gray-700 mb-4">
    TypeScript offers numerous benefits to developers, especially when working
    on large-scale applications or projects that require strong type safety.
    Below are some of the key benefits of using TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Improved Code Quality and Safety
      </h2>
      <p class="text-gray-700">
        By enforcing static typing, TypeScript helps catch type-related errors
        during development, reducing the likelihood of runtime errors. This
        improves overall code quality and safety, making it easier to maintain
        and scale projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Enhanced Developer Experience
      </h2>
      <p class="text-gray-700">
        TypeScript integrates seamlessly with popular IDEs like Visual Studio
        Code, offering advanced features like autocompletion, real-time error
        checking, and intelligent code refactoring. This boosts productivity and
        allows for a smoother development experience.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Early Error Detection
      </h2>
      <p class="text-gray-700">
        TypeScript’s compile-time error checking allows developers to detect and
        fix errors early in the development process. This minimizes the number
        of bugs found during testing and reduces time spent debugging during
        production.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Scalability for Large Projects
      </h2>
      <p class="text-gray-700">
        For large codebases, TypeScript’s static typing and OOP features like
        interfaces, classes, and generics provide a more structured approach.
        This makes it easier to manage and scale complex projects while
        maintaining consistent code quality.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        5. Better Collaboration and Readability
      </h2>
      <p class="text-gray-700">
        The self-documenting nature of TypeScript (through type annotations and
        interfaces) enhances collaboration among team members. Developers can
        easily understand each other's code and work with greater efficiency,
        leading to better readability and maintainability.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Compatibility with JavaScript
      </h2>
      <p class="text-gray-700">
        Since TypeScript is a superset of JavaScript, it can run alongside
        existing JavaScript code. This allows teams to gradually migrate to
        TypeScript without the need for a complete rewrite of legacy code,
        making it an ideal choice for both new and existing projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Strong Ecosystem and Community Support
      </h2>
      <p class="text-gray-700">
        TypeScript has a growing and active community, with support from major
        frameworks like Angular and libraries like React and Vue. The ecosystem
        is mature, offering a wide range of resources, tutorials, and tools to
        support developers.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        8. Enables Modern JavaScript Features
      </h2>
      <p class="text-gray-700">
        TypeScript supports the latest JavaScript features (e.g., async/await,
        destructuring, modules) while ensuring backward compatibility with older
        browsers through transpilation. This means developers can take advantage
        of modern features without sacrificing browser support.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Supports Large-Scale Refactoring
      </h2>
      <p class="text-gray-700">
        TypeScript's strong typing and IDE integration provide powerful
        refactoring capabilities, allowing developers to rename variables,
        functions, or entire modules with confidence, knowing the changes will
        propagate throughout the codebase safely.
      </p>
    </li>
  </ul>
</div>

} @case (3){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">
    Drawbacks of Using TypeScript
  </h1>

  <p class="text-lg text-gray-700 mb-4">
    While TypeScript offers many advantages, it also comes with certain
    drawbacks that developers should be aware of before adopting it in their
    projects. Below are some of the key drawbacks of using TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Additional Learning Curve
      </h2>
      <p class="text-gray-700">
        For developers who are familiar with JavaScript but new to TypeScript,
        there is an additional learning curve. Concepts like static typing,
        interfaces, and generics can take time to grasp, which may slow down the
        initial development process.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Longer Compilation Time
      </h2>
      <p class="text-gray-700">
        TypeScript code needs to be compiled into JavaScript before it can be
        executed. This extra compilation step can introduce delays, especially
        in larger projects, leading to longer build times and slower feedback
        during development.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Increased Project Complexity
      </h2>
      <p class="text-gray-700">
        The introduction of TypeScript can add complexity to a project, as
        developers must manage type definitions, configurations, and potential
        integration issues with third-party libraries. This may increase the
        overall maintenance overhead.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Limited Support for Some JavaScript Libraries
      </h2>
      <p class="text-gray-700">
        Not all JavaScript libraries have complete TypeScript definitions, which
        can make integrating certain libraries difficult. Developers may need to
        write their own type definitions or use third-party tools to ensure
        compatibility.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        5. Larger Codebase
      </h2>
      <p class="text-gray-700">
        TypeScript's strict type enforcement often results in writing more code,
        especially with type annotations. While this improves code safety, it
        can also lead to a larger codebase, which may require additional effort
        to maintain.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Potential Overhead for Small Projects
      </h2>
      <p class="text-gray-700">
        For small projects or scripts, the benefits of TypeScript might not
        justify the added complexity and setup requirements. In such cases, the
        overhead of configuring and maintaining TypeScript might outweigh the
        advantages.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Migration Challenges
      </h2>
      <p class="text-gray-700">
        Migrating existing JavaScript projects to TypeScript can be
        time-consuming, especially for large codebases. Developers must refactor
        code, define types, and address potential issues with dependencies,
        which can slow down the migration process.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        8. Dependency on Build Tools
      </h2>
      <p class="text-gray-700">
        TypeScript relies on build tools like Webpack, Babel, or TypeScript’s
        own compiler to convert TypeScript code into JavaScript. This adds a
        layer of complexity to the development environment, especially for teams
        that are not familiar with these tools.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Debugging Overhead
      </h2>
      <p class="text-gray-700">
        Although TypeScript provides many benefits for catching errors early,
        debugging compiled TypeScript code can sometimes be more challenging
        than debugging plain JavaScript. Developers must use source maps or
        other tools to trace errors back to the original TypeScript source.
      </p>
    </li>
  </ul>
</div>

}@case (4){
<div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
  <h1 class="text-3xl font-bold text-gray-800">TypeScript Compiler (tsc)</h1>

  <p class="text-lg text-gray-700">
    The TypeScript compiler, commonly referred to as
    <code class="font-mono bg-gray-200 p-1 rounded">tsc</code>, is a tool that
    translates TypeScript code into JavaScript. Since browsers and JavaScript
    engines can't execute TypeScript directly,
    <code class="font-mono bg-gray-200 p-1 rounded">tsc</code> is essential in
    converting it.
  </p>

  <div class="space-y-2">
    <h2 class="text-xl font-semibold text-gray-700">
      Key Functions of
      <code class="font-mono bg-gray-200 p-1 rounded">tsc</code>:
    </h2>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">1. Transpilation</h3>
      <p class="text-gray-600">
        Translates TypeScript code into plain JavaScript, allowing it to run in
        any environment supporting JavaScript.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">2. Type Checking</h3>
      <p class="text-gray-600">
        Before converting to JavaScript,
        <code class="font-mono bg-gray-200 p-1 rounded">tsc</code> checks for
        type errors and ensures code consistency based on provided type
        annotations.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">3. Configuration</h3>
      <p class="text-gray-600">
        You can customize the compiler using the
        <code class="font-mono bg-gray-200 p-1 rounded">tsconfig.json</code>
        file to set options like JavaScript target version and module systems.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">
        4. Incremental Compilation
      </h3>
      <p class="text-gray-600">
        The compiler can incrementally compile only changed files, improving
        efficiency in larger projects.
      </p>
    </div>
  </div>
</div>

} @case (5){
<div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
  <h1 class="text-3xl font-bold text-gray-800">
    Type Conversions in TypeScript
  </h1>

  <p class="text-lg text-gray-700">
    TypeScript allows for various ways to convert from one type to another. Type
    conversion, also known as type casting, helps you ensure that data is
    interpreted as expected during code execution.
  </p>

  <div class="space-y-2">
    <h2 class="text-xl font-semibold text-blue-700">
      Key Types of Type Conversions:
    </h2>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        1. Explicit Conversion (Type Casting)
      </h3>
      <p class="text-gray-600">
        In TypeScript, you can explicitly convert one type to another using
        either the angle-bracket syntax (<code
          class="font-mono bg-gray-200 p-1 rounded"
          >&lt;type&gt;</code
        >) or the
        <code class="font-mono bg-gray-200 p-1 rounded">as</code> keyword.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight >let value: any = "123";<br>let num: number = &lt;number&gt;value;</code></pre>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight>let value: any = "123";<br>let num: number = value as number;</code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        2. Implicit Conversion (Type Inference)
      </h3>
      <p class="text-gray-600">
        TypeScript also performs automatic type inference in some cases, where
        it converts one type to another without explicit casting.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight >let num = 123;<br>let str = num + " is a number"; // 'str' becomes a string</code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        3. Built-in Conversion Functions
      </h3>
      <p class="text-gray-600">
        JavaScript (and TypeScript) provides built-in functions like
        <code class="font-mono bg-gray-200 p-1 rounded">Number()</code>,
        <code class="font-mono bg-gray-200 p-1 rounded">String()</code>, and
        <code class="font-mono bg-gray-200 p-1 rounded">Boolean()</code> for
        converting data types.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight>let value: string = "456";<br>let num: number = Number(value);</code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        4. Avoiding Runtime Errors
      </h3>
      <p class="text-gray-600">
        Type conversions help avoid unexpected runtime errors. TypeScript
        ensures that conversions are valid or warns you at compile-time.
      </p>
      <p class="text-gray-600">
        For example, converting a non-numeric string to a number will result in
        <code
          class="language-javascript"
          codeHighlight
          class="font-mono bg-gray-200 p-1 rounded"
          >NaN</code
        >.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight>let invalidNum: number = Number("not a number"); // NaN</code></pre>
    </div>
  </div>
</div>

}@case (6){
  <div class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">TypeScript Loops in Angular</h1>
  
    <p class="mb-4">
      In TypeScript, both <span class="font-semibold">for</span> loops and
      <span class="font-semibold">while</span> loops work similarly to how they do in JavaScript, but with optional static
      typing features that TypeScript provides. Below is an explanation of both types of loops:
    </p>
  
    <!-- For Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">1. For Loop</h2>
      <p class="mb-4">
        A for loop is typically used when you know the number of iterations beforehand. The structure consists of three
        parts: initialization, condition, and increment/decrement.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >for (initialization; condition; increment/decrement) {{'{'}} <br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}}</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>for (let i: number = 0; i < 5; i++)  {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          {{'}'}}</code>
      </pre>
      <p class="my-2">
        <span class="font-semibold">let i: number = 0;</span> → initializes the loop counter <span class="italic">i</span>
        as a number and starts at 0.
      </p>
      <p class="my-2">
        <span class="font-semibold">i < 5;</span> → loop continues as long as <span class="italic">i</span> is less than 5.
      </p>
      <p class="my-2">
        <span class="font-semibold">i++</span> → increments <span class="italic">i</span> by 1 after every iteration.
      </p>
    </div>
  
    <!-- While Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">2. While Loop</h2>
      <p class="mb-4">
        A while loop runs as long as a specified condition is <span class="font-semibold">true</span>. It’s commonly used
        when the number of iterations is not known beforehand.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>while (condition) {{'{'}} <br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}}</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>let i: number = 0;<br><br>
        while (i < 5)  {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;i++;<br>
          {{'}'}}</code>
      </pre>
      <p class="my-2">
        The condition <span class="font-semibold">i < 5</span> is checked before each iteration.
      </p>
      <p class="my-2">The loop runs as long as <span class="font-semibold">i</span> is less than 5.</p>
    </div>
  
    <!-- Do-While Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">3. Do-While Loop</h2>
      <p class="mb-4">
        A do-while loop is similar to the while loop but guarantees that the loop will run at least once since the
        condition is checked after the execution of the code block.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>do {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}} while (condition);</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>let i: number = 0;<br><br>
        do {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;i++;<br>
          {{'}'}} while (i < 5);</code>
      </pre>
      <p class="my-2">
        In this example, the loop runs the first iteration before checking if <span class="font-semibold">i < 5</span>.
      </p>
    </div>
  
    <!-- Key Points -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
      <ul class="list-disc ml-6">
        <li class="my-2">
          <span class="font-semibold">For Loops:</span> Best when you know how many times to iterate.
        </li>
        <li class="my-2">
          <span class="font-semibold">While Loops:</span> Best when the number of iterations is unknown and depends on a
          condition.
        </li>
        <li class="my-2">
          <span class="font-semibold">Do-While Loops:</span> Ensures that the loop runs at least once before checking the
          condition.
        </li>
      </ul>
    </div>
</div>

}@case (7){
<article class="prose lg:prose-xl p-6 bg-gray-100 rounded-lg shadow-lg">
  <h1 class="text-3xl font-bold mb-6">
    Basic Operators and Maths in TypeScript
  </h1>
  <!-- Introduction -->
  <p class="mb-4">
    In TypeScript (and JavaScript), operators are symbols used to perform
    specific operations on variables or values. These operations can include
    mathematical calculations, comparisons, and logical operations. Here’s a
    breakdown of the most common types of operators with a focus on
    <strong>mathematical operators</strong>.
  </p>

  <!-- Arithmetic Operators -->
  <h2 class="text-xl font-semibold text-blue-700">1. Arithmetic Operators</h2>
  <p class="mb-4">
    Arithmetic operators are used to perform mathematical operations on numbers.
  </p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Result</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">+</td>
        <td class="px-4 py-2">Addition</td>
        <td class="px-4 py-2">5 + 2</td>
        <td class="px-4 py-2">7</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">-</td>
        <td class="px-4 py-2">Subtraction</td>
        <td class="px-4 py-2">5 - 2</td>
        <td class="px-4 py-2">3</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">*</td>
        <td class="px-4 py-2">Multiplication</td>
        <td class="px-4 py-2">5 * 2</td>
        <td class="px-4 py-2">10</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">/</td>
        <td class="px-4 py-2">Division</td>
        <td class="px-4 py-2">10 / 2</td>
        <td class="px-4 py-2">5</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">%</td>
        <td class="px-4 py-2">Modulus</td>
        <td class="px-4 py-2">5 % 2</td>
        <td class="px-4 py-2">1</td>
      </tr>
    </tbody>
  </table>

  <!-- Assignment Operators -->
  <h2 class="text-xl font-semibold text-blue-700">2. Assignment Operators</h2>
  <p class="mb-4">Assignment operators assign values to variables.</p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Equivalent</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">=</td>
        <td class="px-4 py-2">Assign value</td>
        <td class="px-4 py-2">x = 5</td>
        <td class="px-4 py-2">-</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">+=</td>
        <td class="px-4 py-2">Add and assign</td>
        <td class="px-4 py-2">x += 3</td>
        <td class="px-4 py-2">x = x + 3</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">-=</td>
        <td class="px-4 py-2">Subtract and assign</td>
        <td class="px-4 py-2">x -= 3</td>
        <td class="px-4 py-2">x = x - 3</td>
      </tr>
    </tbody>
  </table>

  <!-- Comparison Operators -->
  <h2 class="text-xl font-semibold text-blue-700">3. Comparison Operators</h2>
  <p class="mb-4">
    Comparison operators are used to compare two values and return a Boolean
    value (<code>true</code> or <code>false</code>).
  </p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Result</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">==</td>
        <td class="px-4 py-2">Equal to</td>
        <td class="px-4 py-2">5 == 5</td>
        <td class="px-4 py-2">true</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">===</td>
        <td class="px-4 py-2">Strict equal</td>
        <td class="px-4 py-2">5 === "5"</td>
        <td class="px-4 py-2">false</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">!=</td>
        <td class="px-4 py-2">Not equal</td>
        <td class="px-4 py-2">5 != 3</td>
        <td class="px-4 py-2">true</td>
      </tr>
    </tbody>
  </table>

  <!-- Logical Operators -->
  <h2 class="text-xl font-semibold text-blue-700">4. Logical Operators</h2>
  <p class="mb-4">Logical operators are used to combine multiple conditions.</p>

  <pre class="bg-gray-800 text-white p-4 rounded-md mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        let a = true;
        let b = false;
        console.log(a && b);  // false
        console.log(a || b);  // true
        console.log(!a);      // false
      </code>
    </pre>

  <!-- Mathematical Functions -->
  <h2 class="text-xl font-semibold text-blue-700">5. Mathematical Functions</h2>
  <p class="mb-4">
    TypeScript also supports several built-in mathematical functions through the
    <code>Math</code> object.
  </p>

  <pre class="bg-gray-800 text-white p-4 rounded-md mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        let num = Math.sqrt(16);  // 4
        console.log(Math.round(4.7));  // 5
        console.log(Math.random());    // Random number between 0 and 1
      </code>
    </pre>

  <p class="mb-4">
    These are just a few of the key operators and functions available in
    TypeScript for performing mathematical and logical operations.
  </p>
</article>

}@case(8){
<div class="max-w-4xl mx-auto p-6">
  <h1 class="text-xl font-semibold text-indigo-500 mb-2">
    The Switch Statement in TypeScript
  </h1>

  <p class="text-lg mb-4">
    The <span class="font-semibold">switch</span> statement in TypeScript is a
    control flow structure used to perform different actions based on different
    conditions. It's often used as an alternative to a series of
    <span class="font-semibold">if-else</span> statements when there are
    multiple possible outcomes for a single expression.
  </p>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Basic Structure</h2>

  <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  switch (expression) 
    case value1:
      // Code to execute if expression matches value1
      break;
    case value2:
      // Code to execute if expression matches value2
      break;
    default:
      // Code to execute if no cases match
  
      </code>
    </pre>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Explanation of the Components:</h2>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">expression:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>
        The expression inside the <span class="font-semibold">switch</span> is
        evaluated once.
      </li>
      <li>
        The result of the expression is then compared to the values of each case
        (value1, value2, etc.).
      </li>
    </ul>
  </div>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">case value1, value2:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>Each case represents a possible value of the expression.</li>
      <li>
        If a case matches the value of the expression, the corresponding block
        of code will be executed.
      </li>
      <li>
        <span class="font-semibold">break:</span> The
        <span class="font-semibold">break</span> statement ensures that after a
        matching case's code is executed, the
        <span class="font-semibold">switch</span> statement ends. Without a
        <span class="font-semibold">break</span>, the code would continue to
        execute the following cases (a behavior called "fall-through").
      </li>
    </ul>
  </div>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">default:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>The <span class="font-semibold">default</span> case is optional.</li>
      <li>
        If no case matches the value of the expression, the
        <span class="font-semibold">default</span> block will be executed.
      </li>
    </ul>
  </div>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Example of a switch Statement</h2>

  <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
  let day = 2;

  switch (day) 
    case 1:
      console.log('Monday');
      break;
    case 2:
      console.log('Tuesday');
      break;
    case 3:
      console.log('Wednesday');
      break;
    default:
      console.log('Other day');
        
      </code>
    </pre>

  <h3 class="text-xl font-semibold text-indigo-500 mb-4">Explanation:</h3>
  <ul class="list-disc pl-8 text-lg">
    <li>
      The variable <span class="font-semibold">day</span> has a value of 2.
    </li>
    <li>
      The <span class="font-semibold">switch</span> statement checks the value
      of <span class="font-semibold">day</span>:
    </li>
    <li>If it’s 1, it prints "Monday".</li>
    <li>
      If it’s 2, it prints "Tuesday" (this is the matching case, so the code
      executes this block and breaks out of the switch).
    </li>
    <li>
      If no case matches, the <span class="font-semibold">default</span> block
      would execute.
    </li>
  </ul>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">
    Use Cases for the switch Statement:
  </h2>
  <ul class="list-disc pl-8 text-lg">
    <li>
      The <span class="font-semibold">switch</span> statement is useful when you
      have multiple potential outcomes for a single expression.
    </li>
    <li>
      It simplifies code readability over long chains of
      <span class="font-semibold">if-else</span> conditions, especially when
      comparing the same variable multiple times.
    </li>
  </ul>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Key Points:</h2>
  <ul class="list-disc pl-8 text-lg">
    <li>
      <span class="font-semibold">Fall-through:</span> Without a
      <span class="font-semibold">break</span>, TypeScript (and JavaScript) will
      continue to execute subsequent case blocks until it finds a break.
    </li>
    <li>
      <span class="font-semibold">Type Safety:</span> Since TypeScript is
      strongly typed, mismatched data types (like comparing a string case with a
      number expression) will cause compile-time errors.
    </li>
  </ul>
</div>

}@case(9){
  <div>

  
  <p class="mb-4">
    The ternary operator in TypeScript (as in JavaScript) is a concise way to perform conditional logic. It’s sometimes
    called the "conditional operator" and takes three operands, hence the name "ternary." It’s often used as a
    shorthand for simple <span class="font-semibold">if-else</span> conditions.
  </p>

  <!-- Syntax Section -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Syntax:</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >condition ? expressionIfTrue : expressionIfFalse;</code>
    </pre>
    <p class="mt-2">
      <span class="font-semibold">condition</span>: A boolean expression that is evaluated.
    </p>
    <p class="mt-2">
      <span class="font-semibold">expressionIfTrue</span>: The expression that will be executed if the condition is true.
    </p>
    <p class="mt-2">
      <span class="font-semibold">expressionIfFalse</span>: The expression that will be executed if the condition is false.
    </p>
  </div>
   <!-- Example 1: Basic Usage -->
   <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 1: Basic Usage</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let age: number = 18;<br>
      let message: string = age >= 18 ? "You are an adult." : "You are a minor.";<br>
      console.log(message);  // Output: "You are an adult."</code>
    </pre>
    <p class="mt-2">
      If <span class="font-semibold">age >= 18</span> is true, <span class="font-semibold">message</span> will be set to
      <span class="font-semibold">"You are an adult."</span>
    </p>
    <p class="mt-2">
      If <span class="font-semibold">age >= 18</span> is false, <span class="font-semibold">message</span> will be set to
      <span class="font-semibold">"You are a minor."</span>
    </p>
  </div>

  <!-- Example 2: Assigning Values Conditionally -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 2: Assigning Values Conditionally</h2>
    <p class="mb-4">
      The ternary operator is often used to assign values based on conditions, especially for simple logic.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let isAuthenticated: boolean = true;<br>
      let greeting: string = isAuthenticated ? "Welcome back!" : "Please log in.";<br>
      console.log(greeting);  // Output: "Welcome back!"</code>
    </pre>
  </div>
  <!
  <!-- Example 3: Ternary Operator in JSX -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 3: Using Ternary Operator in JSX (React with TypeScript)</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >const loggedIn: boolean = true;<br><br>
      return (<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{'{'}}loggedIn ? &lt;p&gt;Welcome User!&lt;/p&gt; : &lt;p&gt;Please sign in&lt;/p&gt; {{'}'}};<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
      );</code>
    </pre>
    <p class="mt-2">
      You can use the ternary operator in JSX to render different UI elements conditionally.
    </p>
  </div>

  <!-- Example 4: Nesting Ternary Operators -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 4: Nesting Ternary Operators</h2>
    <p class="mb-4">
      Although nesting ternary operators is possible, it can reduce code readability, so it’s recommended to avoid deep
      nesting.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let score: number = 75;<br>
      let grade: string = score >= 90 ? "A" : score >= 75 ? "B" : "C";<br>
      console.log(grade);  // Output: "B"</code>
    </pre>
    <p class="mt-2">
      In this example:
    </p>
    <ul class="list-disc ml-6">
      <li class="my-2">
        If <span class="font-semibold">score >= 90</span>, <span class="font-semibold">grade</span> is "A".
      </li>
      <li class="my-2">
        Otherwise, if <span class="font-semibold">score >= 75</span>, <span class="font-semibold">grade</span> is "B".
      </li>
      <li class="my-2">Otherwise, <span class="font-semibold">grade</span> is "C".</li>
    </ul>
  </div>

  <!-- Key Points Section -->
<!-- Key Points Section -->
<div class="mb-6">
  <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
  <ul class="list-disc ml-6">
    <li class="my-2">
      The ternary operator is best used for simple conditional expressions.
    </li>
    <li class="my-2">
      For complex logic, using <span class="font-semibold">if-else</span> statements might improve readability.
    </li>
    <li class="my-2">
      It is a powerful tool for writing concise code, especially in inline scenarios like JSX, or when assigning
      values based on conditions.
    </li>
  </ul>
</div>

</div> 

}@case(10){
  <div class="p-6 max-w-3xl mx-auto bg-white rounded-xl shadow-md space-y-4">
    <h1 class="text-2xl font-bold text-blue-800">Type Assertions in TypeScript</h1>
    <p class="text-gray-700">
      Type assertions in TypeScript are a way to tell the TypeScript compiler to treat a variable as a different type than what it is initially inferred as or declared. Type assertions can be used when you're certain about the type of a value but TypeScript is unable to infer it.
    </p>
  
    <h2 class="text-xl font-semibold text-blue-800">Two Syntaxes for Type Assertions:</h2>
  
    <div class="space-y-2">
      <h3 class="font-semibold text-lg text-blue-700">1. Using the <span class="text-red-500">as</span> keyword (recommended):</h3>
      <pre class="bg-gray-100 p-4 rounded-md">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >let someValue: unknown = "Hello, World!";<br />let strLength: number = (someValue as string).length;</code>
      </pre>
  
      <h3 class="font-semibold text-lg text-blue-700">2. Using angle-bracket syntax:</h3>
      <pre class="bg-gray-100 p-4 rounded-md">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >let someValue: unknown = "Hello, World!";<br />let strLength: number = (&lt;string&gt;someValue).length;</code>
      </pre>
  
      <p class="text-gray-600">
        <span class="font-bold">Note:</span> The angle-bracket syntax cannot be used in <span class="text-purple-600">.tsx</span> files (React files) because it conflicts with JSX syntax, so the <span class="text-red-500">as</span> syntax is preferred, especially when working with React.
      </p>
    </div>
  
    <h2 class="text-xl font-semibold text-blue-800">Key Points:</h2>
    <ul class="list-disc pl-6 text-gray-700">
      <li>Type assertions do not perform any runtime type checks, they only affect the compile-time type checking.</li>
      <li>Type assertions should only be used when you are confident about the type of the value.</li>
      <li>Type assertions can help when dealing with legacy code, third-party libraries, or when TypeScript cannot infer a specific type.</li>
    </ul>
  
    <h2 class="text-xl font-semibold text-blue-800">Example Usage:</h2>
    <pre class="bg-gray-100 p-4 rounded-md" >
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >// Example with DOM element<br />const inputElement = document.getElementById("myInput") as HTMLInputElement;<br />inputElement.value = "Typed value";</code>
    </pre>
  
    <p class="text-gray-700">
      Without type assertion, the type of <code>inputElement</code> would just be <code>HTMLElement | null</code>. With type assertion, we're telling TypeScript that we're sure it's an HTMLInputElement.
    </p>
  </div>

}@case(11){
  <div class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">Type Aliases in TypeScript</h1>
    
    <p class="mb-4">
      In TypeScript, <span class="font-semibold">Type Aliases</span> provide a way to define a custom name (alias) for a specific type. 
      They can simplify complex type definitions and make your code more readable and manageable. A type alias can be used for 
      primitive types, object types, union types, function signatures, or any other type.
    </p>
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Syntax:</h2>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight  >type AliasName = ExistingType;</code>
      </pre>
    </div>
     <!-- Example 1: Basic Usage with Primitives -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 1: Basic Usage with Primitives</h2>
    <p class="mb-2">
      You can create a type alias for primitive types like <span class="font-semibold">string</span>, <span class="font-semibold">number</span>, etc.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type ID = number;<br>type Name = string;<br><br>
      let userID: ID = 123;<br>let userName: Name = "Alice";</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">ID</span> is an alias for <span class="font-semibold">number</span>, and <span class="font-semibold">Name</span> is an alias for <span class="font-semibold">string</span>.
    </p>
  </div>

  <!-- Example 2: Type Aliases with Objects -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 2: Type Aliases with Objects</h2>
    <p class="mb-2">
      You can also create type aliases for objects and use them to define the shape of the object.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type User =  {{'{'}}<br>&nbsp;&nbsp;id: number;<br>&nbsp;&nbsp;name: string;<br>&nbsp;&nbsp;age: number;<br> {{'}'}};<br><br>
      let user: User = {{'{'}}<br>&nbsp;&nbsp;id: 1,<br>&nbsp;&nbsp;name: "Alice",<br>&nbsp;&nbsp;age: 25<br> {{'}'}};</code>
    </pre>
    <p class="mt-2">
      Here, the <span class="font-semibold">User</span> type alias defines the structure of a user object.
    </p>
  </div>

  <!-- Example 3: Type Aliases with Union Types -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 3: Type Aliases with Union Types</h2>
    <p class="mb-2">
      Type aliases are often useful when dealing with <span class="font-semibold">union types</span> (a type that can be one of several types).
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Status = "success" | "error" | "loading";<br><br>
      let requestStatus: Status = "success";<br>requestStatus = "loading";<br>// requestStatus = "failed"; // Error</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">Status</span> is an alias for a union of string literals, allowing only three possible values.
    </p>
  </div>

  <!-- Example 4: Type Aliases with Functions -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 4: Type Aliases with Functions</h2>
    <p class="mb-2">
      You can use type aliases to describe function signatures.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type AddFunction = (a: number, b: number) => number;<br><br>
      let add: AddFunction = (x, y) => x + y;<br>console.log(add(5, 3));  // Output: 8</code>
    </pre>
    <p class="mt-2">
      In this example, <span class="font-semibold">AddFunction</span> is a type alias for a function that takes two <span class="font-semibold">number</span> arguments and returns a <span class="font-semibold">number</span>.
    </p>
  </div>

  <!-- Example 5: Type Aliases with Tuples -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 5: Type Aliases with Tuples</h2>
    <p class="mb-2">
      Type aliases can also be used for tuples, which are fixed-length arrays with specific types at each index.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Point = [number, number];<br><br>
      let point: Point = [10, 20];</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">Point</span> is an alias for a tuple containing two <span class="font-semibold">number</span> values.
    </p>
  </div>

  <!-- Example 6: Type Aliases with Optional and Read-Only Properties -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 6: Type Aliases with Optional and Read-Only Properties</h2>
    <p class="mb-2">
      You can create type aliases that include optional and read-only properties.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Person =  {{'{'}}<br>&nbsp;&nbsp;name: string;<br>&nbsp;&nbsp;age?: number; // Optional<br>&nbsp;&nbsp;readonly id: number; // Read-only<br> {{'}'}};<br><br>
      let person: Person =  {{'{'}} name: "Alice", id: 1 {{'}'}};<br>person.age = 30;<br>// person.id = 2; // Error</code>
    </pre>
    <p class="mt-2">
      In this example, <span class="font-semibold">Person</span> has both optional and read-only properties.
    </p>
  </div>

 <!-- Key Points Section -->
 <div class="mb-6">
  <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
  <ul class="list-disc ml-6">
    <li class="my-2">Type Aliases can represent complex types in a simpler and more readable form.</li>
    <li class="my-2">They are flexible and can be used for primitives, objects, union types, functions, tuples, and more.</li>
    <li class="my-2">
      Type aliases are not unique types, but just a way to create a name for a type. The alias does not create a new type, it just gives an existing type a new name.
    </li>
    <li class="my-2">
      Type aliases in TypeScript make your code easier to maintain and understand, especially in scenarios where the same structure or pattern is used multiple times.
    </li>
  </ul>
</div>
    </div>
    
}@case(12){
  <div class="p-6 bg-gray-100">
    <h1 class="text-2xl font-bold mb-4">Understanding Interfaces in TypeScript</h1>
  
    <p class="mb-4">
      In TypeScript, interfaces are used to define the structure of objects, classes, and functions. An interface acts as a contract that a class or an object must adhere to. It defines the types of properties and methods an object should have without providing the implementation. Interfaces promote strong typing, making code more predictable and easier to maintain.
    </p>
  
    <h2  class="text-xl font-semibold text-blue-700">Syntax</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface InterfaceName {{'{'}}
      property1: type;
      property2: type;
      method1(param: type): returnType;
      {{'}'}}
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 1: Basic Object Structure</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Person{{'{'}}
      name: string;
      age: number;
      greet(): void;
    {{'}'}}
  
  const person: Person = {{'{'}}
      name: "John",
      age: 30,
      greet(){{'{'}}
          console.log('Hello, my name is ' + this.name);
          {{'}'}}
    {{'}'}};
  
  person.greet();  // Output: Hello, my name is John.
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 2: Optional Properties</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Car {{'{'}}
      make: string;
      model: string;
      year?: number;
    {{']'}}
  
  const car1: Car ={{'{'}} make: "Toyota", model: "Camry" {{'}'}};
  const car2: Car = {{'{'}} make: "Tesla", model: "Model S", year: 2020 {{'}'}};
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 3: Readonly Properties</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface User{{'{'}}
      readonly id: number;
      name: string;
    {{'}'}}
  
  const user: User ={{'{'}} id: 1, name: "Alice" {{'}'}};
  // user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 4: Extending Interfaces</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Animal {{'{'}}
      name: string;
      {{'}'}}
  
  interface Dog extends Animal {{'{'}}
      breed: string;
      {{'}'}}
  
  const myDog: Dog ={{'{'}} name: "Buddy", breed: "Golden Retriever"{{'}'}};
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 5: Function Types</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface MathOperation {{'{'}}
      (a: number, b: number): number;
    {{'}'}}
  
  const add: MathOperation = (x, y) => x + y;
  console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 6: Indexable Types</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface StringArray {{'{'}}
      [index: number]: string;
    {{'}'}}
  
  let myArray: StringArray = ["Hello", "World"];
  console.log(myArray[0]); // Output: Hello
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold text-blue-700">Example 7: Class Implementing an Interface</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Shape {{'{'}}
      area(): number;
    {{'}'}}
  
  class Circle implements Shape {{'{'}}
      constructor(public radius: number) {{'{}'}}
      area() {{'{'}}
          return Math.PI * this.radius * this.radius;
      {{'}'}}
    {{'}'}}
  
  const circle = new Circle(5);
  console.log(circle.area());  // Output: 78.53981633974483
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Benefits of Using Interfaces</h2>
    <ul class="list-disc list-inside mb-4">
      <li>Type Safety: Interfaces enforce a structure, helping avoid runtime errors.</li>
      <li>Code Reusability: Interfaces can be reused across different classes or functions.</li>
      <li>Abstraction: Interfaces provide a way to define the expected structure of data, decoupling the code from concrete implementations.</li>
    </ul>
  
    <h2  class="text-xl font-semibold text-blue-700">Interfaces vs. Types</h2>
    <p>
      Though interfaces and types can be used similarly, interfaces are typically preferred for defining object shapes, while type can be used for unions, intersections, or more complex types.
    </p>
  </div>

}@case(13){
  <div class="container mx-auto p-6 bg-gray-100">
    <h1 class="text-3xl font-bold text-center mb-8">Classes in TypeScript</h1>
  
    <!-- Introduction Section -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Introduction to TypeScript Classes</h2>
      <p class="text-gray-700 mb-4">
        TypeScript classes are a powerful way to create reusable object blueprints. They contain properties, methods,
        constructors, and more.
      </p>
      <p class="text-gray-700">
        In TypeScript, we can define classes that follow OOP principles such as encapsulation, inheritance, and
        polymorphism. Below are some of the key features of TypeScript classes:
      </p>
    </div>
  
    <!-- Basic Class Structure -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Basic Class Structure</h2>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Person {{'{'}}
            name: string;
            age: number;
  
            constructor(name: string, age: number) {{'{'}}
              this.name = name;
              this.age = age;
            {{'}'}}
  
            greet(): void {{'{'}}
              console.log(`Hello, my name is ${{'{'}}this.name{{'}'}} and I am ${{'{'}}this.age{{'}'}} years old.`);
            {{'}'}}
          {{'}'}}
  
          const person1 = new Person("John", 30);
          person1.greet(); // Output: Hello, my name is John and I am 30 years old.
        </code>
      </pre>
    </div>
  
    <!-- Visibility Modifiers -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Visibility Modifiers</h2>
      <p class="text-gray-700 mb-4">
        You can control the visibility of class members (properties and methods) using <code>public</code>,
        <code>private</code>, or <code>protected</code>.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Employee {{'{'}}
            private salary: number;
  
            constructor(salary: number) {{'{'}}
              this.salary = salary;
            {{'}'}}
  
            public getSalary(): number {{'{'}}
              return this.salary;
            {{'}'}}
          {{'}'}}
        </code>
      </pre>
    </div>
  
    <!-- Inheritance -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Inheritance</h2>
      <p class="text-gray-700 mb-4">
        TypeScript classes support inheritance, where one class can extend another class.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Animal {{'{'}}
            constructor(public name: string) {{'{}'}}
  
            move(): void {{'{'}}
              console.log(`$ {{'{'}}this.name{{'}'}} is moving`);
            {{'}'}}
          {{'}'}}
  
          class Dog extends Animal {{'{'}}
            bark(): void {{'{'}}
              console.log(`${{'{'}}this.name{{'}'}} is barking`);
            {{'}'}}
          {{'}'}}
  
          const dog = new Dog('Buddy');
          dog.move(); // Buddy is moving
          dog.bark(); // Buddy is barking
        </code>
      </pre>
    </div>
  
    <!-- Static Members -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Static Members</h2>
      <p class="text-gray-700 mb-4">
        Static members are accessible using the class name itself, not through an instance.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class MathHelper {{'{'}}
            static PI: number = 3.14159;
  
            static areaOfCircle(radius: number): number {{'{'}}
              return MathHelper.PI * radius * radius;
            {{'}'}}
          {{'}'}}
  
          console.log(MathHelper.areaOfCircle(5)); // Output: 78.53975
        </code>
      </pre>
    </div>
  
    <!-- Conclusion -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Conclusion</h2>
      <p class="text-gray-700">
        TypeScript classes provide a robust way to build object-oriented applications. With support for inheritance,
        access modifiers, static members, and more, TypeScript makes it easy to write clean, maintainable code.
      </p>
    </div>
  </div>

}@case(14){
  <div class="container mx-auto p-6 bg-gray-100">
    <h1 class="text-3xl font-bold text-center mb-8">Modules in TypeScript</h1>
  
    <!-- Exporting Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">1. Exporting in TypeScript</h2>
      <p class="text-gray-700 mb-4">
        In TypeScript, you can use <span class="font-bold">Named Exports</span> or <span class="font-bold">Default Exports</span> to make classes, functions, or variables available to other modules.
      </p>
      <div class="mb-4">
        <h3  class="text-xl font-semibold text-blue-500">Named Exports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // mathUtils.ts
            export function add(a: number, b: number): number{{'{'}}
                return a + b;
              {{'}'}}
  
            export function subtract(a: number, b: number): number {{'{'}}
                return a - b;
            {{'}'}}
          </code>
        </pre>
      </div>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Default Exports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // logger.ts
            export default class Logger{{'{'}}
                log(message: string): void{{'{'}}
                    console.log(message);
                {{'}'}}
              {{'}'}}
          </code>
        </pre>
      </div>
    </div>
  
    <!-- Importing Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">2. Importing in TypeScript</h2>
      <p class="text-gray-700 mb-4">
        You can import modules using the <span class="font-bold">import</span> statement. TypeScript supports both Named Imports and Default Imports.
      </p>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Named Imports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // app.ts
            import {{'{'}} add, subtract {{'}'}} from './mathUtils';
  
            console.log(add(5, 3));  // 8
            console.log(subtract(5, 3));  // 2
          </code>
        </pre>
      </div>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Default Imports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // app.ts
            import Logger from './logger';
  
            const logger = new Logger();
            logger.log('Hello, World!');
          </code>
        </pre>
      </div>
    </div>
  
    <!-- Re-exporting Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">3. Re-exporting Modules</h2>
      <p class="text-gray-700 mb-4">
        You can re-export modules to simplify imports in larger projects.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // utils.ts
          export {{'{'}} add, subtract {{'}'}} from './mathUtils';
          export {{'{'}} default as Logger {{'}'}} from './logger';
        </code>
      </pre>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // app.ts
          import{{'{'}} add, Logger {{'}'}} from './utils';
  
          const logger = new Logger();
          logger.log('Adding numbers');
          console.log(add(5, 7));
        </code>
      </pre>
    </div>
  
    <!-- Organizing Code in Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">4. Organizing Code into Modules</h2>
      <p class="text-gray-700 mb-4">
        TypeScript allows you to organize your code into separate modules. Here’s an example of how you can structure your code:
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          src/
            └── math/
                ├── add.ts
                ├── subtract.ts
            └── logger/
                └── logger.ts
            └── app.ts
        </code>
      </pre>
    </div>
  
    <!-- Module Resolution -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">5. Module Resolution</h2>
      <p class="text-gray-700 mb-4">
        TypeScript uses Node.js module resolution strategy by default. You can customize how modules are resolved using the <code >tsconfig.json</code> file.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          {{'{'}}
            "compilerOptions": {{'{'}}
              "module": "commonjs",
              "target": "es6",
              "baseUrl": "./src",
              "paths": {{'{'}}
                "*": ["node_modules/*", "src/types/*"]
              {{'}'}}
            {{'}'}}
          {{'}'}}
        </code>
      </pre>
      
    </div>
  
    <!-- Importing External Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">6. Importing External Modules</h2>
      <p class="text-gray-700 mb-4">
        You can import external modules from npm packages in TypeScript. Here’s how you can import and use Lodash:
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          npm install lodash
          npm install {{'@'}}types/lodash
        </code>
      </pre>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // app.ts
          import * as _ from 'lodash';
  
          const arr = [1, 2, 3, 4];
          console.log(_.shuffle(arr));  // Output: Shuffled array
        </code>
      </pre>
    </div>
  
    <!-- Conclusion -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Conclusion</h2>
      <p class="text-gray-700">
        Modules in TypeScript provide a clean way to organize and manage code. By using named exports, default exports, and proper module resolution, you can create maintainable, scalable applications.
      </p>
    </div>
  </div> 

}@case(15){
  <div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
    <h1 class="text-3xl font-bold text-blue-400">Generics in TypeScript</h1>
    <p class="text-lg">
      Generics in TypeScript allow you to create reusable components, functions, or classes that can work with a variety of data types, while still providing type safety. They enable you to write code that is flexible and reusable, without sacrificing the benefits of static typing.
    </p>
  
    <h2  class="text-xl font-semibold text-blue-700">Why Use Generics?</h2>
    <p class="text-lg">
      Without generics, you might have to create multiple versions of the same function or class to handle different data types, leading to repetitive code. Generics help you avoid that by making your code more abstract, while still preserving the type information.
    </p>
  
    <h2 class="text-2xl font-semibold text-blue-700">Syntax of Generics</h2>
    <p class="text-lg">
      Generics are typically denoted by angle brackets <code class="text-indigo-500">&lt;&gt;</code>, and the generic type is represented by a placeholder (often <code class="text-indigo-500">T</code>, but you can name it anything).
    </p>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Function</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function identity&lt;T&gt;(arg: T): T {{'{'}}
    return arg; 
  {{'}'}}
  
  let output1 = identity&lt;string&gt;("Hello, TypeScript!"); // Explicitly passing type
  let output2 = identity(42); // Type inferred
        </code>
      </pre>
      <p class="text-lg">
        Here, <code class="text-indigo-500">T</code> is a placeholder for the type that will be provided when the function is called. TypeScript infers the type automatically based on the passed argument (42 in the second case).
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Class</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  class GenericNumber&lt;T&gt; {{'{'}} 
    zeroValue: T; 
    add: (x: T, y: T) =&gt; T; 
  {{'}'}}
  
  let myGenericNumber = new GenericNumber&lt;number&gt;(); 
  myGenericNumber.zeroValue = 0; 
  myGenericNumber.add = function (x, y) {{'{'}} return x + y; {{'}'}};
        </code>
      </pre>
      <p class="text-lg">
        In this example, <code class="text-indigo-500">GenericNumber</code> is a class that works with any data type <code class="text-indigo-500">T</code>. It allows you to define behavior for that type (such as the <code class="text-indigo-500">add</code> function).
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Interface</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight > 
  interface Pair&lt;T, U&gt; {{'{'}}
    first: T; 
    second: U; 
  {{'}'}}
  
  let pair: Pair&lt;string, number&gt; = {{'{'}} first: "hello", second: 42 {{'}'}};
        </code>
      </pre>
      <p class="text-lg">
        Here, the <code class="text-indigo-500">Pair</code> interface uses two generic types, <code class="text-indigo-500">T</code> and <code class="text-indigo-500">U</code>, allowing it to work with a combination of different types.
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Generic Constraints</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function loggingIdentity&lt;T extends {{'{'}} length: number {{'}'}}&gt;(arg: T): T {{'{'}} 
    console.log(arg.length); // Now we know 'arg' has a .length property 
    return arg; 
  {{'}'}}
  
  loggingIdentity("Hello");
        </code>
      </pre>
      <p class="text-lg">
        In this example, the generic <code class="text-indigo-500">T</code> is constrained to types that have a <code class="text-indigo-500">length</code> property, which allows you to safely access length within the function.
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Default Types</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function createArray&lt;T = string&gt;(length: number, value: T): T[] {{'{'}}
    return Array(length).fill(value); 
  {{'}'}}
  
  let stringArray = createArray(3, "x"); // ['x', 'x', 'x']
  let numberArray = createArray&lt;number&gt;(3, 42); // [42, 42, 42]
        </code>
      </pre>
    </div>
  
    <h2 class="text-2xl font-semibold text-blue-700">Key Takeaways:</h2>
    <ul class="list-disc list-inside text-lg">
      <li>Generics are a way to create flexible, reusable, and type-safe code.</li>
      <li>Type inference allows TypeScript to figure out the types based on how generics are used.</li>
      <li>Constraints can limit the types a generic can accept.</li>
      <li>Default values for generics allow for fallback types when none are provided.</li>
      <li>Generics make TypeScript more powerful, enabling you to write code that's adaptable to many situations without losing type safety.</li>
    </ul>
  </div>
   
}@case(16){
  <div class="bg-gray-100 p-8 rounded-lg shadow-md max-w-4xl mx-auto my-10">
    <h1 class="text-3xl font-bold text-center text-indigo-600 mb-6">Namespaces in TypeScript</h1>
  
    <div class="space-y-6">
      <!-- Overview Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Introduction</h2>
        <p class="text-gray-700">
          Namespaces in TypeScript are a way to group related code together under a single name to avoid naming conflicts and to organize code better. They are primarily used for logical grouping and encapsulating code into a distinct module-like structure.
        </p>
        <p class="text-gray-700">
          However, with the advent of ECMAScript modules, the usage of namespaces has become less common in modern TypeScript projects.
        </p>
      </section>
  
      <!-- Syntax Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Syntax of a Namespace</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap"  class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace MyNamespace {{'{'}}
    export class MyClass {{'{'}}
      constructor(public name: string) {{'{}'}}
      
      public sayHello(): void {{'{'}}
        console.log(`Hello, ${{'{'}}this.name{{'}'}}`);
      {{'}'}}
    {{'}'}}
  
    export function greet(): void {{'{'}}
      console.log("Greetings from MyNamespace!");
      {{'}'}}
    {{'}'}}
          </code>
        </pre>
      </section>
  
      <!-- Usage Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Using a Namespace</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  let obj = new MyNamespace.MyClass("TypeScript");
  obj.sayHello(); // Output: Hello, TypeScript
  
  MyNamespace.greet(); // Output: Greetings from MyNamespace!
          </code>
        </pre>
      </section>
  
      <!-- Nested Namespaces Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Nested Namespaces</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace OuterNamespace {{'{'}}
    export namespace InnerNamespace {{'{'}}
      export class AnotherClass {{'{'}}
        greet(): void {{'{'}}
          console.log("Hello from InnerNamespace!");
          {{'}'}}
        {{'}'}}
      {{'}'}}
    {{'}'}}
  
  let innerObj = new OuterNamespace.InnerNamespace.AnotherClass();
  innerObj.greet(); // Output: Hello from InnerNamespace!
          </code>
        </pre>
      </section>
  
      <!-- Namespace Merging Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Namespace Merging</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace MyNamespace {{'{'}}
    export const foo = "foo;
    {{'}'}}
  
  namespace MyNamespace {{'{'}}
    export function bar() {{'{'}}
      console.log("bar");
      {{'}'}}
    {{'}'}}
  
  console.log(MyNamespace.foo); // Output: foo
  MyNamespace.bar(); // Output: bar
          </code>
        </pre>
      </section>
  
      <!-- Conclusion Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Conclusion</h2>
        <p class="text-gray-700">
          In modern TypeScript, using ECMAScript modules (via <code>import</code> and <code>export</code>) is preferred as it aligns with the standard JavaScript module system. However, namespaces can still be useful in specific cases like legacy systems or global libraries.
        </p>
      </section>
    </div>
  </div>
  
}@case(17){
<!-- app.component.html -->
<div class="container mx-auto p-5">
  <h1 class="text-2xl font-bold mb-4">Basic Functions of TypeScript</h1>

  <div class="space-y-6">
    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">1. Type Annotations</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let age: number = 30;
let name: string = "Alice";</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2 class="text-xl font-semibold text-blue-700">2. Interfaces</h2>
    <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>interface Person {{'{'}}
  name: string;
  age: number;
{{'}'}}

const person: Person = {{'{'}}
  name: "Bob",
  age: 25
{{'}'}};</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">3. Classes and Inheritance</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>class Animal {{'{'}}
  constructor(public name: string) {{'{}'}}

  speak(): void {{'{'}}
    console.log(\`\${{'{'}}this.name{{'}'}} makes a noise.\`);
  {{'}'}}
{{'}'}}

class Dog extends Animal {{'}'}}
  speak(): void {{'{'}}
    console.log(\`\${{'{'}}this.name{{'}'}} barks.\`);
  {{'}'}}
{{'}'}}

const dog = new Dog("Rex");
dog.speak(); // Rex barks.</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">4. Generics</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>function identity&lt;T&gt;(arg: T): T {{'{'}}
  return arg;
  {{'}'}}

let output = identity&lt;string&gt;("Hello"); // Output: "Hello"</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">5. Union and Intersection Types</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let id: number | string;
id = 101;   // valid
id = "101"; // valid

type Admin = {{'{'}} name: string; admin: true {{'}'}};
type User = {{'{'}} name: string; admin?: false {{'}'}};
type Person = Admin & User; // intersection type</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">6. Enums</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>enum Direction {{'{'}}
  Up = 1,
  Down,
  Left,
  Right,
  {{'}'}}

let move: Direction = Direction.Up; // move is 1</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">7. Type Aliases</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>type StringOrNumber = string | number;
let value: StringOrNumber = "hello"; // valid
value = 42; // valid</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">8. Type Assertion</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let someValue: any = "This is a string";
let strLength: number = (someValue as string).length; // Type assertion</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">9. Optional Properties and Methods</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>interface User {{'{'}}
  id: number;
  name: string;
  age?: number; // Optional
  {{'}'}}

const user: User = {{'{'}} id: 1, name: "Alice" {{'}'}}; // valid without age</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">10. Modules</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>// In module1.ts
export const PI = 3.14;

// In module2.ts
import {{'{'}} PI {{'}'}} from './module1';
console.log(PI);</code></pre>
    </div>
  </div>
</div>

}@case(18){
  <div class="container mx-auto p-6">
    <h1 class="text-3xl font-bold mb-4 text-center text-indigo-600">
      Arrow Functions in TypeScript
    </h1>
  
    <!-- Section 1: Introduction -->
    <div class="mb-6 p-4 bg-gray-100 rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Basic Syntax of Arrow Functions
      </h2>
      <p class="text-gray-600">
        Arrow functions provide a concise way to define functions using the <code>=></code> syntax. Below is the basic syntax of an arrow function.
      </p>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  const functionName = (parameters) => {{'{'}}
    // function body
  {{'}'}};
        </code>
      </pre>
    </div>
  
    <!-- Section 2: Example 1 -->
    <div class="mb-6 p-4 bg-white rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Example 1: Basic Arrow Function
      </h2>
      <pre class="bg-gray-200 p-4 rounded-md">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  const add = (a: number, b: number): number => {{'{'}}
    return a + b;
  {{'}'}};
  
  console.log(add(5, 3)); // Output: 8
        </code>
      </pre>
    </div>
  
    <!-- Section 3: Implicit Return -->
    <div class="mb-6 p-4 bg-gray-100 rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Implicit Return
      </h2>
      <p class="text-gray-600">
        You can omit curly braces and the <code>return</code> keyword when the body contains only a single expression.
      </p>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  const multiply = (a: number, b: number): number => a * b;
  console.log(multiply(4, 5)); // Output: 20
        </code>
      </pre>
    </div>
  
    <!-- Section 4: Arrow Functions and 'this' -->
    <div class="mb-6 p-4 bg-white rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Arrow Functions and <code>this</code>
      </h2>
      <p class="text-gray-600">
        Arrow functions don’t have their own <code>this</code> context; they inherit <code>this</code> from the surrounding context (lexical scope).
      </p>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  class Person {{'{'}}
    name: string;
  
    constructor(name: string) {{'{'}}
      this.name = name;
    {{'}'}}
  
    greet() {{'{'}}
      setTimeout(() => {{'{'}}
        console.log(\`Hello, my name is \${{'{'}}this.name{{'}'}}\`);
      {{'}'}}, 1000);
    {{'}'}}
  {{'}'}}
  
  const person = new Person("Alice");
  person.greet(); // Output: Hello, my name is Alice
        </code>
      </pre>
    </div>
  
    <!-- Section 5: Traditional Functions vs Arrow Functions -->
    <div class="mb-6 p-4 bg-gray-100 rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Traditional Functions vs Arrow Functions
      </h2>
      <ul class="list-disc ml-5 text-gray-600">
        <li><strong>Syntax:</strong> Arrow functions have a more concise syntax.</li>
        <li><strong><code>this</code> keyword:</strong> Arrow functions inherit <code>this</code> from their lexical scope.</li>
        <li><strong>Constructors:</strong> Arrow functions cannot be used as constructors.</li>
        <li><strong>No <code>arguments</code> object:</strong> Arrow functions do not have their own <code>arguments</code> object.</li>
      </ul>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight >
  // Error: 'arguments' is not defined in arrow functions
  const example = () => {{'{'}}
    console.log(arguments);
  {{'}'}};
  
  // Use rest parameters in arrow functions
  const example = (...args: any[]) => {{'{'}}
    console.log(args); // Logs passed arguments
  {{'}'}};
  
  example(1, 2, 3); // Output: [1, 2, 3]
        </code>
      </pre>
    </div>
  </div>
  
}@case(19){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Rest Parameters in TypeScript</h1>
    <p class="mb-4">
      In TypeScript, <strong>Rest Parameters</strong> allow you to pass an indefinite number of arguments to a function as an array. They are denoted by three dots (<code class="font-mono">...</code>) before the parameter name. Rest parameters must be the last parameters in the function's parameter list, because they capture all remaining arguments into an array.
    </p>
    
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>>
  function functionName(...restParameter: type[]): returnType &#123;
    // Function logic
  &#125;
      </code>
    </pre>
    
    <p class="mb-4">
      - <strong>restParameter</strong>: This is the name of the parameter that will hold all the additional arguments as an array.<br />
      - <strong>type[]</strong>: The type of the array elements.<br />
      - <strong>returnType</strong>: (Optional) The return type of the function.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example</h2>
    <pre class="bg-gray-100 p-4 rounded">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>>
  function sum(...numbers: number[]): number &#123;
      return numbers.reduce((acc, curr) => acc + curr, 0);
  &#125;
  
  console.log(sum(1, 2, 3)); // Output: 6
  console.log(sum(10, 20, 30, 40)); // Output: 100
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Key Points:</h2>
    <ul class="list-disc list-inside mb-4">
      <li>Rest parameters collect the remaining arguments into an array.</li>
      <li>They can only be used at the end of a function's parameter list.</li>
      <li>TypeScript ensures type safety by enforcing the type of the elements in the array.</li>
      <li>If no arguments are passed for the rest parameter, it will default to an empty array.</li>
    </ul>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Another Example with Multiple Parameters</h2>
    <pre class="bg-gray-100 p-4 rounded">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
  function greet(greeting: string, ...names: string[]) &#123;
      return \`${{'{'}}greeting{{''}} \${{'{'}}names.join(", "){{'}'}}\`;
  &#125;
  
  console.log(greet("Hello", "Alice", "Bob", "Charlie"));
  // Output: Hello Alice, Bob, Charlie
      </code>
    </pre>
    
    <p class="mb-4">
      In this case, the <strong>greeting</strong> is a regular parameter, and <strong>names</strong> is a rest parameter that collects all the other string arguments passed to the function.
    </p>
  </div>
  
}@case(20){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Spread Operator in TypeScript</h1>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Array Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Copying Arrays</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalArray = [1, 2, 3];<br />
        const copiedArray = [...originalArray];<br />
        console.log(copiedArray); // Output: [1, 2, 3]
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Merging Arrays</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const array1 = [1, 2, 3];<br />
        const array2 = [4, 5, 6];<br />
        const mergedArray = [...array1, ...array2];<br />
        console.log(mergedArray); // Output: [1, 2, 3, 4, 5, 6]
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Adding Elements to Arrays</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalArray = [1, 2, 3];<br />
        const newArray = [0, ...originalArray, 4];<br />
        console.log(newArray); // Output: [0, 1, 2, 3, 4]
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Object Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Copying Objects</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalObject = {{'{'}} a: 1, b: 2 {{'}'}};<br />
        const copiedObject = {{'{'}} ...originalObject {{'}'}};<br />
        console.log(copiedObject); // Output: {{'{'}} a: 1, b: 2 {{'}'}}
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Merging Objects</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const obj1 = {{'{'}} a: 1 {{'}'}};<br />
        const obj2 ={{'{'}} b: 2 {{'}'}};<br />
        const mergedObject = {{'{'}} ...obj1, ...obj2 {{'}'}};<br />
        console.log(mergedObject); // Output: {{'{'}}a: 1, b: 2{{'}'}}
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Updating Object Properties</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalObject ={{'{'}} a: 1, b: 2{{'}'}};<br />
        const updatedObject = {{'{'}} ...originalObject, b: 3 {{'}'}};<br />
        console.log(updatedObject); // Output: {{'{'}} a: 1, b: 3 {{'}'}}
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Spread Operator in Function Calls</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function sum(a: number, b: number, c: number): number {{'{'}}<br />
          return a + b + c;<br />
          {{'}'}}<br />
        const numbers = [1, 2, 3];<br />
        const result = sum(...numbers);<br />
        console.log(result); // Output: 6
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      The spread operator is a powerful feature in TypeScript that simplifies operations on arrays and objects, making your code more concise and readable. It is especially useful for immutable operations where you want to create new arrays or objects without modifying the originals.
    </p>
  </div>
  
}@case(21){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Default Parameters in TypeScript</h1>
  
    <p>
      Default parameters in TypeScript allow you to initialize function parameters with default values if no argument is provided for those parameters. This feature simplifies function calls and makes your code cleaner and more robust.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Syntax</h2>
    <p>
      The syntax for default parameters is straightforward. You simply assign a value to a parameter in the function declaration:
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function functionName(parameterName: parameterType = defaultValue) &#123;<br />
            // function body<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Basic Example</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function greet(name: string = "Guest"): string &#123;<br />
            return `Hello, ${{'{'}}name{{'}'}}!`; <br />
        &#125;<br />
        console.log(greet()); // Output: Hello, Guest!<br />
        console.log(greet("Alice")); // Output: Hello, Alice!
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Multiple Default Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function add(a: number = 0, b: number = 0): number &#123;<br />
            return a + b;<br />
        &#125;<br />
        console.log(add()); // Output: 0<br />
        console.log(add(5)); // Output: 5<br />
        console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Using Default Parameters with Other Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function multiply(a: number, b: number = 1): number &#123;<br />
            return a * b;<br />
        &#125;<br />
        console.log(multiply(5)); // Output: 5 (5 * 1)<br />
        console.log(multiply(5, 2)); // Output: 10
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">4. Default Parameters with Destructuring</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface Person &#123;<br />
            name: string;<br />
            age?: number;<br />
        &#125;<br />
        function introduce({{'{'}} name, age = 18 {{'}'}}: Person): string &#123;<br />
            return `Hi, I'm ${{'{'}}name{{'}'}} and I'm ${{'{'}}age{{'}'}} years old.`;<br />
        &#125;<br />
        console.log(introduce({{'{'}} name: "Bob" {{'}'}})); // Output: Hi, I'm Bob and I'm 18 years old.<br />
        console.log(introduce({{'{'}} name: "Alice", age: 25 {{'}'}})); // Output: Hi, I'm Alice and I'm 25 years old.
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Important Notes</h2>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Order of Parameters:</strong> Default parameters must be defined after any required parameters.</li>
      <li><strong>Undefined vs. Default:</strong> Passing `undefined` as an argument will still use the default parameter.</li>
    </ul>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      Default parameters in TypeScript are a useful feature that enhances the flexibility of functions. They help reduce the need for overloading functions or checking for undefined values, making your code more concise and easier to read.
    </p>
  </div>
  
}@case(22){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Optional Parameters in TypeScript</h1>
  
    <p>
      Optional parameters in TypeScript allow you to define function parameters that are not required when calling the function. If an optional parameter is not provided, it will be assigned the value of <code>undefined</code>. This feature enhances the flexibility of function calls and helps avoid errors related to missing arguments.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Syntax</h2>
    <p>
      To declare an optional parameter, you append a question mark (<code>?</code>) to the parameter name in the function declaration:
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
        function functionName(parameterName?: parameterType) &#123;<br />
            // function body<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Basic Example</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function greet(name?: string): string &#123;<br />
            return `Hello, ${{'{'}}name || 'Guest'{{'}'}}!`;<br />
        &#125;<br />
        console.log(greet()); // Output: Hello, Guest!<br />
        console.log(greet("Alice")); // Output: Hello, Alice!
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Multiple Optional Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function add(a: number, b?: number): number &#123;<br />
            return a + (b || 0); // Treat undefined as 0<br />
        &#125;<br />
        console.log(add(5)); // Output: 5<br />
        console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Using Optional Parameters with Default Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function multiply(a: number, b?: number, c: number = 1): number &#123;<br />
            return a * (b || 1) * c; // If b is undefined, use 1<br />
        &#125;<br />
        console.log(multiply(5)); // Output: 5 (5 * 1 * 1)<br />
        console.log(multiply(5, 2)); // Output: 10 (5 * 2 * 1)<br />
        console.log(multiply(5, 2, 3)); // Output: 30 (5 * 2 * 3)
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">4. Using Optional Parameters with Destructuring</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface User &#123;<br />
            name: string;<br />
            age?: number;<br />
        &#125;<br />
        function introduce({{'{'}} name, age {{'}'}}: User): string &#123;<br />
            return `Hi, I'm ${{'{'}}name{{'}'}}${{'{'}}age ? ` and I'm ${{'{'}}age{{'}'}} years old.` : ''{{'}'}}`;<br />
        &#125;<br />
        console.log(introduce({{'{'}} name: "Bob" {{'}'}})); // Output: Hi, I'm Bob<br />
        console.log(introduce({{'{'}} name: "Alice", age: 25 {{'}'}})); // Output: Hi, I'm Alice and I'm 25 years old.
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Important Notes</h2>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Order of Parameters:</strong> Optional parameters should come after any required parameters in the function declaration.</li>
      <li><strong>Undefined Values:</strong> If an optional parameter is not provided, its value will be <code>undefined</code>.</li>
    </ul>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      Optional parameters in TypeScript enhance the flexibility of function definitions, allowing you to write functions that can handle varying numbers of arguments. This feature is particularly useful for creating APIs and libraries where not all parameters need to be mandatory. By leveraging optional parameters, you can make your code more concise and user-friendly.
    </p>
  </div>
  
}@case(23){
<div class="container mx-auto p-5">
  <h1 class="text-2xl font-bold mb-4">Named Parameters in TypeScript</h1>

  <p>
    Named parameters in TypeScript (and JavaScript) aren't a built-in feature like they are in some other languages (such as Python). However, you can achieve similar functionality using object destructuring. By passing an object as a parameter and destructuring it within the function, you can mimic named parameters. This approach allows for more readable and maintainable code, especially when dealing with multiple parameters.
  </p>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example of Named Parameters in TypeScript</h2>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Basic Example</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      interface GreetOptions &#123;<br />
          name: string;<br />
          greeting?: string; // Optional parameter<br />
      &#125;<br />
      <br />
      function greet({{'{'}} name, greeting = "Hello" {{'}'}}: GreetOptions): string &#123;<br />
          return \`${{'{'}}greeting{{'}'}}, \${{'{'}}name{{'}'}}!\`;<br />
      &#125;<br />
      <br />
      console.log(greet({{'{'}} name: "Alice" {{'}'}})); // Output: Hello, Alice!<br />
      console.log(greet({{'{'}} name: "Bob", greeting: "Hi" {{'}'}})); // Output: Hi, Bob!
    </code>
  </pre>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Multiple Named Parameters</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      interface UserOptions &#123;<br />
          name: string;<br />
          age?: number;<br />
          email?: string;<br />
      &#125;<br />
      <br />
      function displayUser({{'{'}} name, age, email {{'}'}}: UserOptions): string &#123;<br />
          let userInfo = \`Name: \${{'{'}}name{{'}'}}\`;<br />
          if (age !== undefined) userInfo += \`, Age: \${{'{'}}age{{'}'}}\`;<br />
          if (email) userInfo += \`, Email: \${{'{'}}email{{'}'}}\`;<br />
          return userInfo;<br />
      &#125;<br />
      <br />
      console.log(displayUser({{'{'}} name: "Alice", age: 30 {{'}'}})); // Output: Name: Alice, Age: 30<br />
      console.log(displayUser({{'{'}} name: "Bob", email: "bobexample.com" {{'}'}})); // Output: Name: Bob, Email: bobexample.com
    </code>
  </pre>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Default Values with Named Parameters</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      interface ConfigOptions &#123;<br />
          width?: number;<br />
          height?: number;<br />
          color?: string;<br />
      &#125;<br />
      <br />
      function configure({{'{'}} width = 100, height = 100, color = "black" {{'}'}}: ConfigOptions): string &#123;<br />
          return \`Configured with Width: \${{'{'}}width{{'}'}}, Height: \${{'{'}}height{{'}'}}, Color: \${{'{'}}color{{'}'}}\`;<br />
      &#125;<br />
      <br />
      console.log(configure({{'{'}} width: 200, color: "red" {{'}'}})); // Output: Configured with Width: 200, Height: 100, Color: red<br />
      console.log(configure({{'{}'}})); // Output: Configured with Width: 100, Height: 100, Color: black
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Benefits of Using Named Parameters</h2>
  <ul class="list-disc list-inside mt-2">
    <li><strong>Readability:</strong> Named parameters enhance code readability, making it clear what each parameter represents without needing to remember the order.</li>
    <li><strong>Flexibility:</strong> You can pass only the parameters you need without worrying about their order, which is particularly useful for functions with many optional parameters.</li>
    <li><strong>Maintainability:</strong> If you add or remove parameters, you don’t need to change the order of arguments in every call, reducing the risk of errors.</li>
  </ul>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Important Considerations</h2>
  <ul class="list-disc list-inside mt-2">
    <li><strong>Type Checking:</strong> TypeScript will enforce types based on the defined interface or type for the object, providing compile-time checks and IntelliSense support.</li>
    <li><strong>Destructuring:</strong> When using destructuring, ensure to handle cases where properties may be <code>undefined</code> or missing if they are not optional.</li>
  </ul>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
  <p>
    While TypeScript does not have built-in support for named parameters, using object destructuring is an effective workaround. This approach not only improves code readability and flexibility but also leverages TypeScript's strong typing features for better maintainability. By adopting this pattern, you can create functions that are easier to use and understand.
  </p>
</div>

}@case(24){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Function Expressions in TypeScript</h1>
  
    <p>
      Function expressions in TypeScript are a way to define functions as expressions, which can be assigned to variables, passed as arguments, or returned from other functions. This differs from function declarations, where the function is defined in a standalone manner.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Types of Function Expressions</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Anonymous Function Expressions</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const add = function (a: number, b: number): number &#123;<br />
            return a + b;<br />
        &#125;;<br />
        <br />
        console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Named Function Expressions</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const factorial = function fact(n: number): number &#123;<br />
            if (n &lt;= 1) &#123;<br />
                return 1;<br />
            &#125;<br />
            return n * fact(n - 1);<br />
        &#125;;<br />
        <br />
        console.log(factorial(5)); // Output: 120
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Arrow Function Expressions</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const multiply = (a: number, b: number): number =&gt; &#123;<br />
            return a * b;<br />
        &#125;;<br />
        <br />
        console.log(multiply(5, 4)); // Output: 20
      </code>
    </pre>
    <p>For concise arrow functions that have a single expression, you can omit the curly braces and the return statement:</p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const square = (x: number): number =&gt; x * x;<br />
        <br />
        console.log(square(4)); // Output: 16
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Using Function Expressions with Callbacks</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const numbers: number[] = [1, 2, 3, 4, 5];<br />
        <br />
        // Using an anonymous function expression as a callback<br />
        const doubled = numbers.map(function (num: number): number &#123;<br />
            return num * 2;<br />
        &#125;);<br />
        <br />
        console.log(doubled); // Output: [2, 4, 6, 8, 10]<br />
        <br />
        // Using an arrow function expression as a callback<br />
        const tripled = numbers.map((num: number): number =&gt; num * 3);<br />
        <br />
        console.log(tripled); // Output: [3, 6, 9, 12, 15]
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Typed Function Expressions</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        // Defining a type for a function<br />
        type Operation = (a: number, b: number) =&gt; number;<br />
        <br />
        const subtract: Operation = (a, b) =&gt; a - b;<br />
        <br />
        console.log(subtract(10, 4)); // Output: 6
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      Function expressions in TypeScript are a powerful feature that allows for more flexibility and maintainability in your code. They can be anonymous or named, and you can use arrow functions for a more concise syntax. By leveraging TypeScript's typing system, you can ensure type safety and clarity in your function expressions, making your code more robust and easier to understand.
    </p>
  </div>
  
}@case(25){
<div class="container mx-auto p-5">
  <h1 class="text-2xl font-bold mb-4">Anonymous Functions in TypeScript</h1>

  <p>
    Anonymous functions in TypeScript are functions that do not have a name and are often defined inline. They are commonly used in situations where you need a function for a short period of time, such as passing a function as an argument to another function or defining a function that you won't reuse elsewhere.
  </p>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Defining Anonymous Functions</h2>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Using Function Expressions</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const add = function (a: number, b: number): number &#123;<br />
          return a + b;<br />
      &#125;;<br />
      <br />
      console.log(add(5, 3)); // Output: 8
    </code>
  </pre>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Using Arrow Functions</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const multiply = (a: number, b: number): number =&gt; &#123;<br />
          return a * b;<br />
      &#125;;<br />
      <br />
      console.log(multiply(4, 6)); // Output: 24
    </code>
  </pre>
  <p>For simple single-expression functions, you can further simplify it by omitting the curly braces and the return statement:</p>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const square = (x: number): number =&gt; x * x;<br />
      <br />
      console.log(square(5)); // Output: 25
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Using Anonymous Functions as Callbacks</h2>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const numbers: number[] = [1, 2, 3, 4, 5];<br />
      <br />
      // Using an anonymous function with the map method<br />
      const doubled = numbers.map(function (num) &#123;<br />
          return num * 2;<br />
      &#125;);<br />
      <br />
      console.log(doubled); // Output: [2, 4, 6, 8, 10]<br />
      <br />
      // Using an arrow function as a callback<br />
      const tripled = numbers.map(num =&gt; num * 3);<br />
      <br />
      console.log(tripled); // Output: [3, 6, 9, 12, 15]
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Scoping and `this`</h2>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      class Counter &#123;<br />
          count: number = 0;<br />
          <br />
          increment() &#123;<br />
              // Using an anonymous function<br />
              setTimeout(function() &#123;<br />
                  this.count++;<br />
                  console.log(this.count); // `this` refers to the global object (or undefined in strict mode)<br />
              &#125;, 1000);<br />
          &#125;<br />
          <br />
          incrementWithArrow() &#123;<br />
              // Using an arrow function<br />
              setTimeout(() =&gt; &#123;<br />
                  this.count++;<br />
                  console.log(this.count); // `this` refers to the Counter instance<br />
              &#125;, 1000);<br />
          &#125;<br />
      &#125;<br />
      <br />
      const counter = new Counter();<br />
      counter.increment(); // Output will be NaN or undefined<br />
      counter.incrementWithArrow(); // Output after 1 second: 1
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
  <p>
    Anonymous functions in TypeScript are useful for creating functions on-the-fly without the need for a name. They can be defined using traditional function expressions or arrow functions, and they are particularly useful in callbacks and higher-order functions. Understanding how <code>this</code> behaves in different types of functions is crucial for using anonymous functions effectively. By leveraging anonymous functions, you can write cleaner and more concise code.
  </p>
</div>

}@case(26){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Function Types in TypeScript</h1>
  
    <p>
      In TypeScript, function types allow you to define the types of functions, specifying the types of their parameters and their return values. This feature enables better type checking, ensures code correctness, and improves code readability.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Defining Function Types</h2>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">1. Using Type Aliases</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        type AddFunction = (a: number, b: number) =&gt; number;<br />
        <br />
        const add: AddFunction = (x, y) =&gt; &#123;<br />
            return x + y;<br />
        &#125;;<br />
        <br />
        console.log(add(5, 3)); // Output: 8
      </code>
    </pre>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">2. Using Interfaces</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface MathOperation &#123;<br />
            (a: number, b: number): number;<br />
        &#125;;<br />
        <br />
        const multiply: MathOperation = (x, y) =&gt; &#123;<br />
            return x * y;<br />
        &#125;;<br />
        <br />
        console.log(multiply(4, 5)); // Output: 20
      </code>
    </pre>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">3. Inline Function Type Annotations</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const divide: (a: number, b: number) =&gt; number = (x, y) =&gt; &#123;<br />
            return x / y;<br />
        &#125;;<br />
        <br />
        console.log(divide(10, 2)); // Output: 5
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Optional and Default Parameters</h2>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">Optional Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        type GreetFunction = (name: string, greeting?: string) =&gt; string;<br />
        <br />
        const greet: GreetFunction = (name, greeting = "Hello") =&gt; &#123;<br />
            return \`&#123;greeting&#125;, &#123;name&#125;!\`;<br />
        &#125;;<br />
        <br />
        console.log(greet("Alice")); // Output: Hello, Alice!<br />
        console.log(greet("Bob", "Hi")); // Output: Hi, Bob!
      </code>
    </pre>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">Default Parameters</h3>
    <p>
      As shown above, you can set default values for parameters. If no value is provided, the default will be used.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example: Function Types in an Object</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface Calculator &#123;<br />
            add: (a: number, b: number) =&gt; number;<br />
            subtract: (a: number, b: number) =&gt; number;<br />
        &#125;;<br />
        <br />
        const calculator: Calculator = &#123;<br />
            add: (x, y) =&gt; x + y,<br />
            subtract: (x, y) =&gt; x - y,<br />
        &#125;;<br />
        <br />
        console.log(calculator.add(10, 5)); // Output: 15<br />
        console.log(calculator.subtract(10, 5)); // Output: 5
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Function types in TypeScript are a powerful feature that provides a way to define the shape of functions, ensuring that they are called with the correct types of arguments and return the expected types. This enhances type safety, helps catch errors at compile time, and improves the overall quality of the code. By using type aliases, interfaces, and inline annotations, you can create clear and maintainable function types in your TypeScript applications.
    </p>
  </div>
  
}@case(27){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Function Overloading in TypeScript</h1>
  
    <p>
      Function overloading in TypeScript allows you to create multiple function signatures for a single function. This enables a function to behave differently based on the types and number of its parameters, providing a way to specify more than one way to call a function.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">How Function Overloading Works</h2>
  
    <ol class="list-decimal list-inside mt-2">
      <li><strong>Declare Multiple Signatures</strong>: You declare multiple signatures for the same function, which specify the types of parameters and the return type.</li>
      <li><strong>Implement a Single Function</strong>: You then provide a single implementation that handles the various parameter types and return types.</li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function functionName(param: type1): returnType;<br />
        function functionName(param: type2): returnType;<br />
        // Implementation<br />
        function functionName(param: any): returnType &#123;<br />
            // Implementation goes here<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Function Overloading</h2>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">Example: Adding Numbers or Concatenating Strings</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function combine(input1: number, input2: number): number;<br />
        function combine(input1: string, input2: string): string;<br />
        function combine(input1: number | string, input2: number | string): number | string &#123;<br />
            if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number') &#123;<br />
                return input1 + input2; // Adding numbers<br />
            &#125; else &#123;<br />
                return input1.toString() + input2.toString(); // Concatenating strings<br />
            &#125;<br />
        &#125;<br />
        <br />
        console.log(combine(5, 3)); // Output: 8<br />
        console.log(combine('Hello, ', 'World!')); // Output: Hello, World!
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
  
    <ol class="list-decimal list-inside mt-2">
      <li>
        <strong>Function Signatures</strong>: The function <code>combine</code> is defined with two overload signatures:
        <ul class="list-disc list-inside mt-1">
          <li>One that takes two numbers and returns a number.</li>
          <li>Another that takes two strings and returns a string.</li>
        </ul>
      </li>
      <li>
        <strong>Implementation</strong>: The actual implementation of <code>combine</code> accepts parameters of type <code>number | string</code>. Inside the function, type guards are used to determine the type of the inputs and handle them accordingly.
      </li>
      <li>
        <strong>Function Calls</strong>: When calling the function:
        <ul class="list-disc list-inside mt-1">
          <li><code>combine(5, 3)</code> adds the two numbers and returns <code>8</code>.</li>
          <li><code>combine('Hello, ', 'World!')</code> concatenates the two strings and returns <code>Hello, World!</code>.</li>
        </ul>
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Function Overloading</h2>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Type Safety</strong>: Overloading allows you to specify exactly what types of arguments a function can accept, reducing the likelihood of runtime errors.</li>
      <li><strong>Code Readability</strong>: It makes the code clearer, as you can define different behaviors for the same function name based on input types.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Function overloading is useful in various scenarios, such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>When you need to create utility functions that perform similar operations but require different input types.</li>
      <li>When designing libraries or APIs that need to handle multiple data types in a flexible manner.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Function overloading in TypeScript is a powerful feature that enhances the flexibility and usability of functions. By allowing multiple signatures for a single function, it provides better type safety and clarity in code. This makes it easier to work with functions that need to handle various types and combinations of parameters while maintaining a clean and understandable API.
    </p>
  </div>
  
}@case(28){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Function Overriding in TypeScript</h1>
  
    <p>
      Function overriding is a feature in TypeScript (and object-oriented programming in general) that allows a derived class to provide a specific implementation of a method that is already defined in its base class. This enables polymorphism, allowing methods to be redefined to behave differently depending on the object that is invoking them.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Function Overriding</h2>
  
    <p>
      When a derived class has a method that overrides a method in its base class, it uses the same method name and parameter types. The overridden method in the derived class will be called instead of the base class method when invoked on an instance of the derived class.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        class BaseClass &#123;<br />
            greet() &#123;<br />
                console.log('Hello from Base Class');<br />
            &#125;<br />
        &#125;<br />
        <br />
        class DerivedClass extends BaseClass &#123;<br />
            greet() &#123;<br />
                console.log('Hello from Derived Class');<br />
            &#125;<br />
        &#125;<br />
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Function Overriding</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        class Animal &#123;<br />
            speak() &#123;<br />
                console.log('Animal speaks');<br />
            &#125;<br />
        &#125;<br />
        <br />
        class Dog extends Animal &#123;<br />
            speak() &#123;<br />
                console.log('Dog barks');<br />
            &#125;<br />
        &#125;<br />
        <br />
        const animal = new Animal();<br />
        animal.speak(); // Output: Animal speaks<br />
        <br />
        const dog = new Dog();<br />
        dog.speak(); // Output: Dog barks
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        <strong>Base Class</strong>: The <code>Animal</code> class has a method named <code>speak</code> that outputs "Animal speaks".
      </li>
      <li>
        <strong>Derived Class</strong>: The <code>Dog</code> class extends the <code>Animal</code> class and overrides the <code>speak</code> method to output "Dog barks".
      </li>
      <li>
        <strong>Method Invocation</strong>: When invoking <code>speak</code> on an instance of <code>Animal</code>, it calls the base class method. When invoking <code>speak</code> on an instance of <code>Dog</code>, it calls the overridden method in the derived class.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Key Points</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Function overriding allows a derived class to provide a specific implementation of a method that is already defined in its base class.</li>
      <li>The method in the derived class must have the same name and parameter types as the method in the base class.</li>
      <li>Overriding enables polymorphism, allowing methods to behave differently based on the object invoking them.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Function overriding is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Implementing specific behavior for subclasses while maintaining a consistent interface across the base class.</li>
      <li>Creating flexible and reusable code in large applications or frameworks.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Function overriding is a powerful feature in TypeScript that enhances the principles of object-oriented programming, allowing for more flexible and maintainable code. By enabling derived classes to redefine base class methods, it promotes polymorphism and code reuse, ultimately leading to a cleaner and more efficient design.
    </p>
  </div>
  
}@case(29){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Nullish Coalescing Operator in TypeScript</h1>
  
    <p>
      The nullish coalescing operator (??) is a logical operator introduced in TypeScript 3.7. It allows you to provide a default value for a variable that may be null or undefined. This operator is particularly useful when you want to differentiate between a falsy value and an absence of a value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding the Nullish Coalescing Operator</h2>
  
    <p>
      The nullish coalescing operator checks for <code>null</code> or <code>undefined</code> values. If the value is either of these, it returns the right-hand side value; otherwise, it returns the left-hand side value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const result = value1 ?? value2;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Nullish Coalescing Operator</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const name = null;<br />
        const defaultName = 'Guest';<br />
        const displayName = name ?? defaultName;<br />
        console.log(displayName); // Output: Guest
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In the example above, the variable <code>name</code> is set to <code>null</code>.
      </li>
      <li>
        The variable <code>defaultName</code> is set to <code>'Guest'</code>.
      </li>
      <li>
        Using the nullish coalescing operator, <code>displayName</code> will be assigned the value of <code>defaultName</code> because <code>name</code> is <code>null</code>.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Differences with Logical OR (||)</h2>
    <p>
      It's important to note the difference between the nullish coalescing operator and the logical OR operator. The logical OR operator returns the right-hand value if the left-hand value is any falsy value (like <code>0</code>, <code>''</code>, or <code>false</code>), whereas the nullish coalescing operator only checks for <code>null</code> or <code>undefined</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Differences</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const count = 0;<br />
        const fallback = 10;<br />
        const resultOR = count || fallback; // Output: 10<br />
        const resultNullish = count ?? fallback; // Output: 0
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Key Points</h2>
    <ul class="list-disc list-inside mt-2">
      <li>The nullish coalescing operator is represented by <code>??</code>.</li>
      <li>It returns the right-hand operand when the left-hand operand is <code>null</code> or <code>undefined</code>.</li>
      <li>It does not treat other falsy values (like <code>0</code> or <code>''</code>) as nullish.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      The nullish coalescing operator is useful in various scenarios, including:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Providing default values for variables that may not have been initialized.</li>
      <li>Setting default props in React components or similar frameworks.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      The nullish coalescing operator is a valuable addition to TypeScript, allowing developers to manage default values in a concise and clear manner. By distinguishing between nullish values and other falsy values, it provides a more accurate way to handle variables that may not be defined, resulting in cleaner and more maintainable code.
    </p>
  </div>
  
}@case(30){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Optional Chaining in TypeScript</h1>
  
    <p>
      Optional chaining is a feature in TypeScript (and JavaScript) that allows you to safely access deeply nested properties of an object without having to check for the existence of each property along the way. This operator is particularly useful for avoiding runtime errors when attempting to access properties on undefined or null objects.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Optional Chaining</h2>
  
    <p>
      The optional chaining operator is represented by a question mark followed by a dot (?.). It short-circuits the evaluation and returns <code>undefined</code> if the property before the operator is <code>null</code> or <code>undefined</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const value = object?.property?.nestedProperty;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Optional Chaining</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface User &#123;<br />
            name: string;<br />
            address?: &#123;<br />
                city?: string;<br />
                zipCode?: string;<br />
            &#125;<br />
        &#125;<br />
        <br />
        const user: User = &#123;<br />
            name: 'Alice',<br />
            address: &#123;<br />
                city: 'Wonderland'<br />
            &#125;<br />
        &#125;;<br />
        <br />
        const cityName = user.address?.city;<br />
        console.log(cityName); // Output: Wonderland
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In this example, the <code>User</code> interface defines an optional <code>address</code> property.
      </li>
      <li>
        The <code>user</code> object is created with a <code>name</code> and an <code>address</code> that contains a <code>city</code>.
      </li>
      <li>
        By using optional chaining, <code>user.address?.city</code> safely accesses the <code>city</code> property. If <code>address</code> were <code>undefined</code>, it would return <code>undefined</code> instead of throwing an error.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Optional Chaining</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Reduces the need for verbose checks using multiple if-statements to ensure properties exist.</li>
      <li>Prevents runtime errors by safely handling the cases where properties may be <code>null</code> or <code>undefined</code>.</li>
      <li>Improves code readability and maintainability by simplifying property access expressions.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Optional chaining is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Accessing properties in complex nested objects, such as configuration objects or API responses.</li>
      <li>When working with data structures where some properties might not be defined, such as user profiles or settings.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Optional chaining is a powerful feature in TypeScript that allows for safer and more concise access to object properties. By reducing the risk of runtime errors and improving code clarity, it enhances the overall developer experience. This operator is an essential tool for working with complex data structures in modern TypeScript applications.
    </p>
  </div>
  
}@case(31){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Optional Nullish Coalescing Operator in TypeScript</h1>
  
    <p>
      The optional nullish coalescing operator (??.) is a combination of the optional chaining operator (?.) and the nullish coalescing operator (??) in TypeScript. This operator allows you to safely access properties that may be <code>null</code> or <code>undefined</code>, while also providing a default value in case the property doesn't exist. This feature enhances code safety and readability when dealing with nested object properties.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding the Optional Nullish Coalescing Operator</h2>
  
    <p>
      The optional nullish coalescing operator first checks if the left-hand side property is <code>null</code> or <code>undefined</code>. If it is, it returns <code>undefined</code> rather than throwing an error. Then, if the left-hand side evaluates to <code>undefined</code>, it falls back to the right-hand side value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const value = object?.property ?? defaultValue;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Optional Nullish Coalescing Operator</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        interface User &#123;<br />
            name: string;<br />
            age?: number;<br />
            address?: &#123;<br />
                city?: string;<br />
                zipCode?: string;<br />
            &#125;<br />
        &#125;<br />
        <br />
        const user: User = &#123;<br />
            name: 'Alice',<br />
            age: undefined,<br />
            address: &#123;<br />
                city: 'Wonderland'<br />
            &#125;<br />
        &#125;;<br />
        <br />
        const age = user.age ?? 30;<br />
        console.log(age); // Output: 30<br />
        const city = user.address?.city ?? 'Unknown City';<br />
        console.log(city); // Output: Wonderland
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In this example, the <code>User</code> interface defines an optional <code>age</code> and <code>address</code> property.
      </li>
      <li>
        The <code>user</code> object is created with a <code>name</code>, an <code>age</code> set to <code>undefined</code>, and an <code>address</code> that contains a <code>city</code>.
      </li>
      <li>
        The statement <code>const age = user.age ?? 30;</code> assigns <code>30</code> to <code>age</code> since <code>user.age</code> is <code>undefined</code>.
      </li>
      <li>
        The statement <code>const city = user.address?.city ?? 'Unknown City';</code> safely accesses the <code>city</code> property and assigns it to <code>city</code>. If the <code>address</code> were <code>undefined</code>, it would return <code>Unknown City</code>.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Optional Nullish Coalescing Operator</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Combines the benefits of optional chaining and nullish coalescing in a concise and readable manner.</li>
      <li>Helps prevent runtime errors caused by accessing properties on <code>null</code> or <code>undefined</code> objects.</li>
      <li>Enhances the clarity of the code by providing a straightforward way to handle default values.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      The optional nullish coalescing operator is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Accessing nested properties in objects returned from APIs where some fields may be optional.</li>
      <li>Providing fallback values for user input where the input might be <code>null</code> or <code>undefined</code>.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      The optional nullish coalescing operator is a powerful addition to TypeScript that simplifies property access and default value assignment. By combining optional chaining and nullish coalescing, it provides a safe and clean way to handle nested properties, resulting in more maintainable code and reducing the likelihood of runtime errors.
    </p>
  </div>

}@case(32){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Type Narrowing in TypeScript</h1>
  
    <p>
      Type narrowing is a technique used in TypeScript to refine the type of a variable within a certain scope, typically within control flow statements like <code>if</code> or <code>switch</code>. This allows developers to write safer and more predictable code by providing TypeScript with additional information about the variable's type.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Type Narrowing</h2>
  
    <p>
      Type narrowing happens when TypeScript can deduce a more specific type for a variable based on certain conditions. By utilizing type guards, TypeScript enables developers to restrict a variable's type to a more specific subset, allowing for more precise operations on that variable.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Common Techniques for Type Narrowing</h2>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">1. Using <code>typeof</code></h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function logValue(value: number | string) &#123;<br />
            if (typeof value === 'string') &#123;<br />
                console.log('String value:', value);<br />
            &#125; else &#123;<br />
                console.log('Number value:', value);<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">2. Using <code>instanceof</code></h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        class Dog &#123;<br />
            bark() &#123; console.log('Woof!'); &#125;<br />
        &#125;<br />
        class Cat &#123;<br />
            meow() &#123; console.log('Meow!'); &#125;<br />
        &#125;<br />
        function makeSound(animal: Dog | Cat) &#123;<br />
            if (animal instanceof Dog) &#123;<br />
                animal.bark();<br />
            &#125; else &#123;<br />
                animal.meow();<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">3. Using <code>in</code> Operator</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        interface Bird &#123;<br />
            fly: () => void;<br />
        &#125;<br />
        interface Fish &#123;<br />
            swim: () => void;<br />
        &#125;<br />
        function move(animal: Bird | Fish) &#123;<br />
            if ('fly' in animal) &#123;<br />
                animal.fly();<br />
            &#125; else &#123;<br />
                animal.swim();<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Type Narrowing</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Improves type safety by ensuring that the operations performed on a variable are valid for its actual type.</li>
      <li>Reduces the need for type assertions and explicit type casting, leading to cleaner code.</li>
      <li>Helps in catching potential bugs at compile time instead of runtime.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Type narrowing is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Handling user inputs where the type might vary based on the context.</li>
      <li>Working with APIs that may return different types of responses.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Type narrowing is a powerful feature in TypeScript that enhances type safety and code readability. By allowing developers to specify and refine types based on conditions, TypeScript helps prevent errors and improves the overall quality of the code. Understanding and utilizing type narrowing can lead to more robust and maintainable applications.
    </p>
  </div>
  
}@case(33){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Type Predicates in TypeScript</h1>
  
    <p>
      Type predicates in TypeScript are a way to define a function that can return a boolean indicating whether a given variable is of a specific type. They allow for type checking and can help narrow down the types of variables in a type-safe manner, making the code more robust and readable.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Type Predicates</h2>
  
    <p>
      A type predicate is defined using the <code>is</code> keyword in a function's return type. When TypeScript sees a function returning a type predicate, it can refine the type of the variable passed to that function in conditional checks.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function isTypeName(variable: any): variable is TypeName &#123;<br />
            // Logic to determine the type<br />
            return true; // or false<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Type Predicates</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        interface Dog &#123;<br />
            bark: () => void;<br />
        &#125;<br />
        interface Cat &#123;<br />
            meow: () => void;<br />
        &#125;<br />
        function isDog(animal: Dog | Cat): animal is Dog &#123;<br />
            return (animal as Dog).bark !== undefined;<br />
        &#125;<br />
        <br />
        function makeSound(animal: Dog | Cat) &#123;<br />
            if (isDog(animal)) &#123;<br />
                animal.bark();<br />
            &#125; else &#123;<br />
                animal.meow();<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In this example, we have two interfaces, <code>Dog</code> and <code>Cat</code>, each with their respective methods.
      </li>
      <li>
        The function <code>isDog</code> is a type predicate that checks whether the provided animal is a <code>Dog</code> by verifying if the <code>bark</code> method is defined.
      </li>
      <li>
        In the <code>makeSound</code> function, we use the <code>isDog</code> function to narrow down the type of <code>animal</code>. If it's a <code>Dog</code>, we call the <code>bark</code> method; otherwise, we call the <code>meow</code> method on <code>Cat</code>.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Type Predicates</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Improves type safety by allowing more precise type checking at runtime.</li>
      <li>Reduces the need for type assertions, leading to cleaner and more maintainable code.</li>
      <li>Helps in writing functions that can handle multiple types safely, enhancing the overall robustness of the code.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Type predicates are particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Working with union types where specific operations are needed for different types.</li>
      <li>Creating more complex type-checking functions to ensure the integrity of the data being processed.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Type predicates are a powerful feature in TypeScript that enhances type safety and readability. By allowing developers to define specific type checks, TypeScript helps create more maintainable and reliable code. Understanding and effectively using type predicates can significantly improve your TypeScript coding experience.
    </p>
  </div>
  
}@case(34){
  
}
}