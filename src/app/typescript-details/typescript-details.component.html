
@switch (topicId) {
   @case (1){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">TypeScript Key Features</h1>

  <p class="text-lg text-gray-700 mb-4">
    TypeScript is a strongly typed superset of JavaScript that adds optional
    static typing and other features to enhance the development experience. Here
    are the key features of TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Static Typing
      </h2>
      <p class="text-gray-700">
        TypeScript allows developers to assign specific data types (e.g.,
        number, string, boolean, array, etc.) to variables, function parameters,
        and return types. This helps catch type-related errors at compile time,
        improving code safety and maintainability.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Type Inference
      </h2>
      <p class="text-gray-700">
        TypeScript can automatically infer types based on the assigned values,
        which means you don't have to explicitly annotate types in every case,
        making the code cleaner while still maintaining type safety.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Interfaces and Type Aliases
      </h2>
      <p class="text-gray-700">
        TypeScript provides interfaces to define the structure of objects and
        ensure that they have a consistent shape. Type aliases can be used to
        define custom types, making the code more expressive and reusable.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Classes and Object-Oriented Programming (OOP)
      </h2>
      <p class="text-gray-700">
        TypeScript supports OOP concepts like classes, inheritance, access
        modifiers (public, private, protected), and abstract classes. This
        brings a more structured, traditional approach to JavaScript
        development.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">5. Generics</h2>
      <p class="text-gray-700">
        TypeScript supports generics, allowing you to write reusable and
        flexible code that can work with different data types while maintaining
        type safety.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Type Checking and Compile-Time Error Detection
      </h2>
      <p class="text-gray-700">
        TypeScript performs type checking at compile time, helping developers
        catch potential errors early in the development process, reducing
        runtime issues in production.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Union and Intersection Types
      </h2>
      <p class="text-gray-700">
        Union types allow variables to hold multiple possible types (e.g.,
        number | string), and intersection types let you combine multiple types
        into one, offering more flexibility in defining data structures.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">8. Enums</h2>
      <p class="text-gray-700">
        Enums provide a way to define a set of named constants, improving the
        readability and maintainability of code by representing a collection of
        related values more clearly.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Advanced IDE Support
      </h2>
      <p class="text-gray-700">
        TypeScript integrates well with modern IDEs like VS Code, offering
        powerful tooling such as autocompletion, refactoring tools, and inline
        type hints, which significantly improve developer productivity.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        10. Modules and Namespaces
      </h2>
      <p class="text-gray-700">
        TypeScript supports both ES modules and its own module system, making it
        easy to organize code into reusable components. Namespaces help organize
        large codebases by grouping related code under a common namespace.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        11. Compatibility with JavaScript
      </h2>
      <p class="text-gray-700">
        Since TypeScript is a superset of JavaScript, all valid JavaScript code
        is also valid TypeScript code. This makes it easy to gradually adopt
        TypeScript in existing JavaScript projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        12. Decorators (Experimental)
      </h2>
      <p class="text-gray-700">
        TypeScript supports decorators, which are special annotations used for
        adding metadata to classes and methods. They are commonly used in
        frameworks like Angular to define behaviors like routing, services, or
        component metadata.
      </p>
    </li>
  </ul>
</div>
}
 @case (2) {
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">
    Benefits of Using TypeScript
  </h1>

  <p class="text-lg text-gray-700 mb-4">
    TypeScript offe    rs numerous benefits to developers, especially when working
    on large-scale applications or projects that require strong type safety.
    Below are some of the key benefits of using TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Improved Code Quality and Safety
      </h2>
      <p class="text-gray-700">
        By enforcing static typing, TypeScript helps catch type-related errors
        during development, reducing the likelihood of runtime errors. This
        improves overall code quality and safety, making it easier to maintain
        and scale projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Enhanced Developer Experience
      </h2>
      <p class="text-gray-700">
        TypeScript integrates seamlessly with popular IDEs like Visual Studio
        Code, offering advanced features like autocompletion, real-time error
        checking, and intelligent code refactoring. This boosts productivity and
        allows for a smoother development experience.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Early Error Detection
      </h2>
      <p class="text-gray-700">
        TypeScript’s compile-time error checking allows developers to detect and
        fix errors early in the development process. This minimizes the number
        of bugs found during testing and reduces time spent debugging during
        production.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Scalability for Large Projects
      </h2>
      <p class="text-gray-700">
        For large codebases, TypeScript’s static typing and OOP features like
        interfaces, classes, and generics provide a more structured approach.
        This makes it easier to manage and scale complex projects while
        maintaining consistent code quality.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        5. Better Collaboration and Readability
      </h2>
      <p class="text-gray-700">
        The self-documenting nature of TypeScript (through type annotations and
        interfaces) enhances collaboration among team members. Developers can
        easily understand each other's code and work with greater efficiency,
        leading to better readability and maintainability.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Compatibility with JavaScript
      </h2>
      <p class="text-gray-700">
        Since TypeScript is a superset of JavaScript, it can run alongside
        existing JavaScript code. This allows teams to gradually migrate to
        TypeScript without the need for a complete rewrite of legacy code,
        making it an ideal choice for both new and existing projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Strong Ecosystem and Community Support
      </h2>
      <p class="text-gray-700">
        TypeScript has a growing and active community, with support from major
        frameworks like Angular and libraries like React and Vue. The ecosystem
        is mature, offering a wide range of resources, tutorials, and tools to
        support developers.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        8. Enables Modern JavaScript Features
      </h2>
      <p class="text-gray-700">
        TypeScript supports the latest JavaScript features (e.g., async/await,
        destructuring, modules) while ensuring backward compatibility with older
        browsers through transpilation. This means developers can take advantage
        of modern features without sacrificing browser support.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Supports Large-Scale Refactoring
      </h2>
      <p class="text-gray-700">
        TypeScript's strong typing and IDE integration provide powerful
        refactoring capabilities, allowing developers to rename variables,
        functions, or entire modules with confidence, knowing the changes will
        propagate throughout the codebase safely.
      </p>
    </li>
  </ul>
</div>

} @case (3){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">
    Drawbacks of Using TypeScript
  </h1>

  <p class="text-lg text-gray-700 mb-4">
    While TypeScript offers many advantages, it also comes with certain
    drawbacks that developers should be aware of before adopting it in their
    projects. Below are some of the key drawbacks of using TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Additional Learning Curve
      </h2>
      <p class="text-gray-700">
        For developers who are familiar with JavaScript but new to TypeScript,
        there is an additional learning curve. Concepts like static typing,
        interfaces, and generics can take time to grasp, which may slow down the
        initial development process.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Longer Compilation Time
      </h2>
      <p class="text-gray-700">
        TypeScript code needs to be compiled into JavaScript before it can be
        executed. This extra compilation step can introduce delays, especially
        in larger projects, leading to longer build times and slower feedback
        during development.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Increased Project Complexity
      </h2>
      <p class="text-gray-700">
        The introduction of TypeScript can add complexity to a project, as
        developers must manage type definitions, configurations, and potential
        integration issues with third-party libraries. This may increase the
        overall maintenance overhead.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Limited Support for Some JavaScript Libraries
      </h2>
      <p class="text-gray-700">
        Not all JavaScript libraries have complete TypeScript definitions, which
        can make integrating certain libraries difficult. Developers may need to
        write their own type definitions or use third-party tools to ensure
        compatibility.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        5. Larger Codebase
      </h2>
      <p class="text-gray-700">
        TypeScript's strict type enforcement often results in writing more code,
        especially with type annotations. While this improves code safety, it
        can also lead to a larger codebase, which may require additional effort
        to maintain.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Potential Overhead for Small Projects
      </h2>
      <p class="text-gray-700">
        For small projects or scripts, the benefits of TypeScript might not
        justify the added complexity and setup requirements. In such cases, the
        overhead of configuring and maintaining TypeScript might outweigh the
        advantages.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Migration Challenges
      </h2>
      <p class="text-gray-700">
        Migrating existing JavaScript projects to TypeScript can be
        time-consuming, especially for large codebases. Developers must refactor
        code, define types, and address potential issues with dependencies,
        which can slow down the migration process.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        8. Dependency on Build Tools
      </h2>
      <p class="text-gray-700">
        TypeScript relies on build tools like Webpack, Babel, or TypeScript’s
        own compiler to convert TypeScript code into JavaScript. This adds a
        layer of complexity to the development environment, especially for teams
        that are not familiar with these tools.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Debugging Overhead
      </h2>
      <p class="text-gray-700">
        Although TypeScript provides many benefits for catching errors early,
        debugging compiled TypeScript code can sometimes be more challenging
        than debugging plain JavaScript. Developers must use source maps or
        other tools to trace errors back to the original TypeScript source.
      </p>
    </li>
  </ul>
</div>

}@case (4){
<div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
  <h1 class="text-3xl font-bold text-gray-800">TypeScript Compiler (tsc)</h1>

  <p class="text-lg text-gray-700">
    The TypeScript compiler, commonly referred to as
    <code class="font-mono bg-gray-200 p-1 rounded">tsc</code>, is a tool that
    translates TypeScript code into JavaScript. Since browsers and JavaScript
    engines can't execute TypeScript directly,
    <code class="font-mono bg-gray-200 p-1 rounded">tsc</code> is essential in
    converting it.
  </p>

  <div class="space-y-2">
    <h2 class="text-xl font-semibold text-gray-700">
      Key Functions of
      <code class="font-mono bg-gray-200 p-1 rounded">tsc</code>:
    </h2>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">1. Transpilation</h3>
      <p class="text-gray-600">
        Translates TypeScript code into plain JavaScript, allowing it to run in
        any environment supporting JavaScript.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">2. Type Checking</h3>
      <p class="text-gray-600">
        Before converting to JavaScript,
        <code class="font-mono bg-gray-200 p-1 rounded">tsc</code> checks for
        type errors and ensures code consistency based on provided type
        annotations.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">3. Configuration</h3>
      <p class="text-gray-600">
        You can customize the compiler using the
        <code class="font-mono bg-gray-200 p-1 rounded">tsconfig.json</code>
        file to set options like JavaScript target version and module systems.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">
        4. Incremental Compilation
      </h3>
      <p class="text-gray-600">
        The compiler can incrementally compile only changed files, improving
        efficiency in larger projects.
      </p>
    </div>
  </div>
</div>

} @case (5){
<div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
  <h1 class="text-3xl font-bold text-gray-800">
    Type Conversions in TypeScript
  </h1>

  <p class="text-lg text-gray-700">
    TypeScript allows for various ways to convert from one type to another. Type
    conversion, also known as type casting, helps you ensure that data is
    interpreted as expected during code execution.
  </p>

  <div class="space-y-2">
    <h2 class="text-xl font-semibold text-blue-700">
      Key Types of Type Conversions:
    </h2>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        1. Explicit Conversion (Type Casting)
      </h3>
      <p class="text-gray-600">
        In TypeScript, you can explicitly convert one type to another using
        either the angle-bracket syntax (<code
          class="font-mono bg-gray-200 p-1 rounded"
          >&lt;type&gt;</code
        >) or the
        <code class="font-mono bg-gray-200 p-1 rounded">as</code> keyword.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm language-javascript" codeHighlight >
        let value: any = "123";
        let num: number = &lt;number&gt;value;
      </code></pre>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm language-javascript" codeHighlight>
        let value: any = "123";<br>
        let num: number = value as number;
      </code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        2. Implicit Conversion (Type Inference)
      </h3>
      <p class="text-gray-600">
        TypeScript also performs automatic type inference in some cases, where
        it converts one type to another without explicit casting.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"><code class="font-mono text-sm language-javascript" codeHighlight >
          let num = 123;<br>
          let str = num + " is a number"; // 'str' becomes a string
        </code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        3. Built-in Conversion Functions
      </h3>
      <p class="text-gray-600">
        JavaScript (and TypeScript) provides built-in functions like
        <code class="font-mono bg-gray-200 p-1 rounded">Number()</code>,
        <code class="font-mono bg-gray-200 p-1 rounded">String()</code>, and
        <code class="font-mono bg-gray-200 p-1 rounded">Boolean()</code> for
        converting data types.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm language-javascript" codeHighlight>
        let value: string = "456";<br>
        let num: number = Number(value);
      </code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        4. Avoiding Runtime Errors
      </h3>
      <p class="text-gray-600">
        Type conversions help avoid unexpected runtime errors. TypeScript
        ensures that conversions are valid or warns you at compile-time.
      </p>
      <p class="text-gray-600">
        For example, converting a non-numeric string to a number will result in
        <code class="font-mono bg-gray-200 p-1 rounded"
          >NaN</code
        >.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm language-javascript" class="" codeHighlight>
        let invalidNum: number = Number("not a number"); // NaN</code></pre>
    </div>
  </div>
</div>

}@case (6){
  <div class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">TypeScript Loops in Angular</h1>
  
    <p class="mb-4">
      In TypeScript, both <span class="font-semibold">for</span> loops and
      <span class="font-semibold">while</span> loops work similarly to how they do in JavaScript, but with optional static
      typing features that TypeScript provides. Below is an explanation of both types of loops:
    </p>
  
    <!-- For Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">1. For Loop</h2>
      <p class="mb-4">
        A for loop is typically used when you know the number of iterations beforehand. The structure consists of three
        parts: initialization, condition, and increment/decrement.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >for (initialization; condition; increment/decrement) {{'{'}} <br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}}</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>for (let i: number = 0; i < 5; i++)  {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          {{'}'}}</code>
      </pre>
      <p class="my-2">
        <span class="font-semibold">let i: number = 0;</span> → initializes the loop counter <span class="italic">i</span>
        as a number and starts at 0.
      </p>
      <p class="my-2">
        <span class="font-semibold">i < 5;</span> → loop continues as long as <span class="italic">i</span> is less than 5.
      </p>
      <p class="my-2">
        <span class="font-semibold">i++</span> → increments <span class="italic">i</span> by 1 after every iteration.
      </p>
    </div>
  
    <!-- While Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">2. While Loop</h2>
      <p class="mb-4">
        A while loop runs as long as a specified condition is <span class="font-semibold">true</span>. It’s commonly used
        when the number of iterations is not known beforehand.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>while (condition) {{'{'}} <br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}}</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>let i: number = 0;<br><br>
        while (i < 5)  {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;i++;<br>
          {{'}'}}</code>
      </pre>
      <p class="my-2">
        The condition <span class="font-semibold">i < 5</span> is checked before each iteration.
      </p>
      <p class="my-2">The loop runs as long as <span class="font-semibold">i</span> is less than 5.</p>
    </div>
  
    <!-- Do-While Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">3. Do-While Loop</h2>
      <p class="mb-4">
        A do-while loop is similar to the while loop but guarantees that the loop will run at least once since the
        condition is checked after the execution of the code block.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>do {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}} while (condition);</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>let i: number = 0;<br><br>
        do {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;i++;<br>
          {{'}'}} while (i < 5);</code>
      </pre>
      <p class="my-2">
        In this example, the loop runs the first iteration before checking if <span class="font-semibold">i < 5</span>.
      </p>
    </div>
  
    <!-- Key Points -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
      <ul class="list-disc ml-6">
        <li class="my-2">
          <span class="font-semibold">For Loops:</span> Best when you know how many times to iterate.
        </li>
        <li class="my-2">
          <span class="font-semibold">While Loops:</span> Best when the number of iterations is unknown and depends on a
          condition.
        </li>
        <li class="my-2">
          <span class="font-semibold">Do-While Loops:</span> Ensures that the loop runs at least once before checking the
          condition.
        </li>
      </ul>
    </div>
</div>

}@case (7){
<article class="prose lg:prose-xl p-6 bg-gray-100 rounded-lg shadow-lg">
  <h1 class="text-3xl font-bold mb-6">
    Basic Operators and Maths in TypeScript
  </h1>
  <!-- Introduction -->
  <p class="mb-4">
    In TypeScript (and JavaScript), operators are symbols used to perform
    specific operations on variables or values. These operations can include
    mathematical calculations, comparisons, and logical operations. Here’s a
    breakdown of the most common types of operators with a focus on
    <strong>mathematical operators</strong>.
  </p>

  <!-- Arithmetic Operators -->
  <h2 class="text-xl font-semibold text-blue-700">1. Arithmetic Operators</h2>
  <p class="mb-4">
    Arithmetic operators are used to perform mathematical operations on numbers.
  </p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Result</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">+</td>
        <td class="px-4 py-2">Addition</td>
        <td class="px-4 py-2">5 + 2</td>
        <td class="px-4 py-2">7</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">-</td>
        <td class="px-4 py-2">Subtraction</td>
        <td class="px-4 py-2">5 - 2</td>
        <td class="px-4 py-2">3</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">*</td>
        <td class="px-4 py-2">Multiplication</td>
        <td class="px-4 py-2">5 * 2</td>
        <td class="px-4 py-2">10</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">/</td>
        <td class="px-4 py-2">Division</td>
        <td class="px-4 py-2">10 / 2</td>
        <td class="px-4 py-2">5</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">%</td>
        <td class="px-4 py-2">Modulus</td>
        <td class="px-4 py-2">5 % 2</td>
        <td class="px-4 py-2">1</td>
      </tr>
    </tbody>
  </table>

  <!-- Assignment Operators -->
  <h2 class="text-xl font-semibold text-blue-700">2. Assignment Operators</h2>
  <p class="mb-4">Assignment operators assign values to variables.</p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Equivalent</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">=</td>
        <td class="px-4 py-2">Assign value</td>
        <td class="px-4 py-2">x = 5</td>
        <td class="px-4 py-2">-</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">+=</td>
        <td class="px-4 py-2">Add and assign</td>
        <td class="px-4 py-2">x += 3</td>
        <td class="px-4 py-2">x = x + 3</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">-=</td>
        <td class="px-4 py-2">Subtract and assign</td>
        <td class="px-4 py-2">x -= 3</td>
        <td class="px-4 py-2">x = x - 3</td>
      </tr>
    </tbody>
  </table>

  <!-- Comparison Operators -->
  <h2 class="text-xl font-semibold text-blue-700">3. Comparison Operators</h2>
  <p class="mb-4">
    Comparison operators are used to compare two values and return a Boolean
    value (<code>true</code> or <code>false</code>).
  </p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Result</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">==</td>
        <td class="px-4 py-2">Equal to</td>
        <td class="px-4 py-2">5 == 5</td>
        <td class="px-4 py-2">true</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">===</td>
        <td class="px-4 py-2">Strict equal</td>
        <td class="px-4 py-2">5 === "5"</td>
        <td class="px-4 py-2">false</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">!=</td>
        <td class="px-4 py-2">Not equal</td>
        <td class="px-4 py-2">5 != 3</td>
        <td class="px-4 py-2">true</td>
      </tr>
    </tbody>
  </table>

  <!-- Logical Operators -->
  <h2 class="text-xl font-semibold text-blue-700">4. Logical Operators</h2>
  <p class="mb-4">Logical operators are used to combine multiple conditions.</p>

  <pre class="bg-gray-800 text-white p-4 rounded-md mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        let a = true;
        let b = false;
        console.log(a && b);  // false
        console.log(a || b);  // true
        console.log(!a);      // false
      </code>
    </pre>

  <!-- Mathematical Functions -->
  <h2 class="text-xl font-semibold text-blue-700">5. Mathematical Functions</h2>
  <p class="mb-4">
    TypeScript also supports several built-in mathematical functions through the
    <code>Math</code> object.
  </p>

  <pre class="bg-gray-800 text-white p-4 rounded-md mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        let num = Math.sqrt(16);  // 4
        console.log(Math.round(4.7));  // 5
        console.log(Math.random());    // Random number between 0 and 1
      </code>
    </pre>

  <p class="mb-4">
    These are just a few of the key operators and functions available in
    TypeScript for performing mathematical and logical operations.
  </p>
</article>

}@case(8){
<div class="max-w-4xl mx-auto p-6">
  <h1 class="text-xl font-semibold text-indigo-500 mb-2">
    The Switch Statement in TypeScript
  </h1>

  <p class="text-lg mb-4">
    The <span class="font-semibold">switch</span> statement in TypeScript is a
    control flow structure used to perform different actions based on different
    conditions. It's often used as an alternative to a series of
    <span class="font-semibold">if-else</span> statements when there are
    multiple possible outcomes for a single expression.
  </p>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Basic Structure</h2>

  <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  switch (expression) 
    case value1:
      // Code to execute if expression matches value1
      break;
    case value2:
      // Code to execute if expression matches value2
      break;
    default:
      // Code to execute if no cases match
  
      </code>
    </pre>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Explanation of the Components:</h2>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">expression:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>
        The expression inside the <span class="font-semibold">switch</span> is
        evaluated once.
      </li>
      <li>
        The result of the expression is then compared to the values of each case
        (value1, value2, etc.).
      </li>
    </ul>
  </div>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">case value1, value2:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>Each case represents a possible value of the expression.</li>
      <li>
        If a case matches the value of the expression, the corresponding block
        of code will be executed.
      </li>
      <li>
        <span class="font-semibold">break:</span> The
        <span class="font-semibold">break</span> statement ensures that after a
        matching case's code is executed, the
        <span class="font-semibold">switch</span> statement ends. Without a
        <span class="font-semibold">break</span>, the code would continue to
        execute the following cases (a behavior called "fall-through").
      </li>
    </ul>
  </div>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">default:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>The <span class="font-semibold">default</span> case is optional.</li>
      <li>
        If no case matches the value of the expression, the
        <span class="font-semibold">default</span> block will be executed.
      </li>
    </ul>
  </div>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Example of a switch Statement</h2>

  <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
  let day = 2;

  switch (day) 
    case 1:
      console.log('Monday');
      break;
    case 2:
      console.log('Tuesday');
      break;
    case 3:
      console.log('Wednesday');
      break;
    default:
      console.log('Other day');
        
      </code>
    </pre>

  <h3 class="text-xl font-semibold text-indigo-500 mb-4">Explanation:</h3>
  <ul class="list-disc pl-8 text-lg">
    <li>
      The variable <span class="font-semibold">day</span> has a value of 2.
    </li>
    <li>
      The <span class="font-semibold">switch</span> statement checks the value
      of <span class="font-semibold">day</span>:
    </li>
    <li>If it’s 1, it prints "Monday".</li>
    <li>
      If it’s 2, it prints "Tuesday" (this is the matching case, so the code
      executes this block and breaks out of the switch).
    </li>
    <li>
      If no case matches, the <span class="font-semibold">default</span> block
      would execute.
    </li>
  </ul>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">
    Use Cases for the switch Statement:
  </h2>
  <ul class="list-disc pl-8 text-lg">
    <li>
      The <span class="font-semibold">switch</span> statement is useful when you
      have multiple potential outcomes for a single expression.
    </li>
    <li>
      It simplifies code readability over long chains of
      <span class="font-semibold">if-else</span> conditions, especially when
      comparing the same variable multiple times.
    </li>
  </ul>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Key Points:</h2>
  <ul class="list-disc pl-8 text-lg">
    <li>
      <span class="font-semibold">Fall-through:</span> Without a
      <span class="font-semibold">break</span>, TypeScript (and JavaScript) will
      continue to execute subsequent case blocks until it finds a break.
    </li>
    <li>
      <span class="font-semibold">Type Safety:</span> Since TypeScript is
      strongly typed, mismatched data types (like comparing a string case with a
      number expression) will cause compile-time errors.
    </li>
  </ul>
</div>

}@case(9){
  <div>

  
  <p class="mb-4">
    The ternary operator in TypeScript (as in JavaScript) is a concise way to perform conditional logic. It’s sometimes
    called the "conditional operator" and takes three operands, hence the name "ternary." It’s often used as a
    shorthand for simple <span class="font-semibold">if-else</span> conditions.
  </p>

  <!-- Syntax Section -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Syntax:</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >condition ? expressionIfTrue : expressionIfFalse;</code>
    </pre>
    <p class="mt-2">
      <span class="font-semibold">condition</span>: A boolean expression that is evaluated.
    </p>
    <p class="mt-2">
      <span class="font-semibold">expressionIfTrue</span>: The expression that will be executed if the condition is true.
    </p>
    <p class="mt-2">
      <span class="font-semibold">expressionIfFalse</span>: The expression that will be executed if the condition is false.
    </p>
  </div>
   <!-- Example 1: Basic Usage -->
   <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 1: Basic Usage</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let age: number = 18;<br>
      let message: string = age >= 18 ? "You are an adult." : "You are a minor.";<br>
      console.log(message);  // Output: "You are an adult."</code>
    </pre>
    <p class="mt-2">
      If <span class="font-semibold">age >= 18</span> is true, <span class="font-semibold">message</span> will be set to
      <span class="font-semibold">"You are an adult."</span>
    </p>
    <p class="mt-2">
      If <span class="font-semibold">age >= 18</span> is false, <span class="font-semibold">message</span> will be set to
      <span class="font-semibold">"You are a minor."</span>
    </p>
  </div>

  <!-- Example 2: Assigning Values Conditionally -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 2: Assigning Values Conditionally</h2>
    <p class="mb-4">
      The ternary operator is often used to assign values based on conditions, especially for simple logic.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let isAuthenticated: boolean = true;<br>
      let greeting: string = isAuthenticated ? "Welcome back!" : "Please log in.";<br>
      console.log(greeting);  // Output: "Welcome back!"</code>
    </pre>
  </div>
  <!
  <!-- Example 3: Ternary Operator in JSX -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 3: Using Ternary Operator in JSX (React with TypeScript)</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >const loggedIn: boolean = true;<br><br>
      return (<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{'{'}}loggedIn ? &lt;p&gt;Welcome User!&lt;/p&gt; : &lt;p&gt;Please sign in&lt;/p&gt; {{'}'}};<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
      );</code>
    </pre>
    <p class="mt-2">
      You can use the ternary operator in JSX to render different UI elements conditionally.
    </p>
  </div>

  <!-- Example 4: Nesting Ternary Operators -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 4: Nesting Ternary Operators</h2>
    <p class="mb-4">
      Although nesting ternary operators is possible, it can reduce code readability, so it’s recommended to avoid deep
      nesting.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let score: number = 75;<br>
      let grade: string = score >= 90 ? "A" : score >= 75 ? "B" : "C";<br>
      console.log(grade);  // Output: "B"</code>
    </pre>
    <p class="mt-2">
      In this example:
    </p>
    <ul class="list-disc ml-6">
      <li class="my-2">
        If <span class="font-semibold">score >= 90</span>, <span class="font-semibold">grade</span> is "A".
      </li>
      <li class="my-2">
        Otherwise, if <span class="font-semibold">score >= 75</span>, <span class="font-semibold">grade</span> is "B".
      </li>
      <li class="my-2">Otherwise, <span class="font-semibold">grade</span> is "C".</li>
    </ul>
  </div>

  <!-- Key Points Section -->
<!-- Key Points Section -->
<div class="mb-6">
  <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
  <ul class="list-disc ml-6">
    <li class="my-2">
      The ternary operator is best used for simple conditional expressions.
    </li>
    <li class="my-2">
      For complex logic, using <span class="font-semibold">if-else</span> statements might improve readability.
    </li>
    <li class="my-2">
      It is a powerful tool for writing concise code, especially in inline scenarios like JSX, or when assigning
      values based on conditions.
    </li>
  </ul>
</div>

</div> 

}@case(10){
  <div class="p-6 max-w-3xl mx-auto bg-white rounded-xl shadow-md space-y-4">
    <h1 class="text-2xl font-bold text-blue-800">Type Assertions in TypeScript</h1>
    <p class="text-gray-700">
      Type assertions in TypeScript are a way to tell the TypeScript compiler to treat a variable as a different type than what it is initially inferred as or declared. Type assertions can be used when you're certain about the type of a value but TypeScript is unable to infer it.
    </p>
  
    <h2 class="text-xl font-semibold text-blue-800">Two Syntaxes for Type Assertions:</h2>
  
    <div class="space-y-2">
      <h3 class="font-semibold text-lg text-blue-700">1. Using the <span class="text-red-500">as</span> keyword (recommended):</h3>
      <pre class="bg-gray-100 p-4 rounded-md">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >let someValue: unknown = "Hello, World!";<br />let strLength: number = (someValue as string).length;</code>
      </pre>
  
      <h3 class="font-semibold text-lg text-blue-700">2. Using angle-bracket syntax:</h3>
      <pre class="bg-gray-100 p-4 rounded-md">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >let someValue: unknown = "Hello, World!";<br />let strLength: number = (&lt;string&gt;someValue).length;</code>
      </pre>
  
      <p class="text-gray-600">
        <span class="font-bold">Note:</span> The angle-bracket syntax cannot be used in <span class="text-purple-600">.tsx</span> files (React files) because it conflicts with JSX syntax, so the <span class="text-red-500">as</span> syntax is preferred, especially when working with React.
      </p>
    </div>
  
    <h2 class="text-xl font-semibold text-blue-800">Key Points:</h2>
    <ul class="list-disc pl-6 text-gray-700">
      <li>Type assertions do not perform any runtime type checks, they only affect the compile-time type checking.</li>
      <li>Type assertions should only be used when you are confident about the type of the value.</li>
      <li>Type assertions can help when dealing with legacy code, third-party libraries, or when TypeScript cannot infer a specific type.</li>
    </ul>
  
    <h2 class="text-xl font-semibold text-blue-800">Example Usage:</h2>
    <pre class="bg-gray-100 p-4 rounded-md" >
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >// Example with DOM element<br />const inputElement = document.getElementById("myInput") as HTMLInputElement;<br />inputElement.value = "Typed value";</code>
    </pre>
  
    <p class="text-gray-700">
      Without type assertion, the type of <code>inputElement</code> would just be <code>HTMLElement | null</code>. With type assertion, we're telling TypeScript that we're sure it's an HTMLInputElement.
    </p>
  </div>

}@case(11){
  <div class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">Type Aliases in TypeScript</h1>
    
    <p class="mb-4">
      In TypeScript, <span class="font-semibold">Type Aliases</span> provide a way to define a custom name (alias) for a specific type. 
      They can simplify complex type definitions and make your code more readable and manageable. A type alias can be used for 
      primitive types, object types, union types, function signatures, or any other type.
    </p>
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Syntax:</h2>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight  >type AliasName = ExistingType;</code>
      </pre>
    </div>
     <!-- Example 1: Basic Usage with Primitives -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 1: Basic Usage with Primitives</h2>
    <p class="mb-2">
      You can create a type alias for primitive types like <span class="font-semibold">string</span>, <span class="font-semibold">number</span>, etc.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type ID = number;<br>type Name = string;<br><br>
      let userID: ID = 123;<br>let userName: Name = "Alice";</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">ID</span> is an alias for <span class="font-semibold">number</span>, and <span class="font-semibold">Name</span> is an alias for <span class="font-semibold">string</span>.
    </p>
  </div>

  <!-- Example 2: Type Aliases with Objects -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 2: Type Aliases with Objects</h2>
    <p class="mb-2">
      You can also create type aliases for objects and use them to define the shape of the object.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type User =  {{'{'}}<br>&nbsp;&nbsp;id: number;<br>&nbsp;&nbsp;name: string;<br>&nbsp;&nbsp;age: number;<br> {{'}'}};<br><br>
      let user: User = {{'{'}}<br>&nbsp;&nbsp;id: 1,<br>&nbsp;&nbsp;name: "Alice",<br>&nbsp;&nbsp;age: 25<br> {{'}'}};</code>
    </pre>
    <p class="mt-2">
      Here, the <span class="font-semibold">User</span> type alias defines the structure of a user object.
    </p>
  </div>

  <!-- Example 3: Type Aliases with Union Types -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 3: Type Aliases with Union Types</h2>
    <p class="mb-2">
      Type aliases are often useful when dealing with <span class="font-semibold">union types</span> (a type that can be one of several types).
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Status = "success" | "error" | "loading";<br><br>
      let requestStatus: Status = "success";<br>requestStatus = "loading";<br>// requestStatus = "failed"; // Error</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">Status</span> is an alias for a union of string literals, allowing only three possible values.
    </p>
  </div>

  <!-- Example 4: Type Aliases with Functions -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 4: Type Aliases with Functions</h2>
    <p class="mb-2">
      You can use type aliases to describe function signatures.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type AddFunction = (a: number, b: number) => number;<br><br>
      let add: AddFunction = (x, y) => x + y;<br>console.log(add(5, 3));  // Output: 8</code>
    </pre>
    <p class="mt-2">
      In this example, <span class="font-semibold">AddFunction</span> is a type alias for a function that takes two <span class="font-semibold">number</span> arguments and returns a <span class="font-semibold">number</span>.
    </p>
  </div>

  <!-- Example 5: Type Aliases with Tuples -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 5: Type Aliases with Tuples</h2>
    <p class="mb-2">
      Type aliases can also be used for tuples, which are fixed-length arrays with specific types at each index.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Point = [number, number];<br><br>
      let point: Point = [10, 20];</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">Point</span> is an alias for a tuple containing two <span class="font-semibold">number</span> values.
    </p>
  </div>

  <!-- Example 6: Type Aliases with Optional and Read-Only Properties -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 6: Type Aliases with Optional and Read-Only Properties</h2>
    <p class="mb-2">
      You can create type aliases that include optional and read-only properties.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Person =  {{'{'}}<br>&nbsp;&nbsp;name: string;<br>&nbsp;&nbsp;age?: number; // Optional<br>&nbsp;&nbsp;readonly id: number; // Read-only<br> {{'}'}};<br><br>
      let person: Person =  {{'{'}} name: "Alice", id: 1 {{'}'}};<br>person.age = 30;<br>// person.id = 2; // Error</code>
    </pre>
    <p class="mt-2">
      In this example, <span class="font-semibold">Person</span> has both optional and read-only properties.
    </p>
  </div>

 <!-- Key Points Section -->
 <div class="mb-6">
  <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
  <ul class="list-disc ml-6">
    <li class="my-2">Type Aliases can represent complex types in a simpler and more readable form.</li>
    <li class="my-2">They are flexible and can be used for primitives, objects, union types, functions, tuples, and more.</li>
    <li class="my-2">
      Type aliases are not unique types, but just a way to create a name for a type. The alias does not create a new type, it just gives an existing type a new name.
    </li>
    <li class="my-2">
      Type aliases in TypeScript make your code easier to maintain and understand, especially in scenarios where the same structure or pattern is used multiple times.
    </li>
  </ul>
</div>
    </div>
    
}@case(12){
  <div class="p-6 bg-gray-100">
    <h1 class="text-2xl font-bold mb-4">Understanding Interfaces in TypeScript</h1>
  
    <p class="mb-4">
      In TypeScript, interfaces are used to define the structure of objects, classes, and functions. An interface acts as a contract that a class or an object must adhere to. It defines the types of properties and methods an object should have without providing the implementation. Interfaces promote strong typing, making code more predictable and easier to maintain.
    </p>
  
    <h2  class="text-xl font-semibold text-blue-700">Syntax</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface InterfaceName {{'{'}}
      property1: type;
      property2: type;
      method1(param: type): returnType;
      {{'}'}}
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 1: Basic Object Structure</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Person{{'{'}}
      name: string;
      age: number;
      greet(): void;
    {{'}'}}
  
  const person: Person = {{'{'}}
      name: "John",
      age: 30,
      greet(){{'{'}}
          console.log('Hello, my name is ' + this.name);
          {{'}'}}
    {{'}'}};
  
  person.greet();  // Output: Hello, my name is John.
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 2: Optional Properties</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Car {{'{'}}
      make: string;
      model: string;
      year?: number;
    {{']'}}
  
  const car1: Car ={{'{'}} make: "Toyota", model: "Camry" {{'}'}};
  const car2: Car = {{'{'}} make: "Tesla", model: "Model S", year: 2020 {{'}'}};
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 3: Readonly Properties</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface User{{'{'}}
      readonly id: number;
      name: string;
    {{'}'}}
  
  const user: User ={{'{'}} id: 1, name: "Alice" {{'}'}};
  // user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 4: Extending Interfaces</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Animal {{'{'}}
      name: string;
      {{'}'}}
  
  interface Dog extends Animal {{'{'}}
      breed: string;
      {{'}'}}
  
  const myDog: Dog ={{'{'}} name: "Buddy", breed: "Golden Retriever"{{'}'}};
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 5: Function Types</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface MathOperation {{'{'}}
      (a: number, b: number): number;
    {{'}'}}
  
  const add: MathOperation = (x, y) => x + y;
  console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 6: Indexable Types</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface StringArray {{'{'}}
      [index: number]: string;
    {{'}'}}
  
  let myArray: StringArray = ["Hello", "World"];
  console.log(myArray[0]); // Output: Hello
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold text-blue-700">Example 7: Class Implementing an Interface</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Shape {{'{'}}
      area(): number;
    {{'}'}}
  
  class Circle implements Shape {{'{'}}
      constructor(public radius: number) {{'{}'}}
      area() {{'{'}}
          return Math.PI * this.radius * this.radius;
      {{'}'}}
    {{'}'}}
  
  const circle = new Circle(5);
  console.log(circle.area());  // Output: 78.53981633974483
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Benefits of Using Interfaces</h2>
    <ul class="list-disc list-inside mb-4">
      <li>Type Safety: Interfaces enforce a structure, helping avoid runtime errors.</li>
      <li>Code Reusability: Interfaces can be reused across different classes or functions.</li>
      <li>Abstraction: Interfaces provide a way to define the expected structure of data, decoupling the code from concrete implementations.</li>
    </ul>
  
    <h2  class="text-xl font-semibold text-blue-700">Interfaces vs. Types</h2>
    <p>
      Though interfaces and types can be used similarly, interfaces are typically preferred for defining object shapes, while type can be used for unions, intersections, or more complex types.
    </p>
  </div>

}@case(13){
  <div class="container mx-auto p-6 bg-gray-100">
    <h1 class="text-3xl font-bold text-center mb-8">Classes in TypeScript</h1>
  
    <!-- Introduction Section -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Introduction to TypeScript Classes</h2>
      <p class="text-gray-700 mb-4">
        TypeScript classes are a powerful way to create reusable object blueprints. They contain properties, methods,
        constructors, and more.
      </p>
      <p class="text-gray-700">
        In TypeScript, we can define classes that follow OOP principles such as encapsulation, inheritance, and
        polymorphism. Below are some of the key features of TypeScript classes:
      </p>
    </div>
  
    <!-- Basic Class Structure -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Basic Class Structure</h2>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Person {{'{'}}
            name: string;
            age: number;
  
            constructor(name: string, age: number) {{'{'}}
              this.name = name;
              this.age = age;
            {{'}'}}
  
            greet(): void {{'{'}}
              console.log(`Hello, my name is ${{'{'}}this.name{{'}'}} and I am ${{'{'}}this.age{{'}'}} years old.`);
            {{'}'}}
          {{'}'}}
  
          const person1 = new Person("John", 30);
          person1.greet(); // Output: Hello, my name is John and I am 30 years old.
        </code>
      </pre>
    </div>
  
    <!-- Visibility Modifiers -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Visibility Modifiers</h2>
      <p class="text-gray-700 mb-4">
        You can control the visibility of class members (properties and methods) using <code>public</code>,
        <code>private</code>, or <code>protected</code>.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Employee {{'{'}}
            private salary: number;
  
            constructor(salary: number) {{'{'}}
              this.salary = salary;
            {{'}'}}
  
            public getSalary(): number {{'{'}}
              return this.salary;
            {{'}'}}
          {{'}'}}
        </code>
      </pre>
    </div>
  
    <!-- Inheritance -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Inheritance</h2>
      <p class="text-gray-700 mb-4">
        TypeScript classes support inheritance, where one class can extend another class.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Animal {{'{'}}
            constructor(public name: string) {{'{}'}}
  
            move(): void {{'{'}}
              console.log(`$ {{'{'}}this.name{{'}'}} is moving`);
            {{'}'}}
          {{'}'}}
  
          class Dog extends Animal {{'{'}}
            bark(): void {{'{'}}
              console.log(`${{'{'}}this.name{{'}'}} is barking`);
            {{'}'}}
          {{'}'}}
  
          const dog = new Dog('Buddy');
          dog.move(); // Buddy is moving
          dog.bark(); // Buddy is barking
        </code>
      </pre>
    </div>
  
    <!-- Static Members -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Static Members</h2>
      <p class="text-gray-700 mb-4">
        Static members are accessible using the class name itself, not through an instance.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class MathHelper {{'{'}}
            static PI: number = 3.14159;
  
            static areaOfCircle(radius: number): number {{'{'}}
              return MathHelper.PI * radius * radius;
            {{'}'}}
          {{'}'}}
  
          console.log(MathHelper.areaOfCircle(5)); // Output: 78.53975
        </code>
      </pre>
    </div>
  
    <!-- Conclusion -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Conclusion</h2>
      <p class="text-gray-700">
        TypeScript classes provide a robust way to build object-oriented applications. With support for inheritance,
        access modifiers, static members, and more, TypeScript makes it easy to write clean, maintainable code.
      </p>
    </div>
  </div>

}@case(14){
  <div class="container mx-auto p-6 bg-gray-100">
    <h1 class="text-3xl font-bold text-center mb-8">Modules in TypeScript</h1>
  
    <!-- Exporting Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">1. Exporting in TypeScript</h2>
      <p class="text-gray-700 mb-4">
        In TypeScript, you can use <span class="font-bold">Named Exports</span> or <span class="font-bold">Default Exports</span> to make classes, functions, or variables available to other modules.
      </p>
      <div class="mb-4">
        <h3  class="text-xl font-semibold text-blue-500">Named Exports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // mathUtils.ts
            export function add(a: number, b: number): number{{'{'}}
                return a + b;
              {{'}'}}
  
            export function subtract(a: number, b: number): number {{'{'}}
                return a - b;
            {{'}'}}
          </code>
        </pre>
      </div>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Default Exports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // logger.ts
            export default class Logger{{'{'}}
                log(message: string): void{{'{'}}
                    console.log(message);
                {{'}'}}
              {{'}'}}
          </code>
        </pre>
      </div>
    </div>
  
    <!-- Importing Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">2. Importing in TypeScript</h2>
      <p class="text-gray-700 mb-4">
        You can import modules using the <span class="font-bold">import</span> statement. TypeScript supports both Named Imports and Default Imports.
      </p>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Named Imports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // app.ts
            import {{'{'}} add, subtract {{'}'}} from './mathUtils';
  
            console.log(add(5, 3));  // 8
            console.log(subtract(5, 3));  // 2
          </code>
        </pre>
      </div>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Default Imports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // app.ts
            import Logger from './logger';
  
            const logger = new Logger();
            logger.log('Hello, World!');
          </code>
        </pre>
      </div>
    </div>
  
    <!-- Re-exporting Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">3. Re-exporting Modules</h2>
      <p class="text-gray-700 mb-4">
        You can re-export modules to simplify imports in larger projects.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // utils.ts
          export {{'{'}} add, subtract {{'}'}} from './mathUtils';
          export {{'{'}} default as Logger {{'}'}} from './logger';
        </code>
      </pre>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // app.ts
          import{{'{'}} add, Logger {{'}'}} from './utils';
  
          const logger = new Logger();
          logger.log('Adding numbers');
          console.log(add(5, 7));
        </code>
      </pre>
    </div>
  
    <!-- Organizing Code in Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">4. Organizing Code into Modules</h2>
      <p class="text-gray-700 mb-4">
        TypeScript allows you to organize your code into separate modules. Here’s an example of how you can structure your code:
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          src/
            └── math/
                ├── add.ts
                ├── subtract.ts
            └── logger/
                └── logger.ts
            └── app.ts
        </code>
      </pre>
    </div>
  
    <!-- Module Resolution -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">5. Module Resolution</h2>
      <p class="text-gray-700 mb-4">
        TypeScript uses Node.js module resolution strategy by default. You can customize how modules are resolved using the <code >tsconfig.json</code> file.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          {{'{'}}
            "compilerOptions": {{'{'}}
              "module": "commonjs",
              "target": "es6",
              "baseUrl": "./src",
              "paths": {{'{'}}
                "*": ["node_modules/*", "src/types/*"]
              {{'}'}}
            {{'}'}}
          {{'}'}}
        </code>
      </pre>
      
    </div>
  
    <!-- Importing External Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">6. Importing External Modules</h2>
      <p class="text-gray-700 mb-4">
        You can import external modules from npm packages in TypeScript. Here’s how you can import and use Lodash:
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          npm install lodash
          npm install {{'@'}}types/lodash
        </code>
      </pre>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // app.ts
          import * as _ from 'lodash';
  
          const arr = [1, 2, 3, 4];
          console.log(_.shuffle(arr));  // Output: Shuffled array
        </code>
      </pre>
    </div>
  
    <!-- Conclusion -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Conclusion</h2>
      <p class="text-gray-700">
        Modules in TypeScript provide a clean way to organize and manage code. By using named exports, default exports, and proper module resolution, you can create maintainable, scalable applications.
      </p>
    </div>
  </div> 

}@case(15){
  <div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
    <h1 class="text-3xl font-bold text-blue-400">Generics in TypeScript</h1>
    <p class="text-lg">
      Generics in TypeScript allow you to create reusable components, functions, or classes that can work with a variety of data types, while still providing type safety. They enable you to write code that is flexible and reusable, without sacrificing the benefits of static typing.
    </p>
  
    <h2  class="text-xl font-semibold text-blue-700">Why Use Generics?</h2>
    <p class="text-lg">
      Without generics, you might have to create multiple versions of the same function or class to handle different data types, leading to repetitive code. Generics help you avoid that by making your code more abstract, while still preserving the type information.
    </p>
  
    <h2 class="text-2xl font-semibold text-blue-700">Syntax of Generics</h2>
    <p class="text-lg">
      Generics are typically denoted by angle brackets <code class="text-indigo-500">&lt;&gt;</code>, and the generic type is represented by a placeholder (often <code class="text-indigo-500">T</code>, but you can name it anything).
    </p>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Function</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function identity&lt;T&gt;(arg: T): T {{'{'}}
    return arg; 
  {{'}'}}
  
  let output1 = identity&lt;string&gt;("Hello, TypeScript!"); // Explicitly passing type
  let output2 = identity(42); // Type inferred
        </code>
      </pre>
      <p class="text-lg">
        Here, <code class="text-indigo-500">T</code> is a placeholder for the type that will be provided when the function is called. TypeScript infers the type automatically based on the passed argument (42 in the second case).
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Class</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  class GenericNumber&lt;T&gt; {{'{'}} 
    zeroValue: T; 
    add: (x: T, y: T) =&gt; T; 
  {{'}'}}
  
  let myGenericNumber = new GenericNumber&lt;number&gt;(); 
  myGenericNumber.zeroValue = 0; 
  myGenericNumber.add = function (x, y) {{'{'}} return x + y; {{'}'}};
        </code>
      </pre>
      <p class="text-lg">
        In this example, <code class="text-indigo-500">GenericNumber</code> is a class that works with any data type <code class="text-indigo-500">T</code>. It allows you to define behavior for that type (such as the <code class="text-indigo-500">add</code> function).
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Interface</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight > 
  interface Pair&lt;T, U&gt; {{'{'}}
    first: T; 
    second: U; 
  {{'}'}}
  
  let pair: Pair&lt;string, number&gt; = {{'{'}} first: "hello", second: 42 {{'}'}};
        </code>
      </pre>
      <p class="text-lg">
        Here, the <code class="text-indigo-500">Pair</code> interface uses two generic types, <code class="text-indigo-500">T</code> and <code class="text-indigo-500">U</code>, allowing it to work with a combination of different types.
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Generic Constraints</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function loggingIdentity&lt;T extends {{'{'}} length: number {{'}'}}&gt;(arg: T): T {{'{'}} 
    console.log(arg.length); // Now we know 'arg' has a .length property 
    return arg; 
  {{'}'}}
  
  loggingIdentity("Hello");
        </code>
      </pre>
      <p class="text-lg">
        In this example, the generic <code class="text-indigo-500">T</code> is constrained to types that have a <code class="text-indigo-500">length</code> property, which allows you to safely access length within the function.
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Default Types</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function createArray&lt;T = string&gt;(length: number, value: T): T[] {{'{'}}
    return Array(length).fill(value); 
  {{'}'}}
  
  let stringArray = createArray(3, "x"); // ['x', 'x', 'x']
  let numberArray = createArray&lt;number&gt;(3, 42); // [42, 42, 42]
        </code>
      </pre>
    </div>
  
    <h2 class="text-2xl font-semibold text-blue-700">Key Takeaways:</h2>
    <ul class="list-disc list-inside text-lg">
      <li>Generics are a way to create flexible, reusable, and type-safe code.</li>
      <li>Type inference allows TypeScript to figure out the types based on how generics are used.</li>
      <li>Constraints can limit the types a generic can accept.</li>
      <li>Default values for generics allow for fallback types when none are provided.</li>
      <li>Generics make TypeScript more powerful, enabling you to write code that's adaptable to many situations without losing type safety.</li>
    </ul>
  </div>
   
}@case(16){
  <div class="bg-gray-100 p-8 rounded-lg shadow-md max-w-4xl mx-auto my-10">
    <h1 class="text-3xl font-bold text-center text-indigo-600 mb-6">Namespaces in TypeScript</h1>
  
    <div class="space-y-6">
      <!-- Overview Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Introduction</h2>
        <p class="text-gray-700">
          Namespaces in TypeScript are a way to group related code together under a single name to avoid naming conflicts and to organize code better. They are primarily used for logical grouping and encapsulating code into a distinct module-like structure.
        </p>
        <p class="text-gray-700">
          However, with the advent of ECMAScript modules, the usage of namespaces has become less common in modern TypeScript projects.
        </p>
      </section>
  
      <!-- Syntax Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Syntax of a Namespace</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap"  class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace MyNamespace {{'{'}}
    export class MyClass {{'{'}}
      constructor(public name: string) {{'{}'}}
      
      public sayHello(): void {{'{'}}
        console.log(`Hello, ${{'{'}}this.name{{'}'}}`);
      {{'}'}}
    {{'}'}}
  
    export function greet(): void {{'{'}}
      console.log("Greetings from MyNamespace!");
      {{'}'}}
    {{'}'}}
          </code>
        </pre>
      </section>
  
      <!-- Usage Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Using a Namespace</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  let obj = new MyNamespace.MyClass("TypeScript");
  obj.sayHello(); // Output: Hello, TypeScript
  
  MyNamespace.greet(); // Output: Greetings from MyNamespace!
          </code>
        </pre>
      </section>
  
      <!-- Nested Namespaces Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Nested Namespaces</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace OuterNamespace {{'{'}}
    export namespace InnerNamespace {{'{'}}
      export class AnotherClass {{'{'}}
        greet(): void {{'{'}}
          console.log("Hello from InnerNamespace!");
          {{'}'}}
        {{'}'}}
      {{'}'}}
    {{'}'}}
  
  let innerObj = new OuterNamespace.InnerNamespace.AnotherClass();
  innerObj.greet(); // Output: Hello from InnerNamespace!
          </code>
        </pre>
      </section>
  
      <!-- Namespace Merging Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Namespace Merging</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace MyNamespace {{'{'}}
    export const foo = "foo;
    {{'}'}}
  
  namespace MyNamespace {{'{'}}
    export function bar() {{'{'}}
      console.log("bar");
      {{'}'}}
    {{'}'}}
  
  console.log(MyNamespace.foo); // Output: foo
  MyNamespace.bar(); // Output: bar
          </code>
        </pre>
      </section>
  
      <!-- Conclusion Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Conclusion</h2>
        <p class="text-gray-700">
          In modern TypeScript, using ECMAScript modules (via <code>import</code> and <code>export</code>) is preferred as it aligns with the standard JavaScript module system. However, namespaces can still be useful in specific cases like legacy systems or global libraries.
        </p>
      </section>
    </div>
  </div>
  
}@case(17){
<!-- app.component.html -->
<div class="container mx-auto p-5">
  <h1 class="text-2xl font-bold mb-4">Basic Functions of TypeScript</h1>

  <div class="space-y-6">
    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">1. Type Annotations</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let age: number = 30;
let name: string = "Alice";</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2 class="text-xl font-semibold text-blue-700">2. Interfaces</h2>
    <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>interface Person {{'{'}}
  name: string;
  age: number;
{{'}'}}

const person: Person = {{'{'}}
  name: "Bob",
  age: 25
{{'}'}};</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">3. Classes and Inheritance</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>class Animal {{'{'}}
  constructor(public name: string) {{'{}'}}

  speak(): void {{'{'}}
    console.log(\`\${{'{'}}this.name{{'}'}} makes a noise.\`);
  {{'}'}}
{{'}'}}

class Dog extends Animal {{'}'}}
  speak(): void {{'{'}}
    console.log(\`\${{'{'}}this.name{{'}'}} barks.\`);
  {{'}'}}
{{'}'}}

const dog = new Dog("Rex");
dog.speak(); // Rex barks.</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">4. Generics</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>function identity&lt;T&gt;(arg: T): T {{'{'}}
  return arg;
  {{'}'}}

let output = identity&lt;string&gt;("Hello"); // Output: "Hello"</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">5. Union and Intersection Types</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let id: number | string;
id = 101;   // valid
id = "101"; // valid

type Admin = {{'{'}} name: string; admin: true {{'}'}};
type User = {{'{'}} name: string; admin?: false {{'}'}};
type Person = Admin & User; // intersection type</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">6. Enums</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>enum Direction {{'{'}}
  Up = 1,
  Down,
  Left,
  Right,
  {{'}'}}

let move: Direction = Direction.Up; // move is 1</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">7. Type Aliases</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>type StringOrNumber = string | number;
let value: StringOrNumber = "hello"; // valid
value = 42; // valid</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">8. Type Assertion</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let someValue: any = "This is a string";
let strLength: number = (someValue as string).length; // Type assertion</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">9. Optional Properties and Methods</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>interface User {{'{'}}
  id: number;
  name: string;
  age?: number; // Optional
  {{'}'}}

const user: User = {{'{'}} id: 1, name: "Alice" {{'}'}}; // valid without age</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">10. Modules</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>// In module1.ts
export const PI = 3.14;

// In module2.ts
import {{'{'}} PI {{'}'}} from './module1';
console.log(PI);</code></pre>
    </div>
  </div>
</div>

}@case(18){
  <div class="container mx-auto p-6">
    <h1 class="text-3xl font-bold mb-4 text-center text-indigo-600">
      Arrow Functions in TypeScript
    </h1>
  
    <!-- Section 1: Introduction -->
    <div class="mb-6 p-4 bg-gray-100 rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Basic Syntax of Arrow Functions
      </h2>
      <p class="text-gray-600">
        Arrow functions provide a concise way to define functions using the <code>=></code> syntax. Below is the basic syntax of an arrow function.
      </p>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  const functionName = (parameters) => {{'{'}}
    // function body
  {{'}'}};
        </code>
      </pre>
    </div>
  
    <!-- Section 2: Example 1 -->
    <div class="mb-6 p-4 bg-white rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Example 1: Basic Arrow Function
      </h2>
      <pre class="bg-gray-200 p-4 rounded-md">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  const add = (a: number, b: number): number => {{'{'}}
    return a + b;
  {{'}'}};
  
  console.log(add(5, 3)); // Output: 8
        </code>
      </pre>
    </div>
  
    <!-- Section 3: Implicit Return -->
    <div class="mb-6 p-4 bg-gray-100 rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Implicit Return
      </h2>
      <p class="text-gray-600">
        You can omit curly braces and the <code>return</code> keyword when the body contains only a single expression.
      </p>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  const multiply = (a: number, b: number): number => a * b;
  console.log(multiply(4, 5)); // Output: 20
        </code>
      </pre>
    </div>
  
    <!-- Section 4: Arrow Functions and 'this' -->
    <div class="mb-6 p-4 bg-white rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Arrow Functions and <code>this</code>
      </h2>
      <p class="text-gray-600">
        Arrow functions don’t have their own <code>this</code> context; they inherit <code>this</code> from the surrounding context (lexical scope).
      </p>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight>
  class Person {{'{'}}
    name: string;
  
    constructor(name: string) {{'{'}}
      this.name = name;
    {{'}'}}
  
    greet() {{'{'}}
      setTimeout(() => {{'{'}}
        console.log(\`Hello, my name is \${{'{'}}this.name{{'}'}}\`);
      {{'}'}}, 1000);
    {{'}'}}
  {{'}'}}
  
  const person = new Person("Alice");
  person.greet(); // Output: Hello, my name is Alice
        </code>
      </pre>
    </div>
  
    <!-- Section 5: Traditional Functions vs Arrow Functions -->
    <div class="mb-6 p-4 bg-gray-100 rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-2 text-blue-700">
        Traditional Functions vs Arrow Functions
      </h2>
      <ul class="list-disc ml-5 text-gray-600">
        <li><strong>Syntax:</strong> Arrow functions have a more concise syntax.</li>
        <li><strong><code>this</code> keyword:</strong> Arrow functions inherit <code>this</code> from their lexical scope.</li>
        <li><strong>Constructors:</strong> Arrow functions cannot be used as constructors.</li>
        <li><strong>No <code>arguments</code> object:</strong> Arrow functions do not have their own <code>arguments</code> object.</li>
      </ul>
      <pre class="bg-gray-200 p-4 rounded-md mt-3">
        <code lass="font-mono text-sm" class="language-javascript" codeHighlight >
  // Error: 'arguments' is not defined in arrow functions
  const example = () => {{'{'}}
    console.log(arguments);
  {{'}'}};
  
  // Use rest parameters in arrow functions
  const example = (...args: any[]) => {{'{'}}
    console.log(args); // Logs passed arguments
  {{'}'}};
  
  example(1, 2, 3); // Output: [1, 2, 3]
        </code>
      </pre>
    </div>
  </div>
  
}@case(19){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Rest Parameters in TypeScript</h1>
    <p class="mb-4">
      In TypeScript, <strong>Rest Parameters</strong> allow you to pass an indefinite number of arguments to a function as an array. They are denoted by three dots (<code class="font-mono">...</code>) before the parameter name. Rest parameters must be the last parameters in the function's parameter list, because they capture all remaining arguments into an array.
    </p>
    
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>>
  function functionName(...restParameter: type[]): returnType &#123;
    // Function logic
  &#125;
      </code>
    </pre>
    
    <p class="mb-4">
      - <strong>restParameter</strong>: This is the name of the parameter that will hold all the additional arguments as an array.<br />
      - <strong>type[]</strong>: The type of the array elements.<br />
      - <strong>returnType</strong>: (Optional) The return type of the function.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example</h2>
    <pre class="bg-gray-100 p-4 rounded">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>>
  function sum(...numbers: number[]): number &#123;
      return numbers.reduce((acc, curr) => acc + curr, 0);
  &#125;
  
  console.log(sum(1, 2, 3)); // Output: 6
  console.log(sum(10, 20, 30, 40)); // Output: 100
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Key Points:</h2>
    <ul class="list-disc list-inside mb-4">
      <li>Rest parameters collect the remaining arguments into an array.</li>
      <li>They can only be used at the end of a function's parameter list.</li>
      <li>TypeScript ensures type safety by enforcing the type of the elements in the array.</li>
      <li>If no arguments are passed for the rest parameter, it will default to an empty array.</li>
    </ul>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Another Example with Multiple Parameters</h2>
    <pre class="bg-gray-100 p-4 rounded">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
  function greet(greeting: string, ...names: string[]) &#123;
      return \`${{'{'}}greeting{{''}} \${{'{'}}names.join(", "){{'}'}}\`;
  &#125;
  
  console.log(greet("Hello", "Alice", "Bob", "Charlie"));
  // Output: Hello Alice, Bob, Charlie
      </code>
    </pre>
    
    <p class="mb-4">
      In this case, the <strong>greeting</strong> is a regular parameter, and <strong>names</strong> is a rest parameter that collects all the other string arguments passed to the function.
    </p>
  </div>
  
}@case(20){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Spread Operator in TypeScript</h1>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Array Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Copying Arrays</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalArray = [1, 2, 3];<br />
        const copiedArray = [...originalArray];<br />
        console.log(copiedArray); // Output: [1, 2, 3]
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Merging Arrays</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const array1 = [1, 2, 3];<br />
        const array2 = [4, 5, 6];<br />
        const mergedArray = [...array1, ...array2];<br />
        console.log(mergedArray); // Output: [1, 2, 3, 4, 5, 6]
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Adding Elements to Arrays</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalArray = [1, 2, 3];<br />
        const newArray = [0, ...originalArray, 4];<br />
        console.log(newArray); // Output: [0, 1, 2, 3, 4]
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Object Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Copying Objects</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalObject = {{'{'}} a: 1, b: 2 {{'}'}};<br />
        const copiedObject = {{'{'}} ...originalObject {{'}'}};<br />
        console.log(copiedObject); // Output: {{'{'}} a: 1, b: 2 {{'}'}}
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Merging Objects</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const obj1 = {{'{'}} a: 1 {{'}'}};<br />
        const obj2 ={{'{'}} b: 2 {{'}'}};<br />
        const mergedObject = {{'{'}} ...obj1, ...obj2 {{'}'}};<br />
        console.log(mergedObject); // Output: {{'{'}}a: 1, b: 2{{'}'}}
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Updating Object Properties</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const originalObject ={{'{'}} a: 1, b: 2{{'}'}};<br />
        const updatedObject = {{'{'}} ...originalObject, b: 3 {{'}'}};<br />
        console.log(updatedObject); // Output: {{'{'}} a: 1, b: 3 {{'}'}}
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Spread Operator in Function Calls</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function sum(a: number, b: number, c: number): number {{'{'}}<br />
          return a + b + c;<br />
          {{'}'}}<br />
        const numbers = [1, 2, 3];<br />
        const result = sum(...numbers);<br />
        console.log(result); // Output: 6
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      The spread operator is a powerful feature in TypeScript that simplifies operations on arrays and objects, making your code more concise and readable. It is especially useful for immutable operations where you want to create new arrays or objects without modifying the originals.
    </p>
  </div>
  
}@case(21){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Default Parameters in TypeScript</h1>
  
    <p>
      Default parameters in TypeScript allow you to initialize function parameters with default values if no argument is provided for those parameters. This feature simplifies function calls and makes your code cleaner and more robust.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Syntax</h2>
    <p>
      The syntax for default parameters is straightforward. You simply assign a value to a parameter in the function declaration:
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function functionName(parameterName: parameterType = defaultValue) &#123;<br />
            // function body<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Basic Example</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function greet(name: string = "Guest"): string &#123;<br />
            return `Hello, ${{'{'}}name{{'}'}}!`; <br />
        &#125;<br />
        console.log(greet()); // Output: Hello, Guest!<br />
        console.log(greet("Alice")); // Output: Hello, Alice!
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Multiple Default Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function add(a: number = 0, b: number = 0): number &#123;<br />
            return a + b;<br />
        &#125;<br />
        console.log(add()); // Output: 0<br />
        console.log(add(5)); // Output: 5<br />
        console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Using Default Parameters with Other Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function multiply(a: number, b: number = 1): number &#123;<br />
            return a * b;<br />
        &#125;<br />
        console.log(multiply(5)); // Output: 5 (5 * 1)<br />
        console.log(multiply(5, 2)); // Output: 10
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">4. Default Parameters with Destructuring</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface Person &#123;<br />
            name: string;<br />
            age?: number;<br />
        &#125;<br />
        function introduce({{'{'}} name, age = 18 {{'}'}}: Person): string &#123;<br />
            return `Hi, I'm ${{'{'}}name{{'}'}} and I'm ${{'{'}}age{{'}'}} years old.`;<br />
        &#125;<br />
        console.log(introduce({{'{'}} name: "Bob" {{'}'}})); // Output: Hi, I'm Bob and I'm 18 years old.<br />
        console.log(introduce({{'{'}} name: "Alice", age: 25 {{'}'}})); // Output: Hi, I'm Alice and I'm 25 years old.
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Important Notes</h2>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Order of Parameters:</strong> Default parameters must be defined after any required parameters.</li>
      <li><strong>Undefined vs. Default:</strong> Passing `undefined` as an argument will still use the default parameter.</li>
    </ul>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      Default parameters in TypeScript are a useful feature that enhances the flexibility of functions. They help reduce the need for overloading functions or checking for undefined values, making your code more concise and easier to read.
    </p>
  </div>
  
}@case(22){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Optional Parameters in TypeScript</h1>
  
    <p>
      Optional parameters in TypeScript allow you to define function parameters that are not required when calling the function. If an optional parameter is not provided, it will be assigned the value of <code>undefined</code>. This feature enhances the flexibility of function calls and helps avoid errors related to missing arguments.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Syntax</h2>
    <p>
      To declare an optional parameter, you append a question mark (<code>?</code>) to the parameter name in the function declaration:
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
        function functionName(parameterName?: parameterType) &#123;<br />
            // function body<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example Usage</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Basic Example</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function greet(name?: string): string &#123;<br />
            return `Hello, ${{'{'}}name || 'Guest'{{'}'}}!`;<br />
        &#125;<br />
        console.log(greet()); // Output: Hello, Guest!<br />
        console.log(greet("Alice")); // Output: Hello, Alice!
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Multiple Optional Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function add(a: number, b?: number): number &#123;<br />
            return a + (b || 0); // Treat undefined as 0<br />
        &#125;<br />
        console.log(add(5)); // Output: 5<br />
        console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Using Optional Parameters with Default Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function multiply(a: number, b?: number, c: number = 1): number &#123;<br />
            return a * (b || 1) * c; // If b is undefined, use 1<br />
        &#125;<br />
        console.log(multiply(5)); // Output: 5 (5 * 1 * 1)<br />
        console.log(multiply(5, 2)); // Output: 10 (5 * 2 * 1)<br />
        console.log(multiply(5, 2, 3)); // Output: 30 (5 * 2 * 3)
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">4. Using Optional Parameters with Destructuring</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface User &#123;<br />
            name: string;<br />
            age?: number;<br />
        &#125;<br />
        function introduce({{'{'}} name, age {{'}'}}: User): string &#123;<br />
            return `Hi, I'm ${{'{'}}name{{'}'}}${{'{'}}age ? ` and I'm ${{'{'}}age{{'}'}} years old.` : ''{{'}'}}`;<br />
        &#125;<br />
        console.log(introduce({{'{'}} name: "Bob" {{'}'}})); // Output: Hi, I'm Bob<br />
        console.log(introduce({{'{'}} name: "Alice", age: 25 {{'}'}})); // Output: Hi, I'm Alice and I'm 25 years old.
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Important Notes</h2>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Order of Parameters:</strong> Optional parameters should come after any required parameters in the function declaration.</li>
      <li><strong>Undefined Values:</strong> If an optional parameter is not provided, its value will be <code>undefined</code>.</li>
    </ul>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      Optional parameters in TypeScript enhance the flexibility of function definitions, allowing you to write functions that can handle varying numbers of arguments. This feature is particularly useful for creating APIs and libraries where not all parameters need to be mandatory. By leveraging optional parameters, you can make your code more concise and user-friendly.
    </p>
  </div>
  
}@case(23){
<div class="container mx-auto p-5">
  <h1 class="text-2xl font-bold mb-4">Named Parameters in TypeScript</h1>

  <p>
    Named parameters in TypeScript (and JavaScript) aren't a built-in feature like they are in some other languages (such as Python). However, you can achieve similar functionality using object destructuring. By passing an object as a parameter and destructuring it within the function, you can mimic named parameters. This approach allows for more readable and maintainable code, especially when dealing with multiple parameters.
  </p>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Example of Named Parameters in TypeScript</h2>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Basic Example</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      interface GreetOptions &#123;<br />
          name: string;<br />
          greeting?: string; // Optional parameter<br />
      &#125;<br />
      <br />
      function greet({{'{'}} name, greeting = "Hello" {{'}'}}: GreetOptions): string &#123;<br />
          return \`${{'{'}}greeting{{'}'}}, \${{'{'}}name{{'}'}}!\`;<br />
      &#125;<br />
      <br />
      console.log(greet({{'{'}} name: "Alice" {{'}'}})); // Output: Hello, Alice!<br />
      console.log(greet({{'{'}} name: "Bob", greeting: "Hi" {{'}'}})); // Output: Hi, Bob!
    </code>
  </pre>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Multiple Named Parameters</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      interface UserOptions &#123;<br />
          name: string;<br />
          age?: number;<br />
          email?: string;<br />
      &#125;<br />
      <br />
      function displayUser({{'{'}} name, age, email {{'}'}}: UserOptions): string &#123;<br />
          let userInfo = \`Name: \${{'{'}}name{{'}'}}\`;<br />
          if (age !== undefined) userInfo += \`, Age: \${{'{'}}age{{'}'}}\`;<br />
          if (email) userInfo += \`, Email: \${{'{'}}email{{'}'}}\`;<br />
          return userInfo;<br />
      &#125;<br />
      <br />
      console.log(displayUser({{'{'}} name: "Alice", age: 30 {{'}'}})); // Output: Name: Alice, Age: 30<br />
      console.log(displayUser({{'{'}} name: "Bob", email: "bobexample.com" {{'}'}})); // Output: Name: Bob, Email: bobexample.com
    </code>
  </pre>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Default Values with Named Parameters</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      interface ConfigOptions &#123;<br />
          width?: number;<br />
          height?: number;<br />
          color?: string;<br />
      &#125;<br />
      <br />
      function configure({{'{'}} width = 100, height = 100, color = "black" {{'}'}}: ConfigOptions): string &#123;<br />
          return \`Configured with Width: \${{'{'}}width{{'}'}}, Height: \${{'{'}}height{{'}'}}, Color: \${{'{'}}color{{'}'}}\`;<br />
      &#125;<br />
      <br />
      console.log(configure({{'{'}} width: 200, color: "red" {{'}'}})); // Output: Configured with Width: 200, Height: 100, Color: red<br />
      console.log(configure({{'{}'}})); // Output: Configured with Width: 100, Height: 100, Color: black
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Benefits of Using Named Parameters</h2>
  <ul class="list-disc list-inside mt-2">
    <li><strong>Readability:</strong> Named parameters enhance code readability, making it clear what each parameter represents without needing to remember the order.</li>
    <li><strong>Flexibility:</strong> You can pass only the parameters you need without worrying about their order, which is particularly useful for functions with many optional parameters.</li>
    <li><strong>Maintainability:</strong> If you add or remove parameters, you don’t need to change the order of arguments in every call, reducing the risk of errors.</li>
  </ul>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Important Considerations</h2>
  <ul class="list-disc list-inside mt-2">
    <li><strong>Type Checking:</strong> TypeScript will enforce types based on the defined interface or type for the object, providing compile-time checks and IntelliSense support.</li>
    <li><strong>Destructuring:</strong> When using destructuring, ensure to handle cases where properties may be <code>undefined</code> or missing if they are not optional.</li>
  </ul>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
  <p>
    While TypeScript does not have built-in support for named parameters, using object destructuring is an effective workaround. This approach not only improves code readability and flexibility but also leverages TypeScript's strong typing features for better maintainability. By adopting this pattern, you can create functions that are easier to use and understand.
  </p>
</div>

}@case(24){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4">Function Expressions in TypeScript</h1>
  
    <p>
      Function expressions in TypeScript are a way to define functions as expressions, which can be assigned to variables, passed as arguments, or returned from other functions. This differs from function declarations, where the function is defined in a standalone manner.
    </p>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Types of Function Expressions</h2>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Anonymous Function Expressions</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const add = function (a: number, b: number): number &#123;<br />
            return a + b;<br />
        &#125;;<br />
        <br />
        console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Named Function Expressions</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const factorial = function fact(n: number): number &#123;<br />
            if (n &lt;= 1) &#123;<br />
                return 1;<br />
            &#125;<br />
            return n * fact(n - 1);<br />
        &#125;;<br />
        <br />
        console.log(factorial(5)); // Output: 120
      </code>
    </pre>
  
    <h3 class="text-2xl font-semibold mb-2 text-blue-500">3. Arrow Function Expressions</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const multiply = (a: number, b: number): number =&gt; &#123;<br />
            return a * b;<br />
        &#125;;<br />
        <br />
        console.log(multiply(5, 4)); // Output: 20
      </code>
    </pre>
    <p>For concise arrow functions that have a single expression, you can omit the curly braces and the return statement:</p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const square = (x: number): number =&gt; x * x;<br />
        <br />
        console.log(square(4)); // Output: 16
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Using Function Expressions with Callbacks</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const numbers: number[] = [1, 2, 3, 4, 5];<br />
        <br />
        // Using an anonymous function expression as a callback<br />
        const doubled = numbers.map(function (num: number): number &#123;<br />
            return num * 2;<br />
        &#125;);<br />
        <br />
        console.log(doubled); // Output: [2, 4, 6, 8, 10]<br />
        <br />
        // Using an arrow function expression as a callback<br />
        const tripled = numbers.map((num: number): number =&gt; num * 3);<br />
        <br />
        console.log(tripled); // Output: [3, 6, 9, 12, 15]
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Typed Function Expressions</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        // Defining a type for a function<br />
        type Operation = (a: number, b: number) =&gt; number;<br />
        <br />
        const subtract: Operation = (a, b) =&gt; a - b;<br />
        <br />
        console.log(subtract(10, 4)); // Output: 6
      </code>
    </pre>
  
    <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
    <p>
      Function expressions in TypeScript are a powerful feature that allows for more flexibility and maintainability in your code. They can be anonymous or named, and you can use arrow functions for a more concise syntax. By leveraging TypeScript's typing system, you can ensure type safety and clarity in your function expressions, making your code more robust and easier to understand.
    </p>
  </div>
  
}@case(25){
<div class="container mx-auto p-5">
  <h1 class="text-2xl font-bold mb-4">Anonymous Functions in TypeScript</h1>

  <p>
    Anonymous functions in TypeScript are functions that do not have a name and are often defined inline. They are commonly used in situations where you need a function for a short period of time, such as passing a function as an argument to another function or defining a function that you won't reuse elsewhere.
  </p>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Defining Anonymous Functions</h2>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">1. Using Function Expressions</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const add = function (a: number, b: number): number &#123;<br />
          return a + b;<br />
      &#125;;<br />
      <br />
      console.log(add(5, 3)); // Output: 8
    </code>
  </pre>

  <h3 class="text-2xl font-semibold mb-2 text-blue-500">2. Using Arrow Functions</h3>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const multiply = (a: number, b: number): number =&gt; &#123;<br />
          return a * b;<br />
      &#125;;<br />
      <br />
      console.log(multiply(4, 6)); // Output: 24
    </code>
  </pre>
  <p>For simple single-expression functions, you can further simplify it by omitting the curly braces and the return statement:</p>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const square = (x: number): number =&gt; x * x;<br />
      <br />
      console.log(square(5)); // Output: 25
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Using Anonymous Functions as Callbacks</h2>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      const numbers: number[] = [1, 2, 3, 4, 5];<br />
      <br />
      // Using an anonymous function with the map method<br />
      const doubled = numbers.map(function (num) &#123;<br />
          return num * 2;<br />
      &#125;);<br />
      <br />
      console.log(doubled); // Output: [2, 4, 6, 8, 10]<br />
      <br />
      // Using an arrow function as a callback<br />
      const tripled = numbers.map(num =&gt; num * 3);<br />
      <br />
      console.log(tripled); // Output: [3, 6, 9, 12, 15]
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Scoping and `this`</h2>
  <pre class="bg-gray-100 p-4 rounded-md">
    <code class="font-mono text-sm" class="language-javascript" codeHighlight>
      class Counter &#123;<br />
          count: number = 0;<br />
          <br />
          increment() &#123;<br />
              // Using an anonymous function<br />
              setTimeout(function() &#123;<br />
                  this.count++;<br />
                  console.log(this.count); // `this` refers to the global object (or undefined in strict mode)<br />
              &#125;, 1000);<br />
          &#125;<br />
          <br />
          incrementWithArrow() &#123;<br />
              // Using an arrow function<br />
              setTimeout(() =&gt; &#123;<br />
                  this.count++;<br />
                  console.log(this.count); // `this` refers to the Counter instance<br />
              &#125;, 1000);<br />
          &#125;<br />
      &#125;<br />
      <br />
      const counter = new Counter();<br />
      counter.increment(); // Output will be NaN or undefined<br />
      counter.incrementWithArrow(); // Output after 1 second: 1
    </code>
  </pre>

  <h2 class="text-2xl font-semibold mb-2 text-blue-700">Conclusion</h2>
  <p>
    Anonymous functions in TypeScript are useful for creating functions on-the-fly without the need for a name. They can be defined using traditional function expressions or arrow functions, and they are particularly useful in callbacks and higher-order functions. Understanding how <code>this</code> behaves in different types of functions is crucial for using anonymous functions effectively. By leveraging anonymous functions, you can write cleaner and more concise code.
  </p>
</div>

}@case(26){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Function Types in TypeScript</h1>
  
    <p>
      In TypeScript, function types allow you to define the types of functions, specifying the types of their parameters and their return values. This feature enables better type checking, ensures code correctness, and improves code readability.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Defining Function Types</h2>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">1. Using Type Aliases</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        type AddFunction = (a: number, b: number) =&gt; number;<br />
        <br />
        const add: AddFunction = (x, y) =&gt; &#123;<br />
            return x + y;<br />
        &#125;;<br />
        <br />
        console.log(add(5, 3)); // Output: 8
      </code>
    </pre>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">2. Using Interfaces</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface MathOperation &#123;<br />
            (a: number, b: number): number;<br />
        &#125;;<br />
        <br />
        const multiply: MathOperation = (x, y) =&gt; &#123;<br />
            return x * y;<br />
        &#125;;<br />
        <br />
        console.log(multiply(4, 5)); // Output: 20
      </code>
    </pre>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">3. Inline Function Type Annotations</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const divide: (a: number, b: number) =&gt; number = (x, y) =&gt; &#123;<br />
            return x / y;<br />
        &#125;;<br />
        <br />
        console.log(divide(10, 2)); // Output: 5
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Optional and Default Parameters</h2>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">Optional Parameters</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        type GreetFunction = (name: string, greeting?: string) =&gt; string;<br />
        <br />
        const greet: GreetFunction = (name, greeting = "Hello") =&gt; &#123;<br />
            return \`&#123;greeting&#125;, &#123;name&#125;!\`;<br />
        &#125;;<br />
        <br />
        console.log(greet("Alice")); // Output: Hello, Alice!<br />
        console.log(greet("Bob", "Hi")); // Output: Hi, Bob!
      </code>
    </pre>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">Default Parameters</h3>
    <p>
      As shown above, you can set default values for parameters. If no value is provided, the default will be used.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example: Function Types in an Object</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface Calculator &#123;<br />
            add: (a: number, b: number) =&gt; number;<br />
            subtract: (a: number, b: number) =&gt; number;<br />
        &#125;;<br />
        <br />
        const calculator: Calculator = &#123;<br />
            add: (x, y) =&gt; x + y,<br />
            subtract: (x, y) =&gt; x - y,<br />
        &#125;;<br />
        <br />
        console.log(calculator.add(10, 5)); // Output: 15<br />
        console.log(calculator.subtract(10, 5)); // Output: 5
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Function types in TypeScript are a powerful feature that provides a way to define the shape of functions, ensuring that they are called with the correct types of arguments and return the expected types. This enhances type safety, helps catch errors at compile time, and improves the overall quality of the code. By using type aliases, interfaces, and inline annotations, you can create clear and maintainable function types in your TypeScript applications.
    </p>
  </div>
  
}@case(27){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Function Overloading in TypeScript</h1>
  
    <p>
      Function overloading in TypeScript allows you to create multiple function signatures for a single function. This enables a function to behave differently based on the types and number of its parameters, providing a way to specify more than one way to call a function.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">How Function Overloading Works</h2>
  
    <ol class="list-decimal list-inside mt-2">
      <li><strong>Declare Multiple Signatures</strong>: You declare multiple signatures for the same function, which specify the types of parameters and the return type.</li>
      <li><strong>Implement a Single Function</strong>: You then provide a single implementation that handles the various parameter types and return types.</li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function functionName(param: type1): returnType;<br />
        function functionName(param: type2): returnType;<br />
        // Implementation<br />
        function functionName(param: any): returnType &#123;<br />
            // Implementation goes here<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Function Overloading</h2>
  
    <h3 class="text-lg font-medium mt-4 text-blue-500">Example: Adding Numbers or Concatenating Strings</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        function combine(input1: number, input2: number): number;<br />
        function combine(input1: string, input2: string): string;<br />
        function combine(input1: number | string, input2: number | string): number | string &#123;<br />
            if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number') &#123;<br />
                return input1 + input2; // Adding numbers<br />
            &#125; else &#123;<br />
                return input1.toString() + input2.toString(); // Concatenating strings<br />
            &#125;<br />
        &#125;<br />
        <br />
        console.log(combine(5, 3)); // Output: 8<br />
        console.log(combine('Hello, ', 'World!')); // Output: Hello, World!
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
  
    <ol class="list-decimal list-inside mt-2">
      <li>
        <strong>Function Signatures</strong>: The function <code>combine</code> is defined with two overload signatures:
        <ul class="list-disc list-inside mt-1">
          <li>One that takes two numbers and returns a number.</li>
          <li>Another that takes two strings and returns a string.</li>
        </ul>
      </li>
      <li>
        <strong>Implementation</strong>: The actual implementation of <code>combine</code> accepts parameters of type <code>number | string</code>. Inside the function, type guards are used to determine the type of the inputs and handle them accordingly.
      </li>
      <li>
        <strong>Function Calls</strong>: When calling the function:
        <ul class="list-disc list-inside mt-1">
          <li><code>combine(5, 3)</code> adds the two numbers and returns <code>8</code>.</li>
          <li><code>combine('Hello, ', 'World!')</code> concatenates the two strings and returns <code>Hello, World!</code>.</li>
        </ul>
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Function Overloading</h2>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Type Safety</strong>: Overloading allows you to specify exactly what types of arguments a function can accept, reducing the likelihood of runtime errors.</li>
      <li><strong>Code Readability</strong>: It makes the code clearer, as you can define different behaviors for the same function name based on input types.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Function overloading is useful in various scenarios, such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>When you need to create utility functions that perform similar operations but require different input types.</li>
      <li>When designing libraries or APIs that need to handle multiple data types in a flexible manner.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Function overloading in TypeScript is a powerful feature that enhances the flexibility and usability of functions. By allowing multiple signatures for a single function, it provides better type safety and clarity in code. This makes it easier to work with functions that need to handle various types and combinations of parameters while maintaining a clean and understandable API.
    </p>
  </div>
  
}@case(28){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Function Overriding in TypeScript</h1>
  
    <p>
      Function overriding is a feature in TypeScript (and object-oriented programming in general) that allows a derived class to provide a specific implementation of a method that is already defined in its base class. This enables polymorphism, allowing methods to be redefined to behave differently depending on the object that is invoking them.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Function Overriding</h2>
  
    <p>
      When a derived class has a method that overrides a method in its base class, it uses the same method name and parameter types. The overridden method in the derived class will be called instead of the base class method when invoked on an instance of the derived class.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        class BaseClass &#123;<br />
            greet() &#123;<br />
                console.log('Hello from Base Class');<br />
            &#125;<br />
        &#125;<br />
        <br />
        class DerivedClass extends BaseClass &#123;<br />
            greet() &#123;<br />
                console.log('Hello from Derived Class');<br />
            &#125;<br />
        &#125;<br />
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Function Overriding</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        class Animal &#123;<br />
            speak() &#123;<br />
                console.log('Animal speaks');<br />
            &#125;<br />
        &#125;<br />
        <br />
        class Dog extends Animal &#123;<br />
            speak() &#123;<br />
                console.log('Dog barks');<br />
            &#125;<br />
        &#125;<br />
        <br />
        const animal = new Animal();<br />
        animal.speak(); // Output: Animal speaks<br />
        <br />
        const dog = new Dog();<br />
        dog.speak(); // Output: Dog barks
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        <strong>Base Class</strong>: The <code>Animal</code> class has a method named <code>speak</code> that outputs "Animal speaks".
      </li>
      <li>
        <strong>Derived Class</strong>: The <code>Dog</code> class extends the <code>Animal</code> class and overrides the <code>speak</code> method to output "Dog barks".
      </li>
      <li>
        <strong>Method Invocation</strong>: When invoking <code>speak</code> on an instance of <code>Animal</code>, it calls the base class method. When invoking <code>speak</code> on an instance of <code>Dog</code>, it calls the overridden method in the derived class.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Key Points</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Function overriding allows a derived class to provide a specific implementation of a method that is already defined in its base class.</li>
      <li>The method in the derived class must have the same name and parameter types as the method in the base class.</li>
      <li>Overriding enables polymorphism, allowing methods to behave differently based on the object invoking them.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Function overriding is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Implementing specific behavior for subclasses while maintaining a consistent interface across the base class.</li>
      <li>Creating flexible and reusable code in large applications or frameworks.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Function overriding is a powerful feature in TypeScript that enhances the principles of object-oriented programming, allowing for more flexible and maintainable code. By enabling derived classes to redefine base class methods, it promotes polymorphism and code reuse, ultimately leading to a cleaner and more efficient design.
    </p>
  </div>
  
}@case(29){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Nullish Coalescing Operator in TypeScript</h1>
  
    <p>
      The nullish coalescing operator (??) is a logical operator introduced in TypeScript 3.7. It allows you to provide a default value for a variable that may be null or undefined. This operator is particularly useful when you want to differentiate between a falsy value and an absence of a value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding the Nullish Coalescing Operator</h2>
  
    <p>
      The nullish coalescing operator checks for <code>null</code> or <code>undefined</code> values. If the value is either of these, it returns the right-hand side value; otherwise, it returns the left-hand side value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const result = value1 ?? value2;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Nullish Coalescing Operator</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const name = null;<br />
        const defaultName = 'Guest';<br />
        const displayName = name ?? defaultName;<br />
        console.log(displayName); // Output: Guest
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In the example above, the variable <code>name</code> is set to <code>null</code>.
      </li>
      <li>
        The variable <code>defaultName</code> is set to <code>'Guest'</code>.
      </li>
      <li>
        Using the nullish coalescing operator, <code>displayName</code> will be assigned the value of <code>defaultName</code> because <code>name</code> is <code>null</code>.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Differences with Logical OR (||)</h2>
    <p>
      It's important to note the difference between the nullish coalescing operator and the logical OR operator. The logical OR operator returns the right-hand value if the left-hand value is any falsy value (like <code>0</code>, <code>''</code>, or <code>false</code>), whereas the nullish coalescing operator only checks for <code>null</code> or <code>undefined</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Differences</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const count = 0;<br />
        const fallback = 10;<br />
        const resultOR = count || fallback; // Output: 10<br />
        const resultNullish = count ?? fallback; // Output: 0
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Key Points</h2>
    <ul class="list-disc list-inside mt-2">
      <li>The nullish coalescing operator is represented by <code>??</code>.</li>
      <li>It returns the right-hand operand when the left-hand operand is <code>null</code> or <code>undefined</code>.</li>
      <li>It does not treat other falsy values (like <code>0</code> or <code>''</code>) as nullish.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      The nullish coalescing operator is useful in various scenarios, including:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Providing default values for variables that may not have been initialized.</li>
      <li>Setting default props in React components or similar frameworks.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      The nullish coalescing operator is a valuable addition to TypeScript, allowing developers to manage default values in a concise and clear manner. By distinguishing between nullish values and other falsy values, it provides a more accurate way to handle variables that may not be defined, resulting in cleaner and more maintainable code.
    </p>
  </div>
  
}@case(30){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Optional Chaining in TypeScript</h1>
  
    <p>
      Optional chaining is a feature in TypeScript (and JavaScript) that allows you to safely access deeply nested properties of an object without having to check for the existence of each property along the way. This operator is particularly useful for avoiding runtime errors when attempting to access properties on undefined or null objects.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Optional Chaining</h2>
  
    <p>
      The optional chaining operator is represented by a question mark followed by a dot (?.). It short-circuits the evaluation and returns <code>undefined</code> if the property before the operator is <code>null</code> or <code>undefined</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        const value = object?.property?.nestedProperty;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Optional Chaining</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        interface User &#123;<br />
            name: string;<br />
            address?: &#123;<br />
                city?: string;<br />
                zipCode?: string;<br />
            &#125;<br />
        &#125;<br />
        <br />
        const user: User = &#123;<br />
            name: 'Alice',<br />
            address: &#123;<br />
                city: 'Wonderland'<br />
            &#125;<br />
        &#125;;<br />
        <br />
        const cityName = user.address?.city;<br />
        console.log(cityName); // Output: Wonderland
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In this example, the <code>User</code> interface defines an optional <code>address</code> property.
      </li>
      <li>
        The <code>user</code> object is created with a <code>name</code> and an <code>address</code> that contains a <code>city</code>.
      </li>
      <li>
        By using optional chaining, <code>user.address?.city</code> safely accesses the <code>city</code> property. If <code>address</code> were <code>undefined</code>, it would return <code>undefined</code> instead of throwing an error.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Optional Chaining</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Reduces the need for verbose checks using multiple if-statements to ensure properties exist.</li>
      <li>Prevents runtime errors by safely handling the cases where properties may be <code>null</code> or <code>undefined</code>.</li>
      <li>Improves code readability and maintainability by simplifying property access expressions.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Optional chaining is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Accessing properties in complex nested objects, such as configuration objects or API responses.</li>
      <li>When working with data structures where some properties might not be defined, such as user profiles or settings.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Optional chaining is a powerful feature in TypeScript that allows for safer and more concise access to object properties. By reducing the risk of runtime errors and improving code clarity, it enhances the overall developer experience. This operator is an essential tool for working with complex data structures in modern TypeScript applications.
    </p>
  </div>
  
}@case(31){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Optional Nullish Coalescing Operator in TypeScript</h1>
  
    <p>
      The optional nullish coalescing operator (??.) is a combination of the optional chaining operator (?.) and the nullish coalescing operator (??) in TypeScript. This operator allows you to safely access properties that may be <code>null</code> or <code>undefined</code>, while also providing a default value in case the property doesn't exist. This feature enhances code safety and readability when dealing with nested object properties.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding the Optional Nullish Coalescing Operator</h2>
  
    <p>
      The optional nullish coalescing operator first checks if the left-hand side property is <code>null</code> or <code>undefined</code>. If it is, it returns <code>undefined</code> rather than throwing an error. Then, if the left-hand side evaluates to <code>undefined</code>, it falls back to the right-hand side value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const value = object?.property ?? defaultValue;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Optional Nullish Coalescing Operator</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        interface User &#123;<br />
            name: string;<br />
            age?: number;<br />
            address?: &#123;<br />
                city?: string;<br />
                zipCode?: string;<br />
            &#125;<br />
        &#125;<br />
        <br />
        const user: User = &#123;<br />
            name: 'Alice',<br />
            age: undefined,<br />
            address: &#123;<br />
                city: 'Wonderland'<br />
            &#125;<br />
        &#125;;<br />
        <br />
        const age = user.age ?? 30;<br />
        console.log(age); // Output: 30<br />
        const city = user.address?.city ?? 'Unknown City';<br />
        console.log(city); // Output: Wonderland
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In this example, the <code>User</code> interface defines an optional <code>age</code> and <code>address</code> property.
      </li>
      <li>
        The <code>user</code> object is created with a <code>name</code>, an <code>age</code> set to <code>undefined</code>, and an <code>address</code> that contains a <code>city</code>.
      </li>
      <li>
        The statement <code>const age = user.age ?? 30;</code> assigns <code>30</code> to <code>age</code> since <code>user.age</code> is <code>undefined</code>.
      </li>
      <li>
        The statement <code>const city = user.address?.city ?? 'Unknown City';</code> safely accesses the <code>city</code> property and assigns it to <code>city</code>. If the <code>address</code> were <code>undefined</code>, it would return <code>Unknown City</code>.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Optional Nullish Coalescing Operator</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Combines the benefits of optional chaining and nullish coalescing in a concise and readable manner.</li>
      <li>Helps prevent runtime errors caused by accessing properties on <code>null</code> or <code>undefined</code> objects.</li>
      <li>Enhances the clarity of the code by providing a straightforward way to handle default values.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      The optional nullish coalescing operator is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Accessing nested properties in objects returned from APIs where some fields may be optional.</li>
      <li>Providing fallback values for user input where the input might be <code>null</code> or <code>undefined</code>.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      The optional nullish coalescing operator is a powerful addition to TypeScript that simplifies property access and default value assignment. By combining optional chaining and nullish coalescing, it provides a safe and clean way to handle nested properties, resulting in more maintainable code and reducing the likelihood of runtime errors.
    </p>
  </div>

}@case(32){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Type Narrowing in TypeScript</h1>
  
    <p>
      Type narrowing is a technique used in TypeScript to refine the type of a variable within a certain scope, typically within control flow statements like <code>if</code> or <code>switch</code>. This allows developers to write safer and more predictable code by providing TypeScript with additional information about the variable's type.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Type Narrowing</h2>
  
    <p>
      Type narrowing happens when TypeScript can deduce a more specific type for a variable based on certain conditions. By utilizing type guards, TypeScript enables developers to restrict a variable's type to a more specific subset, allowing for more precise operations on that variable.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Common Techniques for Type Narrowing</h2>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">1. Using <code>typeof</code></h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function logValue(value: number | string) &#123;<br />
            if (typeof value === 'string') &#123;<br />
                console.log('String value:', value);<br />
            &#125; else &#123;<br />
                console.log('Number value:', value);<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">2. Using <code>instanceof</code></h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        class Dog &#123;<br />
            bark() &#123; console.log('Woof!'); &#125;<br />
        &#125;<br />
        class Cat &#123;<br />
            meow() &#123; console.log('Meow!'); &#125;<br />
        &#125;<br />
        function makeSound(animal: Dog | Cat) &#123;<br />
            if (animal instanceof Dog) &#123;<br />
                animal.bark();<br />
            &#125; else &#123;<br />
                animal.meow();<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">3. Using <code>in</code> Operator</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        interface Bird &#123;<br />
            fly: () => void;<br />
        &#125;<br />
        interface Fish &#123;<br />
            swim: () => void;<br />
        &#125;<br />
        function move(animal: Bird | Fish) &#123;<br />
            if ('fly' in animal) &#123;<br />
                animal.fly();<br />
            &#125; else &#123;<br />
                animal.swim();<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Type Narrowing</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Improves type safety by ensuring that the operations performed on a variable are valid for its actual type.</li>
      <li>Reduces the need for type assertions and explicit type casting, leading to cleaner code.</li>
      <li>Helps in catching potential bugs at compile time instead of runtime.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Type narrowing is particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Handling user inputs where the type might vary based on the context.</li>
      <li>Working with APIs that may return different types of responses.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Type narrowing is a powerful feature in TypeScript that enhances type safety and code readability. By allowing developers to specify and refine types based on conditions, TypeScript helps prevent errors and improves the overall quality of the code. Understanding and utilizing type narrowing can lead to more robust and maintainable applications.
    </p>
  </div>
  
}@case(33){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Type Predicates in TypeScript</h1>
  
    <p>
      Type predicates in TypeScript are a way to define a function that can return a boolean indicating whether a given variable is of a specific type. They allow for type checking and can help narrow down the types of variables in a type-safe manner, making the code more robust and readable.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding Type Predicates</h2>
  
    <p>
      A type predicate is defined using the <code>is</code> keyword in a function's return type. When TypeScript sees a function returning a type predicate, it can refine the type of the variable passed to that function in conditional checks.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Syntax</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function isTypeName(variable: any): variable is TypeName &#123;<br />
            // Logic to determine the type<br />
            return true; // or false<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Example of Type Predicates</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        interface Dog &#123;<br />
            bark: () => void;<br />
        &#125;<br />
        interface Cat &#123;<br />
            meow: () => void;<br />
        &#125;<br />
        function isDog(animal: Dog | Cat): animal is Dog &#123;<br />
            return (animal as Dog).bark !== undefined;<br />
        &#125;<br />
        <br />
        function makeSound(animal: Dog | Cat) &#123;<br />
            if (isDog(animal)) &#123;<br />
                animal.bark();<br />
            &#125; else &#123;<br />
                animal.meow();<br />
            &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Explanation</h2>
    <ol class="list-decimal list-inside mt-2">
      <li>
        In this example, we have two interfaces, <code>Dog</code> and <code>Cat</code>, each with their respective methods.
      </li>
      <li>
        The function <code>isDog</code> is a type predicate that checks whether the provided animal is a <code>Dog</code> by verifying if the <code>bark</code> method is defined.
      </li>
      <li>
        In the <code>makeSound</code> function, we use the <code>isDog</code> function to narrow down the type of <code>animal</code>. If it's a <code>Dog</code>, we call the <code>bark</code> method; otherwise, we call the <code>meow</code> method on <code>Cat</code>.
      </li>
    </ol>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Type Predicates</h2>
    <ul class="list-disc list-inside mt-2">
      <li>Improves type safety by allowing more precise type checking at runtime.</li>
      <li>Reduces the need for type assertions, leading to cleaner and more maintainable code.</li>
      <li>Helps in writing functions that can handle multiple types safely, enhancing the overall robustness of the code.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Use Cases</h2>
    <p>
      Type predicates are particularly useful in scenarios such as:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Working with union types where specific operations are needed for different types.</li>
      <li>Creating more complex type-checking functions to ensure the integrity of the data being processed.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Type predicates are a powerful feature in TypeScript that enhances type safety and readability. By allowing developers to define specific type checks, TypeScript helps create more maintainable and reliable code. Understanding and effectively using type predicates can significantly improve your TypeScript coding experience.
    </p>
  </div>
  
}@case(34){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Code Styles in TypeScript</h1>
  
    <p>
      Writing clean and consistent code is essential for maintainability and readability, especially in large projects. In TypeScript, adhering to a common code style ensures that developers working on the same codebase can understand and contribute more efficiently. This article discusses some of the widely accepted code styles and best practices for writing TypeScript code.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Code Formatting</h2>
    <p>
      Code formatting is about ensuring the code is readable and follows a consistent structure. Here are some common guidelines for formatting TypeScript code:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Use 2 or 4 spaces for indentation (commonly 2 spaces in TypeScript projects).</li>
      <li>Use semicolons at the end of statements.</li>
      <li>Keep line length below 80 or 100 characters to improve readability.</li>
      <li>Use single quotes for strings instead of double quotes.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Code Example: Proper Formatting</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function greet(name: string): void &#123;<br />
            console.log('Hello, ' + name);<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Naming Conventions</h2>
    <p>
      Consistent naming conventions are key to writing understandable and predictable code. Here are some common naming conventions in TypeScript:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Variables and Functions</strong>: Use <code>camelCase</code> for variable and function names.</li>
      <li><strong>Classes and Interfaces</strong>: Use <code>PascalCase</code> for class and interface names.</li>
      <li><strong>Constants</strong>: Use <code>UPPER_CASE</code> for constant values that are not meant to change.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Code Example: Naming Conventions</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const MAX_COUNT = 100;<br />
        <br />
        interface User &#123;<br />
            firstName: string;<br />
            lastName: string;<br />
        &#125;<br />
        <br />
        function getUserName(user: User): string &#123;<br />
            return user.firstName + ' ' + user.lastName;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Type Annotations</h2>
    <p>
      TypeScript’s type annotations provide clarity about the type of values being passed around. This helps prevent errors and enhances readability.
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Always specify types for function parameters and return types.</li>
      <li>Use TypeScript’s built-in types (like <code>string</code>, <code>number</code>, <code>boolean</code>) for primitive types.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Code Example: Type Annotations</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function add(a: number, b: number): number &#123;<br />
            return a + b;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Arrow Functions</h2>
    <p>
      Arrow functions provide a shorter syntax and are recommended for shorter functions or callbacks. They also maintain the value of <code>this</code> lexically.
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const multiply = (x: number, y: number): number => &#123;<br />
            return x * y;<br />
        &#125;;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Code Comments</h2>
    <p>
      Code comments should be used sparingly and should always explain why something is done rather than what is being done. TypeScript code can be self-explanatory if written clearly.
    </p>
    <ul class="list-disc list-inside mt-2">
      <li>Use <code>//</code> for single-line comments and <code>/* */</code> for block comments.</li>
      <li>Avoid over-commenting; instead, aim for clear and understandable code.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Code Example: Comments</h2>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        // This function calculates the square of a number<br />
        function square(n: number): number &#123;<br />
            return n * n;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Consistent code styles make your TypeScript code more readable, maintainable, and scalable. Following these practices—such as proper formatting, naming conventions, and using type annotations—ensures that your codebase remains clean and easy to navigate. Incorporating these best practices into your TypeScript development workflow will ultimately lead to better code quality and collaboration.
    </p>
  </div>
  
}@case(35){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Linting in TypeScript</h1>
  
    <p>
      Linting is the process of analyzing code to find potential errors, stylistic issues, and deviations from coding standards. In TypeScript, linting ensures code quality, readability, and consistency. This article will cover how linting works, the tools available for TypeScript, and the benefits of integrating linting into your development workflow.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">What is Linting?</h2>
  
    <p>
      Linting refers to the automated checking of your source code for programmatic and stylistic errors. By applying linting rules, developers can catch bugs early, maintain consistency, and ensure adherence to team coding standards.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Linting Tools for TypeScript</h2>
    <p>
      There are several tools available for linting TypeScript code. The most popular ones include:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li><strong>ESLint</strong>: The most widely used linting tool for JavaScript and TypeScript. It offers a rich ecosystem of plugins and configurations.</li>
      <li><strong>TSLint</strong>: A linter specifically for TypeScript, now deprecated in favor of ESLint with TypeScript support.</li>
      <li><strong>Prettier</strong>: A code formatter that ensures consistent code style, often used alongside ESLint.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Setting Up ESLint for TypeScript</h2>
  
    <p>
      To lint TypeScript code with ESLint, you need to install the relevant packages and configure ESLint. Follow these steps to set it up:
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 1: Install ESLint and Plugins</h3>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install eslint &#64;typescript-eslint/parser &#64;typescript-eslint/eslint-plugin --save-dev
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 2: Configure ESLint</h3>
    <p>
      Create a <code>.eslintrc.json</code> file at the root of your project and configure it to support TypeScript.
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "parser": "&#64;typescript-eslint/parser",<br />
          "extends": ["plugin:&#64;typescript-eslint/recommended"],<br />
          "plugins": ["&#64;typescript-eslint"],<br />
          "rules": &#123;<br />
            // Custom rules go here<br />
          &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 3: Run ESLint</h3>
    <p>
      You can run ESLint using the following command:
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npx eslint 'src/**/*.ts'
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Linting</h2>
  
    <p>
      Linting TypeScript offers several benefits that contribute to better code quality and easier maintenance:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Error Prevention</strong>: Catches syntax errors, typos, and potential bugs before they cause runtime issues.</li>
      <li><strong>Consistency</strong>: Enforces coding standards, ensuring the codebase remains consistent across the team.</li>
      <li><strong>Readability</strong>: Linting can improve code readability by enforcing rules like spacing, indentation, and naming conventions.</li>
      <li><strong>Improved Debugging</strong>: By avoiding potential errors and bugs, linting helps make debugging more efficient.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Common Linting Rules</h2>
    <p>
      ESLint with TypeScript offers several recommended rules. Here are a few common ones:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li><code>&#64;typescript-eslint/no-unused-vars</code>: Disallows declaring variables that are not used anywhere in the code.</li>
      <li><code>&#64;typescript-eslint/explicit-function-return-type</code>: Enforces the explicit definition of return types for functions.</li>
      <li><code>&#64;typescript-eslint/no-explicit-any</code>: Prevents the use of the <code>any</code> type in TypeScript.</li>
      <li><code>&#64;typescript-eslint/consistent-type-assertions</code>: Enforces consistent use of type assertions throughout the codebase.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Linting is a crucial part of maintaining a clean, error-free, and consistent codebase in TypeScript. By using tools like ESLint, developers can prevent bugs, enforce coding standards, and improve the overall readability of their code. Integrating linting into your TypeScript projects will significantly enhance code quality and developer productivity.
    </p>
  </div>
  
}@case(36){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Formatting in TypeScript</h1>
  
    <p>
      Formatting in TypeScript refers to the consistent styling of code to improve readability, maintainability, and team collaboration. Code formatting includes indentation, line breaks, spacing, and alignment, which collectively make code easier to understand and maintain. Automated tools like Prettier and ESLint can help enforce formatting standards in TypeScript projects.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Why is Code Formatting Important?</h2>
  
    <p>
      Consistent formatting leads to better code readability, fewer merge conflicts, and enhanced productivity for development teams. When everyone on the team follows the same formatting guidelines, code reviews become easier, and the overall development experience improves.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Common Formatting Guidelines</h2>
    <p>Some common formatting rules for TypeScript include:</p>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Indentation</strong>: Use 2 spaces or 4 spaces for indentation consistently across the codebase.</li>
      <li><strong>Semicolons</strong>: Decide whether to enforce semicolons at the end of statements or omit them, but keep it consistent throughout the project.</li>
      <li><strong>Braces</strong>: Opening braces should be placed on the same line as the control statement (e.g., <code>if</code>, <code>for</code>), while closing braces should be aligned correctly.</li>
      <li><strong>Spacing</strong>: Ensure there is proper spacing between operators, keywords, and braces. For example, there should be a space between the <code>if</code> keyword and the opening parenthesis: <code>if (condition)</code>.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Using Prettier for Code Formatting</h2>
  
    <p>
      Prettier is an opinionated code formatter that enforces a consistent style by parsing your code and reprinting it with its own rules. It's widely used in TypeScript projects for automatic formatting.
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 1: Install Prettier</h3>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install --save-dev prettier
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 2: Create a Configuration File</h3>
  
    <p>
      Prettier allows you to customize its behavior using a configuration file. Create a <code>.prettierrc</code> file in the root directory of your project.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "semi": true,<br />
          "tabWidth": 2,<br />
          "singleQuote": true,<br />
          "trailingComma": "es5"<br />
        &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 3: Run Prettier</h3>
    <p>
      To format your TypeScript files, run the Prettier command in the terminal:
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npx prettier --write "src/**/*.ts"
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Integrating Prettier with ESLint</h2>
  
    <p>
      Prettier can be integrated with ESLint for more comprehensive formatting and linting. To do this, install the necessary plugins and configure ESLint to run Prettier as a part of its linting process.
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 1: Install Plugins</h3>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install --save-dev eslint-config-prettier eslint-plugin-prettier
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 2: Update ESLint Configuration</h3>
  
    <p>
      Update your <code>.eslintrc.json</code> file to include Prettier as a plugin and extend the Prettier configuration:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "extends": ["plugin:&#64;typescript-eslint/recommended", "prettier"],<br />
          "plugins": ["prettier"],<br />
          "rules": &#123;<br />
            "prettier/prettier": "error"<br />
          &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Automated Formatting</h2>
  
    <p>
      Automated formatting tools like Prettier offer several benefits:
    </p>
    <ul class="list-disc list-inside mt-2">
      <li><strong>Consistency</strong>: Ensures that code across the project follows a uniform style.</li>
      <li><strong>Improved Readability</strong>: Enforces rules that improve the visual structure of code.</li>
      <li><strong>Faster Code Reviews</strong>: Reduces the need to comment on stylistic or formatting issues during code reviews.</li>
      <li><strong>Time-saving</strong>: Automates the process of fixing formatting issues, allowing developers to focus on writing code.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
    <p>
      Formatting is an essential aspect of writing clean, readable, and maintainable TypeScript code. Tools like Prettier can automatically format your code according to specified guidelines, ensuring consistency across your project. By integrating formatting tools into your workflow, you can save time and improve collaboration within your development team.
    </p>
  </div>
  
}@case(37){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Static Analysis in TypeScript</h1>
  
    <p>
      Static analysis is the process of analyzing code without executing it to identify potential errors, bugs, and stylistic issues. In TypeScript, static analysis tools are particularly useful as they allow developers to catch issues at an early stage, improving code quality and maintainability. Static analysis is integrated into TypeScript through its type-checking system and additional tools such as ESLint and TSLint.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">What is Static Analysis?</h2>
  
    <p>
      Static analysis involves examining the codebase for potential errors, type mismatches, and other issues before the code is run. It checks the structure, types, and syntax of the code, enabling developers to catch bugs early and improve code readability and reliability.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">TypeScript's Built-In Static Analysis</h2>
  
    <p>
      One of the major advantages of TypeScript over plain JavaScript is its built-in static type checking. The TypeScript compiler verifies that variables, functions, and objects are being used correctly according to their declared types. This process happens at compile time, allowing developers to identify errors before running the code.
    </p>
  
    <p>
      For example, consider the following code:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function add(a: number, b: number): number &#123;<br />
          return a + b;<br />
        &#125;<br />
        <br />
        const result = add(5, "10"); // TypeScript will raise a static analysis error here.
      </code>
    </pre>
  
    <p>
      In the example above, TypeScript will generate a static analysis error because the second argument provided to the <code>add</code> function is a string instead of a number.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Linting Tools for Static Analysis</h2>
  
    <p>
      In addition to TypeScript's type-checking system, external linting tools like ESLint and TSLint provide static analysis by checking for potential errors and enforcing coding standards.
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">ESLint</h3>
    <p>
      ESLint is a widely used tool for static analysis in TypeScript projects. It identifies potential errors, enforces code style rules, and helps improve the overall quality of the codebase.
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">TSLint (Deprecated)</h3>
    <p>
      TSLint was specifically created for TypeScript static analysis, but it has been deprecated in favor of ESLint with TypeScript support. TSLint allowed for type-aware linting, checking for both stylistic issues and type errors.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Configuring ESLint for TypeScript Static Analysis</h2>
  
    <p>
      To set up ESLint for static analysis in a TypeScript project, follow these steps:
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 1: Install ESLint and TypeScript Plugins</h3>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install eslint &#64;typescript-eslint/parser &#64;typescript-eslint/eslint-plugin --save-dev
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 2: Configure ESLint</h3>
  
    <p>
      Create a <code>.eslintrc.json</code> file in the root of your project to configure ESLint with TypeScript support:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "parser": "&#64;typescript-eslint/parser",<br />
          "extends": ["plugin:&#64;typescript-eslint/recommended"],<br />
          "plugins": ["&#64;typescript-eslint"],<br />
          "rules": &#123;<br />
            "no-unused-vars": "error",<br />
            "semi": ["error", "always"]<br />
          &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Benefits of Static Analysis in TypeScript</h2>
  
    <p>
      Static analysis offers several key benefits for TypeScript developers:
    </p>
  
    <ul class="list-disc list-inside mt-2">
      <li><strong>Error Detection:</strong> Catches bugs early in the development process, reducing the chance of runtime errors.</li>
      <li><strong>Improved Code Quality:</strong> Enforces code style, best practices, and type safety, leading to cleaner and more maintainable code.</li>
      <li><strong>Reduced Debugging Time:</strong> By catching errors during the compile-time, static analysis can help reduce the time spent debugging issues later.</li>
      <li><strong>Consistency:</strong> Enforces consistent coding practices across the entire codebase, especially in teams.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
  
    <p>
      Static analysis in TypeScript is a powerful tool that ensures code correctness and consistency before execution. Whether it's through TypeScript's type system or using external tools like ESLint, static analysis significantly improves code quality and reduces the risk of bugs. By integrating these tools into your workflow, you can catch errors early and maintain a clean, high-quality codebase.
    </p>
  </div>
  
}@case(38){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Code Coverage in TypeScript</h1>
  
    <p>
      Code coverage is a metric used to measure how much of your source code is tested by automated tests, such as unit tests or integration tests. In TypeScript projects, achieving high code coverage ensures that most parts of your codebase are executed during tests, increasing the likelihood of catching bugs and ensuring code quality.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">What is Code Coverage?</h2>
  
    <p>
      Code coverage measures the percentage of your code that is executed while your tests run. This can include function calls, branches, loops, and conditions. Coverage reports can help identify untested parts of the code and areas that need additional testing.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Why is Code Coverage Important?</h2>
  
    <p>
      High code coverage improves the reliability of your tests and the stability of your TypeScript codebase. By ensuring that key portions of the code are covered, you reduce the likelihood of undetected bugs and prevent regressions when new changes are made.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Tools for Code Coverage in TypeScript</h2>
  
    <p>
      To measure code coverage in TypeScript projects, various tools and libraries are commonly used. Some of the most popular ones are:
    </p>
  
    <ul class="list-disc list-inside mt-2">
      <li><strong>Jest</strong>: A powerful testing framework that provides built-in support for code coverage.</li>
      <li><strong>Karma with Istanbul</strong>: A test runner that can be integrated with Istanbul to generate code coverage reports.</li>
      <li><strong>NYC (Istanbul)</strong>: A command-line interface for Istanbul that can generate code coverage reports for various testing tools.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Using Jest for Code Coverage</h2>
  
    <p>
      Jest is one of the most popular testing frameworks used in TypeScript projects. It has built-in support for generating code coverage reports. Here's how to use Jest to measure and report code coverage.
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 1: Install Jest</h3>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install --save-dev jest ts-jest &#64;types/jest
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 2: Configure Jest</h3>
  
    <p>
      Add a Jest configuration file to the root of your project (e.g., <code>jest.config.js</code>):
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        module.exports = &#123;<br />
          preset: 'ts-jest',<br />
          testEnvironment: 'node',<br />
          collectCoverage: true,<br />
          coverageDirectory: 'coverage',<br />
          coverageReporters: ['text', 'lcov'],<br />
        &#125;;
      </code>
    </pre>
  
    <p>
      This configuration enables Jest to collect coverage data and output reports in both text and <code>lcov</code> format.
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">Step 3: Run Tests with Coverage</h3>
  
    <p>
      To run your tests with coverage reporting, use the following command:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npx jest --coverage
      </code>
    </pre>
  
    <p>
      After running this command, Jest will generate a coverage report, showing the percentage of code that was executed during the tests.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Understanding the Coverage Report</h2>
  
    <p>
      The code coverage report generated by Jest (or other tools) typically includes the following metrics:
    </p>
  
    <ul class="list-disc list-inside mt-2">
      <li><strong>Statements Coverage</strong>: The percentage of executable statements that have been run during tests.</li>
      <li><strong>Branch Coverage</strong>: The percentage of control structures (e.g., if/else, switch) that have been evaluated.</li>
      <li><strong>Function Coverage</strong>: The percentage of functions that have been called at least once during tests.</li>
      <li><strong>Line Coverage</strong>: The percentage of lines of code that were executed during tests.</li>
    </ul>
  
    <p>
      For example, after running the tests with coverage, you may see an output like this:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        ------------------|----------|----------|----------|----------|----------------|<br />
        File              |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Lines |<br />
        ------------------|----------|----------|----------|----------|----------------|<br />
        src/index.ts      |    95.65 |    80.00 |    100.0 |    95.65 |           10,12 |<br />
        ------------------|----------|----------|----------|----------|----------------|<br />
        All files         |    95.65 |    80.00 |    100.0 |    95.65 |                |
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Improving Code Coverage</h2>
  
    <p>
      Once you have a code coverage report, you can identify areas that need more test coverage. Here are some best practices to improve your TypeScript project's coverage:
    </p>
  
    <ul class="list-disc list-inside mt-2">
      <li><strong>Test Edge Cases</strong>: Ensure that edge cases, such as empty input or null values, are tested.</li>
      <li><strong>Test Branches</strong>: Cover all branches in conditionals and switch cases.</li>
      <li><strong>Write Unit Tests</strong>: Focus on unit tests to ensure that individual functions and methods behave as expected.</li>
      <li><strong>Continuous Integration</strong>: Set up a CI pipeline that automatically checks for code coverage to enforce quality standards.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
  
    <p>
      Code coverage is a vital aspect of ensuring that your TypeScript project is well-tested and reliable. Tools like Jest, Istanbul, and NYC make it easy to measure and report coverage. By incorporating code coverage analysis into your development workflow, you can identify untested areas and improve the overall quality of your codebase.
    </p>
  </div>
  
}@case(39){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Code Quality Issues in TypeScript</h1>
  
    <p>
      Code quality is a crucial aspect of software development that directly affects the maintainability, readability, and scalability of a project. In TypeScript, ensuring high code quality requires attention to how the language's features are used, consistency in coding practices, and the identification of common code quality issues that can lead to technical debt or errors. 
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">What is Code Quality?</h2>
  
    <p>
      Code quality refers to the extent to which your code is clean, efficient, and free of errors. High-quality code is easy to read, maintain, and extend. It adheres to best practices, follows a consistent style, and minimizes the risk of bugs. In TypeScript, code quality is influenced by proper use of type annotations, modular structure, test coverage, and adherence to coding standards.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Common Code Quality Issues in TypeScript</h2>
  
    <p>
      Several code quality issues can arise when working with TypeScript. These issues can lead to bugs, inefficiencies, and a harder-to-maintain codebase. Below are some of the most common problems:
    </p>
  
    <ul class="list-disc list-inside mt-2">
      <li><strong>Improper Type Annotations</strong>: Failing to use or misuse type annotations can lead to runtime errors and missed opportunities for static analysis.</li>
      <li><strong>Overuse of <code>any</code></strong>: Relying too much on the <code>any</code> type bypasses the benefits of TypeScript's type checking, reducing the advantages of using the language.</li>
      <li><strong>Neglecting Type Safety</strong>: Skipping the declaration of types in key areas, especially in functions, can lead to code that is harder to understand and maintain.</li>
      <li><strong>Large, Monolithic Functions</strong>: Functions that are too large or perform multiple responsibilities make it difficult to debug and test the code.</li>
      <li><strong>Inconsistent Coding Styles</strong>: Inconsistent formatting, variable naming, or structural patterns can cause confusion, especially in collaborative projects.</li>
      <li><strong>Not Handling Null or Undefined Properly</strong>: TypeScript provides tools like optional chaining and nullish coalescing to handle potentially null or undefined values, but not using these can lead to errors.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Improper or Missing Type Annotations</h2>
  
    <p>
      One of the core advantages of TypeScript is its type system, which helps catch errors at compile time. However, developers sometimes neglect to use type annotations or use them incorrectly. Missing or improper type annotations make the code harder to understand and maintain, leading to potential bugs at runtime.
    </p>
  
    <p>For example:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        // Missing type annotation for the function parameter<br />
        function greet(name) &#123;<br />
          return 'Hello, ' + name;<br />
        &#125;
      </code>
    </pre>
  
    <p>
      In the above example, the function parameter <code>name</code> is not typed, which could lead to unexpected issues if the wrong type is passed. Adding proper type annotations helps catch these issues:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function greet(name: string): string &#123;<br />
          return 'Hello, ' + name;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Overusing the <code>any</code> Type</h2>
  
    <p>
      The <code>any</code> type in TypeScript is useful when the type of a value is unknown, but overusing it defeats the purpose of type safety. When <code>any</code> is used frequently, TypeScript is unable to perform static type checking, which can introduce errors.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let data: any = fetchData();<br />
        data.name;  // TypeScript cannot check if 'name' exists
      </code>
    </pre>
  
    <p>
      A better practice is to define a type or interface for the expected structure of the data:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        interface User &#123;<br />
          name: string;<br />
          age: number;<br />
        &#125;<br />
        <br />
        let data: User = fetchData();<br />
        data.name;  // TypeScript ensures 'name' exists and is a string
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Neglecting to Handle Null and Undefined</h2>
  
    <p>
      TypeScript provides strict null checking to ensure that variables are not unexpectedly <code>null</code> or <code>undefined</code>. However, neglecting to handle these cases properly can result in runtime errors.
    </p>
  
    <p>For example:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function getLength(input: string | null) &#123;<br />
          return input.length; // Error: Object is possibly 'null'<br />
        &#125;
      </code>
    </pre>
  
    <p>
      The above code can throw an error if <code>input</code> is <code>null</code>. Instead, use TypeScript features like optional chaining or nullish coalescing to handle this safely:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function getLength(input: string | null) &#123;<br />
          return input?.length ?? 0;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Inconsistent Code Style</h2>
  
    <p>
      Code style consistency is vital for readability and collaboration, especially in larger projects. Inconsistent naming conventions, indentation, or formatting make it harder to understand and maintain code. Linting tools like ESLint can enforce consistent style and catch code quality issues early.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Improving Code Quality in TypeScript</h2>
  
    <p>
      To improve code quality in TypeScript projects, follow these best practices:
    </p>
  
    <ul class="list-disc list-inside mt-2">
      <li><strong>Use strict TypeScript settings</strong>: Enable strict mode in the <code>tsconfig.json</code> file to catch potential issues early.</li>
      <li><strong>Avoid the <code>any</code> type</strong>: Use specific types and interfaces to maintain type safety and improve code readability.</li>
      <li><strong>Write unit tests</strong>: Unit tests help catch bugs early and improve the reliability of your code.</li>
      <li><strong>Use linting and formatting tools</strong>: Tools like ESLint and Prettier enforce consistency in style and help avoid common issues.</li>
      <li><strong>Handle null and undefined safely</strong>: Use TypeScript features like optional chaining and nullish coalescing to avoid runtime errors.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
  
    <p>
      Maintaining high code quality in TypeScript requires consistent use of the language’s features, including proper type annotations, handling null and undefined values, and using linting tools to enforce style guidelines. By addressing common code quality issues early, developers can improve the maintainability, readability, and reliability of their TypeScript codebases.
    </p>
  </div>
  
}@case(40){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Code Quality Tools in TypeScript</h1>
  
    <p>
      Maintaining high code quality is essential for building reliable, maintainable, and scalable applications. TypeScript, with its strong typing and additional features, helps in this regard. However, integrating code quality tools can further enhance code maintainability and catch potential issues early. Here are some of the most commonly used code quality tools in TypeScript projects.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. ESLint</h2>
  
    <p>
      <strong>ESLint</strong> is a popular linter for TypeScript that helps detect problematic patterns in your code. It enforces consistent coding style and identifies code smells that might lead to bugs. ESLint can be extended with plugins to handle TypeScript-specific rules.
    </p>
  
    <p>To set up ESLint for a TypeScript project:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install eslint &#64;typescript-eslint/parser &#64;typescript-eslint/eslint-plugin --save-dev
      </code>
    </pre>
  
    <p>Then configure your <code>.eslintrc.js</code> file:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        module.exports = &#123;<br />
          parser: '&#64;typescript-eslint/parser',<br />
          plugins: ['&#64;typescript-eslint'],<br />
          extends: ['plugin:&#64;typescript-eslint/recommended'],<br />
          rules: &#123;<br />
            // Custom rules<br />
          &#125;<br />
        &#125;;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Prettier</h2>
  
    <p>
      <strong>Prettier</strong> is an opinionated code formatter that ensures consistent code style throughout your project. It integrates well with TypeScript and can be used alongside ESLint to ensure both quality and formatting standards.
    </p>
  
    <p>To install Prettier:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install --save-dev prettier
      </code>
    </pre>
  
    <p>Configure Prettier by adding a <code>.prettierrc</code> file:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "semi": true,<br />
          "singleQuote": true,<br />
          "trailingComma": "es5"<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. TypeScript Compiler (tsc)</h2>
  
    <p>
      The <strong>TypeScript compiler (tsc)</strong> itself is a great tool for ensuring code quality. With strict settings enabled, it catches potential errors and enforces strong typing throughout your project. These checks help prevent common errors such as passing the wrong data types or calling functions incorrectly.
    </p>
  
    <p>Enable strict mode in your <code>tsconfig.json</code> file:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "compilerOptions": &#123;<br />
            "strict": true,<br />
            "noImplicitAny": true,<br />
            "strictNullChecks": true,<br />
            "strictFunctionTypes": true,<br />
          &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. SonarQube</h2>
  
    <p>
      <strong>SonarQube</strong> is a comprehensive code quality tool that performs static code analysis to detect code smells, bugs, and security vulnerabilities. It integrates with TypeScript projects and provides detailed reports on code quality, helping teams maintain a clean codebase.
    </p>
  
    <p>SonarQube can be integrated into continuous integration (CI) pipelines to ensure quality checks are automated and reports are generated regularly.</p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. TSLint (Deprecated)</h2>
  
    <p>
      <strong>TSLint</strong> was the original linter for TypeScript but has been deprecated in favor of ESLint with TypeScript support. If you encounter TSLint in older projects, it is recommended to migrate to ESLint for continued support and updates.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Husky & Lint-Staged</h2>
  
    <p>
      <strong>Husky</strong> is a tool that allows you to run scripts at various stages of the Git workflow, such as before committing or pushing code. Combined with <strong>lint-staged</strong>, you can automatically lint and format your TypeScript code before it's committed, ensuring that only quality code reaches the repository.
    </p>
  
    <p>To install Husky and lint-staged:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install husky lint-staged --save-dev
      </code>
    </pre>
  
    <p>Configure your <code>package.json</code> for lint-staged and Husky:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "husky": &#123;<br />
            "hooks": &#123;<br />
              "pre-commit": "lint-staged"<br />
            &#125;<br />
          &#125;,<br />
          "lint-staged": &#123;<br />
            "*.ts": ["eslint --fix", "prettier --write"]<br />
          &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Jest for Testing</h2>
  
    <p>
      <strong>Jest</strong> is a testing framework that includes built-in support for TypeScript. It ensures that your code behaves as expected by running unit tests and generating code coverage reports. Combined with other tools like ESLint and Prettier, Jest helps ensure that both your code quality and functionality are up to par.
    </p>
  
    <p>To install Jest with TypeScript:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install jest ts-jest &#64;types/jest --save-dev
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">8. EditorConfig</h2>
  
    <p>
      <strong>EditorConfig</strong> helps maintain consistent coding styles between different editors and IDEs. It's a configuration file that sets rules for things like indentation, end-of-line characters, and more. While it doesn't directly affect TypeScript, it helps teams ensure that formatting rules are consistent across the project.
    </p>
  
    <p>Create an <code>.editorconfig</code> file in your project:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        # EditorConfig<br />
        root = true<br /><br />
  
        [*]<br />
        indent_style = space<br />
        indent_size = 2<br />
        end_of_line = lf<br />
        charset = utf-8<br />
        trim_trailing_whitespace = true<br />
        insert_final_newline = true
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">Conclusion</h2>
  
    <p>
      Code quality tools are essential for maintaining a clean, reliable, and error-free codebase in TypeScript. Tools like ESLint, Prettier, Husky, and SonarQube automate the process of ensuring that your code meets certain standards, preventing bugs and improving readability. By incorporating these tools into your workflow, you can significantly improve the quality of your TypeScript code and ensure long-term maintainability.
    </p>
  </div>
  
}@case(41){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Polyfills and Transpilers in TypeScript</h1>
  
    <p>
      TypeScript is a powerful superset of JavaScript that enhances the development experience with static typing and other advanced features. However, when writing TypeScript code, it's essential to understand how it interacts with JavaScript runtime environments. This is where polyfills and transpilers come into play. This article will explore what polyfills and transpilers are and how they impact TypeScript development.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. What are Polyfills?</h2>
  
    <p>
      A <strong>polyfill</strong> is a piece of code (usually a JavaScript function) that provides the functionality that is not natively supported in a particular environment. Polyfills allow developers to use newer JavaScript features while still supporting older browsers that do not have those features implemented.
    </p>
  
    <p>For example, if you're using the <code>Array.prototype.includes()</code> method, which is not supported in Internet Explorer, you can use a polyfill:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        if (!Array.prototype.includes) &#123;<br />
          Array.prototype.includes = function(searchElement, fromIndex) &#123;<br />
            // Implementation code here<br />
          &#125;;<br />
        &#125;;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Common Polyfills in TypeScript</h2>
  
    <p>
      Several libraries provide polyfills for various JavaScript features. Here are a few commonly used ones:
    </p>
  
    <ul class="list-disc list-inside">
      <li><strong>core-js</strong>: A modular standard library that includes polyfills for ECMAScript features.</li>
      <li><strong>babel-polyfill</strong>: Includes polyfills for both ECMAScript and certain built-in objects.</li>
      <li><strong>whatwg-fetch</strong>: A polyfill for the Fetch API, allowing for network requests.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. What are Transpilers?</h2>
  
    <p>
      A <strong>transpiler</strong> is a tool that translates code from one version of a language to another. In the context of TypeScript, a transpiler converts TypeScript code into standard JavaScript code that can run in any JavaScript environment. The TypeScript compiler itself is a transpiler, converting TypeScript files (with a .ts extension) to JavaScript files (with a .js extension).
    </p>
  
    <p>For example, the TypeScript compiler can be invoked as follows:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        tsc myfile.ts
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Benefits of Using Transpilers</h2>
  
    <p>
      Using a transpiler offers several advantages:
    </p>
  
    <ul class="list-disc list-inside">
      <li><strong>Cross-browser compatibility</strong>: Transpilers can convert modern JavaScript features into older syntax that can run in all browsers.</li>
      <li><strong>Type Safety</strong>: TypeScript adds type checking, reducing the likelihood of runtime errors.</li>
      <li><strong>Feature access</strong>: Transpilers enable the use of new language features before they are widely supported in browsers.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Using Polyfills and Transpilers Together</h2>
  
    <p>
      In a TypeScript project, using both polyfills and transpilers is common to ensure compatibility and access to modern features. When you transpile your TypeScript code, you may still need to include polyfills for features not supported in your target environments.
    </p>
  
    <p>For example, if your TypeScript code uses the <code>Promise</code> class, you may need a polyfill for older browsers that do not support it:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install promise-polyfill --save
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      Understanding polyfills and transpilers is essential for TypeScript developers who want to write modern JavaScript while ensuring compatibility with a wide range of environments. Polyfills help bridge the gap for missing features in older browsers, while transpilers convert TypeScript to JavaScript, making it accessible to various runtimes. By effectively using these tools, developers can create robust and future-proof applications.
    </p>
  </div>
  
}@case(42){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Automated Testing with Jasmine and Karma in TypeScript</h1>
  
    <p>
      Automated testing is a critical part of the software development process, ensuring that your code behaves as expected and reducing the likelihood of bugs. In the TypeScript ecosystem, Jasmine and Karma are two popular tools used for writing and running tests. This article will explore how to set up and use Jasmine and Karma for automated testing in TypeScript projects.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. What is Jasmine?</h2>
  
    <p>
      <strong>Jasmine</strong> is a behavior-driven development (BDD) testing framework for JavaScript that provides a clean and simple syntax for writing tests. It is widely used for testing Angular applications and integrates seamlessly with TypeScript.
    </p>
  
    <p>To install Jasmine in your project, you can use npm:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install jasmine-core --save-dev
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. What is Karma?</h2>
  
    <p>
      <strong>Karma</strong> is a test runner that allows you to execute your JavaScript tests in various browsers. It works well with Jasmine, making it easier to run tests automatically in multiple environments.
    </p>
  
    <p>To set up Karma, install it along with the necessary dependencies:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npm install karma karma-jasmine karma-chrome-launcher --save-dev
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Setting Up Karma</h2>
  
    <p>After installing Karma and its dependencies, you need to configure it. Run the following command to create a configuration file:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npx karma init
      </code>
    </pre>
  
    <p>Follow the prompts to set up the configuration. A basic <code>karma.conf.js</code> file will look like this:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        module.exports = function(config) &#123;<br />
          config.set(&#123;<br />
            basePath: '',<br />
            frameworks: ['jasmine'],<br />
            files: ['src/**/*.ts'],<br />
            preprocessors: {{'{'}} 'src/**/*.ts': ['typescript'] {{'}'}},<br />
            reporters: ['progress'],<br />
            port: 9876,<br />
            colors: true,<br />
            logLevel: config.LOG_INFO,<br />
            autoWatch: true,<br />
            browsers: ['Chrome'],<br />
            singleRun: false,<br />
            concurrency: Infinity<br />
          &#125;);<br />
        &#125;;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Writing Tests with Jasmine</h2>
  
    <p>
      Jasmine tests are structured using <code>describe</code> and <code>it</code> functions. The <code>describe</code> function groups related tests, while the <code>it</code> function defines individual test cases.
    </p>
  
    <p>Here’s an example of a simple test case in TypeScript:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        describe('Math operations', () => &#123;<br />
          it('should add two numbers', () => &#123;<br />
            const sum = 1 + 1;<br />
            expect(sum).toBe(2);<br />
          &#125;);<br />
        &#125;);<br />
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Running Tests</h2>
  
    <p>
      Once you have written your tests, you can run them using Karma. Start the Karma server with the following command:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        npx karma start
      </code>
    </pre>
  
    <p>Karma will launch the specified browsers and execute the tests, displaying the results in the terminal.</p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Continuous Integration</h2>
  
    <p>
      Integrating Jasmine and Karma into your continuous integration (CI) pipeline can help ensure that tests are run automatically with every code change. Most CI tools, such as Jenkins, Travis CI, or GitHub Actions, can be configured to execute your tests using Karma.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Conclusion</h2>
  
    <p>
      Automated testing is essential for maintaining the quality of TypeScript applications. Jasmine and Karma provide a robust framework for writing and executing tests, ensuring your code behaves as expected. By incorporating these tools into your development workflow, you can improve code reliability, reduce bugs, and enhance overall software quality.
    </p>
  </div>
  
}@case(43){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Debugging with Chrome DevTools in TypeScript</h1>
  
    <p>
      Debugging is an essential part of the development process, allowing developers to identify and fix issues in their code. Chrome DevTools provides a powerful set of tools for debugging TypeScript applications running in the browser. This article explores how to effectively use Chrome DevTools to debug TypeScript code.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. What are Chrome DevTools?</h2>
  
    <p>
      <strong>Chrome DevTools</strong> is a set of web authoring and debugging tools built into the Google Chrome browser. It allows developers to inspect elements, monitor network activity, debug JavaScript, and optimize performance. With the integration of TypeScript, developers can leverage these tools to improve their debugging workflow.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Setting Up Your Environment</h2>
  
    <p>
      To debug TypeScript code in Chrome DevTools, ensure that your TypeScript is compiled with source maps enabled. Source maps allow you to see the original TypeScript code while debugging.
    </p>
  
    <p>In your TypeScript configuration file <code>tsconfig.json</code>, add the following line:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        &#123;<br />
          "compilerOptions": &#123;<br />
            "sourceMap": true,<br />
            // other options<br />
          &#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Opening Chrome DevTools</h2>
  
    <p>
      To open Chrome DevTools, right-click on your web page and select <strong>Inspect</strong>, or use the keyboard shortcut <code>Ctrl + Shift + I</code> (Windows/Linux) or <code>Cmd + Option + I</code> (Mac).
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Debugging TypeScript Code</h2>
  
    <p>
      Once you have DevTools open, navigate to the <strong>Sources</strong> tab to view your files. You will find your TypeScript files listed along with their corresponding compiled JavaScript files.
    </p>
  
    <p>You can set breakpoints in your TypeScript code by clicking on the line number. When your application hits that line, execution will pause, allowing you to inspect variables and control the flow of execution.</p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Inspecting Variables</h2>
  
    <p>
      When execution is paused at a breakpoint, you can hover over variables to see their current values. Additionally, the <strong>Scope</strong> section in the right panel shows local and global variables, enabling you to track the state of your application.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Using the Console</h2>
  
    <p>
      The <strong>Console</strong> tab is an essential part of debugging. You can log messages and variable values using <code>console.log()</code> in your TypeScript code. This output will appear in the Console tab, allowing you to monitor application behavior.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        console.log('Current value:', myVariable);
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Advanced Debugging Techniques</h2>
  
    <p>
      Chrome DevTools offers several advanced debugging features:
    </p>
  
    <ul class="list-disc list-inside">
      <li><strong>Conditional Breakpoints</strong>: Right-click on a breakpoint and select "Edit breakpoint" to specify conditions for when the breakpoint should trigger.</li>
      <li><strong>Watch Expressions</strong>: Add variables to the Watch panel to track their values over time.</li>
      <li><strong>Call Stack</strong>: View the call stack to see the sequence of function calls that led to the current execution point.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">8. Conclusion</h2>
  
    <p>
      Debugging is a crucial skill for developers, and Chrome DevTools provides a comprehensive set of tools to aid in the debugging of TypeScript applications. By leveraging source maps, breakpoints, and the console, you can efficiently identify and resolve issues in your code. Incorporating these debugging techniques into your development workflow can significantly enhance your productivity and code quality.
    </p>
  </div>
  
}@case (44){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Array Methods in TypeScript</h1>
  
    <p>
      Arrays are one of the fundamental data structures in TypeScript, and understanding how to manipulate arrays is key to working with collections of data. TypeScript provides a variety of array methods that allow developers to efficiently work with arrays. In this article, we'll explore some of the most commonly used array methods and how they can be utilized in TypeScript.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. <code>push()</code> and <code>pop()</code></h2>
  
    <p>
      The <code>push()</code> method adds one or more elements to the end of an array and returns the new length of the array. Conversely, the <code>pop()</code> method removes the last element from an array and returns that element.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3];<br />
        numbers.push(4);  // [1, 2, 3, 4]<br />
        numbers.pop();    // [1, 2, 3]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. <code>map()</code></h2>
  
    <p>
      The <code>map()</code> method creates a new array by applying a function to each element of the original array. It doesn’t modify the original array but returns a new one.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3];<br />
        let doubled = numbers.map(n => n * 2);  // [2, 4, 6]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. <code>filter()</code></h2>
  
    <p>
      The <code>filter()</code> method creates a new array with all elements that pass a test defined by a function. The original array is not modified.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4];<br />
        let evenNumbers = numbers.filter(n => n % 2 === 0);  // [2, 4]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. <code>find()</code></h2>
  
    <p>
      The <code>find()</code> method returns the first element in an array that satisfies the provided test function. If no elements match, it returns <code>undefined</code>.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4];<br />
        let firstEven = numbers.find(n => n % 2 === 0);  // 2
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. <code>forEach()</code></h2>
  
    <p>
      The <code>forEach()</code> method executes a provided function once for each array element. It does not return anything and is often used to iterate over arrays for side effects like logging or mutating external variables.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3];<br />
        numbers.forEach(n => console.log(n));  // logs: 1, 2, 3
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. <code>reduce()</code></h2>
  
    <p>
      The <code>reduce()</code> method applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4];<br />
        let sum = numbers.reduce((acc, n) => acc + n, 0);  // 10
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. <code>slice()</code></h2>
  
    <p>
      The <code>slice()</code> method returns a shallow copy of a portion of an array into a new array object. It takes two arguments: the start index and the end index (exclusive). If no end index is provided, it slices till the end of the array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        let subArray = numbers.slice(1, 3);  // [2, 3]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">8. <code>splice()</code></h2>
  
    <p>
      The <code>splice()</code> method changes the contents of an array by removing, replacing, or adding elements in place. It returns the removed elements and modifies the original array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        let removed = numbers.splice(2, 1);  // [3], numbers is now [1, 2, 4, 5]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">9. <code>concat()</code></h2>
  
    <p>
      The <code>concat()</code> method merges two or more arrays without modifying the original arrays. It returns a new array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let arr1: number[] = [1, 2];<br />
        let arr2: number[] = [3, 4];<br />
        let combined = arr1.concat(arr2);  // [1, 2, 3, 4]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">10. Conclusion</h2>
  
    <p>
      Understanding and using array methods in TypeScript is crucial for writing clean, efficient, and readable code. Whether you're transforming, filtering, or reducing data, these methods provide powerful capabilities for handling arrays. By mastering these methods, you can enhance your productivity and code quality.
    </p>
  </div>
  
}@case(45){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">for Methods in TypeScript</h1>
  
    <p>
      Iterating over arrays or objects is a common task in TypeScript, and there are several methods for looping in TypeScript that offer different capabilities depending on the use case. This article explores the different <code>for</code> methods available in TypeScript, such as <code>for</code>, <code>for...of</code>, and <code>for...in</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. The Basic <code>for</code> Loop</h2>
  
    <p>
      The traditional <code>for</code> loop is the most basic form of iteration in TypeScript (or JavaScript). It allows you to loop through an array or a sequence of numbers with full control over the index.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        for (let i = 0; i &lt; numbers.length; i++) &#123;<br />
          console.log(numbers[i]);<br />
        &#125;
      </code>
    </pre>
  
    <p>This loop iterates over the array <code>numbers</code>, and each element is accessed via its index <code>i</code>.</p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. The <code>for...of</code> Loop</h2>
  
    <p>
      The <code>for...of</code> loop is a more modern iteration method introduced in ES6 (and available in TypeScript). It allows you to iterate over the elements of an array or any iterable object (like strings or sets) without using an index.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        for (let num of numbers) &#123;<br />
          console.log(num);<br />
        &#125;
      </code>
    </pre>
  
    <p>
      The <code>for...of</code> loop simplifies iteration as you don't need to manually manage the index, and it directly gives you the value of each element.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. The <code>for...in</code> Loop</h2>
  
    <p>
      The <code>for...in</code> loop iterates over the enumerable properties of an object, including array indices, object keys, and other iterable objects. However, it is important to note that <code>for...in</code> should primarily be used with objects, as it iterates over the properties, not the values.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: 'John', age: 30, city: 'New York' &#125;;<br />
        for (let key in person) &#123;<br />
          console.log(key + ': ' + person[key]);<br />
        &#125;
      </code>
    </pre>
  
    <p>
      In this example, the <code>for...in</code> loop iterates over the keys of the <code>person</code> object, logging both the key and the value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>forEach()</code></h2>
  
    <p>
      The <code>forEach()</code> method is not a traditional loop but rather a higher-order array method that iterates through each element of an array, applying a function to each element. It's a common choice for iteration when you want to avoid manually managing indices.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        numbers.forEach(num => console.log(num));
      </code>
    </pre>
  
    <p>
      The <code>forEach()</code> method allows you to pass a callback function that gets executed for each array element, providing a more functional approach to iteration.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Conclusion</h2>
  
    <p>
      TypeScript offers a variety of <code>for</code> methods, each with its own use case. While the traditional <code>for</code> loop offers full control, <code>for...of</code> is ideal for iterating over iterable objects, and <code>for...in</code> is best used with objects to iterate over properties. The <code>forEach()</code> method provides a functional way to iterate over arrays. Understanding these methods will allow you to choose the right approach for iterating over collections in TypeScript.
    </p>
  </div>
  
}@case(46){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">forEach Method in TypeScript</h1>
  
    <p>
      The <code>forEach()</code> method is one of the most commonly used methods for iterating over arrays in TypeScript. It executes a provided function once for each array element. In this article, we will explore the <code>forEach()</code> method in TypeScript, how it works, and when to use it.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>forEach()</code></h2>
  
    <p>
      The syntax for the <code>forEach()</code> method is straightforward. It takes a callback function as an argument, which is executed for each element in the array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.forEach((element, index, array) => &#123;<br />
          // Your code here<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The callback function can take three arguments: 
    </p>
    <ul class="list-disc list-inside">
      <li><code>element</code> (required) - the current element being processed in the array</li>
      <li><code>index</code> (optional) - the index of the current element</li>
      <li><code>array</code> (optional) - the array that <code>forEach()</code> is being applied to</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Basic Example of <code>forEach()</code></h2>
  
    <p>
      Let’s start with a basic example of using the <code>forEach()</code> method to print each element of an array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        numbers.forEach(num => &#123;<br />
          console.log(num);<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      In this example, the callback function logs each element of the array to the console. The <code>forEach()</code> method will go through every element in the <code>numbers</code> array and execute the function.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Using Index in <code>forEach()</code></h2>
  
    <p>
      The second parameter of the callback function is the index of the current element. This can be useful when you need to know the position of each element while iterating.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let fruits: string[] = ['apple', 'banana', 'cherry'];<br />
        fruits.forEach((fruit, index) => &#123;<br />
          console.log(index + ': ' + fruit);<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The output will be:
    </p>
    <ul class="list-disc list-inside">
      <li>0: apple</li>
      <li>1: banana</li>
      <li>2: cherry</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using the Array Parameter</h2>
  
    <p>
      The third argument of the callback is the array itself. While it's not often used, it can be helpful in certain scenarios where you need access to the full array within the callback.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let colors: string[] = ['red', 'green', 'blue'];<br />
        colors.forEach((color, index, array) => &#123;<br />
          console.log('Array[' + index + '] = ' + color + ' in ' + array);<br />
        &#125;);
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Limitations of <code>forEach()</code></h2>
  
    <p>
      While the <code>forEach()</code> method is a powerful tool for iterating over arrays, it has some limitations:
    </p>
    <ul class="list-disc list-inside">
      <li><strong>No Return Value:</strong> <code>forEach()</code> always returns <code>undefined</code>. It cannot be used to return a transformed array. For that, use methods like <code>map()</code>.</li>
      <li><strong>No Early Exit:</strong> You cannot break out of a <code>forEach()</code> loop. If you need early termination, consider using a <code>for</code> loop or the <code>every()</code> method.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Practical Use Cases of <code>forEach()</code></h2>
  
    <p>
      Here are some common use cases for the <code>forEach()</code> method:
    </p>
  
    <ul class="list-disc list-inside">
      <li>Iterating over an array to log or display data.</li>
      <li>Mutating or changing elements in a separate structure (like updating DOM elements).</li>
      <li>Performing side effects such as updating external variables or calling functions for each element.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Conclusion</h2>
  
    <p>
      The <code>forEach()</code> method in TypeScript is a convenient way to iterate over arrays without needing to manage the index manually. While it has some limitations, such as no return value and no early exit, it's perfect for scenarios where you need to perform side effects or simply iterate over elements in an array.
    </p>
  </div>
  
}@case(47){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">map Method in TypeScript</h1>
  
    <p>
      The <code>map()</code> method in TypeScript is used to create a new array by applying a function to every element in the original array. This method is a common way to transform data. In this article, we will explore how the <code>map()</code> method works, its syntax, and use cases.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>map()</code></h2>
  
    <p>
      The <code>map()</code> method creates a new array with the results of calling a provided function on every element in the original array. It doesn’t modify the original array but instead returns a new one.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.map((element, index, array) => &#123;<br />
          // transformation logic<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The <code>map()</code> method takes a callback function with three parameters:
    </p>
    <ul class="list-disc list-inside">
      <li><code>element</code> (required) - the current element being processed in the array</li>
      <li><code>index</code> (optional) - the index of the current element</li>
      <li><code>array</code> (optional) - the original array being mapped over</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Basic Example of <code>map()</code></h2>
  
    <p>
      Let’s begin with a simple example of using <code>map()</code> to transform an array of numbers by multiplying each element by 2.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        let doubledNumbers = numbers.map(num => num * 2);<br />
        console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]
      </code>
    </pre>
  
    <p>
      In this example, <code>map()</code> creates a new array, <code>doubledNumbers</code>, by applying the transformation <code>num * 2</code> to each element of the <code>numbers</code> array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Mapping Objects</h2>
  
    <p>
      The <code>map()</code> method can also be used to transform an array of objects. Let’s take an array of objects representing users and extract only their names using <code>map()</code>.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let users = [<br />
          &#123; name: 'John', age: 30 &#125;,<br />
          &#123; name: 'Jane', age: 25 &#125;,<br />
          &#123; name: 'Jack', age: 40 &#125;<br />
        ];<br />
        let userNames = users.map(user => user.name);<br />
        console.log(userNames); // Output: ['John', 'Jane', 'Jack']
      </code>
    </pre>
  
    <p>
      The <code>map()</code> method returns a new array containing only the <code>name</code> property of each object in the <code>users</code> array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>index</code> in <code>map()</code></h2>
  
    <p>
      The second parameter of the <code>map()</code> callback function is the index of the current element. This can be useful when the transformation depends on the index.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [10, 20, 30, 40];<br />
        let numbersWithIndex = numbers.map((num, index) => &#123;<br />
          return `Index ${{'{'}}index{{'}'}}: ${{'{'}}num{{'}'}}`;<br />
        &#125;);<br />
        console.log(numbersWithIndex);<br />
        // Output: ['Index 0: 10', 'Index 1: 20', 'Index 2: 30', 'Index 3: 40']
      </code>
    </pre>
  
    <p>
      Here, the <code>index</code> is included in the transformed array, showing how to incorporate the index into the mapped result.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Chaining <code>map()</code> with Other Methods</h2>
  
    <p>
      The <code>map()</code> method can be chained with other array methods like <code>filter()</code> or <code>reduce()</code> for more complex transformations. Let’s take an example where we first filter out odd numbers and then double the remaining numbers.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        let evenDoubled = numbers<br />
          .filter(num => num % 2 === 0)<br />
          .map(num => num * 2);<br />
        console.log(evenDoubled); // Output: [4, 8]
      </code>
    </pre>
  
    <p>
      In this example, we first use <code>filter()</code> to get only the even numbers and then use <code>map()</code> to double those numbers.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>map()</code> method in TypeScript is a powerful tool for transforming arrays. It allows you to create new arrays from existing ones by applying a transformation function. Whether you're working with simple arrays or more complex data structures like objects, <code>map()</code> is an essential tool in any TypeScript developer's toolbox.
    </p>
  </div>

}@case(48){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">filter Method in TypeScript</h1>
  
    <p>
      The <code>filter()</code> method in TypeScript is used to create a new array with elements that pass a specific test (provided as a function). This method is commonly used to filter out unwanted data or extract specific elements from an array. In this article, we will dive into how the <code>filter()</code> method works, its syntax, and examples of its usage.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>filter()</code></h2>
  
    <p>
      The <code>filter()</code> method creates a new array with all elements that pass the test implemented by the provided function.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.filter((element, index, array) => &#123;<br />
          // return true or false based on condition<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The <code>filter()</code> method takes a callback function that accepts three parameters:
    </p>
    <ul class="list-disc list-inside">
      <li><code>element</code> (required) - the current element being processed in the array</li>
      <li><code>index</code> (optional) - the index of the current element</li>
      <li><code>array</code> (optional) - the original array being filtered</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Basic Example of <code>filter()</code></h2>
  
    <p>
      Let’s start with a simple example of using <code>filter()</code> to create a new array containing only the even numbers from an array of numbers.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5, 6];<br />
        let evenNumbers = numbers.filter(num => num % 2 === 0);<br />
        console.log(evenNumbers); // Output: [2, 4, 6]
      </code>
    </pre>
  
    <p>
      In this example, the <code>filter()</code> method returns a new array <code>evenNumbers</code> that contains only the elements that satisfy the condition <code>num % 2 === 0</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Filtering Objects</h2>
  
    <p>
      The <code>filter()</code> method is also useful when working with arrays of objects. Let’s use it to filter an array of objects to find users older than 30 years.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let users = [<br />
          &#123; name: 'John', age: 32 &#125;,<br />
          &#123; name: 'Jane', age: 25 &#125;,<br />
          &#123; name: 'Jack', age: 40 &#125;<br />
        ];<br />
        let olderUsers = users.filter(user => user.age > 30);<br />
        console.log(olderUsers);<br />
        // Output: [&#123; name: 'John', age: 32 &#125;, &#123; name: 'Jack', age: 40 &#125;]
      </code>
    </pre>
  
    <p>
      The <code>filter()</code> method returns an array <code>olderUsers</code> containing only the objects where the user's age is greater than 30.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>index</code> in <code>filter()</code></h2>
  
    <p>
      The second parameter of the callback function is the index of the current element. This can be useful when filtering based on the element’s position in the array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let fruits: string[] = ['apple', 'banana', 'cherry', 'date'];<br />
        let filteredFruits = fruits.filter((fruit, index) => index % 2 === 0);<br />
        console.log(filteredFruits);<br />
        // Output: ['apple', 'cherry']
      </code>
    </pre>
  
    <p>
      In this example, we use the <code>index</code> to filter out every second element in the <code>fruits</code> array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Chaining <code>filter()</code> with Other Methods</h2>
  
    <p>
      The <code>filter()</code> method can be combined with other array methods such as <code>map()</code> for more complex transformations. Let’s use <code>filter()</code> to find numbers greater than 10 and then use <code>map()</code> to multiply those numbers by 2.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [5, 10, 15, 20, 25];<br />
        let doubledFilteredNumbers = numbers<br />
          .filter(num => num > 10)<br />
          .map(num => num * 2);<br />
        console.log(doubledFilteredNumbers); // Output: [30, 40, 50]
      </code>
    </pre>
  
    <p>
      In this example, <code>filter()</code> returns numbers greater than 10, and <code>map()</code> then multiplies each of those numbers by 2.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>filter()</code> method in TypeScript is an essential tool for creating new arrays based on specific conditions. Whether you are filtering numbers or objects, <code>filter()</code> makes it easy to extract the elements that meet your criteria. It is also flexible enough to be combined with other methods for more complex operations.
    </p>
  </div>
  
}@case(49){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">some Method in TypeScript</h1>
  
    <p>
      The <code>some()</code> method in TypeScript is used to check whether at least one element in an array satisfies a specific condition (provided as a function). This method returns a boolean value, <code>true</code> if at least one element passes the test and <code>false</code> otherwise. In this article, we will explore how the <code>some()</code> method works, its syntax, and common use cases.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>some()</code></h2>
  
    <p>
      The <code>some()</code> method tests whether at least one element in the array passes the test implemented by the provided function.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.some((element, index, array) => &#123;<br />
          // return true or false based on the condition<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The <code>some()</code> method takes a callback function that can accept three parameters:
    </p>
    <ul class="list-disc list-inside">
      <li><code>element</code> (required) - the current element being processed in the array</li>
      <li><code>index</code> (optional) - the index of the current element</li>
      <li><code>array</code> (optional) - the original array being processed</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Basic Example of <code>some()</code></h2>
  
    <p>
      Let’s begin with a simple example of using <code>some()</code> to check if an array contains any even numbers.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 3, 5, 7, 8];<br />
        let hasEven = numbers.some(num => num % 2 === 0);<br />
        console.log(hasEven); // Output: true
      </code>
    </pre>
  
    <p>
      In this example, <code>some()</code> returns <code>true</code> because at least one element (the number 8) in the array is even.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Using <code>some()</code> with Objects</h2>
  
    <p>
      The <code>some()</code> method can also be applied to arrays of objects. For instance, let’s check if at least one user in an array is older than 30 years.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let users = [<br />
          &#123; name: 'John', age: 25 &#125;,<br />
          &#123; name: 'Jane', age: 35 &#125;,<br />
          &#123; name: 'Jack', age: 28 &#125;<br />
        ];<br />
        let hasOlderUser = users.some(user => user.age > 30);<br />
        console.log(hasOlderUser); // Output: true
      </code>
    </pre>
  
    <p>
      In this example, <code>some()</code> returns <code>true</code> because at least one user (Jane) is older than 30.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>index</code> in <code>some()</code></h2>
  
    <p>
      The second parameter of the callback function is the index of the current element. This can be useful when the test involves the element's position in the array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let fruits: string[] = ['apple', 'banana', 'cherry', 'date'];<br />
        let hasFruitAtEvenIndex = fruits.some((fruit, index) => index % 2 === 0 && fruit.length > 5);<br />
        console.log(hasFruitAtEvenIndex);<br />
        // Output: false
      </code>
    </pre>
  
    <p>
      In this example, <code>some()</code> checks if there is any fruit with more than 5 characters at an even index, and returns <code>false</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Chaining <code>some()</code> with Other Methods</h2>
  
    <p>
      You can chain <code>some()</code> with other array methods like <code>filter()</code> and <code>map()</code>. For example, let’s use <code>some()</code> to check if the result of filtering an array contains any elements greater than 10.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [4, 7, 10, 15, 20];<br />
        let result = numbers<br />
          .filter(num => num > 5)<br />
          .some(num => num > 10);<br />
        console.log(result); // Output: true
      </code>
    </pre>
  
    <p>
      In this case, <code>filter()</code> first returns the numbers greater than 5, and then <code>some()</code> checks if any of these numbers are greater than 10, returning <code>true</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>some()</code> method is a valuable tool in TypeScript for checking whether at least one element in an array satisfies a given condition. Whether you’re working with simple arrays or complex objects, <code>some()</code> provides an easy way to validate or filter data without iterating through the entire array. It is particularly useful when you only care about the presence of a matching element rather than the entire result.
    </p>
  </div>
  
}@case(50){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">every Method in TypeScript</h1>
  
    <p>
      The <code>every()</code> method in TypeScript is used to test whether all elements in an array pass a specific test (provided as a function). It returns a boolean value: <code>true</code> if all elements meet the condition, and <code>false</code> if at least one element fails the test. This method is useful for verifying if all elements in an array satisfy a condition. In this article, we’ll explore the <code>every()</code> method, its syntax, and examples of its usage.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>every()</code></h2>
  
    <p>
      The <code>every()</code> method checks if all elements in the array pass the test provided by the callback function.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.every((element, index, array) => &#123;<br />
          // return true or false based on condition<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The callback function for <code>every()</code> accepts three parameters:
    </p>
    <ul class="list-disc list-inside">
      <li><code>element</code> (required) - the current element being processed in the array</li>
      <li><code>index</code> (optional) - the index of the current element</li>
      <li><code>array</code> (optional) - the original array being processed</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Basic Example of <code>every()</code></h2>
  
    <p>
      Let’s start with a simple example of using <code>every()</code> to check if all numbers in an array are even.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [2, 4, 6, 8];<br />
        let allEven = numbers.every(num => num % 2 === 0);<br />
        console.log(allEven); // Output: true
      </code>
    </pre>
  
    <p>
      In this example, <code>every()</code> returns <code>true</code> because all the numbers in the array are even.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Using <code>every()</code> with Objects</h2>
  
    <p>
      The <code>every()</code> method can also be used with arrays of objects. Let’s use it to check if all users in an array are older than 18.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let users = [<br />
          &#123; name: 'John', age: 20 &#125;,<br />
          &#123; name: 'Jane', age: 25 &#125;,<br />
          &#123; name: 'Jack', age: 30 &#125;<br />
        ];<br />
        let allAdults = users.every(user => user.age > 18);<br />
        console.log(allAdults); // Output: true
      </code>
    </pre>
  
    <p>
      In this example, <code>every()</code> returns <code>true</code> because all users are older than 18.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>index</code> in <code>every()</code></h2>
  
    <p>
      The second parameter of the callback function is the index of the current element. Let’s use the index to check if all elements at even indices are greater than 5.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [6, 2, 8, 4, 10];<br />
        let checkIndices = numbers.every((num, index) => index % 2 === 0 && num > 5);<br />
        console.log(checkIndices);<br />
        // Output: true
      </code>
    </pre>
  
    <p>
      In this example, <code>every()</code> checks whether the elements at even indices (0, 2, 4) are greater than 5, and returns <code>true</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Chaining <code>every()</code> with Other Methods</h2>
  
    <p>
      The <code>every()</code> method can be chained with other array methods like <code>map()</code> or <code>filter()</code>. Let’s filter an array and then check if the resulting array has all elements greater than 10.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [5, 10, 15, 20];<br />
        let result = numbers<br />
          .filter(num => num > 5)<br />
          .every(num => num > 10);<br />
        console.log(result); // Output: false
      </code>
    </pre>
  
    <p>
      Here, the <code>filter()</code> method returns numbers greater than 5, and then <code>every()</code> checks if all of them are greater than 10. Since the number 10 is not greater than 10, it returns <code>false</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>every()</code> method in TypeScript is useful when you need to verify that all elements in an array satisfy a specific condition. Whether you are working with simple data types or complex objects, <code>every()</code> provides a simple and efficient way to ensure that all elements pass a given test. It is a great tool for validation and data integrity checks.
    </p>
  </div>
  
}@case(51){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">find Method in TypeScript</h1>
  
    <p>
      The <code>find()</code> method in TypeScript is used to search through an array and return the first element that satisfies a given condition (test function). If no elements match the condition, <code>find()</code> returns <code>undefined</code>. This method is commonly used to locate a specific item in an array, especially when working with complex data structures like arrays of objects.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>find()</code></h2>
  
    <p>
      The <code>find()</code> method accepts a callback function that tests each element of the array. It stops execution and returns the first element that meets the condition.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.find((element, index, array) => &#123;<br />
          // return true or false based on condition<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The callback function for <code>find()</code> takes three parameters:
    </p>
    <ul class="list-disc list-inside">
      <li><code>element</code> (required) - the current element being processed</li>
      <li><code>index</code> (optional) - the index of the current element</li>
      <li><code>array</code> (optional) - the original array being processed</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Basic Example of <code>find()</code></h2>
  
    <p>
      Let’s start with a simple example of using <code>find()</code> to search for the first even number in an array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 3, 5, 8, 10];<br />
        let firstEven = numbers.find(num => num % 2 === 0);<br />
        console.log(firstEven); // Output: 8
      </code>
    </pre>
  
    <p>
      In this example, <code>find()</code> returns <code>8</code> because it’s the first even number in the array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Using <code>find()</code> with Objects</h2>
  
    <p>
      The <code>find()</code> method is very useful when searching for objects in an array. For example, let's use it to find a user object based on a specific property (e.g., <code>age</code>).
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let users = [<br />
          &#123; name: 'John', age: 25 &#125;,<br />
          &#123; name: 'Jane', age: 30 &#125;,<br />
          &#123; name: 'Jack', age: 35 &#125;<br />
        ];<br />
        let user = users.find(user => user.age === 30);<br />
        console.log(user); // Output: &#123; name: 'Jane', age: 30 &#125;
      </code>
    </pre>
  
    <p>
      In this example, <code>find()</code> returns the object representing the user with age 30.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Handling <code>undefined</code> with <code>find()</code></h2>
  
    <p>
      Since <code>find()</code> returns <code>undefined</code> if no element matches the condition, it’s important to handle this case to avoid errors.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 3, 5];<br />
        let firstEven = numbers.find(num => num % 2 === 0);<br />
        if (firstEven !== undefined) &#123;<br />
          console.log('First even number:', firstEven);<br />
        &#125; else &#123;<br />
          console.log('No even number found');<br />
        &#125;
      </code>
    </pre>
  
    <p>
      In this example, since there are no even numbers in the array, <code>find()</code> returns <code>undefined</code>, and the conditional check ensures the appropriate message is logged.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Chaining <code>find()</code> with Other Array Methods</h2>
  
    <p>
      The <code>find()</code> method can be chained with other array methods such as <code>filter()</code> and <code>map()</code>. For example, let’s filter an array and then find a specific element in the filtered result.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [4, 9, 16, 25, 36];<br />
        let result = numbers<br />
          .filter(num => num > 10)<br />
          .find(num => num % 3 === 0);<br />
        console.log(result); // Output: 36
      </code>
    </pre>
  
    <p>
      In this example, the <code>filter()</code> method returns numbers greater than 10, and <code>find()</code> locates the first number divisible by 3, which is <code>36</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>find()</code> method in TypeScript is a powerful tool for searching through arrays to find the first element that meets a specified condition. It’s particularly useful when dealing with arrays of objects and when you need to locate a specific element quickly without iterating through the entire array. Just remember to handle cases where <code>undefined</code> is returned when no matching element is found.
    </p>
  </div>
  
}@case(52){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">findIndex Method in TypeScript</h1>
  
    <p>
      The <code>findIndex()</code> method in TypeScript is used to search an array for the first element that satisfies a given condition (test function) and returns the index of that element. If no elements match the condition, it returns <code>-1</code>. This method is helpful when you need to know the position of a particular element that matches the specified condition in an array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>findIndex()</code></h2>
  
    <p>
      The <code>findIndex()</code> method tests each element in the array with a callback function and returns the index of the first matching element. If none of the elements pass the test, it returns <code>-1</code>.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.findIndex((element, index, array) => &#123;<br />
          // return true or false based on condition<br />
        &#125;);
      </code>
    </pre>
  
    <p>
      The callback function for <code>findIndex()</code> takes three parameters:
    </p>
    <ul class="list-disc list-inside">
      <li><code>element</code> (required) - the current element being processed</li>
      <li><code>index</code> (optional) - the index of the current element</li>
      <li><code>array</code> (optional) - the original array being processed</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Basic Example of <code>findIndex()</code></h2>
  
    <p>
      Here is a simple example that uses the <code>findIndex()</code> method to find the index of the first even number in an array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 3, 5, 8, 10];<br />
        let firstEvenIndex = numbers.findIndex(num => num % 2 === 0);<br />
        console.log(firstEvenIndex); // Output: 3
      </code>
    </pre>
  
    <p>
      In this example, <code>findIndex()</code> returns <code>3</code> because <code>8</code> is the first even number in the array, and it is located at index <code>3</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Using <code>findIndex()</code> with Objects</h2>
  
    <p>
      The <code>findIndex()</code> method can also be used with arrays of objects. Here’s an example where we search for a user object based on a specific property (e.g., <code>age</code>).
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let users = [<br />
          &#123; name: 'John', age: 25 &#125;,<br />
          &#123; name: 'Jane', age: 30 &#125;,<br />
          &#123; name: 'Jack', age: 35 &#125;<br />
        ];<br />
        let userIndex = users.findIndex(user => user.age === 30);<br />
        console.log(userIndex); // Output: 1
      </code>
    </pre>
  
    <p>
      In this case, <code>findIndex()</code> returns <code>1</code> because the user with age <code>30</code> is located at index <code>1</code> in the array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Handling <code>-1</code> with <code>findIndex()</code></h2>
  
    <p>
      Since <code>findIndex()</code> returns <code>-1</code> if no element matches the condition, it’s important to handle this case to avoid errors.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 3, 5];<br />
        let firstEvenIndex = numbers.findIndex(num => num % 2 === 0);<br />
        if (firstEvenIndex !== -1) &#123;<br />
          console.log('First even number is at index:', firstEvenIndex);<br />
        &#125; else &#123;<br />
          console.log('No even number found');<br />
        &#125;
      </code>
    </pre>
  
    <p>
      In this example, since no even numbers exist in the array, <code>findIndex()</code> returns <code>-1</code>, and the condition ensures an appropriate message is logged.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Chaining <code>findIndex()</code> with Other Methods</h2>
  
    <p>
      The <code>findIndex()</code> method can be combined with other array methods like <code>filter()</code> or <code>map()</code>. Here’s an example where we first filter the array and then find the index of an element in the filtered result.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [4, 9, 16, 25, 36];<br />
        let index = numbers<br />
          .filter(num => num > 10)<br />
          .findIndex(num => num % 2 === 0);<br />
        console.log(index); // Output: 1
      </code>
    </pre>
  
    <p>
      In this example, <code>filter()</code> returns numbers greater than <code>10</code>, and then <code>findIndex()</code> finds the index of the first even number in the filtered array, which is <code>16</code>, at index <code>1</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>findIndex()</code> method in TypeScript is a powerful tool for locating the index of an element that meets a certain condition in an array. Whether you’re working with primitive values or complex objects, this method is efficient and easy to use. However, be mindful of cases where it returns <code>-1</code>, which indicates no matching element was found.
    </p>
  </div>
  
}@case(53){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">reduce Method in TypeScript</h1>
  
    <p>
      The <code>reduce()</code> method in TypeScript is used to iterate over an array and apply a reducer function on each element, which results in a single output value. It is one of the most powerful array methods that can accumulate values, flatten arrays, or transform data into any desired structure.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>reduce()</code></h2>
  
    <p>
      The <code>reduce()</code> method takes two arguments:
    </p>
  
    <ul class="list-disc list-inside">
      <li><code>callback</code> - A function to execute on each element in the array.</li>
      <li><code>initialValue</code> (optional) - The value to use as the first argument in the first call of the <code>callback</code>.</li>
    </ul>
  
    <p>The basic syntax looks like this:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.reduce((accumulator, currentValue, currentIndex, array) => &#123;<br />
          // reducer logic<br />
        &#125;, initialValue);
      </code>
    </pre>
  
    <p>The <code>callback</code> function parameters are:</p>
    <ul class="list-disc list-inside">
      <li><code>accumulator</code> (required) - Accumulates the result of each call.</li>
      <li><code>currentValue</code> (required) - The current element being processed.</li>
      <li><code>currentIndex</code> (optional) - The index of the current element.</li>
      <li><code>array</code> (optional) - The original array being reduced.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Example of Summing Numbers</h2>
  
    <p>
      A common use case of <code>reduce()</code> is summing all elements in an array. Here's an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        let sum = numbers.reduce((acc, curr) => acc + curr, 0);<br />
        console.log(sum); // Output: 15
      </code>
    </pre>
  
    <p>
      In this example, <code>reduce()</code> iterates over the array and adds each number to the accumulator, starting with an initial value of <code>0</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Flattening Arrays with <code>reduce()</code></h2>
  
    <p>
      The <code>reduce()</code> method is also useful for tasks like flattening arrays. Here's an example where a 2D array is flattened into a 1D array.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let nestedArray: number[][] = [[1, 2], [3, 4], [5]];<br />
        let flatArray = nestedArray.reduce((acc, curr) => acc.concat(curr), []);<br />
        console.log(flatArray); // Output: [1, 2, 3, 4, 5]
      </code>
    </pre>
  
    <p>
      In this case, <code>reduce()</code> concatenates each sub-array into a single array, starting with an empty array as the initial value.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Counting Occurrences with <code>reduce()</code></h2>
  
    <p>
      Another useful application of <code>reduce()</code> is counting occurrences of items in an array. Here’s how you can count the number of times each element appears in an array:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let fruits: string[] = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];<br />
        let fruitCount = fruits.reduce((acc, fruit) => &#123;<br />
          acc[fruit] = (acc[fruit] || 0) + 1;<br />
          return acc;<br />
        &#125;, &#123;&#125;);<br />
        console.log(fruitCount); // Output: &#123; apple: 3, banana: 2, orange: 1 &#125;
      </code>
    </pre>
  
    <p>
      This example demonstrates how to use <code>reduce()</code> to build an object where the keys are the array elements and the values are their counts.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Using <code>reduce()</code> with Objects</h2>
  
    <p>
      You can also use <code>reduce()</code> with arrays of objects. Here's an example that sums the total price of items in a shopping cart:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let cart = [<br />
          &#123; item: 'Book', price: 15 &#125;,<br />
          &#123; item: 'Pen', price: 3 &#125;,<br />
          &#123; item: 'Notebook', price: 7 &#125;<br />
        ];<br />
        let totalPrice = cart.reduce((acc, curr) => acc + curr.price, 0);<br />
        console.log(totalPrice); // Output: 25
      </code>
    </pre>
  
    <p>
      In this example, the <code>reduce()</code> method sums up the <code>price</code> property of each object in the array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>reduce()</code> method in TypeScript is extremely versatile and can be applied to a wide variety of use cases, from summing numbers to flattening arrays and counting occurrences. With its ability to accumulate values, <code>reduce()</code> can transform data in powerful ways.
    </p>
  </div>
  
}@case(54){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">reduceRight Method in TypeScript</h1>
  
    <p>
      The <code>reduceRight()</code> method in TypeScript is used to apply a function against an accumulator and each value of the array (from right to left) to reduce it to a single value. This is similar to the <code>reduce()</code> method but operates in reverse order.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>reduceRight()</code></h2>
  
    <p>
      The <code>reduceRight()</code> method takes two arguments:
    </p>
  
    <ul class="list-disc list-inside">
      <li><code>callback</code> - A function to execute on each element in the array, starting from the right-most element.</li>
      <li><code>initialValue</code> (optional) - The initial value for the accumulator.</li>
    </ul>
  
    <p>The basic syntax looks like this:</p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.reduceRight((accumulator, currentValue, currentIndex, array) => &#123;<br />
          // logic to apply<br />
        &#125;, initialValue);
      </code>
    </pre>
  
    <p>The <code>callback</code> function receives the following parameters:</p>
  
    <ul class="list-disc list-inside">
      <li><code>accumulator</code> (required) - Accumulates the return values of the function.</li>
      <li><code>currentValue</code> (required) - The current element being processed from right to left.</li>
      <li><code>currentIndex</code> (optional) - The index of the current element.</li>
      <li><code>array</code> (optional) - The original array being reduced.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Example of Reversing a String</h2>
  
    <p>
      One common use case of <code>reduceRight()</code> is to reverse a string by reducing an array of characters:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let str = 'hello';<br />
        let reversed = str.split('').reduceRight((acc, curr) => acc + curr, '');<br />
        console.log(reversed); // Output: 'olleh'
      </code>
    </pre>
  
    <p>
      In this example, <code>reduceRight()</code> processes the array of characters from the right-most element and accumulates them in reverse order.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Summing Numbers in Reverse</h2>
  
    <p>
      Here's an example of using <code>reduceRight()</code> to sum an array of numbers, starting from the last element:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers: number[] = [1, 2, 3, 4, 5];<br />
        let sum = numbers.reduceRight((acc, curr) => acc + curr, 0);<br />
        console.log(sum); // Output: 15
      </code>
    </pre>
  
    <p>
      Although the result is the same as using <code>reduce()</code>, the accumulation starts from the last element, i.e., 5, and proceeds toward the first element.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Flattening Arrays in Reverse</h2>
  
    <p>
      You can use <code>reduceRight()</code> to flatten nested arrays starting from the last sub-array:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let nestedArray: number[][] = [[1, 2], [3, 4], [5]];<br />
        let flatArray = nestedArray.reduceRight((acc, curr) => acc.concat(curr), []);<br />
        console.log(flatArray); // Output: [5, 3, 4, 1, 2]
      </code>
    </pre>
  
    <p>
      In this case, the nested arrays are flattened in reverse order, starting with the last sub-array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Processing Objects with <code>reduceRight()</code></h2>
  
    <p>
      Like <code>reduce()</code>, the <code>reduceRight()</code> method can be applied to arrays of objects. For example, we can calculate the total price of items in a shopping cart, starting from the last item:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let cart = [<br />
          &#123; item: 'Book', price: 15 &#125;,<br />
          &#123; item: 'Pen', price: 3 &#125;,<br />
          &#123; item: 'Notebook', price: 7 &#125;<br />
        ];<br />
        let totalPrice = cart.reduceRight((acc, curr) => acc + curr.price, 0);<br />
        console.log(totalPrice); // Output: 25
      </code>
    </pre>
  
    <p>
      This example demonstrates how to use <code>reduceRight()</code> to accumulate the price starting from the last item in the cart.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>reduceRight()</code> method in TypeScript is similar to <code>reduce()</code>, but it processes elements from right to left. It is useful for scenarios where the order of processing is significant, such as reversing strings, summing numbers in reverse, or flattening nested arrays from the right.
    </p>
  </div>
  
}@case(55){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">sort() Method in TypeScript</h1>
  
    <p>
      The <code>sort()</code> method in TypeScript is used to sort the elements of an array in place and returns the sorted array. The default sorting order is based on converting the elements into strings and comparing their sequences of UTF-16 code units.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>sort()</code></h2>
  
    <p>
      The <code>sort()</code> method can be used with or without a compare function. Its syntax is:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.sort([compareFunction]);
      </code>
    </pre>
  
    <p>
      The <code>compareFunction</code> is optional and defines the sort order. If omitted, the array elements are converted to strings and sorted in ascending Unicode code point order.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Sorting Numbers</h2>
  
    <p>
      By default, <code>sort()</code> treats elements as strings, which may cause unexpected results when sorting numbers. To sort numbers correctly, a <code>compareFunction</code> should be provided:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [40, 100, 1, 5, 25, 10];<br />
        numbers.sort((a, b) => a - b);<br />
        console.log(numbers); // Output: [1, 5, 10, 25, 40, 100]
      </code>
    </pre>
  
    <p>
      The <code>compareFunction</code> takes two arguments, <code>a</code> and <code>b</code>, and returns:
    </p>
  
    <ul class="list-disc list-inside">
      <li>A negative value if <code>a</code> should come before <code>b</code>.</li>
      <li>A positive value if <code>a</code> should come after <code>b</code>.</li>
      <li><code>0</code> if they are equal.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Sorting Strings</h2>
  
    <p>
      When sorting strings, the <code>sort()</code> method sorts in ascending order by default. However, to sort in descending order, you can provide a compare function:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let fruits = ['Banana', 'Apple', 'Orange', 'Mango'];<br />
        fruits.sort();<br />
        console.log(fruits); // Output: ['Apple', 'Banana', 'Mango', 'Orange']<br /><br />
        
        fruits.sort((a, b) => b.localeCompare(a));<br />
        console.log(fruits); // Output: ['Orange', 'Mango', 'Banana', 'Apple']
      </code>
    </pre>
  
    <p>
      The <code>localeCompare()</code> method can also be used within the <code>sort()</code> method for locale-aware sorting.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Sorting Objects by Property</h2>
  
    <p>
      To sort an array of objects by a specific property, you need to provide a compare function that compares the values of that property:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let students = [<br />
          &#123; name: 'John', age: 21 &#125;,<br />
          &#123; name: 'Emma', age: 19 &#125;,<br />
          &#123; name: 'Alex', age: 25 &#125;<br />
        ];<br /><br />
        
        students.sort((a, b) => a.age - b.age);<br />
        console.log(students);<br />
        // Output: [&#123; name: 'Emma', age: 19 &#125;, &#123; name: 'John', age: 21 &#125;, &#123; name: 'Alex', age: 25 &#125;]
      </code>
    </pre>
  
    <p>
      In this example, we are sorting the students by their age in ascending order.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Case-Insensitive Sorting</h2>
  
    <p>
      By default, <code>sort()</code> is case-sensitive, meaning capitalized letters come before lowercase letters. You can perform case-insensitive sorting by converting strings to lowercase:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let words = ['apple', 'Banana', 'orange', 'Mango'];<br />
        words.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));<br />
        console.log(words);<br />
        // Output: ['apple', 'Banana', 'Mango', 'orange']
      </code>
    </pre>
  
    <p>
      The <code>toLowerCase()</code> method ensures that the sorting is case-insensitive.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Sorting with <code>undefined</code> Values</h2>
  
    <p>
      When sorting arrays that contain <code>undefined</code> values, <code>undefined</code> is treated as the largest possible value. Here's an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let mixedArray = [5, undefined, 2, 8, undefined, 3];<br />
        mixedArray.sort();<br />
        console.log(mixedArray); // Output: [2, 3, 5, 8, undefined, undefined]
      </code>
    </pre>
  
    <p>
      If you want <code>undefined</code> values to appear at the beginning of the array, you can provide a custom compare function:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        mixedArray.sort((a, b) => (a === undefined ? -1 : b === undefined ? 1 : a - b));<br />
        console.log(mixedArray);<br />
        // Output: [undefined, undefined, 2, 3, 5, 8]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Conclusion</h2>
  
    <p>
      The <code>sort()</code> method in TypeScript is a powerful way to organize arrays, whether you’re working with numbers, strings, or objects. By using custom compare functions, you can implement sorting logic that fits your needs. It's important to understand how sorting works with different types, especially strings and objects, and how case sensitivity and <code>undefined</code> values affect the result.
    </p>
  </div>
  
}@case(56){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">reverse() Method in TypeScript</h1>
  
    <p>
      The <code>reverse()</code> method in TypeScript is used to reverse the elements of an array in place. This method modifies the original array and returns the reversed array. It's a simple and useful method for reversing the order of elements in any array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>reverse()</code></h2>
  
    <p>
      The <code>reverse()</code> method does not take any arguments and its syntax is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.reverse();
      </code>
    </pre>
  
    <p>
      This method operates on the array itself and returns the modified array, with its elements reversed.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Example: Reversing an Array of Numbers</h2>
  
    <p>
      Let’s look at an example where we reverse an array of numbers:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [1, 2, 3, 4, 5];<br />
        numbers.reverse();<br />
        console.log(numbers); // Output: [5, 4, 3, 2, 1]
      </code>
    </pre>
  
    <p>
      As shown, the <code>reverse()</code> method reverses the elements of the array and modifies the original array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Reversing an Array of Strings</h2>
  
    <p>
      The <code>reverse()</code> method works just as well with arrays of strings. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let fruits = ['Apple', 'Banana', 'Cherry'];<br />
        fruits.reverse();<br />
        console.log(fruits); // Output: ['Cherry', 'Banana', 'Apple']
      </code>
    </pre>
  
    <p>
      The string elements are also reversed, maintaining the functionality of reversing the order of elements in any array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Reversing an Array of Objects</h2>
  
    <p>
      You can also use <code>reverse()</code> to reverse an array of objects. Here’s an example of reversing a list of student objects:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let students = [<br />
          &#123; name: 'John', age: 20 &#125;,<br />
          &#123; name: 'Alice', age: 22 &#125;,<br />
          &#123; name: 'Bob', age: 25 &#125;<br />
        ];<br /><br />
        students.reverse();<br />
        console.log(students);<br />
        // Output: [&#123; name: 'Bob', age: 25 &#125;, &#123; name: 'Alice', age: 22 &#125;, &#123; name: 'John', age: 20 &#125;]
      </code>
    </pre>
  
    <p>
      The array of objects is reversed in the same way as arrays of numbers or strings.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Considerations when Using <code>reverse()</code></h2>
  
    <p>
      There are a few important considerations to keep in mind when using the <code>reverse()</code> method:
    </p>
  
    <ul class="list-disc list-inside">
      <li>The <code>reverse()</code> method modifies the original array in place. If you want to keep the original array intact, you should first create a copy of the array and then reverse the copy.</li>
      <li>Reversing an already reversed array will return it to its original order.</li>
    </ul>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [1, 2, 3, 4, 5];<br />
        let reversedNumbers = numbers.reverse();<br />
        reversedNumbers.reverse();<br />
        console.log(reversedNumbers); // Output: [1, 2, 3, 4, 5]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Using <code>reverse()</code> with <code>sort()</code></h2>
  
    <p>
      A common use case is to first sort an array and then reverse the sorted array. Here’s an example where we sort an array of numbers in ascending order, then reverse it to get a descending order:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [10, 5, 8, 3, 2];<br />
        numbers.sort((a, b) => a - b);<br />
        console.log(numbers); // Output: [2, 3, 5, 8, 10]<br /><br />
        
        numbers.reverse();<br />
        console.log(numbers); // Output: [10, 8, 5, 3, 2]
      </code>
    </pre>
  
    <p>
      Combining <code>sort()</code> and <code>reverse()</code> allows for powerful sorting and reordering of elements.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Conclusion</h2>
  
    <p>
      The <code>reverse()</code> method in TypeScript is a straightforward and effective way to reverse the order of elements in an array. Whether you’re working with numbers, strings, or objects, this method provides a simple and efficient solution for reversing arrays.
    </p>
  </div>
  
}@case(57){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">push() Method in TypeScript</h1>
  
    <p>
      The <code>push()</code> method in TypeScript is used to add one or more elements to the end of an array. This method modifies the original array and returns the new length of the array after the elements have been added. It’s a simple yet powerful method for managing arrays.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>push()</code></h2>
  
    <p>
      The <code>push()</code> method takes one or more elements as arguments and its syntax is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        array.push(element1, element2, ...);
      </code>
    </pre>
  
    <p>
      The method modifies the original array and returns the new length of the array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Example: Adding Elements to an Array</h2>
  
    <p>
      Let’s look at an example where we add elements to an array of numbers:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [1, 2, 3];<br />
        numbers.push(4, 5);<br />
        console.log(numbers); // Output: [1, 2, 3, 4, 5]
      </code>
    </pre>
  
    <p>
      As shown, the <code>push()</code> method adds the elements <code>4</code> and <code>5</code> to the end of the array.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Adding Elements of Different Types</h2>
  
    <p>
      The <code>push()</code> method can be used to add elements of different types to an array. Here’s an example with an array of mixed types:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let mixedArray = [1, 'two', true];<br />
        mixedArray.push(3.14, 'four');<br />
        console.log(mixedArray); // Output: [1, 'two', true, 3.14, 'four']
      </code>
    </pre>
  
    <p>
      The <code>push()</code> method allows adding various data types seamlessly.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>push()</code> with Objects</h2>
  
    <p>
      You can also use <code>push()</code> to add objects to an array. Here’s an example of adding student objects to an array:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let students = [];<br />
        students.push(&#123; name: 'John', age: 20 &#125;);<br />
        students.push(&#123; name: 'Alice', age: 22 &#125;);<br />
        console.log(students);<br />
        // Output: [&#123; name: 'John', age: 20 &#125;, &#123; name: 'Alice', age: 22 &#125;]
      </code>
    </pre>
  
    <p>
      In this case, we created an array of student objects by using the <code>push()</code> method.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Chaining <code>push()</code> Method Calls</h2>
  
    <p>
      You can also chain multiple <code>push()</code> calls together. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let colors = ['red'];<br />
        colors.push('green').push('blue');<br />
        console.log(colors); // Output: ['red', 'green', 'blue']
      </code>
    </pre>
  
    <p>
      Chaining allows for concise and efficient code.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Considerations when Using <code>push()</code></h2>
  
    <p>
      There are a few important considerations when using the <code>push()</code> method:
    </p>
  
    <ul class="list-disc list-inside">
      <li>The <code>push()</code> method modifies the original array. If you need to keep the original array intact, consider creating a copy first.</li>
      <li>You can push multiple elements at once, separated by commas.</li>
      <li>The method returns the new length of the array, which can be useful for further operations.</li>
    </ul>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [1, 2, 3];<br />
        let newLength = numbers.push(4);<br />
        console.log(newLength); // Output: 4
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Conclusion</h2>
  
    <p>
      The <code>push()</code> method in TypeScript is a fundamental way to add elements to an array. Its versatility allows for adding different data types and objects, making it a valuable tool for any TypeScript developer. By understanding how to effectively use the <code>push()</code> method, you can enhance your array manipulation capabilities.
    </p>
  </div>
  
}@case(58){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">pop() Method in TypeScript</h1>
  
    <p>
      The <code>pop()</code> method in TypeScript is used to remove the last element from an array. This method modifies the original array and returns the removed element. If the array is empty, it returns <code>undefined</code>. It’s a straightforward method for managing arrays and is widely used in TypeScript development.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Syntax of <code>pop()</code></h2>
  
    <p>
      The syntax of the <code>pop()</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let removedElement = array.pop();
      </code>
    </pre>
  
    <p>
      The method modifies the original array and returns the element that was removed.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Example: Removing an Element from an Array</h2>
  
    <p>
      Let’s look at an example where we remove the last element from an array of numbers:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [1, 2, 3, 4, 5];<br />
        let lastElement = numbers.pop();<br />
        console.log(lastElement); // Output: 5<br />
        console.log(numbers); // Output: [1, 2, 3, 4]
      </code>
    </pre>
  
    <p>
      As shown, the <code>pop()</code> method removes the last element <code>5</code> from the array and returns it.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Removing Elements from an Empty Array</h2>
  
    <p>
      If the <code>pop()</code> method is called on an empty array, it will return <code>undefined</code>. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let emptyArray = [];<br />
        let removedElement = emptyArray.pop();<br />
        console.log(removedElement); // Output: undefined
      </code>
    </pre>
  
    <p>
      In this case, since the array is empty, the returned value is <code>undefined</code>.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>pop()</code> in a Loop</h2>
  
    <p>
      The <code>pop()</code> method can be used in a loop to remove all elements from an array. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let items = ['apple', 'banana', 'cherry'];<br />
        while (items.length > 0) {{'{'}}<br />
          console.log(items.pop());<br />
        {{'}'}}<br />
        // Output: cherry, banana, apple
      </code>
    </pre>
  
    <p>
      This example demonstrates how to continuously remove elements until the array is empty.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Considerations when Using <code>pop()</code></h2>
  
    <p>
      There are a few important considerations when using the <code>pop()</code> method:
    </p>
  
    <ul class="list-disc list-inside">
      <li>The <code>pop()</code> method modifies the original array. If you need to keep the original array intact, consider creating a copy first.</li>
      <li>The method returns the removed element, which can be useful for further operations.</li>
      <li>Using <code>pop()</code> on an empty array returns <code>undefined</code>, so it’s good practice to check the array length before using it if you are unsure.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>pop()</code> method in TypeScript is a fundamental way to remove the last element from an array. Its simplicity and effectiveness make it a valuable tool for managing arrays in TypeScript development. By understanding how to effectively use the <code>pop()</code> method, you can enhance your array manipulation capabilities and streamline your code.
    </p>
  </div>
  
}@case(59){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Object Methods in TypeScript</h1>
  
    <p>
      In TypeScript, objects are a fundamental building block of the language, allowing you to group related data and functionality. Object methods are functions that are properties of objects, enabling you to manipulate object data efficiently. This article explores the various object methods available in TypeScript, along with examples and best practices.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Creating an Object</h2>
  
    <p>
      Before diving into object methods, let’s first understand how to create an object in TypeScript. You can create an object using either object literals or the <code>new</code> keyword.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        // Object Literal<br />
        let person = &#123;<br />
        &nbsp;&nbsp;name: 'Alice',<br />
        &nbsp;&nbsp;age: 30,<br />
        &nbsp;&nbsp;greet: function() &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;console.log(`Hello, my name is $&#123;this.name&#125;`);<br />
        &nbsp;&nbsp;&#125;<br />
        &#125;<br /><br />
        
        // Using Constructor<br />
        class Animal &#123;<br />
        &nbsp;&nbsp;constructor(public name: string) &#123;<br />
        &nbsp;&nbsp;&#125;<br />
        &nbsp;&nbsp;makeSound() &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;console.log(`$&#123;this.name&#125; makes a sound!`);<br />
        &nbsp;&nbsp;&#125;<br />
        &#125;<br />
        
        let dog = new Animal('Buddy');<br />
        dog.makeSound(); // Output: Buddy makes a sound!
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Common Object Methods</h2>
  
    <p>
      TypeScript allows you to define methods within objects. Here are some common object methods:
    </p>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">2.1 <code>Object.keys()</code></h3>
  
    <p>
      The <code>Object.keys()</code> method returns an array of a given object's own property names. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: 'Alice', age: 30 &#125;;<br />
        let keys = Object.keys(person);<br />
        console.log(keys); // Output: ['name', 'age']
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">2.2 <code>Object.values()</code></h3>
  
    <p>
      The <code>Object.values()</code> method returns an array of a given object's own property values:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let values = Object.values(person);<br />
        console.log(values); // Output: ['Alice', 30]
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">2.3 <code>Object.entries()</code></h3>
  
    <p>
      The <code>Object.entries()</code> method returns an array of a given object's own enumerable string-keyed property [key, value] pairs:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let entries = Object.entries(person);<br />
        console.log(entries); // Output: [['name', 'Alice'], ['age', 30]]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Adding and Modifying Object Methods</h2>
  
    <p>
      You can add or modify methods of an object at any time. Here’s how to do it:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        person.sayAge = function() &#123;<br />
        &nbsp;&nbsp;console.log(`I am $&#123;this.age&#125; years old`);<br />
        &#125;;<br />
        
        person.sayAge(); // Output: I am 30 years old
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Object Destructuring</h2>
  
    <p>
      Object destructuring is a powerful feature in TypeScript that allows you to extract properties from objects into variables. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const &#123; name, age &#125; = person;<br />
        console.log(name); // Output: Alice<br />
        console.log(age); // Output: 30
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Conclusion</h2>
  
    <p>
      Object methods in TypeScript provide a powerful way to organize and manipulate data. Understanding these methods, such as <code>Object.keys()</code>, <code>Object.values()</code>, and <code>Object.entries()</code>, enhances your ability to work with complex data structures. By leveraging object methods and features like destructuring, you can write cleaner and more efficient code in TypeScript.
    </p>
  </div>
  
}@case(60){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Keys Methods in TypeScript</h1>
  
    <p>
      In TypeScript, the concept of keys is crucial for accessing properties of objects. Understanding how to use key methods allows you to manipulate and interact with objects effectively. This article explores the various key methods in TypeScript, including examples and best practices.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Understanding Keys in TypeScript</h2>
  
    <p>
      Keys in TypeScript refer to the property names of objects. These keys can be used to access the corresponding values. In TypeScript, keys can be either strings or numbers, and they are often defined using interfaces or types.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Using <code>Object.keys()</code> Method</h2>
  
    <p>
      The <code>Object.keys()</code> method returns an array of a given object's own property names, in the same order as we get with a standard loop. This method is particularly useful when you need to iterate over the properties of an object.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: 'Alice', age: 30, city: 'Wonderland' &#125;;<br />
        let keys = Object.keys(person);<br />
        console.log(keys); // Output: ['name', 'age', 'city']
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Using <code>Object.values()</code> Method</h2>
  
    <p>
      While <code>Object.keys()</code> retrieves the keys, the <code>Object.values()</code> method returns an array of a given object's own property values, providing a way to get the values corresponding to those keys.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let values = Object.values(person);<br />
        console.log(values); // Output: ['Alice', 30, 'Wonderland']
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using <code>Object.entries()</code> Method</h2>
  
    <p>
      The <code>Object.entries()</code> method returns an array of a given object's own enumerable string-keyed property [key, value] pairs, making it easy to access both keys and values.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let entries = Object.entries(person);<br />
        console.log(entries); // Output: [['name', 'Alice'], ['age', 30], ['city', 'Wonderland']]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Example: Iterating Over Keys</h2>
  
    <p>
      You can use the <code>Object.keys()</code> method in combination with the <code>forEach</code> loop to iterate over the properties of an object easily.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.keys(person).forEach(key => &#123;<br />
        &nbsp;&nbsp;console.log(`$&#123;key&#125;: $&#123;person[key]&#125;`);<br />
        &#125;);<br />
        // Output: <br />
        // name: Alice<br />
        // age: 30<br />
        // city: Wonderland
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      Understanding and utilizing key methods in TypeScript, such as <code>Object.keys()</code>, <code>Object.values()</code>, and <code>Object.entries()</code>, empowers developers to work effectively with object data. By leveraging these methods, you can write cleaner, more efficient code and manipulate objects with ease.
    </p>
  </div>
  
}@case(61){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Values Methods in TypeScript</h1>
  
    <p>
      In TypeScript, understanding how to work with values in objects and collections is essential for effective data manipulation. This article explores various methods related to values in TypeScript, including practical examples and usage tips.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Values in TypeScript</h2>
  
    <p>
      Values in TypeScript can be of various types, including primitive types (like numbers, strings, and booleans) and complex types (like objects and arrays). Manipulating these values efficiently is key to effective programming in TypeScript.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Using <code>Object.values()</code> Method</h2>
  
    <p>
      The <code>Object.values()</code> method returns an array of a given object's own property values. This method is particularly useful when you need to access the values of an object without needing to know its keys.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: 'Alice', age: 30, city: 'Wonderland' &#125;;<br />
        let values = Object.values(person);<br />
        console.log(values); // Output: ['Alice', 30, 'Wonderland']
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example: Summing Numeric Values</h2>
  
    <p>
      You can use the <code>Object.values()</code> method to sum numeric values in an object. Here’s a simple example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let scores = &#123; math: 90, science: 85, english: 88 &#125;;<br />
        let totalScore = Object.values(scores).reduce((sum, score) => sum + score, 0);<br />
        console.log(totalScore); // Output: 263
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using Values in Arrays</h2>
  
    <p>
      When working with arrays, you can also manipulate values using methods such as <code>map()</code>, <code>filter()</code>, and <code>reduce()</code>. Here’s an example of how to use the <code>map()</code> method to create a new array from an existing one:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let numbers = [1, 2, 3, 4];<br />
        let doubled = numbers.map(num => num * 2);<br />
        console.log(doubled); // Output: [2, 4, 6, 8]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Filtering Values in an Array</h2>
  
    <p>
      You can also filter values in an array using the <code>filter()</code> method. Here’s how to filter out numbers greater than 2:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let filtered = numbers.filter(num => num > 2);<br />
        console.log(filtered); // Output: [3, 4]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      Mastering values methods in TypeScript, particularly <code>Object.values()</code> and array manipulation methods, is crucial for efficient data handling and programming. By leveraging these methods, you can write cleaner, more effective code and manipulate data structures with ease.
    </p>
  </div>
  
}@case(62){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Entries Methods in TypeScript</h1>
  
    <p>
      In TypeScript, the concept of entries is fundamental when working with objects. This article explores the various methods related to entries, particularly the <code>Object.entries()</code> method, and provides practical examples of its usage.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Entries in TypeScript</h2>
  
    <p>
      Entries in TypeScript refer to key-value pairs within objects. Understanding how to retrieve and manipulate these entries is crucial for effective data management and interaction in applications.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Using <code>Object.entries()</code> Method</h2>
  
    <p>
      The <code>Object.entries()</code> method returns an array of a given object's own enumerable string-keyed property [key, value] pairs. This method is particularly useful for iterating over an object’s properties and accessing both keys and values.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: 'Alice', age: 30, city: 'Wonderland' &#125;;<br />
        let entries = Object.entries(person);<br />
        console.log(entries); // Output: [['name', 'Alice'], ['age', 30], ['city', 'Wonderland']]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Iterating Over Entries</h2>
  
    <p>
      You can easily iterate over the entries of an object using the <code>forEach</code> method on the array returned by <code>Object.entries()</code>. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.entries(person).forEach(([key, value]) => &#123;<br />
        &nbsp;&nbsp;console.log(`$&#123;key&#125;: $&#123;value&#125;`);<br />
        &#125;);<br />
        // Output:<br />
        // name: Alice<br />
        // age: 30<br />
        // city: Wonderland
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Converting Entries Back to Object</h2>
  
    <p>
      After manipulating entries, you might want to convert them back into an object. You can achieve this using the <code>Object.fromEntries()</code> method. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let modifiedEntries = entries.map(([key, value]) => [key, value.toString()]);<br />
        let modifiedPerson = Object.fromEntries(modifiedEntries);<br />
        console.log(modifiedPerson); // Output: &#123; name: 'Alice', age: '30', city: 'Wonderland' &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Example: Filtering Entries</h2>
  
    <p>
      You can also filter entries based on certain criteria. For instance, to get entries where the value is a string, you can do the following:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let stringEntries = Object.entries(person).filter(([key, value]) => typeof value === 'string');<br />
        console.log(stringEntries); // Output: [['name', 'Alice'], ['city', 'Wonderland']]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      Mastering entries methods in TypeScript, especially <code>Object.entries()</code> and its associated functionalities, enables developers to efficiently manage object properties. By understanding how to work with entries, you can enhance your coding practices and streamline data handling in your applications.
    </p>
  </div>
  
}@case(63){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Assign Methods in TypeScript</h1>
  
    <p>
      In TypeScript, the <code>Object.assign()</code> method is a crucial utility for merging objects or copying values from one or more source objects to a target object. This article will explore the functionality of the <code>Object.assign()</code> method and provide practical examples to illustrate its usage.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Object.assign()</h2>
  
    <p>
      The <code>Object.assign()</code> method is a built-in function that allows developers to copy properties from one or more source objects to a target object. If the target object already contains properties with the same keys as the source, the values from the source objects will overwrite the target object's properties.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Syntax of Object.assign()</h2>
  
    <p>
      The syntax of the <code>Object.assign()</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.assign(target, ...sources);
      </code>
    </pre>
  
    <p>
      - <code>target</code>: The target object to which properties will be copied.<br />
      - <code>...sources</code>: One or more source objects from which properties will be copied.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Object.assign()</h2>
  
    <p>
      Below is a simple example demonstrating how to use the <code>Object.assign()</code> method to copy properties from one object to another:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let target = &#123; a: 1, b: 2 &#125;;<br />
        let source = &#123; b: 3, c: 4 &#125;;<br />
        let returnedTarget = Object.assign(target, source);<br />
        console.log(returnedTarget); // Output: &#123; a: 1, b: 3, c: 4 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Merging Multiple Objects</h2>
  
    <p>
      The <code>Object.assign()</code> method can also merge multiple source objects into a single target object. Here’s how it works:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let target = &#123; a: 1 &#125;;<br />
        let source1 = &#123; b: 2 &#125;;<br />
        let source2 = &#123; c: 3, d: 4 &#125;;<br />
        Object.assign(target, source1, source2);<br />
        console.log(target); // Output: &#123; a: 1, b: 2, c: 3, d: 4 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Handling Property Overwrites</h2>
  
    <p>
      If multiple source objects have properties with the same keys, the last one specified will overwrite the previous ones. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let obj1 = &#123; a: 1, b: 2 &#125;;<br />
        let obj2 = &#123; b: 3, c: 4 &#125;;<br />
        let obj3 = &#123; c: 5, d: 6 &#125;;<br />
        Object.assign(obj1, obj2, obj3);<br />
        console.log(obj1); // Output: &#123; a: 1, b: 3, c: 5, d: 6 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Cloning Objects with Object.assign()</h2>
  
    <p>
      The <code>Object.assign()</code> method can also be used to create a shallow copy of an object. Here's an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let original = &#123; a: 1, b: 2 &#125;;<br />
        let clone = Object.assign(&#123;&#125;, original);<br />
        console.log(clone); // Output: &#123; a: 1, b: 2 &#125;<br />
        clone.a = 5;<br />
        console.log(original.a); // Output: 1 (original is unchanged)
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Conclusion</h2>
  
    <p>
      The <code>Object.assign()</code> method in TypeScript is a powerful tool for merging and cloning objects. By understanding how to effectively use this method, developers can manage object properties more efficiently in their applications.
    </p>
  </div>
  
}@case(64){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Spread Methods in TypeScript</h1>
  
    <p>
      The spread operator in TypeScript, represented by three dots (<code>...</code>), allows for an elegant way to expand iterable objects such as arrays and objects into individual elements or properties. This article explores the functionality of the spread operator and provides practical examples to illustrate its usage.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to the Spread Operator</h2>
  
    <p>
      The spread operator is a powerful feature in TypeScript that simplifies array and object manipulations. It is particularly useful for combining arrays, copying them, and creating new objects by merging existing ones.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Using the Spread Operator with Arrays</h2>
  
    <p>
      The spread operator can be used to expand an array into individual elements. Here’s a simple example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let array1 = &#123;1, 2, 3&#125;;<br />
        let array2 = &#123;...array1, 4, 5&#125;;<br />
        console.log(array2); // Output: [1, 2, 3, 4, 5]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Copying Arrays</h2>
  
    <p>
      You can create a shallow copy of an array using the spread operator. This is particularly useful to avoid modifying the original array:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let originalArray = &#123;1, 2, 3&#125;;<br />
        let copiedArray = &#123;...originalArray&#125;;<br />
        console.log(copiedArray); // Output: [1, 2, 3]<br />
        copiedArray.push(4);<br />
        console.log(originalArray); // Output: [1, 2, 3] (original is unchanged)
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Using the Spread Operator with Objects</h2>
  
    <p>
      The spread operator is also applicable to objects, allowing you to merge properties from multiple objects or create copies of objects. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let obj1 = &#123; a: 1, b: 2 &#125;;<br />
        let obj2 = &#123; b: 3, c: 4 &#125;;<br />
        let mergedObject = &#123;...obj1, ...obj2&#125;;<br />
        console.log(mergedObject); // Output: &#123; a: 1, b: 3, c: 4 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Combining Arrays</h2>
  
    <p>
      The spread operator is useful for combining multiple arrays into one. Here’s how it works:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let arr1 = &#123;1, 2&#125;;<br />
        let arr2 = &#123;3, 4&#125;;<br />
        let combinedArray = &#123;...arr1, ...arr2&#125;;<br />
        console.log(combinedArray); // Output: [1, 2, 3, 4]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Function Calls with Spread Operator</h2>
  
    <p>
      You can use the spread operator to pass elements of an array as arguments to a function. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        function add(a, b, c) &#123;<br />
        &nbsp;&nbsp;return a + b + c;<br />
        &#125;;<br />
        let numbers = &#123;1, 2, 3&#125;;<br />
        console.log(add(...numbers)); // Output: 6
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">7. Conclusion</h2>
  
    <p>
      The spread operator in TypeScript is an essential feature for efficient array and object manipulation. By mastering the spread operator, developers can write cleaner, more concise code when dealing with iterable objects in their applications.
    </p>
  </div>
  
}@case(65){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Object.keys Methods in TypeScript</h1>
  
    <p>
      The <code>Object.keys()</code> method in TypeScript is a powerful utility for retrieving the keys of an object as an array of strings. This article will explore how to use <code>Object.keys()</code>, along with practical examples to illustrate its functionality.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Object.keys()</h2>
  
    <p>
      The <code>Object.keys()</code> method is part of the Object class in JavaScript and TypeScript. It returns an array containing the names of the object's own enumerable properties. This method is particularly useful for iterating over object keys when performing various operations on the object.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Syntax of Object.keys()</h2>
  
    <p>
      The syntax of the <code>Object.keys()</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.keys(obj);
      </code>
    </pre>
  
    <p>
      - <code>obj</code>: The object from which you want to retrieve the keys.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Object.keys()</h2>
  
    <p>
      Below is a simple example demonstrating how to use the <code>Object.keys()</code> method:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: "Alice", age: 30, city: "New York" &#125;;<br />
        let keys = Object.keys(person);<br />
        console.log(keys); // Output: ["name", "age", "city"]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Iterating Over Object Keys</h2>
  
    <p>
      The <code>Object.keys()</code> method can be used in conjunction with other methods to iterate over an object's properties. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let car = &#123; make: "Toyota", model: "Corolla", year: 2020 &#125;;<br />
        Object.keys(car).forEach(key => &#123;<br />
        &nbsp;&nbsp;console.log(key + ": " + car[key]);<br />
        &#125;);<br />
        // Output:<br />
        // make: Toyota<br />
        // model: Corolla<br />
        // year: 2020
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Practical Use Cases</h2>
  
    <p>
      The <code>Object.keys()</code> method is useful in many scenarios, such as:
    </p>
    <ul class="list-disc ml-5">
      <li>Validating object properties</li>
      <li>Creating dynamic forms based on object keys</li>
      <li>Transforming objects into arrays for data processing</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>Object.keys()</code> method in TypeScript is a vital tool for working with object properties. By understanding how to effectively use this method, developers can manipulate and access object data with greater ease and efficiency.
    </p>
  </div>
  
}@case(66){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Object.values Methods in TypeScript</h1>
  
    <p>
      The <code>Object.values()</code> method in TypeScript is a powerful utility that retrieves the values of an object as an array. This article will explore how to use <code>Object.values()</code>, along with practical examples to illustrate its functionality.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Object.values()</h2>
  
    <p>
      The <code>Object.values()</code> method is part of the Object class in JavaScript and TypeScript. It returns an array containing the values of the object's own enumerable properties. This method is particularly useful for accessing and processing the values stored in an object.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Syntax of Object.values()</h2>
  
    <p>
      The syntax of the <code>Object.values()</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.values(obj);
      </code>
    </pre>
  
    <p>
      - <code>obj</code>: The object from which you want to retrieve the values.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Object.values()</h2>
  
    <p>
      Below is a simple example demonstrating how to use the <code>Object.values()</code> method:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: "Alice", age: 30, city: "New York" &#125;;<br />
        let values = Object.values(person);<br />
        console.log(values); // Output: ["Alice", 30, "New York"]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Iterating Over Object Values</h2>
  
    <p>
      The <code>Object.values()</code> method can be used in conjunction with other methods to iterate over an object's values. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let car = &#123; make: "Toyota", model: "Corolla", year: 2020 &#125;;<br />
        Object.values(car).forEach(value => &#123;<br />
        &nbsp;&nbsp;console.log(value);<br />
        &#125;);<br />
        // Output:<br />
        // Toyota<br />
        // Corolla<br />
        // 2020
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Practical Use Cases</h2>
  
    <p>
      The <code>Object.values()</code> method is useful in many scenarios, such as:
    </p>
    <ul class="list-disc ml-5">
      <li>Validating object values</li>
      <li>Transforming objects into arrays for data processing</li>
      <li>Filtering or searching values within objects</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>Object.values()</code> method in TypeScript is a vital tool for working with object values. By understanding how to effectively use this method, developers can manipulate and access object data with greater ease and efficiency.
    </p>
  </div>
  
}@case(67){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Object.entries Methods in TypeScript</h1>
  
    <p>
      The <code>Object.entries()</code> method in TypeScript is a useful utility for retrieving the key-value pairs of an object as an array of arrays. This article will explore how to use <code>Object.entries()</code>, along with practical examples to illustrate its functionality.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Object.entries()</h2>
  
    <p>
      The <code>Object.entries()</code> method is part of the Object class in JavaScript and TypeScript. It returns an array of a given object's own enumerable string-keyed property [key, value] pairs. This method is particularly useful for iterating over object properties and accessing both keys and values simultaneously.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Syntax of Object.entries()</h2>
  
    <p>
      The syntax of the <code>Object.entries()</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.entries(obj);
      </code>
    </pre>
  
    <p>
      - <code>obj</code>: The object from which you want to retrieve the entries.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Object.entries()</h2>
  
    <p>
      Below is a simple example demonstrating how to use the <code>Object.entries()</code> method:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let person = &#123; name: "Alice", age: 30, city: "New York" &#125;;<br />
        let entries = Object.entries(person);<br />
        console.log(entries); // Output: [["name", "Alice"], ["age", 30], ["city", "New York"]]
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Iterating Over Object Entries</h2>
  
    <p>
      The <code>Object.entries()</code> method can be used in conjunction with other methods to iterate over an object's entries. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let car = &#123; make: "Toyota", model: "Corolla", year: 2020 &#125;;<br />
        Object.entries(car).forEach(([key, value]) => &#123;<br />
        &nbsp;&nbsp;console.log(key + ": " + value);<br />
        &#125;);<br />
        // Output:<br />
        // make: Toyota<br />
        // model: Corolla<br />
        // year: 2020
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Practical Use Cases</h2>
  
    <p>
      The <code>Object.entries()</code> method is useful in many scenarios, such as:
    </p>
    <ul class="list-disc ml-5">
      <li>Transforming objects into arrays for data processing</li>
      <li>Filtering or searching key-value pairs within objects</li>
      <li>Creating dynamic structures based on object entries</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>Object.entries()</code> method in TypeScript is a vital tool for working with object properties. By understanding how to effectively use this method, developers can manipulate and access object data with greater ease and efficiency.
    </p>
  </div>
  
}@case(68){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Object.assign Methods in TypeScript</h1>
  
    <p>
      The <code>Object.assign()</code> method in TypeScript is a powerful utility that allows you to copy the values of all enumerable own properties from one or more source objects to a target object. This article will explore how to use <code>Object.assign()</code>, along with practical examples to illustrate its functionality.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Object.assign()</h2>
  
    <p>
      The <code>Object.assign()</code> method is part of the Object class in JavaScript and TypeScript. It can be used for merging objects, cloning objects, and setting default values. This method returns the target object, which is modified by the properties of the source objects.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Syntax of Object.assign()</h2>
  
    <p>
      The syntax of the <code>Object.assign()</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.assign(target, ...sources);
      </code>
    </pre>
  
    <p>
      - <code>target</code>: The target object that will receive the properties.
    </p>
    <p>
      - <code>...sources</code>: One or more source objects from which properties will be copied.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Object.assign()</h2>
  
    <p>
      Below is a simple example demonstrating how to use the <code>Object.assign()</code> method:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let target = &#123; a: 1, b: 2 &#125;;<br />
        let source = &#123; b: 3, c: 4 &#125;;<br />
        let result = Object.assign(target, source);<br />
        console.log(result); // Output: &#123; a: 1, b: 3, c: 4 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Merging Multiple Objects</h2>
  
    <p>
      The <code>Object.assign()</code> method can also be used to merge multiple objects into one. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let obj1 = &#123; a: 1 &#125;;<br />
        let obj2 = &#123; b: 2 &#125;;<br />
        let obj3 = &#123; c: 3 &#125;;<br />
        let merged = Object.assign({{'{}'}}, obj1, obj2, obj3);<br />
        console.log(merged); // Output: &#123; a: 1, b: 2, c: 3 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Cloning Objects</h2>
  
    <p>
      You can also use <code>Object.assign()</code> to create a shallow clone of an object:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        let original = &#123; x: 1, y: 2 &#125;;<br />
        let clone = Object.assign({{'{}'}}, original);<br />
        console.log(clone); // Output: &#123; x: 1, y: 2 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>Object.assign()</code> method in TypeScript is a versatile tool for merging, cloning, and manipulating objects. By understanding how to effectively use this method, developers can streamline their code and enhance object handling in TypeScript applications.
    </p>
  </div>
  
}@case(69){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Object.fromEntries Methods in TypeScript</h1>
  
    <p>
      The <code>Object.fromEntries()</code> method in TypeScript is a powerful utility that allows you to convert a list of key-value pairs into an object. This article will explore how to use <code>Object.fromEntries()</code>, along with practical examples to illustrate its functionality.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Object.fromEntries()</h2>
  
    <p>
      The <code>Object.fromEntries()</code> method is a part of the Object class in JavaScript and TypeScript. It takes an iterable (such as an array) of key-value pairs and transforms them into an object. This method is particularly useful when you need to create an object from data structures like Maps or arrays.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Syntax of Object.fromEntries()</h2>
  
    <p>
      The syntax of the <code>Object.fromEntries()</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        Object.fromEntries(iterable);
      </code>
    </pre>
  
    <p>
      - <code>iterable</code>: An iterable such as an array or a Map that contains key-value pairs.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Object.fromEntries()</h2>
  
    <p>
      Below is a simple example demonstrating how to use the <code>Object.fromEntries()</code> method:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const entries = [['name', 'Alice'], ['age', 30], ['city', 'New York']];<br />
        const obj = Object.fromEntries(entries);<br />
        console.log(obj); // Output: &#123; name: "Alice", age: 30, city: "New York" &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Converting Maps to Objects</h2>
  
    <p>
      The <code>Object.fromEntries()</code> method can be used to convert a Map into an object. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const map = new Map();<br />
        map.set('a', 1);<br />
        map.set('b', 2);<br />
        const objFromMap = Object.fromEntries(map);<br />
        console.log(objFromMap); // Output: &#123; a: 1, b: 2 &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Use Cases for Object.fromEntries()</h2>
  
    <p>
      The <code>Object.fromEntries()</code> method is useful in many scenarios, such as:
    </p>
    <ul class="list-disc ml-5">
      <li>Transforming key-value pairs from various data structures into objects</li>
      <li>Reconstructing objects from serialized data</li>
      <li>Working with dynamic property names in applications</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      The <code>Object.fromEntries()</code> method in TypeScript is an essential tool for converting key-value pairs into objects. By understanding how to effectively use this method, developers can streamline their code and enhance data manipulation in TypeScript applications.
    </p>
  </div>
  
}@case(70){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Set Methods in TypeScript</h1>
  
    <p>
      The <code>Set</code> object in TypeScript is a collection of values where each value must be unique. This article explores the various methods provided by the <code>Set</code> class and how they can be utilized in TypeScript applications.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Set</h2>
  
    <p>
      A <code>Set</code> is a built-in data structure that lets you store unique values of any type, whether primitive values or object references. The <code>Set</code> object provides various methods to manipulate the collection of unique values.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Creating a Set</h2>
  
    <p>
      You can create a <code>Set</code> using the following syntax:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const mySet = new Set();<br />
        const mySetWithValues = new Set(&#123;'apple', 'banana', 'orange'&#125;);
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Common Set Methods</h2>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">a. add(value)</h3>
    <p>
      The <code>add()</code> method adds a new element to the <code>Set</code>. If the value already exists, it will not add it again.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        mySet.add('grape');<br />
        console.log(mySet); // Output: Set(4) &#123; 'apple', 'banana', 'orange', 'grape' &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">b. delete(value)</h3>
    <p>
      The <code>delete()</code> method removes a specified value from the <code>Set</code>.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        mySet.delete('banana');<br />
        console.log(mySet); // Output: Set(3) &#123; 'apple', 'orange', 'grape' &#125;
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">c. has(value)</h3>
    <p>
      The <code>has()</code> method checks if a specific value exists in the <code>Set</code>.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        console.log(mySet.has('apple')); // Output: true<br />
        console.log(mySet.has('banana')); // Output: false
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">d. clear()</h3>
    <p>
      The <code>clear()</code> method removes all elements from the <code>Set</code>.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        mySet.clear();<br />
        console.log(mySet); // Output: Set(0) {{'{}'}}
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">e. size</h3>
    <p>
      The <code>size</code> property returns the number of unique values in the <code>Set</code>.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        console.log(mySet.size); // Output: 0
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Conclusion</h2>
  
    <p>
      The <code>Set</code> object in TypeScript provides a versatile way to work with collections of unique values. By utilizing the various methods provided, developers can efficiently manage and manipulate data collections in their TypeScript applications.
    </p>
  </div>
  
}@case(71){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Get Methods in TypeScript</h1>
  
    <p>
      In TypeScript, the <code>get</code> methods are used to define properties in a class that can be accessed like regular properties, but they run a method when accessed. This article will explore the usage of <code>get</code> methods, along with practical examples to illustrate their functionality.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Get Methods</h2>
  
    <p>
      A <code>get</code> method in TypeScript is a way to create a property that retrieves a value when accessed. This provides a way to encapsulate data and implement logic without exposing the underlying implementation directly.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Syntax of Get Methods</h2>
  
    <p>
      The syntax for defining a <code>get</code> method is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        class ClassName &#123;<br />
        &nbsp;&nbsp;private _property: type;<br />
        <br />
        &nbsp;&nbsp;constructor(value: type) &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;this._property = value;<br />
        &nbsp;&nbsp;&#125;<br />
        <br />
        &nbsp;&nbsp;get property() &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;return this._property;<br />
        &nbsp;&nbsp;&#125;<br />
        &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Example of Get Methods</h2>
  
    <p>
      Below is a simple example demonstrating how to use a <code>get</code> method in a class:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        class Person &#123;<br />
        &nbsp;&nbsp;private _name: string;<br />
        <br />
        &nbsp;&nbsp;constructor(name: string) &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;this._name = name;<br />
        &nbsp;&nbsp;&#125;<br />
        <br />
        &nbsp;&nbsp;get name() &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;return this._name;<br />
        &nbsp;&nbsp;&#125;<br />
        &#125;<br />
        <br />
        const person = new Person('Alice');<br />
        console.log(person.name); // Output: Alice
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Use Cases for Get Methods</h2>
  
    <p>
      Get methods are particularly useful in scenarios where:
    </p>
    <ul class="list-disc ml-5">
      <li>You want to calculate a value dynamically based on other properties.</li>
      <li>You need to encapsulate logic when retrieving a value, such as validation or transformation.</li>
      <li>You want to provide read-only access to a property while keeping the internal state private.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Conclusion</h2>
  
    <p>
      Get methods in TypeScript provide a powerful way to manage properties within classes. By using <code>get</code> methods, developers can implement encapsulation, validation, and dynamic calculations seamlessly, enhancing the maintainability and readability of their code.
    </p>
  </div>
  
}@case(72){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Has Methods in TypeScript</h1>
  
    <p>
      In TypeScript, the <code>has</code> method is commonly associated with the <code>Set</code> and <code>Map</code> objects, allowing developers to check the existence of a specific value in a collection. This article will explore how the <code>has</code> method works in TypeScript, with practical examples to illustrate its usage.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to the Has Method</h2>
  
    <p>
      The <code>has</code> method is used to determine if a particular value exists in a <code>Set</code> or a key exists in a <code>Map</code>. This method returns a boolean value: <code>true</code> if the value or key is found and <code>false</code> otherwise.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Using the Has Method with Sets</h2>
  
    <p>
      The syntax for using the <code>has</code> method with a <code>Set</code> is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const mySet = new Set(&#123;'apple', 'banana', 'orange'&#125;);<br />
        console.log(mySet.has('banana')); // Output: true<br />
        console.log(mySet.has('grape')); // Output: false
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Using the Has Method with Maps</h2>
  
    <p>
      The syntax for using the <code>has</code> method with a <code>Map</code> is as follows:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const myMap = new Map(&#123;<br />
        &nbsp;&nbsp;'name': 'Alice',<br />
        &nbsp;&nbsp;'age': 25,<br />
        &nbsp;&nbsp;'city': 'New York'&#125;);<br />
        <br />
        console.log(myMap.has('name')); // Output: true<br />
        console.log(myMap.has('country')); // Output: false
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Practical Example of Has Methods</h2>
  
    <p>
      Below is an example that combines both <code>Set</code> and <code>Map</code> objects to illustrate the usage of the <code>has</code> method:
    </p>
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        class UserProfile &#123;<br />
        &nbsp;&nbsp;private roles: Set&lt;string&gt;;<br />
        &nbsp;&nbsp;private settings: Map&lt;string, any&gt;;<br />
        <br />
        &nbsp;&nbsp;constructor() &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;this.roles = new Set(&#123;'admin', 'user'&#125;);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;this.settings = new Map(&#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'theme': 'dark',<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'notifications': true<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&#125;);<br />
        &nbsp;&nbsp;&#125;<br />
        <br />
        &nbsp;&nbsp;checkRole(role: string) &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;return this.roles.has(role);<br />
        &nbsp;&nbsp;&#125;<br />
        <br />
        &nbsp;&nbsp;checkSetting(setting: string) &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;return this.settings.has(setting);<br />
        &nbsp;&nbsp;&#125;<br />
        &#125;<br />
        <br />
        const userProfile = new UserProfile();<br />
        console.log(userProfile.checkRole('admin')); // Output: true<br />
        console.log(userProfile.checkSetting('theme')); // Output: true<br />
        console.log(userProfile.checkSetting('language')); // Output: false
      </code>
    </pre>

    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Conclusion</h2>
  
    <p>
      The <code>has</code> method in TypeScript is a valuable tool for checking the presence of values in collections like <code>Set</code> and <code>Map</code>. By leveraging this method, developers can efficiently manage and validate the existence of data in their applications, ensuring better data integrity and performance.
    </p>
  </div>
  
}@case(73){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Delete Methods in TypeScript</h1>
  
    <p>
      In TypeScript, the <code>delete</code> operator is used to remove properties from an object. This operator allows you to manage object properties dynamically at runtime. In this article, we'll explore how to use the <code>delete</code> operator effectively with practical examples.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to the Delete Operator</h2>
  
    <p>
      The <code>delete</code> operator removes a property from an object. It takes the form:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        delete objectName.propertyName;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Using the Delete Operator</h2>
  
    <p>
      Below is an example of how to use the <code>delete</code> operator to remove properties from an object:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const user = &#123;<br />
        &nbsp;&nbsp;'name': 'Alice',<br />
        &nbsp;&nbsp;'age': 30,<br />
        &nbsp;&nbsp;'city': 'New York'&#125;;<br />
        <br />
        console.log(user); // Output: &#123; name: 'Alice', age: 30, city: 'New York' &#125;<br />
        delete user.age;<br />
        console.log(user); // Output: &#123; name: 'Alice', city: 'New York' &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Important Notes on the Delete Operator</h2>
  
    <p>
      - The <code>delete</code> operator returns <code>true</code> if the property was successfully deleted, and <code>false</code> if the property could not be deleted (e.g., if it is a non-configurable property).<br />
      - If the property does not exist, <code>delete</code> will return <code>true</code> without throwing an error.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Practical Example of the Delete Operator</h2>
  
    <p>
      Here’s a practical example that shows the use of the <code>delete</code> operator in a more complex scenario:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        class Car &#123;<br />
        &nbsp;&nbsp;make: string;<br />
        &nbsp;&nbsp;model: string;<br />
        &nbsp;&nbsp;year: number;<br />
        <br />
        &nbsp;&nbsp;constructor(make: string, model: string, year: number) &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;this.make = make;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;this.model = model;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;this.year = year;<br />
        &nbsp;&nbsp;&#125;<br />
        <br />
        &nbsp;&nbsp;deleteYear() &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;delete this.year;<br />
        &nbsp;&nbsp;&#125;<br />
        &#125;<br />
        <br />
        const myCar = new Car('Toyota', 'Corolla', 2020);<br />
        console.log(myCar); // Output: Car &#123; make: 'Toyota', model: 'Corolla', year: 2020 &#125;<br />
        myCar.deleteYear();<br />
        console.log(myCar); // Output: Car &#123; make: 'Toyota', model: 'Corolla' &#125;
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Conclusion</h2>
  
    <p>
      The <code>delete</code> operator in TypeScript is a powerful tool for dynamically managing object properties. It allows developers to create flexible and adaptable objects, making it easier to handle various scenarios in applications.
    </p>
  </div>
  
}@case(74){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">Destructuring Methods in TypeScript</h1>
  
    <p>
      Destructuring is a powerful feature in TypeScript that allows you to unpack values from arrays or properties from objects into distinct variables. This method simplifies the code and enhances readability. In this article, we'll explore how to use destructuring effectively in TypeScript.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to Destructuring</h2>
  
    <p>
      Destructuring allows you to extract values from arrays or properties from objects and assign them to variables. This syntax is more concise and cleaner than traditional methods of accessing object properties or array elements.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Destructuring Objects</h2>
  
    <p>
      You can destructure objects by using curly braces. Here’s an example:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const person = &#123;<br />
        &nbsp;&nbsp;'name': 'Alice',<br />
        &nbsp;&nbsp;'age': 25,<br />
        &nbsp;&nbsp;'city': 'New York'&#125;;<br />
        <br />
        const &#123; name, age &#125; = person;<br />
        console.log(name); // Output: Alice<br />
        console.log(age); // Output: 25
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. Destructuring Arrays</h2>
  
    <p>
      Array destructuring uses square brackets. Here's how to do it:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const colors = ['red', 'green', 'blue'];<br />
        const &#91; firstColor, secondColor &#93; = colors;<br />
        console.log(firstColor); // Output: red<br />
        console.log(secondColor); // Output: green
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Default Values in Destructuring</h2>
  
    <p>
      You can assign default values to variables during destructuring. This is useful when the property might be undefined:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const user = &#123;<br />
        &nbsp;&nbsp;'name': 'Alice'<br />
        &#125;;<br />
        <br />
        const &#123; name, age = 30 &#125; = user;<br />
        console.log(name); // Output: Alice<br />
        console.log(age); // Output: 30
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Nested Destructuring</h2>
  
    <p>
      Destructuring can also be used for nested objects and arrays:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const student = &#123;<br />
        &nbsp;&nbsp;'name': 'Bob',<br />
        &nbsp;&nbsp;'scores': &#123;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;'math': 90,<br />
        &nbsp;&nbsp;&nbsp;&nbsp;'science': 85<br />
        &nbsp;&nbsp;&#125;<br />
        &#125;;<br />
        <br />
        const &#123; scores: &#123; math &#125; &#125; = student;<br />
        console.log(math); // Output: 90
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">6. Conclusion</h2>
  
    <p>
      Destructuring in TypeScript simplifies the process of extracting values from objects and arrays. It enhances code readability and reduces boilerplate code, making it a valuable feature in modern JavaScript and TypeScript development.
    </p>
  </div>
  
}@case(75){
  <div class="container mx-auto p-5">
    <h1 class="text-2xl font-bold mb-4 text-blue-500">WeakMap Methods in TypeScript</h1>
  
    <p>
      A WeakMap is a collection of key-value pairs where the keys are objects and the values can be any value. WeakMaps are similar to Maps, but they allow for garbage collection of the keys. This article will explore the key methods provided by WeakMap in TypeScript and how to use them effectively.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">1. Introduction to WeakMap</h2>
  
    <p>
      A WeakMap is particularly useful for storing data that needs to be associated with an object without preventing that object from being garbage-collected. This is ideal for cases like caching and managing private data.
    </p>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">2. Creating a WeakMap</h2>
  
    <p>
      You can create a WeakMap using the following syntax:
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const weakMap = new WeakMap();<br />
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">3. WeakMap Methods</h2>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">3.1. set(key: object, value: any)</h3>
  
    <p>
      The <code class="font-mono">set</code> method adds a new key-value pair to the WeakMap. The key must be an object.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const obj = &#123;&#125;;<br />
        weakMap.set(obj, 'value');<br />
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">3.2. get(key: object)</h3>
  
    <p>
      The <code class="font-mono">get</code> method retrieves the value associated with the specified key.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const value = weakMap.get(obj);<br />
        console.log(value); // Output: 'value'<br />
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">3.3. has(key: object)</h3>
  
    <p>
      The <code class="font-mono">has</code> method checks if a key exists in the WeakMap.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        const exists = weakMap.has(obj);<br />
        console.log(exists); // Output: true<br />
      </code>
    </pre>
  
    <h3 class="text-lg font-semibold mt-4 text-blue-500">3.4. delete(key: object)</h3>
  
    <p>
      The <code class="font-mono">delete</code> method removes the specified key and its associated value from the WeakMap.
    </p>
  
    <pre class="bg-gray-100 p-4 rounded-md">
      <code class="font-mono text-sm language-javascript">
        weakMap.delete(obj);<br />
        console.log(weakMap.has(obj)); // Output: false<br />
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">4. Use Cases for WeakMap</h2>
  
    <p>
      WeakMaps are useful for scenarios such as:
    </p>
    <ul class="list-disc ml-6">
      <li>Storing metadata about an object.</li>
      <li>Caching results of expensive computations.</li>
      <li>Maintaining private data for objects without risking memory leaks.</li>
    </ul>
  
    <h2 class="text-xl font-semibold mt-6 text-blue-500">5. Conclusion</h2>
  
    <p>
      WeakMaps provide a powerful way to manage memory efficiently in JavaScript and TypeScript. By allowing garbage collection of keys, they enable developers to avoid memory leaks while associating values with objects.
    </p>
  </div>
  
}
}