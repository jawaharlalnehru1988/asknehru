<!-- <pre>
    <code class="language-javascript" codeHighlight>
        {{code}}
    </code>
</pre> -->

@switch (topicId){ 
@case (1){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">TypeScript Key Features</h1>

  <p class="text-lg text-gray-700 mb-4">
    TypeScript is a strongly typed superset of JavaScript that adds optional
    static typing and other features to enhance the development experience. Here
    are the key features of TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Static Typing
      </h2>
      <p class="text-gray-700">
        TypeScript allows developers to assign specific data types (e.g.,
        number, string, boolean, array, etc.) to variables, function parameters,
        and return types. This helps catch type-related errors at compile time,
        improving code safety and maintainability.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Type Inference
      </h2>
      <p class="text-gray-700">
        TypeScript can automatically infer types based on the assigned values,
        which means you don't have to explicitly annotate types in every case,
        making the code cleaner while still maintaining type safety.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Interfaces and Type Aliases
      </h2>
      <p class="text-gray-700">
        TypeScript provides interfaces to define the structure of objects and
        ensure that they have a consistent shape. Type aliases can be used to
        define custom types, making the code more expressive and reusable.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Classes and Object-Oriented Programming (OOP)
      </h2>
      <p class="text-gray-700">
        TypeScript supports OOP concepts like classes, inheritance, access
        modifiers (public, private, protected), and abstract classes. This
        brings a more structured, traditional approach to JavaScript
        development.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">5. Generics</h2>
      <p class="text-gray-700">
        TypeScript supports generics, allowing you to write reusable and
        flexible code that can work with different data types while maintaining
        type safety.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Type Checking and Compile-Time Error Detection
      </h2>
      <p class="text-gray-700">
        TypeScript performs type checking at compile time, helping developers
        catch potential errors early in the development process, reducing
        runtime issues in production.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Union and Intersection Types
      </h2>
      <p class="text-gray-700">
        Union types allow variables to hold multiple possible types (e.g.,
        number | string), and intersection types let you combine multiple types
        into one, offering more flexibility in defining data structures.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">8. Enums</h2>
      <p class="text-gray-700">
        Enums provide a way to define a set of named constants, improving the
        readability and maintainability of code by representing a collection of
        related values more clearly.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Advanced IDE Support
      </h2>
      <p class="text-gray-700">
        TypeScript integrates well with modern IDEs like VS Code, offering
        powerful tooling such as autocompletion, refactoring tools, and inline
        type hints, which significantly improve developer productivity.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        10. Modules and Namespaces
      </h2>
      <p class="text-gray-700">
        TypeScript supports both ES modules and its own module system, making it
        easy to organize code into reusable components. Namespaces help organize
        large codebases by grouping related code under a common namespace.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        11. Compatibility with JavaScript
      </h2>
      <p class="text-gray-700">
        Since TypeScript is a superset of JavaScript, all valid JavaScript code
        is also valid TypeScript code. This makes it easy to gradually adopt
        TypeScript in existing JavaScript projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        12. Decorators (Experimental)
      </h2>
      <p class="text-gray-700">
        TypeScript supports decorators, which are special annotations used for
        adding metadata to classes and methods. They are commonly used in
        frameworks like Angular to define behaviors like routing, services, or
        component metadata.
      </p>
    </li>
  </ul>
</div>

} @case (2){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">
    Benefits of Using TypeScript
  </h1>

  <p class="text-lg text-gray-700 mb-4">
    TypeScript offers numerous benefits to developers, especially when working
    on large-scale applications or projects that require strong type safety.
    Below are some of the key benefits of using TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Improved Code Quality and Safety
      </h2>
      <p class="text-gray-700">
        By enforcing static typing, TypeScript helps catch type-related errors
        during development, reducing the likelihood of runtime errors. This
        improves overall code quality and safety, making it easier to maintain
        and scale projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Enhanced Developer Experience
      </h2>
      <p class="text-gray-700">
        TypeScript integrates seamlessly with popular IDEs like Visual Studio
        Code, offering advanced features like autocompletion, real-time error
        checking, and intelligent code refactoring. This boosts productivity and
        allows for a smoother development experience.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Early Error Detection
      </h2>
      <p class="text-gray-700">
        TypeScript’s compile-time error checking allows developers to detect and
        fix errors early in the development process. This minimizes the number
        of bugs found during testing and reduces time spent debugging during
        production.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Scalability for Large Projects
      </h2>
      <p class="text-gray-700">
        For large codebases, TypeScript’s static typing and OOP features like
        interfaces, classes, and generics provide a more structured approach.
        This makes it easier to manage and scale complex projects while
        maintaining consistent code quality.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        5. Better Collaboration and Readability
      </h2>
      <p class="text-gray-700">
        The self-documenting nature of TypeScript (through type annotations and
        interfaces) enhances collaboration among team members. Developers can
        easily understand each other's code and work with greater efficiency,
        leading to better readability and maintainability.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Compatibility with JavaScript
      </h2>
      <p class="text-gray-700">
        Since TypeScript is a superset of JavaScript, it can run alongside
        existing JavaScript code. This allows teams to gradually migrate to
        TypeScript without the need for a complete rewrite of legacy code,
        making it an ideal choice for both new and existing projects.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Strong Ecosystem and Community Support
      </h2>
      <p class="text-gray-700">
        TypeScript has a growing and active community, with support from major
        frameworks like Angular and libraries like React and Vue. The ecosystem
        is mature, offering a wide range of resources, tutorials, and tools to
        support developers.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        8. Enables Modern JavaScript Features
      </h2>
      <p class="text-gray-700">
        TypeScript supports the latest JavaScript features (e.g., async/await,
        destructuring, modules) while ensuring backward compatibility with older
        browsers through transpilation. This means developers can take advantage
        of modern features without sacrificing browser support.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Supports Large-Scale Refactoring
      </h2>
      <p class="text-gray-700">
        TypeScript's strong typing and IDE integration provide powerful
        refactoring capabilities, allowing developers to rename variables,
        functions, or entire modules with confidence, knowing the changes will
        propagate throughout the codebase safely.
      </p>
    </li>
  </ul>
</div>

} @case (3){
<div class="max-w-4xl mx-auto p-8">
  <h1 class="text-3xl font-bold text-blue-600 mb-6">
    Drawbacks of Using TypeScript
  </h1>

  <p class="text-lg text-gray-700 mb-4">
    While TypeScript offers many advantages, it also comes with certain
    drawbacks that developers should be aware of before adopting it in their
    projects. Below are some of the key drawbacks of using TypeScript:
  </p>

  <ul class="space-y-6">
    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        1. Additional Learning Curve
      </h2>
      <p class="text-gray-700">
        For developers who are familiar with JavaScript but new to TypeScript,
        there is an additional learning curve. Concepts like static typing,
        interfaces, and generics can take time to grasp, which may slow down the
        initial development process.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        2. Longer Compilation Time
      </h2>
      <p class="text-gray-700">
        TypeScript code needs to be compiled into JavaScript before it can be
        executed. This extra compilation step can introduce delays, especially
        in larger projects, leading to longer build times and slower feedback
        during development.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        3. Increased Project Complexity
      </h2>
      <p class="text-gray-700">
        The introduction of TypeScript can add complexity to a project, as
        developers must manage type definitions, configurations, and potential
        integration issues with third-party libraries. This may increase the
        overall maintenance overhead.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        4. Limited Support for Some JavaScript Libraries
      </h2>
      <p class="text-gray-700">
        Not all JavaScript libraries have complete TypeScript definitions, which
        can make integrating certain libraries difficult. Developers may need to
        write their own type definitions or use third-party tools to ensure
        compatibility.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        5. Larger Codebase
      </h2>
      <p class="text-gray-700">
        TypeScript's strict type enforcement often results in writing more code,
        especially with type annotations. While this improves code safety, it
        can also lead to a larger codebase, which may require additional effort
        to maintain.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        6. Potential Overhead for Small Projects
      </h2>
      <p class="text-gray-700">
        For small projects or scripts, the benefits of TypeScript might not
        justify the added complexity and setup requirements. In such cases, the
        overhead of configuring and maintaining TypeScript might outweigh the
        advantages.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        7. Migration Challenges
      </h2>
      <p class="text-gray-700">
        Migrating existing JavaScript projects to TypeScript can be
        time-consuming, especially for large codebases. Developers must refactor
        code, define types, and address potential issues with dependencies,
        which can slow down the migration process.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        8. Dependency on Build Tools
      </h2>
      <p class="text-gray-700">
        TypeScript relies on build tools like Webpack, Babel, or TypeScript’s
        own compiler to convert TypeScript code into JavaScript. This adds a
        layer of complexity to the development environment, especially for teams
        that are not familiar with these tools.
      </p>
    </li>

    <li>
      <h2 class="text-xl font-semibold text-indigo-500 mb-2">
        9. Debugging Overhead
      </h2>
      <p class="text-gray-700">
        Although TypeScript provides many benefits for catching errors early,
        debugging compiled TypeScript code can sometimes be more challenging
        than debugging plain JavaScript. Developers must use source maps or
        other tools to trace errors back to the original TypeScript source.
      </p>
    </li>
  </ul>
</div>

}@case (4){
<div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
  <h1 class="text-3xl font-bold text-gray-800">TypeScript Compiler (tsc)</h1>

  <p class="text-lg text-gray-700">
    The TypeScript compiler, commonly referred to as
    <code class="font-mono bg-gray-200 p-1 rounded">tsc</code>, is a tool that
    translates TypeScript code into JavaScript. Since browsers and JavaScript
    engines can't execute TypeScript directly,
    <code class="font-mono bg-gray-200 p-1 rounded">tsc</code> is essential in
    converting it.
  </p>

  <div class="space-y-2">
    <h2 class="text-xl font-semibold text-gray-700">
      Key Functions of
      <code class="font-mono bg-gray-200 p-1 rounded">tsc</code>:
    </h2>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">1. Transpilation</h3>
      <p class="text-gray-600">
        Translates TypeScript code into plain JavaScript, allowing it to run in
        any environment supporting JavaScript.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">2. Type Checking</h3>
      <p class="text-gray-600">
        Before converting to JavaScript,
        <code class="font-mono bg-gray-200 p-1 rounded">tsc</code> checks for
        type errors and ensures code consistency based on provided type
        annotations.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">3. Configuration</h3>
      <p class="text-gray-600">
        You can customize the compiler using the
        <code class="font-mono bg-gray-200 p-1 rounded">tsconfig.json</code>
        file to set options like JavaScript target version and module systems.
      </p>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800">
        4. Incremental Compilation
      </h3>
      <p class="text-gray-600">
        The compiler can incrementally compile only changed files, improving
        efficiency in larger projects.
      </p>
    </div>
  </div>
</div>

} @case (5){
<div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
  <h1 class="text-3xl font-bold text-gray-800">
    Type Conversions in TypeScript
  </h1>

  <p class="text-lg text-gray-700">
    TypeScript allows for various ways to convert from one type to another. Type
    conversion, also known as type casting, helps you ensure that data is
    interpreted as expected during code execution.
  </p>

  <div class="space-y-2">
    <h2 class="text-xl font-semibold text-blue-700">
      Key Types of Type Conversions:
    </h2>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        1. Explicit Conversion (Type Casting)
      </h3>
      <p class="text-gray-600">
        In TypeScript, you can explicitly convert one type to another using
        either the angle-bracket syntax (<code
          class="font-mono bg-gray-200 p-1 rounded"
          >&lt;type&gt;</code
        >) or the
        <code class="font-mono bg-gray-200 p-1 rounded">as</code> keyword.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight >let value: any = "123";<br>let num: number = &lt;number&gt;value;</code></pre>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight>let value: any = "123";<br>let num: number = value as number;</code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        2. Implicit Conversion (Type Inference)
      </h3>
      <p class="text-gray-600">
        TypeScript also performs automatic type inference in some cases, where
        it converts one type to another without explicit casting.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight >let num = 123;<br>let str = num + " is a number"; // 'str' becomes a string</code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        3. Built-in Conversion Functions
      </h3>
      <p class="text-gray-600">
        JavaScript (and TypeScript) provides built-in functions like
        <code class="font-mono bg-gray-200 p-1 rounded">Number()</code>,
        <code class="font-mono bg-gray-200 p-1 rounded">String()</code>, and
        <code class="font-mono bg-gray-200 p-1 rounded">Boolean()</code> for
        converting data types.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight>let value: string = "456";<br>let num: number = Number(value);</code></pre>
    </div>

    <div class="p-4 bg-gray-50 rounded-md border border-gray-200">
      <h3 class="text-lg font-semibold text-blue-800">
        4. Avoiding Runtime Errors
      </h3>
      <p class="text-gray-600">
        Type conversions help avoid unexpected runtime errors. TypeScript
        ensures that conversions are valid or warns you at compile-time.
      </p>
      <p class="text-gray-600">
        For example, converting a non-numeric string to a number will result in
        <code
          class="language-javascript"
          codeHighlight
          class="font-mono bg-gray-200 p-1 rounded"
          >NaN</code
        >.
      </p>
      <pre
        class="bg-gray-100 p-3 rounded"
      ><code class="font-mono text-sm" class="language-javascript" codeHighlight>let invalidNum: number = Number("not a number"); // NaN</code></pre>
    </div>
  </div>
</div>

}@case (6){
  <div class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">TypeScript Loops in Angular</h1>
  
    <p class="mb-4">
      In TypeScript, both <span class="font-semibold">for</span> loops and
      <span class="font-semibold">while</span> loops work similarly to how they do in JavaScript, but with optional static
      typing features that TypeScript provides. Below is an explanation of both types of loops:
    </p>
  
    <!-- For Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">1. For Loop</h2>
      <p class="mb-4">
        A for loop is typically used when you know the number of iterations beforehand. The structure consists of three
        parts: initialization, condition, and increment/decrement.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >for (initialization; condition; increment/decrement) {{'{'}} <br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}}</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>for (let i: number = 0; i < 5; i++)  {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          {{'}'}}</code>
      </pre>
      <p class="my-2">
        <span class="font-semibold">let i: number = 0;</span> → initializes the loop counter <span class="italic">i</span>
        as a number and starts at 0.
      </p>
      <p class="my-2">
        <span class="font-semibold">i < 5;</span> → loop continues as long as <span class="italic">i</span> is less than 5.
      </p>
      <p class="my-2">
        <span class="font-semibold">i++</span> → increments <span class="italic">i</span> by 1 after every iteration.
      </p>
    </div>
  
    <!-- While Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">2. While Loop</h2>
      <p class="mb-4">
        A while loop runs as long as a specified condition is <span class="font-semibold">true</span>. It’s commonly used
        when the number of iterations is not known beforehand.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>while (condition) {{'{'}} <br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}}</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>let i: number = 0;<br><br>
        while (i < 5)  {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;i++;<br>
          {{'}'}}</code>
      </pre>
      <p class="my-2">
        The condition <span class="font-semibold">i < 5</span> is checked before each iteration.
      </p>
      <p class="my-2">The loop runs as long as <span class="font-semibold">i</span> is less than 5.</p>
    </div>
  
    <!-- Do-While Loop Section -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">3. Do-While Loop</h2>
      <p class="mb-4">
        A do-while loop is similar to the while loop but guarantees that the loop will run at least once since the
        condition is checked after the execution of the code block.
      </p>
      <h3 class="text-lg font-semibold">Syntax:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>do {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;// code block to execute <br>
          {{'}'}} while (condition);</code>
      </pre>
  
      <h3 class="text-lg font-semibold">Example:</h3>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight>let i: number = 0;<br><br>
        do {{'{'}}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;console.log(i);  // Output: 0 1 2 3 4 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;i++;<br>
          {{'}'}} while (i < 5);</code>
      </pre>
      <p class="my-2">
        In this example, the loop runs the first iteration before checking if <span class="font-semibold">i < 5</span>.
      </p>
    </div>
  
    <!-- Key Points -->
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
      <ul class="list-disc ml-6">
        <li class="my-2">
          <span class="font-semibold">For Loops:</span> Best when you know how many times to iterate.
        </li>
        <li class="my-2">
          <span class="font-semibold">While Loops:</span> Best when the number of iterations is unknown and depends on a
          condition.
        </li>
        <li class="my-2">
          <span class="font-semibold">Do-While Loops:</span> Ensures that the loop runs at least once before checking the
          condition.
        </li>
      </ul>
    </div>
</div>

}@case (7){
<article class="prose lg:prose-xl p-6 bg-gray-100 rounded-lg shadow-lg">
  <h1 class="text-3xl font-bold mb-6">
    Basic Operators and Maths in TypeScript
  </h1>
  <!-- Introduction -->
  <p class="mb-4">
    In TypeScript (and JavaScript), operators are symbols used to perform
    specific operations on variables or values. These operations can include
    mathematical calculations, comparisons, and logical operations. Here’s a
    breakdown of the most common types of operators with a focus on
    <strong>mathematical operators</strong>.
  </p>

  <!-- Arithmetic Operators -->
  <h2 class="text-xl font-semibold text-blue-700">1. Arithmetic Operators</h2>
  <p class="mb-4">
    Arithmetic operators are used to perform mathematical operations on numbers.
  </p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Result</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">+</td>
        <td class="px-4 py-2">Addition</td>
        <td class="px-4 py-2">5 + 2</td>
        <td class="px-4 py-2">7</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">-</td>
        <td class="px-4 py-2">Subtraction</td>
        <td class="px-4 py-2">5 - 2</td>
        <td class="px-4 py-2">3</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">*</td>
        <td class="px-4 py-2">Multiplication</td>
        <td class="px-4 py-2">5 * 2</td>
        <td class="px-4 py-2">10</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">/</td>
        <td class="px-4 py-2">Division</td>
        <td class="px-4 py-2">10 / 2</td>
        <td class="px-4 py-2">5</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">%</td>
        <td class="px-4 py-2">Modulus</td>
        <td class="px-4 py-2">5 % 2</td>
        <td class="px-4 py-2">1</td>
      </tr>
    </tbody>
  </table>

  <!-- Assignment Operators -->
  <h2 class="text-xl font-semibold text-blue-700">2. Assignment Operators</h2>
  <p class="mb-4">Assignment operators assign values to variables.</p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Equivalent</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">=</td>
        <td class="px-4 py-2">Assign value</td>
        <td class="px-4 py-2">x = 5</td>
        <td class="px-4 py-2">-</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">+=</td>
        <td class="px-4 py-2">Add and assign</td>
        <td class="px-4 py-2">x += 3</td>
        <td class="px-4 py-2">x = x + 3</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">-=</td>
        <td class="px-4 py-2">Subtract and assign</td>
        <td class="px-4 py-2">x -= 3</td>
        <td class="px-4 py-2">x = x - 3</td>
      </tr>
    </tbody>
  </table>

  <!-- Comparison Operators -->
  <h2 class="text-xl font-semibold text-blue-700">3. Comparison Operators</h2>
  <p class="mb-4">
    Comparison operators are used to compare two values and return a Boolean
    value (<code>true</code> or <code>false</code>).
  </p>

  <table class="table-auto bg-white shadow rounded-lg mb-6">
    <thead>
      <tr>
        <th class="px-4 py-2">Operator</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Example</th>
        <th class="px-4 py-2">Result</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-t">
        <td class="px-4 py-2">==</td>
        <td class="px-4 py-2">Equal to</td>
        <td class="px-4 py-2">5 == 5</td>
        <td class="px-4 py-2">true</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">===</td>
        <td class="px-4 py-2">Strict equal</td>
        <td class="px-4 py-2">5 === "5"</td>
        <td class="px-4 py-2">false</td>
      </tr>
      <tr class="border-t">
        <td class="px-4 py-2">!=</td>
        <td class="px-4 py-2">Not equal</td>
        <td class="px-4 py-2">5 != 3</td>
        <td class="px-4 py-2">true</td>
      </tr>
    </tbody>
  </table>

  <!-- Logical Operators -->
  <h2 class="text-xl font-semibold text-blue-700">4. Logical Operators</h2>
  <p class="mb-4">Logical operators are used to combine multiple conditions.</p>

  <pre class="bg-gray-800 text-white p-4 rounded-md mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        let a = true;
        let b = false;
        console.log(a && b);  // false
        console.log(a || b);  // true
        console.log(!a);      // false
      </code>
    </pre>

  <!-- Mathematical Functions -->
  <h2 class="text-xl font-semibold text-blue-700">5. Mathematical Functions</h2>
  <p class="mb-4">
    TypeScript also supports several built-in mathematical functions through the
    <code>Math</code> object.
  </p>

  <pre class="bg-gray-800 text-white p-4 rounded-md mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
        let num = Math.sqrt(16);  // 4
        console.log(Math.round(4.7));  // 5
        console.log(Math.random());    // Random number between 0 and 1
      </code>
    </pre>

  <p class="mb-4">
    These are just a few of the key operators and functions available in
    TypeScript for performing mathematical and logical operations.
  </p>
</article>

}@case(8){
<div class="max-w-4xl mx-auto p-6">
  <h1 class="text-xl font-semibold text-indigo-500 mb-2">
    The Switch Statement in TypeScript
  </h1>

  <p class="text-lg mb-4">
    The <span class="font-semibold">switch</span> statement in TypeScript is a
    control flow structure used to perform different actions based on different
    conditions. It's often used as an alternative to a series of
    <span class="font-semibold">if-else</span> statements when there are
    multiple possible outcomes for a single expression.
  </p>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Basic Structure</h2>

  <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  switch (expression) 
    case value1:
      // Code to execute if expression matches value1
      break;
    case value2:
      // Code to execute if expression matches value2
      break;
    default:
      // Code to execute if no cases match
  
      </code>
    </pre>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Explanation of the Components:</h2>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">expression:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>
        The expression inside the <span class="font-semibold">switch</span> is
        evaluated once.
      </li>
      <li>
        The result of the expression is then compared to the values of each case
        (value1, value2, etc.).
      </li>
    </ul>
  </div>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">case value1, value2:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>Each case represents a possible value of the expression.</li>
      <li>
        If a case matches the value of the expression, the corresponding block
        of code will be executed.
      </li>
      <li>
        <span class="font-semibold">break:</span> The
        <span class="font-semibold">break</span> statement ensures that after a
        matching case's code is executed, the
        <span class="font-semibold">switch</span> statement ends. Without a
        <span class="font-semibold">break</span>, the code would continue to
        execute the following cases (a behavior called "fall-through").
      </li>
    </ul>
  </div>

  <div class="mb-6">
    <h3 class="text-xl font-semibold">default:</h3>
    <ul class="list-disc pl-8 text-lg">
      <li>The <span class="font-semibold">default</span> case is optional.</li>
      <li>
        If no case matches the value of the expression, the
        <span class="font-semibold">default</span> block will be executed.
      </li>
    </ul>
  </div>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Example of a switch Statement</h2>

  <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight>
  let day = 2;

  switch (day) 
    case 1:
      console.log('Monday');
      break;
    case 2:
      console.log('Tuesday');
      break;
    case 3:
      console.log('Wednesday');
      break;
    default:
      console.log('Other day');
        
      </code>
    </pre>

  <h3 class="text-xl font-semibold text-indigo-500 mb-4">Explanation:</h3>
  <ul class="list-disc pl-8 text-lg">
    <li>
      The variable <span class="font-semibold">day</span> has a value of 2.
    </li>
    <li>
      The <span class="font-semibold">switch</span> statement checks the value
      of <span class="font-semibold">day</span>:
    </li>
    <li>If it’s 1, it prints "Monday".</li>
    <li>
      If it’s 2, it prints "Tuesday" (this is the matching case, so the code
      executes this block and breaks out of the switch).
    </li>
    <li>
      If no case matches, the <span class="font-semibold">default</span> block
      would execute.
    </li>
  </ul>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">
    Use Cases for the switch Statement:
  </h2>
  <ul class="list-disc pl-8 text-lg">
    <li>
      The <span class="font-semibold">switch</span> statement is useful when you
      have multiple potential outcomes for a single expression.
    </li>
    <li>
      It simplifies code readability over long chains of
      <span class="font-semibold">if-else</span> conditions, especially when
      comparing the same variable multiple times.
    </li>
  </ul>

  <h2 class="text-xl font-semibold text-indigo-500 mb-2">Key Points:</h2>
  <ul class="list-disc pl-8 text-lg">
    <li>
      <span class="font-semibold">Fall-through:</span> Without a
      <span class="font-semibold">break</span>, TypeScript (and JavaScript) will
      continue to execute subsequent case blocks until it finds a break.
    </li>
    <li>
      <span class="font-semibold">Type Safety:</span> Since TypeScript is
      strongly typed, mismatched data types (like comparing a string case with a
      number expression) will cause compile-time errors.
    </li>
  </ul>
</div>

}@case(9){
  <div>

  
  <p class="mb-4">
    The ternary operator in TypeScript (as in JavaScript) is a concise way to perform conditional logic. It’s sometimes
    called the "conditional operator" and takes three operands, hence the name "ternary." It’s often used as a
    shorthand for simple <span class="font-semibold">if-else</span> conditions.
  </p>

  <!-- Syntax Section -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Syntax:</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >condition ? expressionIfTrue : expressionIfFalse;</code>
    </pre>
    <p class="mt-2">
      <span class="font-semibold">condition</span>: A boolean expression that is evaluated.
    </p>
    <p class="mt-2">
      <span class="font-semibold">expressionIfTrue</span>: The expression that will be executed if the condition is true.
    </p>
    <p class="mt-2">
      <span class="font-semibold">expressionIfFalse</span>: The expression that will be executed if the condition is false.
    </p>
  </div>
   <!-- Example 1: Basic Usage -->
   <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 1: Basic Usage</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let age: number = 18;<br>
      let message: string = age >= 18 ? "You are an adult." : "You are a minor.";<br>
      console.log(message);  // Output: "You are an adult."</code>
    </pre>
    <p class="mt-2">
      If <span class="font-semibold">age >= 18</span> is true, <span class="font-semibold">message</span> will be set to
      <span class="font-semibold">"You are an adult."</span>
    </p>
    <p class="mt-2">
      If <span class="font-semibold">age >= 18</span> is false, <span class="font-semibold">message</span> will be set to
      <span class="font-semibold">"You are a minor."</span>
    </p>
  </div>

  <!-- Example 2: Assigning Values Conditionally -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 2: Assigning Values Conditionally</h2>
    <p class="mb-4">
      The ternary operator is often used to assign values based on conditions, especially for simple logic.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let isAuthenticated: boolean = true;<br>
      let greeting: string = isAuthenticated ? "Welcome back!" : "Please log in.";<br>
      console.log(greeting);  // Output: "Welcome back!"</code>
    </pre>
  </div>
  <!
  <!-- Example 3: Ternary Operator in JSX -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 3: Using Ternary Operator in JSX (React with TypeScript)</h2>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >const loggedIn: boolean = true;<br><br>
      return (<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{'{'}}loggedIn ? &lt;p&gt;Welcome User!&lt;/p&gt; : &lt;p&gt;Please sign in&lt;/p&gt; {{'}'}};<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
      );</code>
    </pre>
    <p class="mt-2">
      You can use the ternary operator in JSX to render different UI elements conditionally.
    </p>
  </div>

  <!-- Example 4: Nesting Ternary Operators -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 4: Nesting Ternary Operators</h2>
    <p class="mb-4">
      Although nesting ternary operators is possible, it can reduce code readability, so it’s recommended to avoid deep
      nesting.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >let score: number = 75;<br>
      let grade: string = score >= 90 ? "A" : score >= 75 ? "B" : "C";<br>
      console.log(grade);  // Output: "B"</code>
    </pre>
    <p class="mt-2">
      In this example:
    </p>
    <ul class="list-disc ml-6">
      <li class="my-2">
        If <span class="font-semibold">score >= 90</span>, <span class="font-semibold">grade</span> is "A".
      </li>
      <li class="my-2">
        Otherwise, if <span class="font-semibold">score >= 75</span>, <span class="font-semibold">grade</span> is "B".
      </li>
      <li class="my-2">Otherwise, <span class="font-semibold">grade</span> is "C".</li>
    </ul>
  </div>

  <!-- Key Points Section -->
<!-- Key Points Section -->
<div class="mb-6">
  <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
  <ul class="list-disc ml-6">
    <li class="my-2">
      The ternary operator is best used for simple conditional expressions.
    </li>
    <li class="my-2">
      For complex logic, using <span class="font-semibold">if-else</span> statements might improve readability.
    </li>
    <li class="my-2">
      It is a powerful tool for writing concise code, especially in inline scenarios like JSX, or when assigning
      values based on conditions.
    </li>
  </ul>
</div>

</div> 

}@case(10){
  <div class="p-6 max-w-3xl mx-auto bg-white rounded-xl shadow-md space-y-4">
    <h1 class="text-2xl font-bold text-blue-800">Type Assertions in TypeScript</h1>
    <p class="text-gray-700">
      Type assertions in TypeScript are a way to tell the TypeScript compiler to treat a variable as a different type than what it is initially inferred as or declared. Type assertions can be used when you're certain about the type of a value but TypeScript is unable to infer it.
    </p>
  
    <h2 class="text-xl font-semibold text-blue-800">Two Syntaxes for Type Assertions:</h2>
  
    <div class="space-y-2">
      <h3 class="font-semibold text-lg text-blue-700">1. Using the <span class="text-red-500">as</span> keyword (recommended):</h3>
      <pre class="bg-gray-100 p-4 rounded-md">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >let someValue: unknown = "Hello, World!";<br />let strLength: number = (someValue as string).length;</code>
      </pre>
  
      <h3 class="font-semibold text-lg text-blue-700">2. Using angle-bracket syntax:</h3>
      <pre class="bg-gray-100 p-4 rounded-md">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >let someValue: unknown = "Hello, World!";<br />let strLength: number = (&lt;string&gt;someValue).length;</code>
      </pre>
  
      <p class="text-gray-600">
        <span class="font-bold">Note:</span> The angle-bracket syntax cannot be used in <span class="text-purple-600">.tsx</span> files (React files) because it conflicts with JSX syntax, so the <span class="text-red-500">as</span> syntax is preferred, especially when working with React.
      </p>
    </div>
  
    <h2 class="text-xl font-semibold text-blue-800">Key Points:</h2>
    <ul class="list-disc pl-6 text-gray-700">
      <li>Type assertions do not perform any runtime type checks, they only affect the compile-time type checking.</li>
      <li>Type assertions should only be used when you are confident about the type of the value.</li>
      <li>Type assertions can help when dealing with legacy code, third-party libraries, or when TypeScript cannot infer a specific type.</li>
    </ul>
  
    <h2 class="text-xl font-semibold text-blue-800">Example Usage:</h2>
    <pre class="bg-gray-100 p-4 rounded-md" >
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >// Example with DOM element<br />const inputElement = document.getElementById("myInput") as HTMLInputElement;<br />inputElement.value = "Typed value";</code>
    </pre>
  
    <p class="text-gray-700">
      Without type assertion, the type of <code>inputElement</code> would just be <code>HTMLElement | null</code>. With type assertion, we're telling TypeScript that we're sure it's an HTMLInputElement.
    </p>
  </div>

}@case(11){
  <div class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">Type Aliases in TypeScript</h1>
    
    <p class="mb-4">
      In TypeScript, <span class="font-semibold">Type Aliases</span> provide a way to define a custom name (alias) for a specific type. 
      They can simplify complex type definitions and make your code more readable and manageable. A type alias can be used for 
      primitive types, object types, union types, function signatures, or any other type.
    </p>
    <div class="mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Syntax:</h2>
      <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight  >type AliasName = ExistingType;</code>
      </pre>
    </div>
     <!-- Example 1: Basic Usage with Primitives -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 1: Basic Usage with Primitives</h2>
    <p class="mb-2">
      You can create a type alias for primitive types like <span class="font-semibold">string</span>, <span class="font-semibold">number</span>, etc.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type ID = number;<br>type Name = string;<br><br>
      let userID: ID = 123;<br>let userName: Name = "Alice";</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">ID</span> is an alias for <span class="font-semibold">number</span>, and <span class="font-semibold">Name</span> is an alias for <span class="font-semibold">string</span>.
    </p>
  </div>

  <!-- Example 2: Type Aliases with Objects -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 2: Type Aliases with Objects</h2>
    <p class="mb-2">
      You can also create type aliases for objects and use them to define the shape of the object.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type User =  {{'{'}}<br>&nbsp;&nbsp;id: number;<br>&nbsp;&nbsp;name: string;<br>&nbsp;&nbsp;age: number;<br> {{'}'}};<br><br>
      let user: User = {{'{'}}<br>&nbsp;&nbsp;id: 1,<br>&nbsp;&nbsp;name: "Alice",<br>&nbsp;&nbsp;age: 25<br> {{'}'}};</code>
    </pre>
    <p class="mt-2">
      Here, the <span class="font-semibold">User</span> type alias defines the structure of a user object.
    </p>
  </div>

  <!-- Example 3: Type Aliases with Union Types -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 3: Type Aliases with Union Types</h2>
    <p class="mb-2">
      Type aliases are often useful when dealing with <span class="font-semibold">union types</span> (a type that can be one of several types).
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Status = "success" | "error" | "loading";<br><br>
      let requestStatus: Status = "success";<br>requestStatus = "loading";<br>// requestStatus = "failed"; // Error</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">Status</span> is an alias for a union of string literals, allowing only three possible values.
    </p>
  </div>

  <!-- Example 4: Type Aliases with Functions -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 4: Type Aliases with Functions</h2>
    <p class="mb-2">
      You can use type aliases to describe function signatures.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type AddFunction = (a: number, b: number) => number;<br><br>
      let add: AddFunction = (x, y) => x + y;<br>console.log(add(5, 3));  // Output: 8</code>
    </pre>
    <p class="mt-2">
      In this example, <span class="font-semibold">AddFunction</span> is a type alias for a function that takes two <span class="font-semibold">number</span> arguments and returns a <span class="font-semibold">number</span>.
    </p>
  </div>

  <!-- Example 5: Type Aliases with Tuples -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 5: Type Aliases with Tuples</h2>
    <p class="mb-2">
      Type aliases can also be used for tuples, which are fixed-length arrays with specific types at each index.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Point = [number, number];<br><br>
      let point: Point = [10, 20];</code>
    </pre>
    <p class="mt-2">
      Here, <span class="font-semibold">Point</span> is an alias for a tuple containing two <span class="font-semibold">number</span> values.
    </p>
  </div>

  <!-- Example 6: Type Aliases with Optional and Read-Only Properties -->
  <div class="mb-6">
    <h2 class="text-xl font-semibold text-blue-700">Example 6: Type Aliases with Optional and Read-Only Properties</h2>
    <p class="mb-2">
      You can create type aliases that include optional and read-only properties.
    </p>
    <pre class="bg-gray-100 rounded-lg p-4 my-2 text-sm">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >type Person =  {{'{'}}<br>&nbsp;&nbsp;name: string;<br>&nbsp;&nbsp;age?: number; // Optional<br>&nbsp;&nbsp;readonly id: number; // Read-only<br> {{'}'}};<br><br>
      let person: Person =  {{'{'}} name: "Alice", id: 1 {{'}'}};<br>person.age = 30;<br>// person.id = 2; // Error</code>
    </pre>
    <p class="mt-2">
      In this example, <span class="font-semibold">Person</span> has both optional and read-only properties.
    </p>
  </div>

 <!-- Key Points Section -->
 <div class="mb-6">
  <h2 class="text-xl font-semibold text-blue-700">Key Points:</h2>
  <ul class="list-disc ml-6">
    <li class="my-2">Type Aliases can represent complex types in a simpler and more readable form.</li>
    <li class="my-2">They are flexible and can be used for primitives, objects, union types, functions, tuples, and more.</li>
    <li class="my-2">
      Type aliases are not unique types, but just a way to create a name for a type. The alias does not create a new type, it just gives an existing type a new name.
    </li>
    <li class="my-2">
      Type aliases in TypeScript make your code easier to maintain and understand, especially in scenarios where the same structure or pattern is used multiple times.
    </li>
  </ul>
</div>
    </div>
    
}@case(12){
  <div class="p-6 bg-gray-100">
    <h1 class="text-2xl font-bold mb-4">Understanding Interfaces in TypeScript</h1>
  
    <p class="mb-4">
      In TypeScript, interfaces are used to define the structure of objects, classes, and functions. An interface acts as a contract that a class or an object must adhere to. It defines the types of properties and methods an object should have without providing the implementation. Interfaces promote strong typing, making code more predictable and easier to maintain.
    </p>
  
    <h2  class="text-xl font-semibold text-blue-700">Syntax</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface InterfaceName {{'{'}}
      property1: type;
      property2: type;
      method1(param: type): returnType;
      {{'}'}}
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 1: Basic Object Structure</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Person{{'{'}}
      name: string;
      age: number;
      greet(): void;
    {{'}'}}
  
  const person: Person = {{'{'}}
      name: "John",
      age: 30,
      greet(){{'{'}}
          console.log('Hello, my name is ' + this.name);
          {{'}'}}
    {{'}'}};
  
  person.greet();  // Output: Hello, my name is John.
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 2: Optional Properties</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Car {{'{'}}
      make: string;
      model: string;
      year?: number;
    {{']'}}
  
  const car1: Car ={{'{'}} make: "Toyota", model: "Camry" {{'}'}};
  const car2: Car = {{'{'}} make: "Tesla", model: "Model S", year: 2020 {{'}'}};
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 3: Readonly Properties</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface User{{'{'}}
      readonly id: number;
      name: string;
    {{'}'}}
  
  const user: User ={{'{'}} id: 1, name: "Alice" {{'}'}};
  // user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 4: Extending Interfaces</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Animal {{'{'}}
      name: string;
      {{'}'}}
  
  interface Dog extends Animal {{'{'}}
      breed: string;
      {{'}'}}
  
  const myDog: Dog ={{'{'}} name: "Buddy", breed: "Golden Retriever"{{'}'}};
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 5: Function Types</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface MathOperation {{'{'}}
      (a: number, b: number): number;
    {{'}'}}
  
  const add: MathOperation = (x, y) => x + y;
  console.log(add(5, 10)); // Output: 15
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Example 6: Indexable Types</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface StringArray {{'{'}}
      [index: number]: string;
    {{'}'}}
  
  let myArray: StringArray = ["Hello", "World"];
  console.log(myArray[0]); // Output: Hello
      </code>
    </pre>
  
    <h2 class="text-xl font-semibold text-blue-700">Example 7: Class Implementing an Interface</h2>
    <pre class="bg-gray-900 text-white p-4 rounded mb-4">
      <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  interface Shape {{'{'}}
      area(): number;
    {{'}'}}
  
  class Circle implements Shape {{'{'}}
      constructor(public radius: number) {{'{}'}}
      area() {{'{'}}
          return Math.PI * this.radius * this.radius;
      {{'}'}}
    {{'}'}}
  
  const circle = new Circle(5);
  console.log(circle.area());  // Output: 78.53981633974483
      </code>
    </pre>
  
    <h2  class="text-xl font-semibold text-blue-700">Benefits of Using Interfaces</h2>
    <ul class="list-disc list-inside mb-4">
      <li>Type Safety: Interfaces enforce a structure, helping avoid runtime errors.</li>
      <li>Code Reusability: Interfaces can be reused across different classes or functions.</li>
      <li>Abstraction: Interfaces provide a way to define the expected structure of data, decoupling the code from concrete implementations.</li>
    </ul>
  
    <h2  class="text-xl font-semibold text-blue-700">Interfaces vs. Types</h2>
    <p>
      Though interfaces and types can be used similarly, interfaces are typically preferred for defining object shapes, while type can be used for unions, intersections, or more complex types.
    </p>
  </div>

}@case(13){
  <div class="container mx-auto p-6 bg-gray-100">
    <h1 class="text-3xl font-bold text-center mb-8">Classes in TypeScript</h1>
  
    <!-- Introduction Section -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Introduction to TypeScript Classes</h2>
      <p class="text-gray-700 mb-4">
        TypeScript classes are a powerful way to create reusable object blueprints. They contain properties, methods,
        constructors, and more.
      </p>
      <p class="text-gray-700">
        In TypeScript, we can define classes that follow OOP principles such as encapsulation, inheritance, and
        polymorphism. Below are some of the key features of TypeScript classes:
      </p>
    </div>
  
    <!-- Basic Class Structure -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Basic Class Structure</h2>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Person {{'{'}}
            name: string;
            age: number;
  
            constructor(name: string, age: number) {{'{'}}
              this.name = name;
              this.age = age;
            {{'}'}}
  
            greet(): void {{'{'}}
              console.log(`Hello, my name is ${{'{'}}this.name{{'}'}} and I am ${{'{'}}this.age{{'}'}} years old.`);
            {{'}'}}
          {{'}'}}
  
          const person1 = new Person("John", 30);
          person1.greet(); // Output: Hello, my name is John and I am 30 years old.
        </code>
      </pre>
    </div>
  
    <!-- Visibility Modifiers -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Visibility Modifiers</h2>
      <p class="text-gray-700 mb-4">
        You can control the visibility of class members (properties and methods) using <code>public</code>,
        <code>private</code>, or <code>protected</code>.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Employee {{'{'}}
            private salary: number;
  
            constructor(salary: number) {{'{'}}
              this.salary = salary;
            {{'}'}}
  
            public getSalary(): number {{'{'}}
              return this.salary;
            {{'}'}}
          {{'}'}}
        </code>
      </pre>
    </div>
  
    <!-- Inheritance -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Inheritance</h2>
      <p class="text-gray-700 mb-4">
        TypeScript classes support inheritance, where one class can extend another class.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class Animal {{'{'}}
            constructor(public name: string) {{'{}'}}
  
            move(): void {{'{'}}
              console.log(`$ {{'{'}}this.name{{'}'}} is moving`);
            {{'}'}}
          {{'}'}}
  
          class Dog extends Animal {{'{'}}
            bark(): void {{'{'}}
              console.log(`${{'{'}}this.name{{'}'}} is barking`);
            {{'}'}}
          {{'}'}}
  
          const dog = new Dog('Buddy');
          dog.move(); // Buddy is moving
          dog.bark(); // Buddy is barking
        </code>
      </pre>
    </div>
  
    <!-- Static Members -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Static Members</h2>
      <p class="text-gray-700 mb-4">
        Static members are accessible using the class name itself, not through an instance.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto mb-4">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          class MathHelper {{'{'}}
            static PI: number = 3.14159;
  
            static areaOfCircle(radius: number): number {{'{'}}
              return MathHelper.PI * radius * radius;
            {{'}'}}
          {{'}'}}
  
          console.log(MathHelper.areaOfCircle(5)); // Output: 78.53975
        </code>
      </pre>
    </div>
  
    <!-- Conclusion -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">Conclusion</h2>
      <p class="text-gray-700">
        TypeScript classes provide a robust way to build object-oriented applications. With support for inheritance,
        access modifiers, static members, and more, TypeScript makes it easy to write clean, maintainable code.
      </p>
    </div>
  </div>

}@case(14){
  <div class="container mx-auto p-6 bg-gray-100">
    <h1 class="text-3xl font-bold text-center mb-8">Modules in TypeScript</h1>
  
    <!-- Exporting Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2  class="text-xl font-semibold text-blue-700">1. Exporting in TypeScript</h2>
      <p class="text-gray-700 mb-4">
        In TypeScript, you can use <span class="font-bold">Named Exports</span> or <span class="font-bold">Default Exports</span> to make classes, functions, or variables available to other modules.
      </p>
      <div class="mb-4">
        <h3  class="text-xl font-semibold text-blue-500">Named Exports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // mathUtils.ts
            export function add(a: number, b: number): number{{'{'}}
                return a + b;
              {{'}'}}
  
            export function subtract(a: number, b: number): number {{'{'}}
                return a - b;
            {{'}'}}
          </code>
        </pre>
      </div>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Default Exports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // logger.ts
            export default class Logger{{'{'}}
                log(message: string): void{{'{'}}
                    console.log(message);
                {{'}'}}
              {{'}'}}
          </code>
        </pre>
      </div>
    </div>
  
    <!-- Importing Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">2. Importing in TypeScript</h2>
      <p class="text-gray-700 mb-4">
        You can import modules using the <span class="font-bold">import</span> statement. TypeScript supports both Named Imports and Default Imports.
      </p>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Named Imports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // app.ts
            import {{'{'}} add, subtract {{'}'}} from './mathUtils';
  
            console.log(add(5, 3));  // 8
            console.log(subtract(5, 3));  // 2
          </code>
        </pre>
      </div>
      <div class="mb-4">
        <h3 class="text-xl font-semibold text-blue-500">Default Imports Example</h3>
        <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
          <code class="font-mono text-sm" class="language-javascript" codeHighlight >
            // app.ts
            import Logger from './logger';
  
            const logger = new Logger();
            logger.log('Hello, World!');
          </code>
        </pre>
      </div>
    </div>
  
    <!-- Re-exporting Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">3. Re-exporting Modules</h2>
      <p class="text-gray-700 mb-4">
        You can re-export modules to simplify imports in larger projects.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // utils.ts
          export {{'{'}} add, subtract {{'}'}} from './mathUtils';
          export {{'{'}} default as Logger {{'}'}} from './logger';
        </code>
      </pre>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // app.ts
          import{{'{'}} add, Logger {{'}'}} from './utils';
  
          const logger = new Logger();
          logger.log('Adding numbers');
          console.log(add(5, 7));
        </code>
      </pre>
    </div>
  
    <!-- Organizing Code in Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">4. Organizing Code into Modules</h2>
      <p class="text-gray-700 mb-4">
        TypeScript allows you to organize your code into separate modules. Here’s an example of how you can structure your code:
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          src/
            └── math/
                ├── add.ts
                ├── subtract.ts
            └── logger/
                └── logger.ts
            └── app.ts
        </code>
      </pre>
    </div>
  
    <!-- Module Resolution -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">5. Module Resolution</h2>
      <p class="text-gray-700 mb-4">
        TypeScript uses Node.js module resolution strategy by default. You can customize how modules are resolved using the <code >tsconfig.json</code> file.
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          {{'{'}}
            "compilerOptions": {{'{'}}
              "module": "commonjs",
              "target": "es6",
              "baseUrl": "./src",
              "paths": {{'{'}}
                "*": ["node_modules/*", "src/types/*"]
              {{'}'}}
            {{'}'}}
          {{'}'}}
        </code>
      </pre>
      
    </div>
  
    <!-- Importing External Modules -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">6. Importing External Modules</h2>
      <p class="text-gray-700 mb-4">
        You can import external modules from npm packages in TypeScript. Here’s how you can import and use Lodash:
      </p>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          npm install lodash
          npm install {{'@'}}types/lodash
        </code>
      </pre>
      <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
          // app.ts
          import * as _ from 'lodash';
  
          const arr = [1, 2, 3, 4];
          console.log(_.shuffle(arr));  // Output: Shuffled array
        </code>
      </pre>
    </div>
  
    <!-- Conclusion -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <h2 class="text-xl font-semibold text-blue-700">Conclusion</h2>
      <p class="text-gray-700">
        Modules in TypeScript provide a clean way to organize and manage code. By using named exports, default exports, and proper module resolution, you can create maintainable, scalable applications.
      </p>
    </div>
  </div> 

}@case(15){
  <div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg space-y-4">
    <h1 class="text-3xl font-bold text-blue-400">Generics in TypeScript</h1>
    <p class="text-lg">
      Generics in TypeScript allow you to create reusable components, functions, or classes that can work with a variety of data types, while still providing type safety. They enable you to write code that is flexible and reusable, without sacrificing the benefits of static typing.
    </p>
  
    <h2  class="text-xl font-semibold text-blue-700">Why Use Generics?</h2>
    <p class="text-lg">
      Without generics, you might have to create multiple versions of the same function or class to handle different data types, leading to repetitive code. Generics help you avoid that by making your code more abstract, while still preserving the type information.
    </p>
  
    <h2 class="text-2xl font-semibold text-blue-700">Syntax of Generics</h2>
    <p class="text-lg">
      Generics are typically denoted by angle brackets <code class="text-indigo-500">&lt;&gt;</code>, and the generic type is represented by a placeholder (often <code class="text-indigo-500">T</code>, but you can name it anything).
    </p>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Function</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function identity&lt;T&gt;(arg: T): T {{'{'}}
    return arg; 
  {{'}'}}
  
  let output1 = identity&lt;string&gt;("Hello, TypeScript!"); // Explicitly passing type
  let output2 = identity(42); // Type inferred
        </code>
      </pre>
      <p class="text-lg">
        Here, <code class="text-indigo-500">T</code> is a placeholder for the type that will be provided when the function is called. TypeScript infers the type automatically based on the passed argument (42 in the second case).
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Class</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  class GenericNumber&lt;T&gt; {{'{'}} 
    zeroValue: T; 
    add: (x: T, y: T) =&gt; T; 
  {{'}'}}
  
  let myGenericNumber = new GenericNumber&lt;number&gt;(); 
  myGenericNumber.zeroValue = 0; 
  myGenericNumber.add = function (x, y) {{'{'}} return x + y; {{'}'}};
        </code>
      </pre>
      <p class="text-lg">
        In this example, <code class="text-indigo-500">GenericNumber</code> is a class that works with any data type <code class="text-indigo-500">T</code>. It allows you to define behavior for that type (such as the <code class="text-indigo-500">add</code> function).
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Example: Generic Interface</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight > 
  interface Pair&lt;T, U&gt; {{'{'}}
    first: T; 
    second: U; 
  {{'}'}}
  
  let pair: Pair&lt;string, number&gt; = {{'{'}} first: "hello", second: 42 {{'}'}};
        </code>
      </pre>
      <p class="text-lg">
        Here, the <code class="text-indigo-500">Pair</code> interface uses two generic types, <code class="text-indigo-500">T</code> and <code class="text-indigo-500">U</code>, allowing it to work with a combination of different types.
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Generic Constraints</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function loggingIdentity&lt;T extends {{'{'}} length: number {{'}'}}&gt;(arg: T): T {{'{'}} 
    console.log(arg.length); // Now we know 'arg' has a .length property 
    return arg; 
  {{'}'}}
  
  loggingIdentity("Hello");
        </code>
      </pre>
      <p class="text-lg">
        In this example, the generic <code class="text-indigo-500">T</code> is constrained to types that have a <code class="text-indigo-500">length</code> property, which allows you to safely access length within the function.
      </p>
    </div>
  
    <div class="bg-gray-100 p-4 rounded-lg">
      <h3 class="text-xl font-semibold text-blue-700">Default Types</h3>
      <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
        <code class="font-mono text-sm" class="language-javascript" codeHighlight >
  function createArray&lt;T = string&gt;(length: number, value: T): T[] {{'{'}}
    return Array(length).fill(value); 
  {{'}'}}
  
  let stringArray = createArray(3, "x"); // ['x', 'x', 'x']
  let numberArray = createArray&lt;number&gt;(3, 42); // [42, 42, 42]
        </code>
      </pre>
    </div>
  
    <h2 class="text-2xl font-semibold text-blue-700">Key Takeaways:</h2>
    <ul class="list-disc list-inside text-lg">
      <li>Generics are a way to create flexible, reusable, and type-safe code.</li>
      <li>Type inference allows TypeScript to figure out the types based on how generics are used.</li>
      <li>Constraints can limit the types a generic can accept.</li>
      <li>Default values for generics allow for fallback types when none are provided.</li>
      <li>Generics make TypeScript more powerful, enabling you to write code that's adaptable to many situations without losing type safety.</li>
    </ul>
  </div>
   
}@case(16){
  <div class="bg-gray-100 p-8 rounded-lg shadow-md max-w-4xl mx-auto my-10">
    <h1 class="text-3xl font-bold text-center text-indigo-600 mb-6">Namespaces in TypeScript</h1>
  
    <div class="space-y-6">
      <!-- Overview Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Introduction</h2>
        <p class="text-gray-700">
          Namespaces in TypeScript are a way to group related code together under a single name to avoid naming conflicts and to organize code better. They are primarily used for logical grouping and encapsulating code into a distinct module-like structure.
        </p>
        <p class="text-gray-700">
          However, with the advent of ECMAScript modules, the usage of namespaces has become less common in modern TypeScript projects.
        </p>
      </section>
  
      <!-- Syntax Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Syntax of a Namespace</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap"  class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace MyNamespace {{'{'}}
    export class MyClass {{'{'}}
      constructor(public name: string) {{'{}'}}
      
      public sayHello(): void {{'{'}}
        console.log(`Hello, ${{'{'}}this.name{{'}'}}`);
      {{'}'}}
    {{'}'}}
  
    export function greet(): void {{'{'}}
      console.log("Greetings from MyNamespace!");
      {{'}'}}
    {{'}'}}
          </code>
        </pre>
      </section>
  
      <!-- Usage Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Using a Namespace</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  let obj = new MyNamespace.MyClass("TypeScript");
  obj.sayHello(); // Output: Hello, TypeScript
  
  MyNamespace.greet(); // Output: Greetings from MyNamespace!
          </code>
        </pre>
      </section>
  
      <!-- Nested Namespaces Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Nested Namespaces</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace OuterNamespace {{'{'}}
    export namespace InnerNamespace {{'{'}}
      export class AnotherClass {{'{'}}
        greet(): void {{'{'}}
          console.log("Hello from InnerNamespace!");
          {{'}'}}
        {{'}'}}
      {{'}'}}
    {{'}'}}
  
  let innerObj = new OuterNamespace.InnerNamespace.AnotherClass();
  innerObj.greet(); // Output: Hello from InnerNamespace!
          </code>
        </pre>
      </section>
  
      <!-- Namespace Merging Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Namespace Merging</h2>
        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-auto">
          <code class="whitespace-pre-wrap" class="font-mono text-sm" class="language-javascript" codeHighlight >
  namespace MyNamespace {{'{'}}
    export const foo = "foo;
    {{'}'}}
  
  namespace MyNamespace {{'{'}}
    export function bar() {{'{'}}
      console.log("bar");
      {{'}'}}
    {{'}'}}
  
  console.log(MyNamespace.foo); // Output: foo
  MyNamespace.bar(); // Output: bar
          </code>
        </pre>
      </section>
  
      <!-- Conclusion Section -->
      <section>
        <h2 class="text-2xl font-semibold text-blue-800 mb-4">Conclusion</h2>
        <p class="text-gray-700">
          In modern TypeScript, using ECMAScript modules (via <code>import</code> and <code>export</code>) is preferred as it aligns with the standard JavaScript module system. However, namespaces can still be useful in specific cases like legacy systems or global libraries.
        </p>
      </section>
    </div>
  </div>
  
}@case(17){
<!-- app.component.html -->
<div class="container mx-auto p-5">
  <h1 class="text-2xl font-bold mb-4">Basic Functions of TypeScript</h1>

  <div class="space-y-6">
    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">1. Type Annotations</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let age: number = 30;
let name: string = "Alice";</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2 class="text-xl font-semibold text-blue-700">2. Interfaces</h2>
    <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>interface Person {{'{'}}
  name: string;
  age: number;
{{'}'}}

const person: Person = {{'{'}}
  name: "Bob",
  age: 25
{{'}'}};</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">3. Classes and Inheritance</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>class Animal {{'{'}}
  constructor(public name: string) {{'{}'}}

  speak(): void {{'{'}}
    console.log(\`\${{'{'}}this.name{{'}'}} makes a noise.\`);
  {{'}'}}
{{'}'}}

class Dog extends Animal {{'}'}}
  speak(): void {{'{'}}
    console.log(\`\${{'{'}}this.name{{'}'}} barks.\`);
  {{'}'}}
{{'}'}}

const dog = new Dog("Rex");
dog.speak(); // Rex barks.</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">4. Generics</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>function identity&lt;T&gt;(arg: T): T {{'{'}}
  return arg;
  {{'}'}}

let output = identity&lt;string&gt;("Hello"); // Output: "Hello"</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">5. Union and Intersection Types</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let id: number | string;
id = 101;   // valid
id = "101"; // valid

type Admin = {{'{'}} name: string; admin: true {{'}'}};
type User = {{'{'}} name: string; admin?: false {{'}'}};
type Person = Admin & User; // intersection type</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">6. Enums</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>enum Direction {{'{'}}
  Up = 1,
  Down,
  Left,
  Right,
  {{'}'}}

let move: Direction = Direction.Up; // move is 1</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">7. Type Aliases</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>type StringOrNumber = string | number;
let value: StringOrNumber = "hello"; // valid
value = 42; // valid</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">8. Type Assertion</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>let someValue: any = "This is a string";
let strLength: number = (someValue as string).length; // Type assertion</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">9. Optional Properties and Methods</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>interface User {{'{'}}
  id: number;
  name: string;
  age?: number; // Optional
  {{'}'}}

const user: User = {{'{'}} id: 1, name: "Alice" {{'}'}}; // valid without age</code></pre>
    </div>

    <div class="bg-gray-100 p-4 rounded-lg shadow">
      <h2  class="text-xl font-semibold text-blue-700">10. Modules</h2>
      <pre class="bg-gray-200 p-3 rounded"><code lass="font-mono text-sm" class="language-javascript" codeHighlight>// In module1.ts
export const PI = 3.14;

// In module2.ts
import {{'{'}} PI {{'}'}} from './module1';
console.log(PI);</code></pre>
    </div>
  </div>
</div>

}
}