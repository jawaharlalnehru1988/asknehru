import { Component, inject } from "@angular/core";

export interface ISpringContent {
    title: string;
    content: string;
}

export class SpringContent {
    mainContent: ISpringContent[] = [
        {title: "Intro", content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot is an open-source Java framework designed to simplify the development of 
    stand-alone, production-ready Spring applications. It provides a convention-over-configuration 
    approach, reducing boilerplate code and enabling developers to focus on business logic.
  </p>

  <h3 style="color: #16a085;">Key Features of Spring Boot:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Auto-configuration to reduce manual setup.</li>
    <li>Embedded servers like Tomcat, Jetty, and Undertow.</li>
    <li>Microservices-friendly architecture.</li>
    <li>Spring Boot Starter dependencies for easy integration.</li>
    <li>Spring Boot Actuator for monitoring and management.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Spring Boot?</h3>
  <p style="color: #2c3e50;">
    Spring Boot streamlines the development of Java applications by eliminating XML configuration 
    and simplifying dependency management. It is widely used for building RESTful APIs, microservices, 
    and cloud-native applications.
  </p>

  <h3 style="color: #2980b9;">Example: Basic Spring Boot Application</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;

      @SpringBootApplication
      public class MySpringBootApp {
          public static void main(String[] args) {
              SpringApplication.run(MySpringBootApp.class, args);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The above code is a minimal Spring Boot application that starts an embedded server 
    and runs the application.
  </p>
</div>
`},
{title: "Controller Basics", content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Boot Controller Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, a Controller is responsible for handling HTTP requests and returning responses. 
    It is part of the Spring MVC framework and plays a key role in developing RESTful APIs.
  </p>

  <h3 style="color: #16a085;">Key Features of a Controller:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Handles HTTP requests (GET, POST, PUT, DELETE).</li>
    <li>Uses '@RestController' or '@Controller' annotations.</li>
    <li>Returns JSON, HTML, or other response types.</li>
    <li>Supports request parameters and path variables.</li>
    <li>Works seamlessly with service layers and repositories.</li>
  </ul>

  <h3 style="color: #e67e22;">Difference Between '@Controller' and '@RestController'</h3>
  <p style="color: #2c3e50;">
    - <strong>'@Controller'</strong>: Used for traditional MVC-based web applications that return HTML views.<br>
    - <strong>'@RestController'</strong>: A specialization of '@Controller' that automatically converts responses to JSON.
  </p>

  <h3 style="color: #2980b9;">Example: Basic Spring Boot Controller</h3>
  <pre style="background: #2c3e50; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto; color: white;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class HelloController {
      
          @GetMapping("/hello")
          public String sayHello() {
              return "Hello, Spring Boot!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Explanation of the Code:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong> '@RestController'</strong>: Marks the class as a REST API controller.</li>
    <li><strong> '@RequestMapping("/api")'</strong>: Defines the base URL for the controller.</li>
    <li><strong> \`@GetMapping("/hello")\`</strong>: Maps HTTP GET requests to the \`sayHello()\` method.</li>
    <li>The method returns a simple text response: "Hello, Spring Boot!".</li>
  </ul>

  <h3 style="color: #e67e22;">Running the Controller</h3>
  <p style="color: #2c3e50;">
    Start your Spring Boot application and open a browser or use Postman to access:<br>
    <code style="background: #ecf0f1; padding: 4px; border-radius: 3px; color: #2c3e50;">
      http://localhost:8080/api/hello
    </code>
  </p>

  <p style="color: #2c3e50;">
    You will see the response: <strong>"Hello, Spring Boot!"</strong>.
  </p>
</div>
`},
{
    title: "Spring @Controller", content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring <code>@Controller</code> Annotation</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Controller</code> annotation is used to define a class as a Spring MVC controller. 
    It is typically used for handling web requests and returning HTML views (as opposed to RESTful responses, 
    which use <code>@RestController</code>).
  </p>

  <h3 style="color: #16a085;">Key Features of <code>@Controller</code>:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Processes HTTP requests and returns views.</li>
    <li>Works with view templates like Thymeleaf, JSP, or FreeMarker.</li>
    <li>Uses <code>@RequestMapping</code> to map URLs to methods.</li>
    <li>Can pass data to the view using <code>Model</code> or <code>ModelAndView</code>.</li>
    <li>Supports form handling and validation.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using <code>@Controller</code> in a Spring Boot Application</h3>
  <pre style="background: #2c3e50; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto; color: white;">
    <code>
      import org.springframework.stereotype.Controller;
      import org.springframework.ui.Model;
      import org.springframework.web.bind.annotation.GetMapping;

      @Controller
      public class HomeController {

          @GetMapping("/home")
          public String homePage(Model model) {
              model.addAttribute("message", "Welcome to Spring Boot!");
              return "home"; // Returns the "home.html" or "home.jsp" view
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Explanation of the Code:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong><code>@Controller</code></strong>: Marks the class as a Spring MVC controller.</li>
    <li><strong><code>@GetMapping("/home")</code></strong>: Maps HTTP GET requests to the <code>homePage()</code> method.</li>
    <li><strong><code>Model model</code></strong>: Used to pass data to the view.</li>
    <li><strong><code>return "home"</code></strong>: Returns the view named <code>home</code> (resolved by a template engine like Thymeleaf).</li>
  </ul>

  <h3 style="color: #2980b9;">Thymeleaf View (home.html)</h3>
  <pre style="background: #2c3e50; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto; color: white;">
    <code>
      &lt;html&gt;
      &lt;body&gt;
          &lt;h1&gt;Spring Boot Home Page&lt;/h1&gt;
          &lt;p&gt;Message: [[\${message}]]&lt;/p&gt;
      &lt;/body&gt;
      &lt;/html&gt;
    </code>
  </pre>

  <h3 style="color: #e67e22;">When to Use <code>@Controller</code>?</h3>
  <p style="color: #2c3e50;">
    - Use <code>@Controller</code> when developing traditional web applications with server-side rendering.<br>
    - Use <code>@RestController</code> when building RESTful APIs that return JSON responses.
  </p>

  <h3 style="color: #16a085;">Running the Application</h3>
  <p style="color: #2c3e50;">
    Start the Spring Boot application and open:<br>
    <code style="background: #ecf0f1; padding: 4px; border-radius: 3px; color: #2c3e50;">
      http://localhost:8080/home
    </code>
  </p>
  
  <p style="color: #2c3e50;">
    This will display the HTML view with the message from the controller.
  </p>
</div>
`
},
{
    title: "Spring @RestController", content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring <code>@RestController</code> Annotation</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@RestController</code> annotation is used to create RESTful web services. 
    It simplifies the development of APIs by combining <code>@Controller</code> and <code>@ResponseBody</code>, 
    ensuring that data is returned as JSON or XML instead of rendering views.
  </p>

  <h3 style="color: #16a085;">Key Features of <code>@RestController</code>:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Used for building RESTful APIs.</li>
    <li>Returns data as JSON or XML instead of HTML views.</li>
    <li>Eliminates the need for <code>@ResponseBody</code> on each method.</li>
    <li>Supports request handling using <code>@GetMapping</code>, <code>@PostMapping</code>, etc.</li>
    <li>Can work with request parameters and path variables.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using <code>@RestController</code> in a Spring Boot Application</h3>
  <pre style="background: #2c3e50; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto; color: white;">
    <code>
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class UserController {

          @GetMapping("/user")
          public String getUser() {
              return "Hello, User!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Explanation of the Code:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong><code>@RestController</code></strong>: Marks the class as a REST API controller.</li>
    <li><strong><code>@RequestMapping("/api")</code></strong>: Defines the base URL for the controller.</li>
    <li><strong><code>@GetMapping("/user")</code></strong>: Maps HTTP GET requests to the <code>getUser()</code> method.</li>
    <li>The method returns a simple text response: <code>"Hello, User!"</code>.</li>
  </ul>

  <h3 style="color: #2980b9;">Returning JSON Data</h3>
  <p style="color: #2c3e50;">
    Instead of returning a string, we can return JSON using a model class:
  </p>
  <pre style="background: #2c3e50; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto; color: white;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class UserController {

          @GetMapping("/user")
          public User getUser() {
              return new User(1, "John Doe", "john@example.com");
          }
      }

      class User {
          private int id;
          private String name;
          private String email;

          public User(int id, String name, String email) {
              this.id = id;
              this.name = name;
              this.email = email;
          }

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">When to Use <code>@RestController</code>?</h3>
  <p style="color: #2c3e50;">
    - Use <code>@RestController</code> when developing RESTful APIs.<br>
    - Use <code>@Controller</code> when returning HTML views using a template engine like Thymeleaf.
  </p>

  <h3 style="color: #e67e22;">Testing the API</h3>
  <p style="color: #2c3e50;">
    Start the Spring Boot application and access the API in a browser or Postman:
  </p>
  <p style="background: #ecf0f1; padding: 4px; border-radius: 3px; color: #2c3e50;">
    <strong>URL:</strong> <code>http://localhost:8080/api/user</code>
  </p>

  <p style="color: #2c3e50;">
    The response will be a JSON object:
  </p>
  <pre style="background: #2c3e50; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto; color: white;">
    <code>
      {
          "id": 1,
          "name": "John Doe",
          "email": "john@example.com"
      }
    </code>
  </pre>
</div>
`
},
{
  title: `Request Mapping`, content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Request Mapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Request Mapping in Spring Boot is used to map HTTP requests to specific handler methods 
    within a controller. It allows developers to define URL patterns and handle different 
    HTTP methods like GET, POST, PUT, DELETE, etc., efficiently.
  </p>

  <h3 style="color: #16a085;">Annotations for Request Mapping:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>@RequestMapping</strong> - Generic mapping for all HTTP methods.</li>
    <li><strong>@GetMapping</strong> - Handles HTTP GET requests.</li>
    <li><strong>@PostMapping</strong> - Handles HTTP POST requests.</li>
    <li><strong>@PutMapping</strong> - Handles HTTP PUT requests.</li>
    <li><strong>@DeleteMapping</strong> - Handles HTTP DELETE requests.</li>
    <li><strong>@PatchMapping</strong> - Handles HTTP PATCH requests.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using @RequestMapping</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      
      @RestController
      @RequestMapping("/api")
      public class RequestMappingController {
          
          @GetMapping("/hello")
          public String sayHello() {
              return "Hello, Spring Boot!";
          }
      }
    </code>
  </pre>
  
  <p style="color: #2c3e50;">
    In this example, the <code>@RequestMapping("/api")</code> annotation maps all requests under 
    <code>/api</code>, while <code>@GetMapping("/hello")</code> specifically handles GET requests 
    to <code>/api/hello</code>.
  </p>

  <h3 style="color: #2980b9;">Advanced Request Mapping Features</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Path Variables:</strong> Use <code>@PathVariable</code> to capture values from the URL.</li>
    <li><strong>Request Parameters:</strong> Use <code>@RequestParam</code> to handle query parameters.</li>
    <li><strong>Consumes and Produces:</strong> Define supported content types with <code>consumes</code> and <code>produces</code>.</li>
    <li><strong>Multiple URL Patterns:</strong> A method can handle multiple endpoints.</li>
  </ul>

  <h3 style="color: #c0392b;">Example: Using Path Variables</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.PathVariable;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      
      @RestController
      @RequestMapping("/user")
      public class UserController {
          
          @GetMapping("/{id}")
          public String getUserById(@PathVariable("id") int userId) {
              return "User ID: " + userId;
          }
      }
    </code>
  </pre>
  
  <p style="color: #2c3e50;">
    Here, the <code>@PathVariable</code> annotation captures the user ID from the URL, allowing dynamic mapping.
  </p>
</div>
`
},
{
  title: `GetMapping`, content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @GetMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@GetMapping</code> annotation in Spring Boot is a specialized version of <code>@RequestMapping</code> 
    used to handle HTTP GET requests. It simplifies the process of defining endpoints for retrieving data from the server.
  </p>

  <h3 style="color: #16a085;">Why Use @GetMapping?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Specifically designed for handling GET requests.</li>
    <li>More readable and concise than <code>@RequestMapping</code>.</li>
    <li>Can be combined with <code>@RequestParam</code> and <code>@PathVariable</code> for dynamic request handling.</li>
    <li>Supports response customization using <code>produces</code> attribute.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Basic @GetMapping Usage</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      
      @RestController
      @RequestMapping("/api")
      public class GetMappingController {
          
          @GetMapping("/message")
          public String getMessage() {
              return "Welcome to Spring Boot!";
          }
      }
    </code>
  </pre>
  
  <p style="color: #2c3e50;">
    In this example, the <code>@GetMapping("/message")</code> annotation maps HTTP GET requests to the <code>/api/message</code> endpoint.
  </p>

  <h3 style="color: #2980b9;">Using @GetMapping with @PathVariable</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.PathVariable;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      
      @RestController
      @RequestMapping("/users")
      public class UserController {
          
          @GetMapping("/{id}")
          public String getUserById(@PathVariable("id") int userId) {
              return "User ID: " + userId;
          }
      }
    </code>
  </pre>
  
  <p style="color: #2c3e50;">
    Here, <code>@PathVariable</code> is used to capture a dynamic value from the URL and return user details based on the provided ID.
  </p>

  <h3 style="color: #c0392b;">Using @GetMapping with @RequestParam</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RequestParam;
      import org.springframework.web.bind.annotation.RestController;
      
      @RestController
      @RequestMapping("/search")
      public class SearchController {
          
          @GetMapping("/product")
          public String searchProduct(@RequestParam("name") String productName) {
              return "Searching for product: " + productName;
          }
      }
    </code>
  </pre>
  
  <p style="color: #2c3e50;">
    In this case, <code>@RequestParam</code> is used to extract query parameters from the URL, making it useful for search functionalities.
  </p>
</div>
`
},
{
  title:`PostMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @PostMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>@PostMapping</code> is an annotation used to map HTTP POST requests to specific controller methods.
    It simplifies the creation of RESTful APIs by handling data submission from clients. This annotation is commonly used for 
    creating resources, such as adding new records in a database.
  </p>

  <h3 style="color: #16a085;">Key Features of @PostMapping:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Handles HTTP POST requests easily.</li>
    <li>Supports automatic JSON and form data binding.</li>
    <li>Works with request body data using <code>@RequestBody</code>.</li>
    <li>Integrates with validation mechanisms like <code>@Valid</code> or <code>@Validated</code>.</li>
    <li>Enhances API development by mapping URLs directly to handler methods.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use @PostMapping?</h3>
  <p style="color: #2c3e50;">
    The <code>@PostMapping</code> annotation is preferred over <code>@RequestMapping(method = RequestMethod.POST)</code>
    because it provides a more concise and readable way to handle POST requests. It is primarily used in RESTful web services
    where data needs to be sent from the client to the server.
  </p>

  <h3 style="color: #2980b9;">Example: Using @PostMapping in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @PostMapping("/create")
          public ResponseEntity<String> createUser(@RequestBody User user) {
              return ResponseEntity.ok("User " + user.getName() + " created successfully");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In the example above, the <code>createUser</code> method is mapped to the <code>/users/create</code> endpoint,
    handling POST requests. The request body is automatically converted into a <code>User</code> object.
  </p>

  <h3 style="color: #9b59b6;">Handling Form Data with @PostMapping</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @PostMapping("/submit")
      public ResponseEntity<String> handleFormSubmission(@RequestParam String name, @RequestParam int age) {
          return ResponseEntity.ok("Received form data: Name=" + name + ", Age=" + age);
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example shows how <code>@PostMapping</code> can handle form submissions using <code>@RequestParam</code> to extract individual values.
  </p>
</div>
`
},
{
   title: `PutMapping`, content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @PutMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>@PutMapping</code> is an annotation used to map HTTP PUT requests to specific controller methods.
    It is commonly used for updating existing resources in RESTful APIs, ensuring modifications are performed efficiently.
  </p>

  <h3 style="color: #16a085;">Key Features of @PutMapping:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Handles HTTP PUT requests.</li>
    <li>Used for updating existing resources.</li>
    <li>Works with request body data using <code>@RequestBody</code>.</li>
    <li>Supports validation with <code>@Valid</code> or <code>@Validated</code>.</li>
    <li>Enhances API development by providing clear request handling.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use @PutMapping?</h3>
  <p style="color: #2c3e50;">
    The <code>@PutMapping</code> annotation simplifies handling PUT requests compared to using <code>@RequestMapping(method = RequestMethod.PUT)</code>.
    It is primarily used for updating resources, ensuring that the API follows RESTful principles effectively.
  </p>

  <h3 style="color: #2980b9;">Example: Using @PutMapping in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @PutMapping("/update")
          public ResponseEntity<String> updateUser(@RequestBody User user) {
              return ResponseEntity.ok("User " + user.getName() + " updated successfully");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In the example above, the <code>updateUser</code> method is mapped to the <code>/users/update</code> endpoint,
    handling PUT requests. The request body is automatically converted into a <code>User</code> object.
  </p>

  <h3 style="color: #9b59b6;">Handling Path Variables with @PutMapping</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @PutMapping("/update/{id}")
      public ResponseEntity<String> updateUserById(@PathVariable Long id, @RequestBody User user) {
          return ResponseEntity.ok("User with ID " + id + " updated successfully");
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example demonstrates how <code>@PutMapping</code> can handle updates with a specified user ID using <code>@PathVariable</code>.
  </p>
</div>
`
},
{
  title: `DeleteMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @DeleteMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>@DeleteMapping</code> is an annotation used to map HTTP DELETE requests to specific controller methods.
    It is commonly used for deleting resources in RESTful APIs, ensuring proper handling of data removal operations.
  </p>

  <h3 style="color: #16a085;">Key Features of @DeleteMapping:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Handles HTTP DELETE requests.</li>
    <li>Used for deleting existing resources.</li>
    <li>Works with path variables to specify which resource to delete.</li>
    <li>Supports response handling with <code>ResponseEntity</code>.</li>
    <li>Ensures proper API design by enforcing resource removal principles.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use @DeleteMapping?</h3>
  <p style="color: #2c3e50;">
    The <code>@DeleteMapping</code> annotation simplifies handling DELETE requests compared to using <code>@RequestMapping(method = RequestMethod.DELETE)</code>.
    It is an essential part of RESTful API design, ensuring that resources can be removed efficiently.
  </p>

  <h3 style="color: #2980b9;">Example: Using @DeleteMapping in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @DeleteMapping("/delete/{id}")
          public ResponseEntity<String> deleteUser(@PathVariable Long id) {
              return ResponseEntity.ok("User with ID " + id + " deleted successfully");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In the example above, the <code>deleteUser</code> method is mapped to the <code>/users/delete/{id}</code> endpoint,
    handling DELETE requests. The <code>@PathVariable</code> annotation extracts the user ID from the request URL.
  </p>

  <h3 style="color: #9b59b6;">Handling Request Body with @DeleteMapping</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @DeleteMapping("/remove")
      public ResponseEntity<String> deleteUser(@RequestBody User user) {
          return ResponseEntity.ok("User " + user.getName() + " removed successfully");
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example demonstrates how <code>@DeleteMapping</code> can handle DELETE requests with a request body using <code>@RequestBody</code>.
  </p>
</div>
`
},
{
  title: `PatchMapping`, content: `<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @PatchMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>@PatchMapping</code> is an annotation used to map HTTP PATCH requests to specific controller methods.
    It is primarily used for partial updates of a resource in RESTful APIs, allowing modifications to only specific fields rather than replacing the entire resource.
  </p>

  <h3 style="color: #16a085;">Key Features of @PatchMapping:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Handles HTTP PATCH requests.</li>
    <li>Used for partial updates of a resource.</li>
    <li>Works with request bodies to modify specific fields.</li>
    <li>Supports response handling with <code>ResponseEntity</code>.</li>
    <li>Enhances API efficiency by updating only required data.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use @PatchMapping?</h3>
  <p style="color: #2c3e50;">
    The <code>@PatchMapping</code> annotation simplifies handling PATCH requests compared to using <code>@RequestMapping(method = RequestMethod.PATCH)</code>.
    It follows the RESTful API best practices by allowing partial updates rather than full replacements.
  </p>

  <h3 style="color: #2980b9;">Example: Using @PatchMapping in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @PatchMapping("/update/{id}")
          public ResponseEntity<String> updateUser(@PathVariable Long id, @RequestBody Map<String, Object> updates) {
              return ResponseEntity.ok("User with ID " + id + " updated successfully with changes: " + updates);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In the example above, the <code>updateUser</code> method is mapped to the <code>/users/update/{id}</code> endpoint,
    handling PATCH requests. The <code>@RequestBody</code> annotation allows partial updates by accepting a JSON object with specific fields to modify.
  </p>

  <h3 style="color: #9b59b6;">Handling Complex Partial Updates with @PatchMapping</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @PatchMapping("/modify")
      public ResponseEntity<String> modifyUser(@RequestBody User user) {
          return ResponseEntity.ok("User " + user.getName() + " modified successfully");
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example demonstrates how <code>@PatchMapping</code> can handle complex objects for partial updates using <code>@RequestBody</code>.
  </p>
</div>
`
},
{
  title: `PathVariable`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @PathVariable in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@PathVariable</code> annotation in Spring Boot is used to extract values from URI paths. It helps map dynamic values in the URL to method parameters in a controller, making RESTful APIs more flexible and intuitive.
  </p>

  <h3 style="color: #16a085;">Key Features of @PathVariable:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Extracts dynamic values from URI paths.</li>
    <li>Supports multiple path variables in a single endpoint.</li>
    <li>Can be made optional using default values.</li>
    <li>Works seamlessly with RESTful APIs.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using @PathVariable</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/api/users")
      public class UserController {

          @GetMapping("/{id}")
          public ResponseEntity<String> getUserById(@PathVariable("id") Long userId) {
              return ResponseEntity.ok("User ID: " + userId);
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Handling Multiple @PathVariable</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/api/orders")
      public class OrderController {

          @GetMapping("/{userId}/orders/{orderId}")
          public ResponseEntity<String> getOrderDetails(
              @PathVariable Long userId, @PathVariable Long orderId) {
              return ResponseEntity.ok("User " + userId + " ordered item " + orderId);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Optional @PathVariable with Default Values</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/api/products")
      public class ProductController {

          @GetMapping({"", "/{id}"})
          public ResponseEntity<String> getProduct(@PathVariable(name = "id", required = false) Long productId) {
              if (productId == null) {
                  return ResponseEntity.ok("Fetching all products");
              }
              return ResponseEntity.ok("Product ID: " + productId);
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Best Practices for Using @PathVariable</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use descriptive names for path variables to improve readability.</li>
    <li>Ensure paths are structured consistently for better API design.</li>
    <li>Use <code>@PathVariable</code> only when the variable is a required part of the path; otherwise, prefer <code>@RequestParam</code>.</li>
    <li>Handle exceptions for invalid path variables using <code>@ControllerAdvice</code>.</li>
  </ul>

  <p style="color: #2c3e50;">
    The <code>@PathVariable</code> annotation enhances RESTful APIs by allowing dynamic values in URLs, making applications more interactive and scalable.
  </p>
</div>

`
},
{
  title:`RequestParam`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @RequestParam in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>@RequestParam</code> is an annotation used to extract query parameters from the request URL.
    It allows passing parameters in the URL and mapping them directly to method parameters in RESTful web services.
  </p>

  <h3 style="color: #16a085;">Key Features of @RequestParam:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Extracts query parameters from the request URL.</li>
    <li>Supports optional and required parameters.</li>
    <li>Can provide default values.</li>
    <li>Works with different HTTP methods such as GET and POST.</li>
    <li>Improves readability and flexibility of REST API endpoints.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use @RequestParam?</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestParam</code> annotation simplifies handling of query parameters in Spring Boot applications,
    allowing easy extraction and validation of user input directly from the URL.
  </p>

  <h3 style="color: #2980b9;">Example: Using @RequestParam in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @GetMapping("/search")
          public ResponseEntity<String> searchUser(@RequestParam String name) {
              return ResponseEntity.ok("Searched for user: " + name);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>searchUser</code> method extracts the <code>name</code> query parameter from the request URL
    and returns a response containing the search result.
  </p>

  <h3 style="color: #9b59b6;">Using Optional @RequestParam with Default Values</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @GetMapping("/filter")
      public ResponseEntity<String> filterUsers(@RequestParam(defaultValue = "10") int limit) {
          return ResponseEntity.ok("Fetching " + limit + " users");
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example demonstrates how a default value is provided for <code>limit</code>
    when the parameter is not explicitly passed in the request.
  </p>
</div>
`
},
{
  title:`RequestBody`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @RequestBody in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>@RequestBody</code> is an annotation used to bind HTTP request body content
    to a Java object. It is commonly used in RESTful web services to handle JSON or XML input from clients.
  </p>

  <h3 style="color: #16a085;">Key Features of @RequestBody:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Binds JSON/XML request body to a Java object.</li>
    <li>Works with HTTP methods like POST, PUT, and PATCH.</li>
    <li>Automatically deserializes JSON/XML using Jackson or other configured libraries.</li>
    <li>Reduces manual parsing of request payloads.</li>
    <li>Supports validation using <code>@Valid</code> and <code>@Validated</code> annotations.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use @RequestBody?</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestBody</code> annotation simplifies data handling in Spring Boot applications,
    making it easier to receive and process structured data from HTTP requests.
  </p>

  <h3 style="color: #2980b9;">Example: Using @RequestBody in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @PostMapping("/create")
          public ResponseEntity<String> createUser(@RequestBody User user) {
              return ResponseEntity.ok("User created: " + user.getName());
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>createUser</code> method accepts a JSON object representing a user,
    automatically mapping it to a <code>User</code> Java object.
  </p>

  <h3 style="color: #9b59b6;">Using @RequestBody with Validation</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.validation.Valid;

      @PostMapping("/register")
      public ResponseEntity<String> registerUser(@Valid @RequestBody User user) {
          return ResponseEntity.ok("User registered successfully!");
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example demonstrates how to apply validation on the request body to ensure required fields are provided.
  </p>
</div>
`
},
{
  title:`ResponseBody`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @ResponseBody in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>@ResponseBody</code> is an annotation used to indicate that the return value of a method
    should be written directly to the HTTP response body instead of being processed as a view.
    It is commonly used in RESTful web services to return data in JSON or XML format.
  </p>

  <h3 style="color: #16a085;">Key Features of @ResponseBody:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Automatically converts Java objects into JSON or XML.</li>
    <li>Eliminates the need for explicit <code>ResponseEntity</code> objects.</li>
    <li>Works with REST controllers for API responses.</li>
    <li>Supports serialization via Jackson or other libraries.</li>
    <li>Can be applied at method or class level.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use @ResponseBody?</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseBody</code> annotation simplifies API development by automatically converting
    return values into structured response formats, reducing the need for manual serialization.
  </p>

  <h3 style="color: #2980b9;">Example: Using @ResponseBody in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @GetMapping("/info")
          @ResponseBody
          public User getUser() {
              return new User("John Doe", 30);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>getUser</code> method returns a Java object, which is automatically
    converted to JSON format in the HTTP response.
  </p>

  <h3 style="color: #9b59b6;">Using @ResponseBody at Class Level</h3>
  <p style="color: #2c3e50;">
    Instead of annotating each method with <code>@ResponseBody</code>, you can use <code>@RestController</code>
    at the class level, which is a combination of <code>@Controller</code> and <code>@ResponseBody</code>.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/products")
      public class ProductController {

          @GetMapping("/list")
          public List<Product> getProducts() {
              return Arrays.asList(new Product("Laptop", 1200), new Product("Phone", 800));
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    Here, all methods within <code>ProductController</code> will automatically return JSON responses.
  </p>
</div>
`
},
{
  title:`ResponseEntity`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding ResponseEntity in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <code>ResponseEntity</code> is a powerful class that represents the full HTTP response,
    including the status code, headers, and body. It provides better control over the response
    structure and is commonly used in RESTful web services.
  </p>

  <h3 style="color: #16a085;">Key Features of ResponseEntity:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Allows setting HTTP status codes explicitly.</li>
    <li>Supports adding custom headers in the response.</li>
    <li>Handles different response types, including JSON and XML.</li>
    <li>Can be used to return error messages or structured responses.</li>
    <li>Improves flexibility compared to <code>@ResponseBody</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use ResponseEntity?</h3>
  <p style="color: #2c3e50;">
    The <code>ResponseEntity</code> class enables developers to customize API responses by setting
    status codes, headers, and message bodies, making it a useful tool for handling errors and
    success responses effectively.
  </p>

  <h3 style="color: #2980b9;">Example: Using ResponseEntity in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @GetMapping("/{id}")
          public ResponseEntity<User> getUser(@PathVariable int id) {
              User user = new User("John Doe", 30);
              return ResponseEntity.ok(user);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, <code>ResponseEntity.ok()</code> is used to return a successful HTTP response
    with a <code>User</code> object in JSON format.
  </p>

  <h3 style="color: #9b59b6;">Setting Custom Headers with ResponseEntity</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpHeaders;
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/products")
      public class ProductController {

          @GetMapping("/info")
          public ResponseEntity<String> getProductInfo() {
              HttpHeaders headers = new HttpHeaders();
              headers.add("Custom-Header", "CustomValue");
              return new ResponseEntity<>("Product details", headers, HttpStatus.OK);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example demonstrates how to set custom headers in the response using <code>HttpHeaders</code>.
  </p>
</div>
`
},
{
  title:`Exception Handling`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Exception Handling in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Exception handling in Spring Boot is a crucial feature that allows developers to gracefully handle errors
    and provide meaningful responses to users. Spring Boot provides multiple ways to handle exceptions,
    including <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code>, and <code>ResponseEntityExceptionHandler</code>.
  </p>

  <h3 style="color: #16a085;">Key Features of Exception Handling in Spring Boot:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Centralized exception handling with <code>@ControllerAdvice</code>.</li>
    <li>Custom exception handling using <code>@ExceptionHandler</code>.</li>
    <li>Global exception handling using <code>ResponseEntityExceptionHandler</code>.</li>
    <li>Custom error response structures.</li>
    <li>Automatic handling of common exceptions like <code>NullPointerException</code>, <code>MethodArgumentNotValidException</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Exception Handling?</h3>
  <p style="color: #2c3e50;">
    Exception handling improves application stability and user experience by ensuring errors
    are handled properly instead of exposing raw stack traces. It also helps maintain
    a consistent response structure across the API.
  </p>

  <h3 style="color: #2980b9;">Example: Handling Exceptions with @ExceptionHandler</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @GetMapping("/{id}")
          public User getUser(@PathVariable int id) {
              if (id <= 0) {
                  throw new IllegalArgumentException("Invalid user ID");
              }
              return new User("John Doe", 30);
          }

          @ExceptionHandler(IllegalArgumentException.class)
          public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
              return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, <code>@ExceptionHandler</code> catches the <code>IllegalArgumentException</code>
    and returns a custom error message with a <code>400 BAD REQUEST</code> status.
  </p>

  <h3 style="color: #9b59b6;">Global Exception Handling with @ControllerAdvice</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;
      import org.springframework.web.bind.annotation.ControllerAdvice;

      @ControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(Exception.class)
          public ResponseEntity<String> handleGlobalException(Exception ex) {
              return new ResponseEntity<>("An error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The <code>@ControllerAdvice</code> annotation enables centralized exception handling
    across all controllers, ensuring consistent error responses.
  </p>
</div>
`
},
{
  title:`Controller Advice`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Controller Advice in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Controller Advice is a powerful feature in Spring Boot that allows developers to handle exceptions, 
    apply global configurations, and manage cross-cutting concerns across multiple controllers. 
    It provides a centralized way to manage exceptions and customize the response for specific 
    scenarios, ensuring cleaner and more maintainable code.
  </p>

  <h3 style="color: #16a085;">Key Features of Controller Advice:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Global exception handling for all controllers.</li>
    <li>Custom error responses for specific exceptions.</li>
    <li>Support for applying global <code>@ModelAttribute</code> and <code>@InitBinder</code> configurations.</li>
    <li>Centralized logic for cross-cutting concerns like logging and validation.</li>
    <li>Integration with Spring's dependency injection and AOP (Aspect-Oriented Programming).</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Controller Advice?</h3>
  <p style="color: #2c3e50;">
    Controller Advice eliminates the need for repetitive exception handling code in individual 
    controllers. It promotes the DRY (Don't Repeat Yourself) principle by providing a single 
    place to manage exceptions and global configurations. This makes the application more robust, 
    scalable, and easier to debug.
  </p>

  <h3 style="color: #2980b9;">Example: Implementing Controller Advice</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.ControllerAdvice;
      import org.springframework.web.bind.annotation.ExceptionHandler;

      @ControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(ResourceNotFoundException.class)
          public ResponseEntity&lt;String&gt; handleResourceNotFoundException(ResourceNotFoundException ex) {
              return new ResponseEntity&lt;&gt;(ex.getMessage(), HttpStatus.NOT_FOUND);
          }

          @ExceptionHandler(Exception.class)
          public ResponseEntity&lt;String&gt; handleGlobalException(Exception ex) {
              return new ResponseEntity&lt;&gt;("An error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In the above example, the <code>@ControllerAdvice</code> annotation is used to create a global 
    exception handler. The <code>@ExceptionHandler</code> methods are defined to handle specific 
    exceptions like <code>ResourceNotFoundException</code> and a generic <code>Exception</code>. 
    This ensures that all controllers in the application can leverage this centralized exception 
    handling mechanism.
  </p>

  <h3 style="color: #8e44ad;">Advanced Usage: Custom Error Responses</h3>
  <p style="color: #2c3e50;">
    You can also customize the error response by returning a structured JSON object instead of a plain 
    string. This is particularly useful for RESTful APIs where clients expect consistent error formats.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.ControllerAdvice;
      import org.springframework.web.bind.annotation.ExceptionHandler;

      @ControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(ResourceNotFoundException.class)
          public ResponseEntity&lt;ErrorResponse&gt; handleResourceNotFoundException(ResourceNotFoundException ex) {
              ErrorResponse errorResponse = new ErrorResponse(HttpStatus.NOT_FOUND.value(), ex.getMessage());
              return new ResponseEntity&lt;&gt;(errorResponse, HttpStatus.NOT_FOUND);
          }

          @ExceptionHandler(Exception.class)
          public ResponseEntity&lt;ErrorResponse&gt; handleGlobalException(Exception ex) {
              ErrorResponse errorResponse = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), "An unexpected error occurred");
              return new ResponseEntity&lt;&gt;(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }

      class ErrorResponse {
          private int statusCode;
          private String message;

          public ErrorResponse(int statusCode, String message) {
              this.statusCode = statusCode;
              this.message = message;
          }

          // Getters and Setters
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this advanced example, the <code>ErrorResponse</code> class is used to create a structured 
    JSON response. This provides more detailed information to the client, such as the HTTP status 
    code and a descriptive error message.
  </p>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Controller Advice is an essential tool in Spring Boot for managing exceptions and global 
    configurations. By centralizing these concerns, it helps developers build cleaner, more 
    maintainable, and scalable applications. Whether you're building RESTful APIs or complex 
    web applications, Controller Advice ensures that your error handling is consistent and 
    efficient.
  </p>
</div>
`
},
{
  title:`Controller Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Controller Security in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Controller Security is a critical aspect of building secure web applications in Spring Boot. It involves protecting your application's endpoints from unauthorized access, ensuring that only authenticated and authorized users can perform specific actions. Spring Boot, combined with Spring Security, provides robust tools to implement security at the controller level.
  </p>

  <h3 style="color: #16a085;">Why is Controller Security Important?</h3>
  <p style="color: #2c3e50;">
    In modern web applications, controllers handle sensitive data and business logic. Without proper security measures, attackers can exploit vulnerabilities to gain unauthorized access, manipulate data, or disrupt services. Controller Security ensures that:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Only authenticated users can access protected endpoints.</li>
    <li>Users have the necessary permissions (roles) to perform specific actions.</li>
    <li>Sensitive data is protected from unauthorized access.</li>
    <li>Common security vulnerabilities (e.g., CSRF, XSS) are mitigated.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts in Controller Security</h3>
  <p style="color: #2c3e50;">
    Spring Security provides several features to secure controllers effectively:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Authentication</strong>: Verifying the identity of a user (e.g., via username/password, OAuth2, or JWT).</li>
    <li><strong>Authorization</strong>: Granting or denying access to resources based on user roles or permissions.</li>
    <li><strong>CSRF Protection</strong>: Preventing Cross-Site Request Forgery attacks.</li>
    <li><strong>Method-Level Security</strong>: Applying security rules directly to controller methods.</li>
    <li><strong>Endpoint Filtering</strong>: Restricting access to specific endpoints based on security rules.</li>
  </ul>

  <h3 style="color: #2980b9;">Implementing Controller Security in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below are examples of how to implement Controller Security in a Spring Boot application using Spring Security.
  </p>

  <h4 style="color: #8e44ad;">1. Securing Endpoints with <code>HttpSecurity</code></h4>
  <p style="color: #2c3e50;">
    You can configure security rules for your controllers using the <code>HttpSecurity</code> class in a <code>SecurityConfig</code> class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.web.SecurityFilterChain;

      @EnableWebSecurity
      public class SecurityConfig {

          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .authorizeHttpRequests(auth -> auth
                      .requestMatchers("/public/**").permitAll() // Allow public access
                      .requestMatchers("/admin/**").hasRole("ADMIN") // Restrict to ADMIN role
                      .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN") // Allow USER and ADMIN roles
                      .anyRequest().authenticated() // Require authentication for all other requests
                  )
                  .formLogin(form -> form
                      .loginPage("/login") // Custom login page
                      .permitAll()
                  )
                  .logout(logout -> logout
                      .logoutSuccessUrl("/login?logout") // Redirect after logout
                      .permitAll()
                  )
                  .csrf(csrf -> csrf.disable()); // Disable CSRF for simplicity (not recommended for production)
              return http.build();
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>HttpSecurity</code> configuration ensures that:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Public endpoints under <code>/public/**</code> are accessible to everyone.</li>
    <li>Endpoints under <code>/admin/**</code> are restricted to users with the <code>ADMIN</code> role.</li>
    <li>Endpoints under <code>/user/**</code> are accessible to users with either the <code>USER</code> or <code>ADMIN</code> role.</li>
    <li>All other endpoints require authentication.</li>
  </ul>

  <h4 style="color: #8e44ad;">2. Method-Level Security with <code>@PreAuthorize</code></h4>
  <p style="color: #2c3e50;">
    You can also secure individual controller methods using annotations like <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, and <code>@Secured</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.security.access.prepost.PreAuthorize;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class SecureController {

          @GetMapping("/admin")
          @PreAuthorize("hasRole('ADMIN')") // Only ADMIN role can access
          public String adminEndpoint() {
              return "Welcome, Admin!";
          }

          @GetMapping("/user")
          @PreAuthorize("hasAnyRole('USER', 'ADMIN')") // USER or ADMIN roles can access
          public String userEndpoint() {
              return "Welcome, User!";
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>@PreAuthorize</code> annotation is used to enforce role-based access control at the method level.
  </p>

  <h4 style="color: #8e44ad;">3. Enabling CSRF Protection</h4>
  <p style="color: #2c3e50;">
    CSRF (Cross-Site Request Forgery) protection is enabled by default in Spring Security. You can customize it as follows:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      http
          .csrf(csrf -> csrf
              .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) // Store CSRF token in a cookie
          );
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Controller Security</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use HTTPS to encrypt communication between the client and server.</li>
    <li>Always validate and sanitize user inputs to prevent injection attacks.</li>
    <li>Use strong password hashing algorithms (e.g., bcrypt) for storing credentials.</li>
    <li>Regularly update dependencies to patch known vulnerabilities.</li>
    <li>Implement logging and monitoring to detect suspicious activities.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Controller Security is a fundamental aspect of building secure Spring Boot applications. By leveraging Spring Security's features, such as endpoint filtering, method-level security, and CSRF protection, developers can ensure that their applications are protected from unauthorized access and common vulnerabilities. Implementing these best practices will help you build robust and secure web applications.
  </p>
</div>
`
},
{
  title:`DTO in Controllers`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding DTO in Controllers</h2>
  <p style="font-size: 16px; color: #34495e;">
    A Data Transfer Object (DTO) is a simple Java object used to transfer data between layers in a Spring Boot application. DTOs help improve security, reduce unnecessary data exposure, and ensure cleaner code in controllers by separating domain models from API responses.
  </p>

  <h3 style="color: #16a085;">Why Use DTOs?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prevents overexposure of domain models.</li>
    <li>Encapsulates only required data for API responses.</li>
    <li>Improves maintainability and separation of concerns.</li>
    <li>Ensures flexibility by transforming data before sending it to the client.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using DTO in a Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }

      @RestController
      @RequestMapping("/api/users")
      public class UserController {

          @PostMapping
          public ResponseEntity<String> createUser(@RequestBody UserDTO userDTO) {
              return ResponseEntity.ok("User created: " + userDTO.getName());
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Mapping Entity to DTO</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserMapper {
          public static UserDTO toDTO(User user) {
              UserDTO dto = new UserDTO();
              dto.setId(user.getId());
              dto.setName(user.getName());
              dto.setEmail(user.getEmail());
              return dto;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Best Practices for Using DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use DTOs only for external API communication.</li>
    <li>Keep DTOs lightweight and include only necessary fields.</li>
    <li>Use mapping libraries like MapStruct for automatic conversion.</li>
    <li>Separate DTOs for request and response to maintain flexibility.</li>
  </ul>

  <p style="color: #2c3e50;">
    Using DTOs in controllers enhances maintainability, security, and performance by structuring data transfer efficiently while keeping domain models separate from API layers.
  </p>
</div>
`
},
{
  title:`Cross-Origin (CORS)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cross-Origin Resource Sharing (CORS) in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cross-Origin Resource Sharing (CORS) is a security feature implemented by web browsers to prevent unauthorized
    access to resources from a different domain. By default, web browsers block cross-origin requests for security reasons.
    Spring Boot provides flexible ways to configure CORS policies to allow or restrict access from different domains.
  </p>

  <h3 style="color: #16a085;">Key Features of CORS in Spring Boot:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Configurable CORS policies using <code>@CrossOrigin</code> annotation.</li>
    <li>Global CORS configuration using <code>WebMvcConfigurer</code>.</li>
    <li>Fine-grained control over allowed origins, methods, headers, and credentials.</li>
    <li>Support for preflight requests using HTTP OPTIONS method.</li>
    <li>Integration with security frameworks for enhanced protection.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use CORS?</h3>
  <p style="color: #2c3e50;">
    CORS is essential for enabling communication between different domains, such as allowing frontend applications
    hosted on one domain to interact with APIs hosted on another. Properly configuring CORS helps prevent security
    risks while maintaining cross-origin accessibility.
  </p>

  <h3 style="color: #2980b9;">Example: Enabling CORS with @CrossOrigin</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import java.util.*;

      @RestController
      @RequestMapping("/api")
      @CrossOrigin(origins = "http://example.com")
      public class ApiController {

          @GetMapping("/data")
          public List<String> getData() {
              return Arrays.asList("Item 1", "Item 2", "Item 3");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>@CrossOrigin</code> annotation allows requests from <code>http://example.com</code>.
    You can specify multiple origins, HTTP methods, and headers.
  </p>

  <h3 style="color: #9b59b6;">Example: Global CORS Configuration</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.*;
      import org.springframework.web.servlet.config.annotation.*;

      @Configuration
      public class CorsConfig implements WebMvcConfigurer {
          @Override
          public void addCorsMappings(CorsRegistry registry) {
              registry.addMapping("/**")
                      .allowedOrigins("http://example.com")
                      .allowedMethods("GET", "POST", "PUT", "DELETE")
                      .allowedHeaders("Content-Type");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This approach applies CORS settings globally, allowing requests from <code>http://example.com</code>
    with specified methods and headers.
  </p>
</div>
`
},
{
  title:`Validation in Controllers`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Validation in Controllers</h2>
  <p style="font-size: 16px; color: #34495e;">
    Validation in controllers is a critical aspect of building robust and secure Spring Boot applications. It ensures that the data received by your application meets specific criteria before being processed, preventing invalid or malicious data from causing errors or security vulnerabilities. Spring Boot provides powerful validation mechanisms, primarily through the <strong>Bean Validation API (JSR 380)</strong> and Spring's validation support.
  </p>

  <h3 style="color: #16a085;">Why is Validation Important?</h3>
  <p style="color: #2c3e50;">
    Validation is essential for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures that the data conforms to expected formats and constraints.</li>
    <li><strong>Security</strong>: Prevents injection attacks and other malicious inputs.</li>
    <li><strong>User Experience</strong>: Provides meaningful error messages to users when input is invalid.</li>
    <li><strong>Business Logic</strong>: Ensures that only valid data is processed by the application, reducing the risk of runtime errors.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Validation in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot leverages the Bean Validation API (JSR 380) to perform validation. Key concepts include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Validation Annotations</strong>: Annotations like <code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>, and <code>@Pattern</code> are used to define validation rules.</li>
    <li><strong>Validation Groups</strong>: Allows you to apply different validation rules for different scenarios (e.g., create vs. update).</li>
    <li><strong>Custom Validators</strong>: Enables you to create custom validation logic for complex use cases.</li>
    <li><strong>Error Handling</strong>: Spring Boot provides mechanisms to handle validation errors and return meaningful responses to clients.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Validation in a Spring Boot Controller</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement validation in a Spring Boot controller using the Bean Validation API.
  </p>

  <h4 style="color: #8e44ad;">1. Define a DTO with Validation Annotations</h4>
  <p style="color: #2c3e50;">
    First, define a DTO (Data Transfer Object) with validation annotations.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.validation.constraints.*;

      public class UserDTO {

          @NotNull(message = "Name is required")
          private String name;

          @Email(message = "Invalid email format")
          @NotBlank(message = "Email is required")
          private String email;

          @Size(min = 6, message = "Password must be at least 6 characters")
          @NotBlank(message = "Password is required")
          private String password;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Enable Validation in the Controller</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Valid</code> annotation to enable validation for the incoming request body.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.ResponseEntity;
      import org.springframework.validation.annotation.Validated;
      import org.springframework.web.bind.annotation.*;

      import jakarta.validation.Valid;

      @RestController
      @RequestMapping("/users")
      @Validated
      public class UserController {

          @PostMapping
          public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody UserDTO userDTO) {
              // Process the validated userDTO
              return ResponseEntity.ok("User created successfully");
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Handle Validation Errors</h4>
  <p style="color: #2c3e50;">
    Use <code>@ExceptionHandler</code> to handle validation errors and return meaningful error messages.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.RestControllerAdvice;

      import java.util.HashMap;
      import java.util.Map;

      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(MethodArgumentNotValidException.class)
          public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
              ex.getBindingResult().getFieldErrors().forEach(error -&gt;
                  errors.put(error.getField(), error.getDefaultMessage())
              );
              return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>GlobalExceptionHandler</code> captures validation errors and returns a map of field names and error messages with a <code>400 Bad Request</code> status.
  </p>

  <h3 style="color: #d35400;">Custom Validators</h3>
  <p style="color: #2c3e50;">
    For complex validation logic, you can create custom validators by implementing the <code>ConstraintValidator</code> interface.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.validation.Constraint;
      import jakarta.validation.ConstraintValidator;
      import jakarta.validation.ConstraintValidatorContext;
      import jakarta.validation.Payload;
      import java.lang.annotation.*;

      @Target({ ElementType.FIELD })
      @Retention(RetentionPolicy.RUNTIME)
      @Constraint(validatedBy = CustomEmailValidator.class)
      public @interface CustomEmail {
          String message() default "Invalid email format";
          Class&lt;?&gt;[] groups() default {};
          Class&lt;? extends Payload&gt;[] payload() default {};
      }

      public class CustomEmailValidator implements ConstraintValidator&lt;CustomEmail, String&gt; {
          @Override
          public boolean isValid(String email, ConstraintValidatorContext context) {
              return email != null && email.endsWith("@example.com");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    You can then use the custom annotation in your DTO:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          @CustomEmail(message = "Email must end with @example.com")
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Validation in controllers is a fundamental aspect of building secure and reliable Spring Boot applications. By leveraging the Bean Validation API and Spring's validation support, you can ensure that your application processes only valid and safe data. Whether you're using built-in annotations or custom validators, proper validation practices will enhance the quality and security of your application.
  </p>
</div>
`
},
{
  title:`Logging in Controllers`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Logging in Controllers</h2>
  <p style="font-size: 16px; color: #34495e;">
    Logging is an essential practice in software development that helps developers monitor, debug, and analyze the behavior of their applications. In Spring Boot, logging in controllers is particularly important for tracking incoming requests, outgoing responses, and any errors or exceptions that occur during request processing. Proper logging ensures that you have visibility into your application's runtime behavior and can quickly identify and resolve issues.
  </p>

  <h3 style="color: #16a085;">Why is Logging Important in Controllers?</h3>
  <p style="color: #2c3e50;">
    Logging in controllers provides several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Debugging</strong>: Helps identify and resolve issues by providing detailed information about the flow of requests and responses.</li>
    <li><strong>Monitoring</strong>: Tracks the performance and behavior of your application in real-time.</li>
    <li><strong>Auditing</strong>: Provides a record of user actions and system events for compliance and security purposes.</li>
    <li><strong>Error Tracking</strong>: Captures exceptions and errors, making it easier to diagnose and fix problems.</li>
    <li><strong>Performance Analysis</strong>: Logs request processing times to identify performance bottlenecks.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Logging in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot uses the <strong>SLF4J (Simple Logging Facade for Java)</strong> API with <strong>Logback</strong> as the default logging framework. Key concepts include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Log Levels</strong>: Different levels of logging, such as <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, and <code>ERROR</code>, allow you to control the verbosity of logs.</li>
    <li><strong>Logging Configuration</strong>: Customize logging behavior using configuration files like <code>application.properties</code> or <code>logback-spring.xml</code>.</li>
    <li><strong>Structured Logging</strong>: Logs in a structured format (e.g., JSON) for easier parsing and analysis.</li>
    <li><strong>Contextual Logging</strong>: Add contextual information (e.g., request IDs, user IDs) to logs for better traceability.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Logging in a Spring Boot Controller</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement logging in a Spring Boot controller.
  </p>

  <h4 style="color: #8e44ad;">1. Add Logging to a Controller</h4>
  <p style="color: #2c3e50;">
    Use the <code>Logger</code> class from SLF4J to add logging statements to your controller.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.slf4j.Logger;
      import org.slf4j.LoggerFactory;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/api")
      public class UserController {

          private static final Logger logger = LoggerFactory.getLogger(UserController.class);

          @GetMapping("/users/{id}")
          public String getUserById(@PathVariable Long id) {
              logger.info("Fetching user with ID: {}", id);
              // Simulate fetching user
              String user = "User" + id;
              logger.debug("Fetched user: {}", user);
              return user;
          }

          @PostMapping("/users")
          public String createUser(@RequestBody String user) {
              logger.info("Creating user: {}", user);
              // Simulate user creation
              logger.debug("User created successfully");
              return "User created";
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the <code>Logger</code> is used to log messages at different levels (<code>INFO</code> and <code>DEBUG</code>) to track the flow of requests and responses.
  </p>

  <h4 style="color: #8e44ad;">2. Configure Logging in <code>application.properties</code></h4>
  <p style="color: #2c3e50;">
    Customize logging behavior using the <code>application.properties</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      # Set log level for the application
      logging.level.root=INFO
      logging.level.com.example.demo=DEBUG

      # Log to a file
      logging.file.name=app.log
      logging.file.path=/var/logs

      # Log in JSON format
      logging.pattern.console={"timestamp":"%d{yyyy-MM-dd HH:mm:ss}","level":"%level","message":"%msg"}%n
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Add Contextual Information to Logs</h4>
  <p style="color: #2c3e50;">
    Use <code>MDC (Mapped Diagnostic Context)</code> to add contextual information, such as request IDs or user IDs, to your logs.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.slf4j.Logger;
      import org.slf4j.LoggerFactory;
      import org.slf4j.MDC;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/api")
      public class UserController {

          private static final Logger logger = LoggerFactory.getLogger(UserController.class);

          @GetMapping("/users/{id}")
          public String getUserById(@PathVariable Long id) {
              MDC.put("requestId", "12345"); // Add request ID to logs
              logger.info("Fetching user with ID: {}", id);
              // Simulate fetching user
              String user = "User" + id;
              logger.debug("Fetched user: {}", user);
              MDC.clear(); // Clear MDC after request
              return user;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Logging in Controllers</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use appropriate log levels (<code>INFO</code> for general information, <code>DEBUG</code> for detailed debugging, <code>ERROR</code> for errors).</li>
    <li>Avoid logging sensitive information (e.g., passwords, credit card numbers).</li>
    <li>Use structured logging (e.g., JSON) for easier parsing and analysis.</li>
    <li>Add contextual information (e.g., request IDs, user IDs) to logs for better traceability.</li>
    <li>Regularly review and rotate log files to prevent them from consuming too much disk space.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Logging in controllers is a vital practice for building maintainable, debuggable, and secure Spring Boot applications. By leveraging SLF4J and Logback, you can implement effective logging strategies that provide visibility into your application's behavior and help you quickly identify and resolve issues. Whether you're logging request details, errors, or performance metrics, proper logging practices will enhance the reliability and observability of your application.
  </p>
</div>
`
},
{
  title:`Interceptor in Controllers`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Interceptors in Controllers</h2>
  <p style="font-size: 16px; color: #34495e;">
    Interceptors in Spring Boot are powerful components that allow you to intercept and modify HTTP requests and responses before they reach the controller or after they leave the controller. They are commonly used for cross-cutting concerns such as logging, authentication, authorization, request validation, and performance monitoring. Interceptors provide a clean and reusable way to implement such functionality without cluttering your controller logic.
  </p>

  <h3 style="color: #16a085;">Why Use Interceptors in Controllers?</h3>
  <p style="color: #2c3e50;">
    Interceptors offer several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Separation of Concerns</strong>: Keeps cross-cutting concerns like logging and security separate from business logic.</li>
    <li><strong>Reusability</strong>: Interceptors can be applied to multiple controllers, reducing code duplication.</li>
    <li><strong>Flexibility</strong>: Allows you to modify requests and responses dynamically.</li>
    <li><strong>Centralized Logic</strong>: Provides a single place to handle common tasks like authentication and logging.</li>
    <li><strong>Improved Maintainability</strong>: Makes the codebase cleaner and easier to maintain.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Interceptors</h3>
  <p style="color: #2c3e50;">
    Spring Boot interceptors are based on the <code>HandlerInterceptor</code> interface, which provides three key methods:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>preHandle</strong>: Executes before the request reaches the controller. Useful for authentication, logging, or request modification.</li>
    <li><strong>postHandle</strong>: Executes after the controller processes the request but before the response is sent. Useful for modifying the response or adding additional data.</li>
    <li><strong>afterCompletion</strong>: Executes after the response is sent to the client. Useful for cleanup tasks or logging.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing an Interceptor in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to create and configure an interceptor in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Create a Custom Interceptor</h4>
  <p style="color: #2c3e50;">
    Implement the <code>HandlerInterceptor</code> interface to create a custom interceptor.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Component;
      import org.springframework.web.servlet.HandlerInterceptor;
      import org.springframework.web.servlet.ModelAndView;

      import jakarta.servlet.http.HttpServletRequest;
      import jakarta.servlet.http.HttpServletResponse;

      @Component
      public class CustomInterceptor implements HandlerInterceptor {

          @Override
          public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
              System.out.println("Pre Handle method: Checking request before reaching the controller");
              // Example: Check authentication
              String authToken = request.getHeader("Authorization");
              if (authToken == null || !authToken.startsWith("Bearer ")) {
                  response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
                  return false; // Stop further processing
              }
              return true; // Continue processing
          }

          @Override
          public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
              System.out.println("Post Handle method: Modifying response before sending to client");
              // Example: Add custom headers
              response.setHeader("X-Custom-Header", "Interceptor-Added");
          }

          @Override
          public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
              System.out.println("After Completion method: Cleaning up after response is sent");
              // Example: Logging request completion
              if (ex != null) {
                  System.err.println("Request failed with exception: " + ex.getMessage());
              }
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Register the Interceptor</h4>
  <p style="color: #2c3e50;">
    Register the interceptor in a configuration class by extending <code>WebMvcConfigurer</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
      import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

      @Configuration
      public class WebConfig implements WebMvcConfigurer {

          @Autowired
          private CustomInterceptor customInterceptor;

          @Override
          public void addInterceptors(InterceptorRegistry registry) {
              registry.addInterceptor(customInterceptor)
                      .addPathPatterns("/api/**") // Apply to all endpoints under /api
                      .excludePathPatterns("/api/public/**"); // Exclude public endpoints
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Interceptor in a Controller</h4>
  <p style="color: #2c3e50;">
    The interceptor will automatically apply to the specified endpoints. Here's an example controller:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class UserController {

          @GetMapping("/users")
          public String getUsers() {
              return "List of users";
          }

          @GetMapping("/public/info")
          public String getPublicInfo() {
              return "Public information";
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Common Use Cases for Interceptors</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Authentication and Authorization</strong>: Validate tokens or check user roles before allowing access to endpoints.</li>
    <li><strong>Logging</strong>: Log incoming requests, outgoing responses, and execution times.</li>
    <li><strong>Request/Response Modification</strong>: Add or modify headers, sanitize inputs, or transform responses.</li>
    <li><strong>Performance Monitoring</strong>: Measure and log the time taken to process requests.</li>
    <li><strong>Error Handling</strong>: Capture and log exceptions globally.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Interceptors in Spring Boot provide a powerful and flexible way to handle cross-cutting concerns in your application. By intercepting requests and responses, you can implement reusable logic for authentication, logging, performance monitoring, and more. Whether you're building RESTful APIs or complex web applications, interceptors help you keep your code clean, modular, and maintainable.
  </p>
</div>
`
},
{
  title:`Controller Testing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Controller Testing in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Controller testing in Spring Boot is essential for verifying the behavior of RESTful APIs.
    It ensures that endpoints return the expected responses based on different request inputs.
    Spring Boot provides several ways to test controllers, including unit tests using <code>MockMvc</code>
    and integration tests with a real application context.
  </p>

  <h3 style="color: #16a085;">Key Features of Controller Testing:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Unit testing with <code>MockMvc</code> for isolating controllers.</li>
    <li>Integration testing with the actual application context.</li>
    <li>Verifying response status, headers, and body.</li>
    <li>Mocking dependencies with <code>@MockBean</code>.</li>
    <li>Using <code>@WebMvcTest</code> for focused controller testing.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Test Controllers?</h3>
  <p style="color: #2c3e50;">
    Testing controllers ensures that API endpoints work correctly before deployment.
    It helps catch issues early, improves code reliability, and ensures correct request handling.
  </p>

  <h3 style="color: #2980b9;">Example: Unit Test with MockMvc</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
      import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
      import org.springframework.test.web.servlet.MockMvc;

      @WebMvcTest(controllers = ApiController.class)
      public class ApiControllerTest {
          @Autowired
          private MockMvc mockMvc;

          @Test
          public void testGetData() throws Exception {
              mockMvc.perform(get("/api/data"))
                     .andExpect(status().isOk())
                     .andExpect(content().json("[\"Item 1\", \"Item 2\", \"Item 3\"]"));
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example tests a controller method using <code>MockMvc</code>. It verifies the status and expected JSON response.
  </p>

  <h3 style="color: #9b59b6;">Example: Integration Test</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.junit.jupiter.api.Test;
      import org.springframework.boot.test.context.SpringBootTest;
      import org.springframework.boot.test.web.client.TestRestTemplate;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.http.ResponseEntity;
      import static org.assertj.core.api.Assertions.assertThat;

      @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
      public class ApiControllerIT {
          @Autowired
          private TestRestTemplate restTemplate;

          @Test
          public void testGetData() {
              ResponseEntity<String> response = restTemplate.getForEntity("/api/data", String.class);
              assertThat(response.getStatusCodeValue()).isEqualTo(200);
              assertThat(response.getBody()).contains("Item 1", "Item 2", "Item 3");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example uses <code>TestRestTemplate</code> for integration testing with a running Spring Boot application.
  </p>
</div>
`
},
{
  title:`MockMvc Testing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">MockMvc Testing in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    MockMvc is a powerful testing tool in Spring Boot that allows developers to test controllers without
    starting a full HTTP server. It provides a way to simulate HTTP requests and validate responses,
    ensuring that controllers function correctly.
  </p>

  <h3 style="color: #16a085;">Key Features of MockMvc:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Allows testing controllers without a running server.</li>
    <li>Provides fluent API for making requests and asserting responses.</li>
    <li>Supports request validation and content verification.</li>
    <li>Integrates well with JUnit and Spring Boot testing frameworks.</li>
    <li>Facilitates unit testing and behavior-driven development.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use MockMvc?</h3>
  <p style="color: #2c3e50;">
    MockMvc simplifies testing by eliminating the need for an actual HTTP server. It enables developers
    to test endpoints in isolation, reducing complexity and execution time.
  </p>

  <h3 style="color: #2980b9;">Example: Basic MockMvc Test</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
      import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
      import org.springframework.test.web.servlet.MockMvc;

      @WebMvcTest(controllers = MyController.class)
      public class MyControllerTest {
          @Autowired
          private MockMvc mockMvc;

          @Test
          public void testHelloEndpoint() throws Exception {
              mockMvc.perform(get("/hello"))
                     .andExpect(status().isOk())
                     .andExpect(content().string("Hello, World!"));
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example tests a simple endpoint using <code>MockMvc</code>. It verifies the response status and body content.
  </p>

  <h3 style="color: #9b59b6;">Example: Mocking Service Layer</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import static org.mockito.Mockito.*;
      import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
      import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
      import org.springframework.boot.test.mock.mockito.MockBean;
      import org.springframework.test.web.servlet.MockMvc;

      @WebMvcTest(controllers = MyController.class)
      public class MyControllerMockServiceTest {
          @Autowired
          private MockMvc mockMvc;

          @MockBean
          private MyService myService;

          @Test
          public void testServiceMocking() throws Exception {
              when(myService.getMessage()).thenReturn("Mocked Response");

              mockMvc.perform(get("/message"))
                     .andExpect(status().isOk())
                     .andExpect(content().string("Mocked Response"));
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This example mocks a service layer dependency using <code>@MockBean</code> to isolate controller behavior.
  </p>
</div>
`
},
{
  title:`Controller Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Controller Best Practices in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, controllers handle HTTP requests and define application endpoints. Following best practices
    ensures maintainability, scalability, and efficient performance.
  </p>

  <h3 style="color: #16a085;">Key Best Practices:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@RestController</code> instead of <code>@Controller</code> when working with REST APIs.</li>
    <li>Keep controller methods small and focused on request handling.</li>
    <li>Use <code>@RequestMapping</code> at the class level for consistency.</li>
    <li>Leverage <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, and <code>@PatchMapping</code> for clarity.</li>
    <li>Use DTOs (Data Transfer Objects) to encapsulate request and response data.</li>
    <li>Implement proper validation using <code>@Valid</code> and <code>@RequestBody</code>.</li>
    <li>Handle exceptions globally using <code>@ControllerAdvice</code>.</li>
    <li>Avoid business logic inside controllers; delegate it to services.</li>
    <li>Use meaningful endpoint naming for clarity (e.g., <code>/api/users</code> instead of <code>/getUsers</code>).</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Well-Structured Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;
      import java.util.List;

      @RestController
      @RequestMapping("/api/users")
      public class UserController {

          private final UserService userService;

          public UserController(UserService userService) {
              this.userService = userService;
          }

          @GetMapping
          public ResponseEntity<List<UserDTO>> getAllUsers() {
              return ResponseEntity.ok(userService.getAllUsers());
          }

          @PostMapping
          public ResponseEntity<UserDTO> createUser(@Valid @RequestBody UserDTO userDTO) {
              return ResponseEntity.ok(userService.createUser(userDTO));
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Example: Global Exception Handling</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import java.util.HashMap;
      import java.util.Map;

      @ControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(MethodArgumentNotValidException.class)
          public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map<String, String> errors = new HashMap<>();
              ex.getBindingResult().getFieldErrors().forEach(error ->
                  errors.put(error.getField(), error.getDefaultMessage()));
              return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    By following these best practices, you can create maintainable, scalable, and efficient Spring Boot controllers.
  </p>
</div>
`
},
{
title:`Controller Anti-Patterns`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Controller Anti-Patterns in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    While building Spring Boot applications, avoiding common controller anti-patterns is crucial to maintain clean, efficient, and scalable code. Controllers should be well-structured and free from unnecessary complexity.
  </p>

  <h3 style="color: #16a085;">Common Controller Anti-Patterns</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Fat Controllers:</strong> Placing too much business logic inside controllers instead of delegating it to service layers.</li>
    <li><strong>Improper Exception Handling:</strong> Handling exceptions within controller methods instead of using <code>@ControllerAdvice</code>.</li>
    <li><strong>Using Entity Objects as DTOs:</strong> Exposing database entities directly in APIs instead of using separate DTOs.</li>
    <li><strong>Lack of Validation:</strong> Not validating request data properly, leading to security and data integrity issues.</li>
    <li><strong>Poor Naming Conventions:</strong> Using vague or inconsistent endpoint names that do not follow RESTful conventions.</li>
    <li><strong>Hardcoding Values:</strong> Hardcoding URLs, configurations, or response values instead of externalizing them.</li>
    <li><strong>Ignoring Response Status Codes:</strong> Always returning HTTP 200 status, even for errors, making debugging difficult.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Avoiding a Fat Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/api/users")
      public class UserController {

          private final UserService userService;

          public UserController(UserService userService) {
              this.userService = userService;
          }

          @PostMapping
          public ResponseEntity<UserDTO> createUser(@Valid @RequestBody UserDTO userDTO) {
              UserDTO savedUser = userService.createUser(userDTO);
              return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
          }

          @GetMapping("/{id}")
          public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {
              return ResponseEntity.ok(userService.getUserById(id));
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Best Practices to Avoid Anti-Patterns</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep controllers thin by moving business logic to service layers.</li>
    <li>Use DTOs for request and response objects to separate concerns.</li>
    <li>Implement proper validation using <code>@Valid</code> and <code>@Validated</code>.</li>
    <li>Handle exceptions using <code>@ControllerAdvice</code> and return meaningful error responses.</li>
    <li>Follow RESTful conventions for endpoint naming and response status codes.</li>
  </ul>

  <p style="color: #2c3e50;">
    Avoiding these anti-patterns will ensure better maintainability, performance, and security in your Spring Boot application.
  </p>
</div>
`
},
{
title:`DTO Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO Basics in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) are simple objects used to encapsulate data and transfer it between layers in an application. They help in separating domain models from API contracts, ensuring better maintainability and security.
  </p>

  <h3 style="color: #16a085;">Why Use DTOs?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prevents direct exposure of entity objects.</li>
    <li>Improves API security by limiting exposed data fields.</li>
    <li>Allows transformation and validation of data before processing.</li>
    <li>Facilitates API versioning and backward compatibility.</li>
    <li>Enhances separation of concerns between persistence and presentation layers.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Implementing a DTO</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          private Long id;
          private String name;
          private String email;

          public UserDTO() {}

          public UserDTO(Long id, String name, String email) {
              this.id = id;
              this.name = name;
              this.email = email;
          }

          public Long getId() {
              return id;
          }

          public void setId(Long id) {
              this.id = id;
          }

          public String getName() {
              return name;
          }

          public void setName(String name) {
              this.name = name;
          }

          public String getEmail() {
              return email;
          }

          public void setEmail(String email) {
              this.email = email;
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Mapping DTOs with Entity Objects</h3>
  <p style="color: #2c3e50;">
    DTOs are typically mapped to entity objects using tools like <code>ModelMapper</code> or manual conversion methods. Example using ModelMapper:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      ModelMapper modelMapper = new ModelMapper();
      UserDTO userDTO = modelMapper.map(userEntity, UserDTO.class);
    </code>
  </pre>

  <h3 style="color: #3498db;">Best Practices for Using DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use DTOs only for API requests and responses.</li>
    <li>Keep DTOs lightweight by including only necessary fields.</li>
    <li>Validate DTOs using annotations like <code>@Valid</code> and <code>@NotNull</code>.</li>
    <li>Convert between DTOs and entities in the service layer, not in controllers.</li>
  </ul>

  <p style="color: #2c3e50;">
    Implementing DTOs correctly enhances application security, maintainability, and scalability.
  </p>
</div>
`
},
{
  title:`DTO vs Entity`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO vs Entity in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot applications, Data Transfer Objects (DTOs) and Entities serve different purposes. While entities represent database objects and are managed by JPA, DTOs act as data carriers between layers, improving performance and security.
  </p>

  <h3 style="color: #16a085;">Key Differences Between DTO and Entity</h3>
  <table style="width: 100%; border-collapse: collapse;">
    <tr style="background: #16a085; color: white;">
      <th style="padding: 10px; border: 1px solid #ddd;">Aspect</th>
      <th style="padding: 10px; border: 1px solid #ddd;">DTO</th>
      <th style="padding: 10px; border: 1px solid #ddd;">Entity</th>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Purpose</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Transfers data between layers</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Represents database table</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Persistence</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Not managed by JPA</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Managed by JPA and Hibernate</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Fields</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Contains only necessary fields</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Maps to all table columns</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Usage</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Used in API responses and requests</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Used for database operations</td>
    </tr>
  </table>

  <h3 style="color: #e67e22;">Example: Entity vs DTO</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
          // Getters and Setters
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The entity is mapped directly to a database table and is managed by JPA.</p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          private String name;
          private String email;
          // Getters and Setters
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The DTO contains only relevant fields for API responses.</p>

  <h3 style="color: #3498db;">Best Practices for Using DTOs and Entities</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep entities only in the persistence layer.</li>
    <li>Use DTOs to expose minimal necessary data in API responses.</li>
    <li>Convert between DTOs and entities in the service layer, not in controllers.</li>
    <li>Leverage tools like <code>ModelMapper</code> or <code>MapStruct</code> for conversion.</li>
  </ul>

  <p style="color: #2c3e50;">
    Understanding the distinction between DTOs and Entities ensures a clean architecture and enhances security by preventing direct entity exposure.
  </p>
</div>
`
},
{
  title:`DTO in MVC`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in MVC Architecture</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a Spring Boot MVC (Model-View-Controller) architecture, a Data Transfer Object (DTO) plays a crucial role in handling data flow between different layers. DTOs help decouple the domain model from the API layer, enhancing security, performance, and maintainability.
  </p>

  <h3 style="color: #16a085;">Why Use DTO in MVC?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prevents direct exposure of entity classes in API responses.</li>
    <li>Improves performance by reducing unnecessary data transfer.</li>
    <li>Enhances security by hiding sensitive database fields.</li>
    <li>Keeps domain models focused on database operations.</li>
    <li>Facilitates API versioning and transformation of data.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using DTO in a Spring MVC Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          private String name;
          private String email;
          // Getters and Setters
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The DTO is a simple Java class that contains only the necessary fields.</p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/users")
      public class UserController {
          private final UserService userService;

          public UserController(UserService userService) {
              this.userService = userService;
          }

          @GetMapping("/{id}")
          public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
              UserDTO userDTO = userService.getUserById(id);
              return ResponseEntity.ok(userDTO);
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The controller only interacts with the DTO instead of directly using entity objects.</p>

  <h3 style="color: #3498db;">Best Practices for DTO in MVC</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep DTOs lightweight with only necessary fields.</li>
    <li>Use a service layer for converting entities to DTOs and vice versa.</li>
    <li>Leverage tools like <code>ModelMapper</code> or <code>MapStruct</code> for automated mapping.</li>
    <li>Ensure DTOs are immutable where possible.</li>
    <li>Follow REST API best practices when designing DTOs.</li>
  </ul>

  <p style="color: #2c3e50;">
    Using DTOs in MVC helps in structuring a clean, scalable, and maintainable application by ensuring a clear separation of concerns between the controller, service, and persistence layers.
  </p>
</div>
`
},
{
  title:`DTO in Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a Spring Boot application, a Data Transfer Object (DTO) is used to transfer data between different layers of the application. DTOs help in structuring APIs, improving performance, and maintaining a clean separation of concerns.
  </p>

  <h3 style="color: #16a085;">Why Use DTO in Spring Boot?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulates only required data, avoiding unnecessary exposure of entities.</li>
    <li>Improves security by restricting sensitive data in API responses.</li>
    <li>Enhances performance by reducing the size of data transferred.</li>
    <li>Facilitates API versioning by modifying DTOs without changing entity models.</li>
    <li>Maintains separation of concerns between persistence and API layers.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Implementing DTO in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          private String name;
          private String email;
          // Constructors, Getters, and Setters
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The DTO class contains only necessary fields without exposing the full entity.</p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/users")
      public class UserController {
          private final UserService userService;

          public UserController(UserService userService) {
              this.userService = userService;
          }

          @GetMapping("/{id}")
          public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
              UserDTO userDTO = userService.getUserById(id);
              return ResponseEntity.ok(userDTO);
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The controller uses the DTO to send only necessary data to the client.</p>

  <h3 style="color: #3498db;">Best Practices for Using DTO in Spring Boot</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use DTOs only for API communication, not for persistence.</li>
    <li>Keep DTOs lightweight and focus on necessary fields.</li>
    <li>Use a service layer to handle conversions between DTOs and entities.</li>
    <li>Automate DTO mapping using <code>ModelMapper</code> or <code>MapStruct</code>.</li>
    <li>Ensure immutability of DTOs where possible.</li>
  </ul>

  <p style="color: #2c3e50;">
    Using DTOs in Spring Boot ensures a well-structured, secure, and maintainable application, enhancing both API efficiency and data protection.
  </p>
</div>
`
},
{
title:`Lombok with DTO`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Lombok with DTO</h2>
  <p style="font-size: 16px; color: #34495e;">
    Lombok is a Java library that helps reduce boilerplate code by automatically generating getter, setter, constructor, and other methods. When used with Data Transfer Objects (DTOs) in Spring Boot, Lombok simplifies the development process and improves code readability.
  </p>

  <h3 style="color: #16a085;">Why Use Lombok with DTO?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Reduces boilerplate code by eliminating manual getters, setters, and constructors.</li>
    <li>Enhances code readability and maintainability.</li>
    <li>Improves development efficiency by reducing repetitive tasks.</li>
    <li>Works seamlessly with Spring Boot applications.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using Lombok in a DTO</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;

      @Data
      @NoArgsConstructor
      @AllArgsConstructor
      public class UserDTO {
          private String name;
          private String email;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">With Lombok annotations, getters, setters, and constructors are automatically generated.</p>

  <h3 style="color: #3498db;">Integrating DTO with a Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/users")
      public class UserController {
          private final UserService userService;

          public UserController(UserService userService) {
              this.userService = userService;
          }

          @GetMapping("/{id}")
          public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
              UserDTO userDTO = userService.getUserById(id);
              return ResponseEntity.ok(userDTO);
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The controller efficiently returns DTOs, ensuring only necessary data is exposed.</p>

  <h3 style="color: #e74c3c;">Best Practices for Using Lombok with DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Data</code> for automatic generation of getters, setters, and toString.</li>
    <li>Use <code>@NoArgsConstructor</code> and <code>@AllArgsConstructor</code> for constructor generation.</li>
    <li>Ensure DTOs remain lightweight and only contain necessary fields.</li>
    <li>Keep DTOs separate from entity classes to maintain clean architecture.</li>
    <li>Consider using <code>@Builder</code> for better object creation flexibility.</li>
  </ul>

  <p style="color: #2c3e50;">
    By integrating Lombok with DTOs, Spring Boot applications become more efficient, reducing boilerplate code and improving maintainability.
  </p>
</div>
`
},
{
  title:`Mapping DTOs`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Mapping DTOs</h2>
  <p style="font-size: 16px; color: #34495e;">
    Mapping Data Transfer Objects (DTOs) is essential for separating business logic from data representation. In Spring Boot, DTOs help ensure that only relevant data is exposed in APIs, improving security and maintainability.
  </p>

  <h3 style="color: #16a085;">Why Map DTOs?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Decouples domain models from API responses.</li>
    <li>Improves security by exposing only required fields.</li>
    <li>Enhances maintainability and reusability.</li>
    <li>Facilitates easier data transformation and validation.</li>
  </ul>

  <h3 style="color: #e67e22;">Methods for Mapping DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Manual Mapping (explicit setters/getters).</li>
    <li>Using ModelMapper library.</li>
    <li>Using MapStruct for compile-time mapping.</li>
  </ul>

  <h3 style="color: #3498db;">Example: Manual DTO Mapping</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserMapper {
          public static UserDTO toDTO(User user) {
              UserDTO dto = new UserDTO();
              dto.setName(user.getName());
              dto.setEmail(user.getEmail());
              return dto;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Example: Mapping DTOs with ModelMapper</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      ModelMapper modelMapper = new ModelMapper();
      UserDTO userDTO = modelMapper.map(user, UserDTO.class);
    </code>
  </pre>
  <p style="color: #2c3e50;">ModelMapper automates the conversion process with minimal configuration.</p>

  <h3 style="color: #e74c3c;">Example: Using MapStruct</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Mapper
      public interface UserMapper {
          UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);
          UserDTO userToUserDTO(User user);
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">MapStruct provides a powerful and efficient compile-time mapping mechanism.</p>

  <h3 style="color: #e74c3c;">Best Practices for Mapping DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep DTOs lightweight and focused on specific use cases.</li>
    <li>Use libraries like ModelMapper or MapStruct for consistency.</li>
    <li>Ensure mappings are properly tested.</li>
    <li>Avoid overuse of DTOs that duplicate entity structures.</li>
  </ul>

  <p style="color: #2c3e50;">
    Mapping DTOs properly improves the structure and security of Spring Boot applications. Choosing the right approach depends on project needs and complexity.
  </p>
</div>
`
},
{
  title:`ModelMapper`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">ModelMapper in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    ModelMapper is a powerful Java library used for object mapping, simplifying the conversion between DTOs and entities. It provides an intuitive API to eliminate manual mapping code and improves code maintainability.
  </p>

  <h3 style="color: #16a085;">Why Use ModelMapper?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Reduces boilerplate mapping code.</li>
    <li>Improves code readability and maintainability.</li>
    <li>Automatically maps object properties based on matching names.</li>
    <li>Supports complex object mapping and custom configurations.</li>
  </ul>

  <h3 style="color: #e67e22;">Adding ModelMapper to a Spring Boot Project</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;
          &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;
          &lt;version&gt;2.4.4&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #3498db;">Configuring ModelMapper in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Configuration
      public class ModelMapperConfig {
          @Bean
          public ModelMapper modelMapper() {
              return new ModelMapper();
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">This configuration registers ModelMapper as a Spring bean, making it available for dependency injection.</p>

  <h3 style="color: #e74c3c;">Example: Mapping DTOs with ModelMapper</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      public class UserController {
          @Autowired
          private ModelMapper modelMapper;

          @GetMapping("/user")
          public UserDTO getUser() {
              User user = new User("John Doe", "john@example.com");
              return modelMapper.map(user, UserDTO.class);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Best Practices for Using ModelMapper</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use ModelMapper for simple and automated mapping.</li>
    <li>Customize mappings when needed using property mappings.</li>
    <li>Optimize performance by configuring lazy loading for deep object graphs.</li>
    <li>Test mappings to ensure data integrity.</li>
  </ul>

  <p style="color: #2c3e50;">
    ModelMapper simplifies the conversion between DTOs and entities, making data transformation more efficient in Spring Boot applications.
  </p>
</div>
`
},
{
  title:`MapStruct`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">MapStruct in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    MapStruct is a Java annotation-based code generator that simplifies the mapping between Java objects, particularly DTOs and entities. It provides a type-safe and efficient way to perform object transformations without requiring reflection.
  </p>

  <h3 style="color: #16a085;">Why Use MapStruct?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Generates mapping code at compile time, ensuring high performance.</li>
    <li>Eliminates manual mapping code, reducing boilerplate.</li>
    <li>Provides strong type safety, catching errors at compile time.</li>
    <li>Supports complex object mappings with minimal configuration.</li>
  </ul>

  <h3 style="color: #e67e22;">Adding MapStruct to a Spring Boot Project</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;
          &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;
          &lt;version&gt;1.5.5.Final&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;
          &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;
          &lt;version&gt;1.5.5.Final&lt;/version&gt;
          &lt;scope&gt;provided&lt;/scope&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #3498db;">Creating a MapStruct Mapper</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.mapstruct.Mapper;
      import org.mapstruct.Mapping;
      import org.mapstruct.factory.Mappers;

      @Mapper
      public interface UserMapper {
          UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

          @Mapping(source = "email", target = "contactEmail")
          UserDTO userToUserDTO(User user);
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The above code defines a MapStruct mapper that converts a User entity to a UserDTO.</p>

  <h3 style="color: #e74c3c;">Using MapStruct in a Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      public class UserController {
          @GetMapping("/user")
          public UserDTO getUser() {
              User user = new User("John Doe", "john@example.com");
              return UserMapper.INSTANCE.userToUserDTO(user);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Best Practices for Using MapStruct</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use MapStruct for high-performance, compile-time object mapping.</li>
    <li>Define mapping rules explicitly using annotations for clarity.</li>
    <li>Ensure that the processor dependency is added to generate mapping code.</li>
    <li>Test mappings thoroughly to verify correct data transformation.</li>
  </ul>

  <p style="color: #2c3e50;">
    MapStruct provides an efficient and type-safe approach to object mapping in Spring Boot applications, significantly improving development speed and code maintainability.
  </p>
</div>
`
},
{
  title:`Jackson and DTO`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Jackson and DTO in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Jackson is a widely used Java library for handling JSON data. In Spring Boot applications, it is commonly used to serialize and deserialize Data Transfer Objects (DTOs) when exchanging data between the client and the server.
  </p>

  <h3 style="color: #16a085;">Why Use Jackson with DTOs?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Simplifies JSON serialization and deserialization.</li>
    <li>Reduces boilerplate code using annotations.</li>
    <li>Supports custom configurations for handling JSON properties.</li>
    <li>Ensures structured and readable JSON responses.</li>
  </ul>

  <h3 style="color: #e67e22;">Adding Jackson to a Spring Boot Project</h3>
  <p style="color: #2c3e50;">Spring Boot includes Jackson by default, but you can explicitly add it to your project using the following dependency:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
          &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
          &lt;version&gt;2.15.0&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #3498db;">Defining a DTO with Jackson Annotations</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import com.fasterxml.jackson.annotation.JsonProperty;

      public class UserDTO {
          @JsonProperty("user_name")
          private String name;

          @JsonProperty("user_email")
          private String email;

          // Constructors, Getters, and Setters
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">Here, the <code>@JsonProperty</code> annotation customizes the JSON field names.</p>

  <h3 style="color: #e74c3c;">Using Jackson in a Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      public class UserController {
          @PostMapping("/user")
          public ResponseEntity<UserDTO> createUser(@RequestBody UserDTO userDTO) {
              return ResponseEntity.ok(userDTO);
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">This example demonstrates how Jackson automatically converts JSON to a Java object using <code>@RequestBody</code>.</p>

  <h3 style="color: #e74c3c;">Best Practices for Using Jackson with DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@JsonProperty</code> to customize JSON field names.</li>
    <li>Apply <code>@JsonIgnore</code> to exclude sensitive fields.</li>
    <li>Use <code>@JsonFormat</code> for date/time formatting.</li>
    <li>Ensure DTOs have proper getters and setters for serialization.</li>
  </ul>

  <p style="color: #2c3e50;">
    Jackson simplifies data exchange in Spring Boot applications by automating JSON serialization and deserialization of DTOs. Using its annotations, developers can control JSON structure efficiently.
  </p>
</div>
`
},
{
  title:`Serialization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Serialization in Java</h2>
  <p style="font-size: 16px; color: #34495e;">
    Serialization is the process of converting a Java object into a byte stream so that it can be easily stored or transmitted. It is used to persist data, send objects over a network, and perform deep copies of objects.
  </p>

  <h3 style="color: #16a085;">Why Use Serialization?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Allows object persistence by saving objects to files or databases.</li>
    <li>Facilitates communication by sending objects over a network.</li>
    <li>Supports deep cloning of objects.</li>
    <li>Helps in caching complex objects.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Serialization in Java</h3>
  <p style="color: #2c3e50;">To make a class serializable, it must implement the <code>Serializable</code> interface:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import java.io.Serializable;

      public class Person implements Serializable {
          private static final long serialVersionUID = 1L;
          private String name;
          private int age;
          
          // Constructors, Getters, and Setters
      }
    </code>
  </pre>

  <h3 style="color: #3498db;">Saving and Retrieving Serialized Objects</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import java.io.*;

      public class SerializationDemo {
          public static void main(String[] args) throws IOException, ClassNotFoundException {
              Person person = new Person("John Doe", 30);
              
              // Serialize object
              FileOutputStream fileOut = new FileOutputStream("person.ser");
              ObjectOutputStream out = new ObjectOutputStream(fileOut);
              out.writeObject(person);
              out.close();
              fileOut.close();
              
              // Deserialize object
              FileInputStream fileIn = new FileInputStream("person.ser");
              ObjectInputStream in = new ObjectInputStream(fileIn);
              Person deserializedPerson = (Person) in.readObject();
              in.close();
              fileIn.close();
              
              System.out.println("Deserialized Person: " + deserializedPerson.getName());
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">The above code demonstrates how to serialize and deserialize an object in Java.</p>

  <h3 style="color: #e74c3c;">Best Practices for Serialization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always define <code>serialVersionUID</code> to maintain version control.</li>
    <li>Use <code>transient</code> keyword for sensitive data that should not be serialized.</li>
    <li>Consider using <code>Externalizable</code> for custom serialization logic.</li>
    <li>Avoid serializing large objects to improve performance.</li>
  </ul>

  <p style="color: #2c3e50;">
    Serialization is a powerful feature in Java that enables object persistence and data exchange. By following best practices, developers can ensure efficient and secure serialization in their applications.
  </p>
</div>
`
},
{
  title:`Deserialization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Deserialization in Java</h2>
  <p style="font-size: 16px; color: #34495e;">
    Deserialization is the process of converting a byte stream back into a Java object. It allows restoring previously serialized objects, making it useful for data storage, network communication, and caching mechanisms.
  </p>

  <h3 style="color: #16a085;">Why Use Deserialization?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Restores object states from a file or database.</li>
    <li>Facilitates data transfer between applications.</li>
    <li>Supports distributed computing by enabling object sharing.</li>
    <li>Enhances performance in caching mechanisms.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Deserialization in Java</h3>
  <p style="color: #2c3e50;">To deserialize an object, read it from a file using <code>ObjectInputStream</code>:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import java.io.*;

      public class DeserializationDemo {
          public static void main(String[] args) throws IOException, ClassNotFoundException {
              FileInputStream fileIn = new FileInputStream("person.ser");
              ObjectInputStream in = new ObjectInputStream(fileIn);
              Person deserializedPerson = (Person) in.readObject();
              in.close();
              fileIn.close();
              
              System.out.println("Deserialized Person: " + deserializedPerson.getName());
          }
      }
    </code>
  </pre>

  <h3 style="color: #3498db;">Handling Deserialization Issues</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>ClassNotFoundException:</strong> Ensure the class definition is available during deserialization.</li>
    <li><strong>InvalidClassException:</strong> Maintain a consistent <code>serialVersionUID</code> to prevent incompatibility issues.</li>
    <li><strong>EOFException:</strong> Verify that the file or stream contains valid serialized data.</li>
    <li><strong>Security Concerns:</strong> Avoid deserializing untrusted data to prevent exploits.</li>
  </ul>

  <h3 style="color: #e74c3c;">Best Practices for Deserialization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always define a <code>serialVersionUID</code> to handle version changes.</li>
    <li>Use <code>transient</code> for sensitive data that should not be deserialized.</li>
    <li>Implement <code>readObject</code> method for custom validation and security.</li>
    <li>Prefer JSON or XML serialization for safer data handling in distributed applications.</li>
  </ul>

  <p style="color: #2c3e50;">
    Deserialization is a crucial aspect of Java programming, enabling object restoration and data exchange. However, careful implementation is necessary to ensure security and maintain application integrity.
  </p>
</div>
`
},
{
  title:`Nested DTOs`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Nested DTOs in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Nested Data Transfer Objects (DTOs) are a design pattern used to represent complex data structures in a hierarchical manner. In Spring Boot, nested DTOs are particularly useful when dealing with APIs that require sending or receiving data with multiple levels of relationships, such as a user with an address, an order with items, or a department with employees. By using nested DTOs, you can encapsulate related data into a single object, making your API contracts cleaner and more intuitive.
  </p>

  <h3 style="color: #16a085;">Why Use Nested DTOs?</h3>
  <p style="color: #2c3e50;">
    Nested DTOs offer several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Structured Data</strong>: Represent complex data relationships in a clear and organized way.</li>
    <li><strong>Improved Readability</strong>: Make API contracts easier to understand by grouping related fields.</li>
    <li><strong>Reusability</strong>: Reuse nested DTOs across multiple endpoints or services.</li>
    <li><strong>Validation</strong>: Apply validation rules to nested objects for better data integrity.</li>
    <li><strong>Separation of Concerns</strong>: Keep the API layer decoupled from the internal data model.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Nested DTOs</h3>
  <p style="color: #2c3e50;">
    When working with nested DTOs in Spring Boot, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Composition</strong>: Nesting one DTO inside another to represent relationships (e.g., a user with an address).</li>
    <li><strong>Validation</strong>: Applying validation annotations to nested objects to ensure data integrity.</li>
    <li><strong>Serialization</strong>: Converting nested DTOs to and from JSON or other formats using libraries like Jackson.</li>
    <li><strong>Mapping</strong>: Mapping nested DTOs to entities and vice versa using tools like <code>ModelMapper</code> or manual mapping.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Nested DTOs in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement nested DTOs in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define Nested DTOs</h4>
  <p style="color: #2c3e50;">
    Create a parent DTO and a nested DTO to represent a user with an address.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.validation.constraints.NotBlank;
      import jakarta.validation.constraints.NotNull;

      public class UserDTO {
          private Long id;

          @NotBlank(message = "Name is required")
          private String name;

          @NotBlank(message = "Email is required")
          private String email;

          @NotNull(message = "Address is required")
          private AddressDTO address;

          // Getters and Setters
      }

      public class AddressDTO {
          @NotBlank(message = "Street is required")
          private String street;

          @NotBlank(message = "City is required")
          private String city;

          @NotBlank(message = "State is required")
          private String state;

          @NotBlank(message = "Zip code is required")
          private String zipCode;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Use Nested DTOs in a Controller</h4>
  <p style="color: #2c3e50;">
    Use the nested DTOs in a controller to handle incoming and outgoing data.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/api")
      public class UserController {

          @PostMapping("/user")
          public String createUser(@RequestBody UserDTO userDTO) {
              System.out.println("User created: " + userDTO.getName());
              System.out.println("Address: " + userDTO.getAddress().getCity());
              return "User created successfully";
          }

          @GetMapping("/user")
          public UserDTO getUser() {
              AddressDTO address = new AddressDTO("123 Main St", "Springfield", "IL", "62701");
              return new UserDTO(1L, "John Doe", "john.doe@example.com", address);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Map Nested DTOs to Entities</h4>
  <p style="color: #2c3e50;">
    Use a mapping library like <code>ModelMapper</code> to convert between nested DTOs and entities.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.modelmapper.ModelMapper;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          private final ModelMapper modelMapper = new ModelMapper();

          public UserDTO createUser(UserDTO userDTO) {
              // Map DTO to entity
              User user = modelMapper.map(userDTO, User.class);
              // Save entity to database
              User savedUser = userRepository.save(user);
              // Map entity back to DTO
              return modelMapper.map(savedUser, UserDTO.class);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Nested DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep nested DTOs focused and avoid excessive nesting to prevent complexity.</li>
    <li>Use validation annotations to ensure data integrity at all levels.</li>
    <li>Leverage mapping libraries to simplify conversions between DTOs and entities.</li>
    <li>Document your API contracts clearly to help consumers understand the structure of nested DTOs.</li>
    <li>Avoid exposing sensitive information in nested DTOs.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Nested DTOs are a powerful tool for representing complex data structures in Spring Boot applications. By encapsulating related data into a single object, you can create cleaner, more intuitive APIs that are easier to maintain and extend. Whether you're building RESTful APIs or integrating with external systems, nested DTOs provide a flexible and efficient way to manage hierarchical data.
  </p>
</div>`
},
{
  title:`DTO Validation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to DTO Validation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) are commonly used in Spring Boot applications to encapsulate data sent between the client and server. Validating DTOs ensures that the data received by your application meets specific criteria, such as required fields, correct formats, and business rules. Spring Boot provides robust support for DTO validation through the <strong>Bean Validation API (JSR 380)</strong>, which allows you to define validation rules using annotations and handle validation errors gracefully.
  </p>

  <h3 style="color: #16a085;">Why is DTO Validation Important?</h3>
  <p style="color: #2c3e50;">
    DTO validation is essential for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures that the data conforms to expected formats and constraints.</li>
    <li><strong>Security</strong>: Prevents injection attacks and other malicious inputs.</li>
    <li><strong>User Experience</strong>: Provides meaningful error messages to users when input is invalid.</li>
    <li><strong>Business Logic</strong>: Ensures that only valid data is processed by the application, reducing the risk of runtime errors.</li>
    <li><strong>API Consistency</strong>: Maintains consistent data standards across your application.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of DTO Validation</h3>
  <p style="color: #2c3e50;">
    Spring Boot leverages the Bean Validation API (JSR 380) to perform DTO validation. Key concepts include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Validation Annotations</strong>: Annotations like <code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>, and <code>@Pattern</code> are used to define validation rules.</li>
    <li><strong>Validation Groups</strong>: Allows you to apply different validation rules for different scenarios (e.g., create vs. update).</li>
    <li><strong>Custom Validators</strong>: Enables you to create custom validation logic for complex use cases.</li>
    <li><strong>Error Handling</strong>: Spring Boot provides mechanisms to handle validation errors and return meaningful responses to clients.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing DTO Validation in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement DTO validation in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define a DTO with Validation Annotations</h4>
  <p style="color: #2c3e50;">
    Create a DTO with validation annotations to enforce constraints on the data.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.validation.constraints.*;

      public class UserDTO {

          @NotNull(message = "ID is required")
          private Long id;

          @NotBlank(message = "Name is required")
          @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
          private String name;

          @Email(message = "Invalid email format")
          @NotBlank(message = "Email is required")
          private String email;

          @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$", 
                   message = "Password must be at least 8 characters and contain at least one letter and one number")
          private String password;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Enable Validation in the Controller</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Valid</code> annotation to enable validation for the incoming request body.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.ResponseEntity;
      import org.springframework.validation.annotation.Validated;
      import org.springframework.web.bind.annotation.*;

      import jakarta.validation.Valid;

      @RestController
      @RequestMapping("/users")
      @Validated
      public class UserController {

          @PostMapping
          public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody UserDTO userDTO) {
              // Process the validated userDTO
              return ResponseEntity.ok("User created successfully");
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Handle Validation Errors</h4>
  <p style="color: #2c3e50;">
    Use <code>@ExceptionHandler</code> to handle validation errors and return meaningful error messages.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.RestControllerAdvice;

      import java.util.HashMap;
      import java.util.Map;

      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(MethodArgumentNotValidException.class)
          public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
              ex.getBindingResult().getFieldErrors().forEach(error -&gt;
                  errors.put(error.getField(), error.getDefaultMessage())
              );
              return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Custom Validators</h3>
  <p style="color: #2c3e50;">
    For complex validation logic, you can create custom validators by implementing the <code>ConstraintValidator</code> interface.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.validation.Constraint;
      import jakarta.validation.ConstraintValidator;
      import jakarta.validation.ConstraintValidatorContext;
      import jakarta.validation.Payload;
      import java.lang.annotation.*;

      @Target({ ElementType.FIELD })
      @Retention(RetentionPolicy.RUNTIME)
      @Constraint(validatedBy = CustomEmailValidator.class)
      public @interface CustomEmail {
          String message() default "Invalid email format";
          Class&lt;?&gt;[] groups() default {};
          Class&lt;? extends Payload&gt;[] payload() default {};
      }

      public class CustomEmailValidator implements ConstraintValidator&lt;CustomEmail, String&gt; {
          @Override
          public boolean isValid(String email, ConstraintValidatorContext context) {
              return email != null && email.endsWith("@example.com");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    You can then use the custom annotation in your DTO:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          @CustomEmail(message = "Email must end with @example.com")
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    DTO validation is a fundamental aspect of building secure and reliable Spring Boot applications. By leveraging the Bean Validation API and Spring's validation support, you can ensure that your application processes only valid and safe data. Whether you're using built-in annotations or custom validators, proper validation practices will enhance the quality and security of your application.
  </p>
</div>`
},
{
  title:`Custom Validators`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Custom Validators in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Custom validators in Spring Boot allow developers to implement their own validation logic beyond the standard constraints like <code>@NotNull</code> and <code>@Size</code>. These validators help ensure data integrity and enforce business rules in applications.
  </p>

  <h3 style="color: #16a085;">Why Use Custom Validators?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Handles complex validation scenarios.</li>
    <li>Encapsulates business logic within reusable components.</li>
    <li>Improves code readability and maintainability.</li>
    <li>Ensures consistency in data validation across the application.</li>
  </ul>

  <h3 style="color: #e67e22;">Creating a Custom Validator in Spring Boot</h3>
  <p style="color: #2c3e50;">A custom validator requires two main components: an annotation and a validation class.</p>

  <h4 style="color: #2980b9;">Step 1: Define a Custom Annotation</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.validation.Constraint;
      import javax.validation.Payload;
      import java.lang.annotation.ElementType;
      import java.lang.annotation.Retention;
      import java.lang.annotation.RetentionPolicy;
      import java.lang.annotation.Target;

      @Target({ElementType.FIELD})
      @Retention(RetentionPolicy.RUNTIME)
      @Constraint(validatedBy = AgeValidator.class)
      public @interface ValidAge {
          String message() default "Age must be between 18 and 60";
          Class<?>[] groups() default {};
          Class<? extends Payload>[] payload() default {};
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">Step 2: Implement the Validator</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.validation.ConstraintValidator;
      import javax.validation.ConstraintValidatorContext;

      public class AgeValidator implements ConstraintValidator<ValidAge, Integer> {
          @Override
          public void initialize(ValidAge constraintAnnotation) {}
          
          @Override
          public boolean isValid(Integer age, ConstraintValidatorContext context) {
              return age != null && age >= 18 && age <= 60;
          }
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">Step 3: Apply the Validator</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.validation.Valid;
      import javax.validation.constraints.NotNull;

      public class User {
          @NotNull
          private String name;
          
          @ValidAge
          private Integer age;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #3498db;">Validating Custom Constraints in a Controller</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.validation.annotation.Validated;
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;

      @RestController
      @RequestMapping("/users")
      @Validated
      public class UserController {
          @PostMapping("/create")
          public String createUser(@Valid @RequestBody User user) {
              return "User created successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Best Practices for Custom Validators</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep validation logic simple and reusable.</li>
    <li>Use meaningful error messages for better debugging.</li>
    <li>Combine multiple validators for complex scenarios.</li>
    <li>Test validators thoroughly to ensure correctness.</li>
  </ul>

  <p style="color: #2c3e50;">
    Custom validators in Spring Boot provide a robust way to enforce business rules and ensure data consistency. By implementing custom annotations and validation logic, developers can create more reliable and maintainable applications.
  </p>
</div>
`
},
{
  title:`DTO in REST APIs`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in REST APIs</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) play a crucial role in REST APIs by ensuring a structured and efficient way to exchange data 
    between clients and servers. They help decouple the internal domain models from the API's response/request structure, 
    improving maintainability and security.
  </p>

  <h3 style="color: #16a085;">Why Use DTOs in REST APIs?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulation of data to prevent exposing internal domain models.</li>
    <li>Flexibility in modifying API responses without affecting internal logic.</li>
    <li>Better control over serialization and deserialization.</li>
    <li>Improved security by preventing over-posting vulnerabilities.</li>
    <li>Facilitates API versioning by structuring data independently.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using DTO in a Spring Boot REST API</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class UserDTO {
          private String name;
          private String email;
          
          public UserDTO(String name, String email) {
              this.name = name;
              this.email = email;
          }

          public String getName() { return name; }
          public void setName(String name) { this.name = name; }

          public String getEmail() { return email; }
          public void setEmail(String email) { this.email = email; }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Mapping Entity to DTO</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/users")
      public class UserController {
          private final UserService userService;

          public UserController(UserService userService) {
              this.userService = userService;
          }

          @GetMapping("/{id}")
          public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
              User user = userService.findUserById(id);
              UserDTO userDTO = new UserDTO(user.getName(), user.getEmail());
              return ResponseEntity.ok(userDTO);
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for Using DTOs in REST APIs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use DTOs for both request and response payloads.</li>
    <li>Leverage libraries like ModelMapper or MapStruct for automatic mapping.</li>
    <li>Keep DTOs lightweight and avoid adding business logic.</li>
    <li>Use separate DTOs for different use cases (e.g., UserResponseDTO, UserRequestDTO).</li>
    <li>Ensure proper validation on DTO fields using annotations like <code>@Valid</code>.</li>
  </ul>
</div>
`
},
{
title:`DTO in Microservices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a microservices architecture, Data Transfer Objects (DTOs) help streamline communication between services
    by structuring data efficiently and reducing unnecessary exposure of internal domain models.
    DTOs enhance security, maintainability, and consistency across different microservices.
  </p>

  <h3 style="color: #16a085;">Why Use DTOs in Microservices?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prevents direct exposure of database entities.</li>
    <li>Ensures a consistent data format across microservices.</li>
    <li>Reduces coupling between services by defining a clear contract.</li>
    <li>Improves security by preventing over-fetching and under-fetching of data.</li>
    <li>Enables easy versioning of APIs.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using DTOs in a Microservice</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class OrderDTO {
          private Long id;
          private String productName;
          private int quantity;
          
          public OrderDTO(Long id, String productName, int quantity) {
              this.id = id;
              this.productName = productName;
              this.quantity = quantity;
          }

          public Long getId() { return id; }
          public void setId(Long id) { this.id = id; }

          public String getProductName() { return productName; }
          public void setProductName(String productName) { this.productName = productName; }

          public int getQuantity() { return quantity; }
          public void setQuantity(int quantity) { this.quantity = quantity; }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Mapping DTOs Between Microservices</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @RestController
      @RequestMapping("/orders")
      public class OrderController {
          private final OrderService orderService;

          public OrderController(OrderService orderService) {
              this.orderService = orderService;
          }

          @GetMapping("/{id}")
          public ResponseEntity<OrderDTO> getOrder(@PathVariable Long id) {
              Order order = orderService.findOrderById(id);
              OrderDTO orderDTO = new OrderDTO(order.getId(), order.getProductName(), order.getQuantity());
              return ResponseEntity.ok(orderDTO);
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for DTOs in Microservices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use DTOs for both request and response payloads.</li>
    <li>Leverage libraries like ModelMapper or MapStruct for automatic mapping.</li>
    <li>Ensure DTOs are versioned properly to avoid breaking changes.</li>
    <li>Keep DTOs minimal and avoid adding unnecessary data fields.</li>
    <li>Utilize DTOs to maintain API contracts between microservices.</li>
  </ul>
</div>
`
},
{
  title:`DTO in GraphQL`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in GraphQL</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) play a crucial role in GraphQL by structuring the data exchanged between
    clients and the server. Unlike REST, GraphQL enables clients to request specific fields, making DTOs
    essential for optimizing data transfer and maintaining a clear schema.
  </p>

  <h3 style="color: #16a085;">Why Use DTOs in GraphQL?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prevents over-fetching and under-fetching of data.</li>
    <li>Improves API response performance by limiting returned fields.</li>
    <li>Encapsulates business logic and ensures API consistency.</li>
    <li>Provides a structured contract for GraphQL queries and mutations.</li>
    <li>Enhances security by restricting exposed fields.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using DTOs in GraphQL</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Data
      public class UserDTO {
          private Long id;
          private String username;
          private String email;
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Implementing DTOs in a GraphQL Query</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Component
      public class UserGraphQLResolver implements GraphQLQueryResolver {
          private final UserService userService;

          public UserGraphQLResolver(UserService userService) {
              this.userService = userService;
          }

          public UserDTO getUser(Long id) {
              User user = userService.findById(id);
              return new UserDTO(user.getId(), user.getUsername(), user.getEmail());
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for DTOs in GraphQL</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use DTOs to structure responses and avoid exposing internal entities.</li>
    <li>Define GraphQL schema clearly with mapped DTOs.</li>
    <li>Use libraries like MapStruct to automate DTO conversion.</li>
    <li>Ensure DTOs contain only necessary fields for a specific GraphQL query.</li>
    <li>Keep DTOs versioned to support backward compatibility.</li>
  </ul>
</div>
`
},
{
  title:`DTO in Kafka/RabbitMQ`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in Kafka/RabbitMQ</h2>
  <p style="font-size: 16px; color: #34495e;">
    In event-driven architectures, Data Transfer Objects (DTOs) facilitate seamless communication between
    microservices using messaging systems like Apache Kafka and RabbitMQ. They help structure and standardize
    message payloads, ensuring consistency and reducing dependencies on internal entity structures.
  </p>

  <h3 style="color: #16a085;">Why Use DTOs in Kafka/RabbitMQ?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensures message payloads are well-structured and version-controlled.</li>
    <li>Decouples internal domain models from external consumers.</li>
    <li>Enhances compatibility between different microservices.</li>
    <li>Improves serialization and deserialization of messages.</li>
    <li>Facilitates schema evolution with minimal impact on services.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using DTOs in Kafka</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class OrderDTO {
          private String orderId;
          private String product;
          private int quantity;
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Publishing DTO Messages to Kafka</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Service
      public class OrderProducer {
          private final KafkaTemplate<String, OrderDTO> kafkaTemplate;

          public OrderProducer(KafkaTemplate<String, OrderDTO> kafkaTemplate) {
              this.kafkaTemplate = kafkaTemplate;
          }

          public void sendOrder(OrderDTO order) {
              kafkaTemplate.send("order-topic", order);
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Consuming DTO Messages in RabbitMQ</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Service
      public class OrderConsumer {
          @RabbitListener(queues = "order-queue")
          public void receiveOrder(OrderDTO order) {
              System.out.println("Received order: " + order);
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for DTOs in Kafka/RabbitMQ</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use versioning in DTOs to support backward compatibility.</li>
    <li>Keep DTOs lightweight and only include necessary fields.</li>
    <li>Utilize serialization formats like JSON or Avro for interoperability.</li>
    <li>Ensure DTOs are immutable to maintain data integrity.</li>
    <li>Validate DTOs before sending or processing messages.</li>
  </ul>
</div>
`
},
{
  title:`DTO in Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    In security implementations, Data Transfer Objects (DTOs) play a crucial role in handling authentication,
    authorization, and secure data exchange. By encapsulating user credentials, roles, and permissions, DTOs help
    prevent direct exposure of sensitive domain models.
  </p>

  <h3 style="color: #16a085;">Why Use DTOs in Security?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prevents exposure of internal domain entities.</li>
    <li>Enhances security by enforcing validation before processing.</li>
    <li>Separates authentication logic from business logic.</li>
    <li>Standardizes data exchange in secure APIs.</li>
    <li>Improves compliance with security best practices.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Authentication Request DTO</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class AuthRequestDTO {
          private String username;
          private String password;
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Example: Authentication Response DTO</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class AuthResponseDTO {
          private String token;
          private String role;
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Using DTOs in Security Service</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Service
      public class AuthService {
          public AuthResponseDTO authenticate(AuthRequestDTO authRequest) {
              // Simulated authentication logic
              String token = generateToken(authRequest.getUsername());
              return new AuthResponseDTO(token, "USER");
          }

          private String generateToken(String username) {
              return Base64.getEncoder().encodeToString((username + "-token").getBytes());
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for Secure DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use validation annotations to prevent malicious inputs.</li>
    <li>Ensure passwords are never included in response DTOs.</li>
    <li>Utilize JWT for secure authentication responses.</li>
    <li>Implement role-based access control (RBAC) within DTOs.</li>
    <li>Keep DTOs lightweight and only include necessary fields.</li>
  </ul>
</div>
`
},
{
  title:`DTO Performance`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO Performance</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) play a crucial role in optimizing the performance of applications by reducing data
    redundancy and ensuring efficient communication between different layers of an application. Well-structured DTOs
    improve serialization, minimize unnecessary data transfer, and enhance overall application responsiveness.
  </p>

  <h3 style="color: #16a085;">Why DTOs Impact Performance?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Reduces data size by excluding unnecessary fields.</li>
    <li>Optimizes serialization and deserialization processes.</li>
    <li>Minimizes database queries by aggregating required data.</li>
    <li>Improves caching by structuring frequently used data.</li>
    <li>Enhances response time in microservices and REST APIs.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Optimized DTO for Performance</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class UserDTO {
          private Long id;
          private String name;
          private String email;
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Best Practices for DTO Performance</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use selective field inclusion to reduce payload size.</li>
    <li>Utilize caching mechanisms for frequently used DTOs.</li>
    <li>Ensure proper indexing in the database to support DTO queries.</li>
    <li>Leverage lazy loading for DTO-related entity fetching.</li>
    <li>Use efficient mapping frameworks like MapStruct or ModelMapper.</li>
  </ul>

  <h3 style="color: #27ae60;">Benchmarking DTO Performance</h3>
  <p style="color: #2c3e50;">
    Performance benchmarking helps measure the efficiency of DTOs in data transfer. Tools such as JMH (Java
    Microbenchmark Harness) and profiling utilities like YourKit or VisualVM can be used to analyze serialization,
    deserialization, and network transmission times.
  </p>
</div>
`
},
{
  title:`DTO Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO Best Practices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) are essential for efficient communication between different layers of an application. 
    Following best practices in DTO design improves maintainability, performance, and scalability while preventing 
    unnecessary data exposure.
  </p>

  <h3 style="color: #16a085;">Key Best Practices for DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure DTOs contain only necessary fields to minimize payload size.</li>
    <li>Keep DTOs immutable whenever possible to prevent unintended modifications.</li>
    <li>Use DTOs to decouple entity models from external exposure.</li>
    <li>Leverage mapping frameworks like MapStruct for efficient object transformation.</li>
    <li>Validate input data at the DTO level using annotations like <code>@Valid</code> and <code>@NotNull</code>.</li>
    <li>Implement versioning in DTOs to ensure backward compatibility.</li>
    <li>Group related DTOs in packages for better project structure.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Well-Structured DTO</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class ProductDTO {
          private Long id;
          private String name;
          private BigDecimal price;
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Common Mistakes to Avoid</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Exposing entity models instead of using DTOs.</li>
    <li>Including unnecessary fields, leading to bloated DTOs.</li>
    <li>Using DTOs for database transactions instead of proper entity models.</li>
    <li>Ignoring proper serialization techniques, which can impact performance.</li>
  </ul>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Well-designed DTOs improve the efficiency and security of an application by optimizing data transfer and 
    maintaining separation between different layers. Following these best practices ensures scalable and maintainable 
    software architecture.
  </p>
</div>
`
},
{
  title:`Testing DTOs`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing DTOs</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) play a critical role in transferring data between layers of an application. 
    Proper testing of DTOs ensures data integrity, correctness, and compliance with business rules.
  </p>

  <h3 style="color: #16a085;">Why Test DTOs?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensures DTOs correctly serialize and deserialize data.</li>
    <li>Validates object mapping and transformations.</li>
    <li>Confirms that validation constraints function properly.</li>
    <li>Prevents unintended modifications by ensuring immutability.</li>
    <li>Enhances maintainability by catching issues early.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Testing a DTO with JUnit</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import static org.junit.jupiter.api.Assertions.*;
      import org.junit.jupiter.api.Test;
      import java.math.BigDecimal;

      class ProductDTOTest {
          @Test
          void testDTOCreation() {
              ProductDTO productDTO = new ProductDTO(1L, "Laptop", new BigDecimal("999.99"));
              assertEquals(1L, productDTO.getId());
              assertEquals("Laptop", productDTO.getName());
              assertEquals(new BigDecimal("999.99"), productDTO.getPrice());
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Testing DTO Serialization</h3>
  <p style="color: #2c3e50;">
    It is crucial to test if DTOs can correctly serialize and deserialize JSON data.
    Tools like Jackson's ObjectMapper can be used for this purpose.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import com.fasterxml.jackson.databind.ObjectMapper;
      import org.junit.jupiter.api.Test;
      import static org.junit.jupiter.api.Assertions.*;

      class ProductDTOSerializationTest {
          @Test
          void testSerialization() throws Exception {
              ObjectMapper objectMapper = new ObjectMapper();
              ProductDTO productDTO = new ProductDTO(1L, "Laptop", new BigDecimal("999.99"));
              String json = objectMapper.writeValueAsString(productDTO);
              ProductDTO deserializedDTO = objectMapper.readValue(json, ProductDTO.class);
              assertEquals(productDTO, deserializedDTO);
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Proper testing of DTOs ensures they function correctly in serialization, validation, and data transformation. 
    Using frameworks like JUnit and Jackson can help automate these tests and improve software quality.
  </p>
</div>
`
},
{
  title:`DTO Anti-Patterns`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to DTO Anti-Patterns</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data Transfer Objects (DTOs) are widely used in Spring Boot applications to encapsulate data sent between the client and server. While DTOs provide many benefits, such as decoupling the API layer from the persistence layer and improving security, they can also be misused. DTO anti-patterns are common mistakes or poor practices that can lead to bloated, inefficient, or hard-to-maintain code. Recognizing and avoiding these anti-patterns is crucial for building clean, scalable, and maintainable applications.
  </p>

  <h3 style="color: #16a085;">Why Avoid DTO Anti-Patterns?</h3>
  <p style="color: #2c3e50;">
    Avoiding DTO anti-patterns is important for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Code Maintainability</strong>: Poorly designed DTOs can make the codebase harder to understand and maintain.</li>
    <li><strong>Performance</strong>: Inefficient DTOs can lead to unnecessary data transfer and processing overhead.</li>
    <li><strong>Security</strong>: Exposing sensitive data through DTOs can lead to security vulnerabilities.</li>
    <li><strong>Scalability</strong>: Bloated or overly complex DTOs can hinder the scalability of your application.</li>
    <li><strong>Consistency</strong>: Inconsistent use of DTOs can lead to confusion and errors in the application.</li>
  </ul>

  <h3 style="color: #e67e22;">Common DTO Anti-Patterns</h3>
  <p style="color: #2c3e50;">
    Below are some common DTO anti-patterns and how to avoid them:
  </p>

  <h4 style="color: #2980b9;">1. Exposing Sensitive Data</h4>
  <p style="color: #2c3e50;">
    <strong>Anti-Pattern</strong>: Including sensitive information like passwords, credit card numbers, or personal identification numbers (PINs) in DTOs.
  </p>
  <p style="color: #2c3e50;">
    <strong>Solution</strong>: Exclude sensitive fields from DTOs or use masking techniques to hide sensitive data.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      // Bad: Exposing sensitive data
      public class UserDTO {
          private String username;
          private String password; // Sensitive data
      }

      // Good: Exclude sensitive data
      public class UserDTO {
          private String username;
          // Password is excluded
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">2. Overloading DTOs with Unnecessary Data</h4>
  <p style="color: #2c3e50;">
    <strong>Anti-Pattern</strong>: Including fields in DTOs that are not required by the client, leading to bloated payloads.
  </p>
  <p style="color: #2c3e50;">
    <strong>Solution</strong>: Design DTOs to include only the fields needed for a specific use case.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      // Bad: Overloaded DTO
      public class UserDTO {
          private Long id;
          private String name;
          private String email;
          private String address;
          private String phoneNumber;
          private String socialSecurityNumber; // Unnecessary field
      }

      // Good: Minimal DTO
      public class UserDTO {
          private Long id;
          private String name;
          private String email;
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">3. Ignoring Validation</h4>
  <p style="color: #2c3e50;">
    <strong>Anti-Pattern</strong>: Failing to validate data in DTOs, leading to potential security vulnerabilities or data integrity issues.
  </p>
  <p style="color: #2c3e50;">
    <strong>Solution</strong>: Use validation annotations like <code>@NotNull</code>, <code>@Size</code>, and <code>@Email</code> to enforce data integrity.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      // Bad: No validation
      public class UserDTO {
          private String name;
          private String email;
      }

      // Good: With validation
      public class UserDTO {
          @NotBlank(message = "Name is required")
          private String name;

          @Email(message = "Invalid email format")
          @NotBlank(message = "Email is required")
          private String email;
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">4. Using Entities as DTOs</h4>
  <p style="color: #2c3e50;">
    <strong>Anti-Pattern</strong>: Using entity classes directly as DTOs, which tightly couples the API layer to the persistence layer.
  </p>
  <p style="color: #2c3e50;">
    <strong>Solution</strong>: Create separate DTO classes to decouple the API layer from the persistence layer.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      // Bad: Using entity as DTO
      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
      }

      // Good: Separate DTO
      public class UserDTO {
          private Long id;
          private String name;
          private String email;
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">5. Overusing Nested DTOs</h4>
  <p style="color: #2c3e50;">
    <strong>Anti-Pattern</strong>: Creating deeply nested DTOs that are difficult to understand and maintain.
  </p>
  <p style="color: #2c3e50;">
    <strong>Solution</strong>: Limit the depth of nested DTOs and ensure they are logically structured.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      // Bad: Deeply nested DTOs
      public class UserDTO {
          private Long id;
          private String name;
          private AddressDTO address;
          private List<OrderDTO> orders;
      }

      public class OrderDTO {
          private Long id;
          private List<ItemDTO> items;
      }

      // Good: Flattened structure
      public class UserDTO {
          private Long id;
          private String name;
          private String address;
          private List<String> orders; // Simplified
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using DTOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep DTOs focused and minimal, including only the necessary fields.</li>
    <li>Use validation annotations to enforce data integrity.</li>
    <li>Separate DTOs from entities to decouple the API layer from the persistence layer.</li>
    <li>Avoid exposing sensitive data in DTOs.</li>
    <li>Limit the depth of nested DTOs to maintain simplicity.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    DTOs are a powerful tool for managing data transfer in Spring Boot applications, but they must be used correctly to avoid common anti-patterns. By following best practices and avoiding pitfalls like exposing sensitive data, overloading DTOs, and ignoring validation, you can ensure that your application remains clean, secure, and maintainable. Proper use of DTOs will enhance the scalability and reliability of your application while providing a clear and consistent API contract.
  </p>
</div>`
},
{
  title:`Service Layer Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Service Layer Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    The service layer is a crucial component in a layered application architecture. It acts as an intermediary between the controller and repository layers, ensuring business logic is centralized and reusable. 
  </p>

  <h3 style="color: #16a085;">Key Responsibilities of the Service Layer</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulating business logic and preventing it from being scattered across controllers.</li>
    <li>Coordinating between the controller and data access layers.</li>
    <li>Handling transactions and enforcing security constraints.</li>
    <li>Supporting service reusability and maintainability.</li>
    <li>Facilitating unit testing and separation of concerns.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Implementing a Service Layer in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class ProductService {
          private final ProductRepository productRepository;

          public ProductService(ProductRepository productRepository) {
              this.productRepository = productRepository;
          }

          public List<Product> getAllProducts() {
              return productRepository.findAll();
          }

          public Product getProductById(Long id) {
              return productRepository.findById(id).orElseThrow(() -> new RuntimeException("Product not found"));
          }

          public Product saveProduct(Product product) {
              return productRepository.save(product);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Advantages of Using a Service Layer</h3>
  <p style="color: #2c3e50;">
    Implementing a service layer provides several advantages, such as:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Better organization and separation of concerns.</li>
    <li>Easier unit testing by isolating business logic.</li>
    <li>Enhanced maintainability and scalability of applications.</li>
    <li>Centralized error handling and transaction management.</li>
  </ul>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The service layer in a Spring Boot application acts as a bridge between controllers and data layers, ensuring business logic is well-structured and reusable. 
    By adopting a service layer, developers can build scalable, maintainable, and testable applications.
  </p>
</div>
`
},
{
  title:`MVC & Service Layer`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">MVC & Service Layer</h2>
  <p style="font-size: 16px; color: #34495e;">
    The Model-View-Controller (MVC) pattern is a widely used architectural pattern for designing web applications. The service layer plays a critical role in this architecture by separating business logic from the controller and data access layers. This enhances modularity, maintainability, and testability.
  </p>

  <h3 style="color: #16a085;">Role of Service Layer in MVC</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Acts as an intermediary between controllers and repositories.</li>
    <li>Encapsulates business logic to keep controllers lightweight.</li>
    <li>Manages transactions and security aspects.</li>
    <li>Improves reusability and maintainability of code.</li>
    <li>Facilitates unit testing by isolating business logic from controllers.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Implementing Service Layer in MVC</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List<User> getAllUsers() {
              return userRepository.findAll();
          }

          public User getUserById(Long id) {
              return userRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found"));
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Advantages of MVC with a Service Layer</h3>
  <p style="color: #2c3e50;">
    Using a service layer within the MVC pattern provides multiple benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Improves application structure by enforcing separation of concerns.</li>
    <li>Enhances code maintainability and modularity.</li>
    <li>Makes business logic reusable across different parts of the application.</li>
    <li>Simplifies debugging and unit testing.</li>
    <li>Provides a centralized point for handling business rules.</li>
  </ul>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The combination of MVC and a well-structured service layer helps in designing scalable and maintainable applications. By keeping controllers clean and delegating business logic to the service layer, developers can achieve better code organization and reusability.
  </p>
</div>
`
},
{
  title:`Service Layer in Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Service Layer in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a Spring Boot application, the service layer plays a crucial role in separating business logic from controllers and repositories. This enhances modularity, maintainability, and testability, making it a core part of a well-structured application.
  </p>

  <h3 style="color: #16a085;">Purpose of Service Layer in Spring Boot</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulates business logic and computations.</li>
    <li>Decouples controllers from direct database access.</li>
    <li>Facilitates unit testing by isolating business logic.</li>
    <li>Improves code organization and maintainability.</li>
    <li>Handles transactions, security, and validation.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Implementing a Service Layer in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List<User> getAllUsers() {
              return userRepository.findAll();
          }

          public User getUserById(Long id) {
              return userRepository.findById(id)
                  .orElseThrow(() -> new RuntimeException("User not found"));
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Advantages of Using a Service Layer</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keeps controllers clean and focused on handling requests.</li>
    <li>Improves separation of concerns, making code more modular.</li>
    <li>Facilitates unit testing and debugging.</li>
    <li>Enhances scalability and maintainability.</li>
    <li>Provides a central place for managing business logic.</li>
  </ul>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The service layer in Spring Boot applications is essential for maintaining clean architecture and ensuring scalability. By separating business logic from controllers, developers can create robust, maintainable, and testable applications.
  </p>
</div>
`
},
{
  title:`@Service Annotation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Service Annotation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@Service</code> annotation in Spring Boot is a specialization of the <code>@Component</code> annotation that marks a class as a service component. It is typically used to define service-layer beans that contain business logic and interact with repositories.
  </p>

  <h3 style="color: #16a085;">Purpose of @Service Annotation</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Indicates that a class is a service component in the application.</li>
    <li>Helps in automatic component scanning and dependency injection.</li>
    <li>Enhances code readability and modularity.</li>
    <li>Encapsulates business logic separate from the controller and repository layers.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using @Service Annotation</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List<User> getAllUsers() {
              return userRepository.findAll();
          }

          public User getUserById(Long id) {
              return userRepository.findById(id)
                  .orElseThrow(() -> new RuntimeException("User not found"));
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Advantages of Using @Service Annotation</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Makes service classes easily identifiable and manageable.</li>
    <li>Ensures separation of concerns by keeping business logic isolated.</li>
    <li>Supports Spring's dependency injection mechanism.</li>
    <li>Improves application modularity and maintainability.</li>
  </ul>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Service</code> annotation in Spring Boot is a key component in defining the service layer of an application. It helps structure code effectively, improves testability, and simplifies dependency management through Spring's built-in capabilities.
  </p>
</div>
`
},
{
  title:`Dependency Injection`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Dependency Injection in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Dependency Injection (DI) is a fundamental design pattern in Spring Boot that promotes loose coupling and enhances modularity. It allows dependencies to be injected into components, rather than being manually instantiated within them, making the application more flexible and testable.
  </p>

  <h3 style="color: #16a085;">Types of Dependency Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Constructor Injection:</strong> Dependencies are passed via a constructor.</li>
    <li><strong>Setter Injection:</strong> Dependencies are assigned through setter methods.</li>
    <li><strong>Field Injection:</strong> Dependencies are injected directly into fields using <code>@Autowired</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Constructor-Based Dependency Injection</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.beans.factory.annotation.Autowired;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          @Autowired
          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List<User> getAllUsers() {
              return userRepository.findAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Benefits of Dependency Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Reduces tight coupling between components.</li>
    <li>Enhances code reusability and maintainability.</li>
    <li>Improves testability by allowing dependencies to be mocked easily.</li>
    <li>Promotes better separation of concerns in the application architecture.</li>
  </ul>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Dependency Injection in Spring Boot simplifies application development by managing component dependencies automatically. By using DI, developers can build more scalable, maintainable, and testable applications efficiently.
  </p>
</div>
`
},

{
  title:`Service vs Repository`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Service vs Repository in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <strong>Service</strong> and <strong>Repository</strong> layers play distinct roles in structuring an application. Understanding their responsibilities and differences is crucial for designing scalable and maintainable applications.
  </p>

  <h3 style="color: #16a085;">What is a Service?</h3>
  <p style="color: #2c3e50;">
    The <strong>Service Layer</strong> contains business logic and acts as a bridge between the Controller and Repository layers. It is annotated with <code>@Service</code> to indicate that it holds core business functionalities.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List<User> getAllUsers() {
              return userRepository.findAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">What is a Repository?</h3>
  <p style="color: #2c3e50;">
    The <strong>Repository Layer</strong> is responsible for database operations and is typically annotated with <code>@Repository</code>. It interacts with the database to perform CRUD operations using Spring Data JPA.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.stereotype.Repository;

      @Repository
      public interface UserRepository extends JpaRepository<User, Long> {
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Key Differences</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Service Layer:</strong> Handles business logic and acts as a middle layer between controllers and repositories.</li>
    <li><strong>Repository Layer:</strong> Directly interacts with the database to fetch and store data.</li>
    <li><strong>Separation of Concerns:</strong> Keeping business logic separate from database operations improves maintainability.</li>
  </ul>

  <h3 style="color: #27ae60;">Conclusion</h3>
  <p style="color: #2c3e50;">
    In a well-structured Spring Boot application, the <strong>Service Layer</strong> should contain business rules, while the <strong>Repository Layer</strong> should handle data persistence. This separation improves modularity, scalability, and maintainability of the application.
  </p>
</div>
`
},
{
  title:`Database Interaction`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Database Interaction in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Database interaction is a crucial part of any application, enabling data persistence and retrieval. 
    Spring Boot simplifies database interactions by providing built-in support for JPA, JDBC, and NoSQL databases.
  </p>

  <h3 style="color: #16a085;">Key Concepts of Database Interaction:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Spring Data JPA for ORM-based interaction.</li>
    <li>Spring JDBC for direct SQL execution.</li>
    <li>Transaction management for data consistency.</li>
    <li>Connection pooling for efficient database connections.</li>
    <li>Support for NoSQL databases like MongoDB and Redis.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Spring Boot for Database Interaction?</h3>
  <p style="color: #2c3e50;">
    Spring Boot abstracts database complexities and provides easy-to-use configurations 
    for integrating relational and NoSQL databases. It also supports declarative transaction management 
    and simplifies repository creation through Spring Data JPA.
  </p>

  <h3 style="color: #2980b9;">Example: Spring Boot with JPA</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.stereotype.Repository;

      @Repository
      public interface UserRepository extends JpaRepository<User, Long> {
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The above code defines a repository interface for database interaction, 
    allowing CRUD operations without writing SQL queries.
  </p>
</div>
`
},
{
  title:`DTO in Service Layer`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DTO in Service Layer</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot applications, the service layer acts as a bridge between the controller and the repository layers. 
    Using Data Transfer Objects (DTOs) in the service layer helps in structuring data efficiently, improving security, 
    and ensuring loose coupling between different layers.
  </p>

  <h3 style="color: #16a085;">Key Benefits of Using DTOs in the Service Layer:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulates business logic and prevents exposing domain models directly.</li>
    <li>Enhances security by controlling exposed data fields.</li>
    <li>Reduces dependency on database structures in the controller layer.</li>
    <li>Improves performance by transferring only required data fields.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use DTOs in the Service Layer?</h3>
  <p style="color: #2c3e50;">
    DTOs allow developers to separate business logic from the database entities. This ensures that 
    changes in the database model do not directly affect the API responses. DTOs also help with 
    mapping complex objects and filtering unnecessary fields.
  </p>

  <h3 style="color: #2980b9;">Example: Using DTO in Service Layer</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;
      import java.util.stream.Collectors;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List<UserDTO> getAllUsers() {
              return userRepository.findAll()
                                   .stream()
                                   .map(user -> new UserDTO(user.getId(), user.getName(), user.getEmail()))
                                   .collect(Collectors.toList());
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The above code demonstrates how a service layer retrieves user data and converts it into a DTO 
    before passing it to the controller. This approach improves maintainability and scalability.
  </p>
</div>
`
},
{
  title:`Exception Handling`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Exception Handling in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Exception handling is a crucial aspect of building robust and user-friendly applications. 
    Spring Boot provides various mechanisms to handle exceptions gracefully, ensuring proper error 
    responses and logging.
  </p>

  <h3 style="color: #16a085;">Why is Exception Handling Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prevents application crashes and improves stability.</li>
    <li>Provides meaningful error messages to clients.</li>
    <li>Helps in debugging by logging detailed error information.</li>
    <li>Enhances user experience by handling errors gracefully.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Handle Exceptions in Spring Boot?</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides multiple ways to handle exceptions, including using 
    <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code>, and 
    <code>ResponseStatusException</code>. Below is an example of handling a custom exception.
  </p>

  <h3 style="color: #2980b9;">Example: Custom Exception Handling</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestControllerAdvice;

      @RestControllerAdvice
      public class GlobalExceptionHandler {
          
          @ExceptionHandler(ResourceNotFoundException.class)
          @ResponseStatus(HttpStatus.NOT_FOUND)
          public ErrorResponse handleResourceNotFoundException(ResourceNotFoundException ex) {
              return new ErrorResponse("NOT_FOUND", ex.getMessage());
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The above code demonstrates a global exception handler using <code>@RestControllerAdvice</code>. 
    It catches <code>ResourceNotFoundException</code> and returns a meaningful error response with an HTTP status.
  </p>
</div>
`
},
{
  title:`Transaction Management`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Transaction Management in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction management is a critical aspect of building reliable and consistent applications, especially when dealing with databases. In Spring Boot, transaction management ensures that a series of database operations either complete successfully as a single unit of work or are rolled back entirely in case of an error. This guarantees data integrity and consistency, even in the face of failures or concurrent access.
  </p>

  <h3 style="color: #16a085;">Why is Transaction Management Important?</h3>
  <p style="color: #2c3e50;">
    Transaction management is essential for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures that database operations are atomic, consistent, isolated, and durable (ACID properties).</li>
    <li><strong>Error Handling</strong>: Automatically rolls back changes if an error occurs, preventing partial updates.</li>
    <li><strong>Concurrency Control</strong>: Manages concurrent access to data, preventing issues like dirty reads or lost updates.</li>
    <li><strong>Simplified Code</strong>: Reduces boilerplate code by handling transaction boundaries declaratively.</li>
    <li><strong>Scalability</strong>: Supports distributed transactions in microservices architectures.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Transaction Management</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides robust support for transaction management through the <strong>Spring Framework's transaction abstraction</strong>. Key concepts include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Programmatic vs. Declarative Transactions</strong>: Programmatic transactions are managed manually in code, while declarative transactions are managed using annotations or configuration.</li>
    <li><strong>Transaction Propagation</strong>: Defines how transactions behave when multiple methods are called (e.g., REQUIRED, REQUIRES_NEW).</li>
    <li><strong>Isolation Levels</strong>: Controls the visibility of changes made by one transaction to other transactions (e.g., READ_COMMITTED, SERIALIZABLE).</li>
    <li><strong>Rollback Rules</strong>: Specifies which exceptions trigger a rollback.</li>
    <li><strong>Distributed Transactions</strong>: Manages transactions across multiple data sources or services.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Transaction Management in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement transaction management in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Enable Transaction Management</h4>
  <p style="color: #2c3e50;">
    Spring Boot automatically configures transaction management if you include a data source and Spring Data JPA. You can enable it explicitly using the <code>@EnableTransactionManagement</code> annotation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.transaction.annotation.EnableTransactionManagement;

      @Configuration
      @EnableTransactionManagement
      public class TransactionConfig {
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Use Declarative Transactions</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Transactional</code> annotation to manage transactions declaratively.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class UserService {

          @Autowired
          private UserRepository userRepository;

          @Transactional
          public void createUser(User user) {
              userRepository.save(user);
              // Simulate an error
              if (user.getName() == null) {
                  throw new RuntimeException("User name cannot be null");
              }
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Configure Transaction Propagation</h4>
  <p style="color: #2c3e50;">
    Use the <code>propagation</code> attribute to define how transactions propagate.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Transactional(propagation = Propagation.REQUIRED)
      public void updateUser(User user) {
          userRepository.save(user);
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Configure Isolation Levels</h4>
  <p style="color: #2c3e50;">
    Use the <code>isolation</code> attribute to control transaction isolation levels.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Transactional(isolation = Isolation.READ_COMMITTED)
      public User getUserById(Long id) {
          return userRepository.findById(id).orElse(null);
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">5. Handle Rollbacks</h4>
  <p style="color: #2c3e50;">
    Use the <code>rollbackFor</code> and <code>noRollbackFor</code> attributes to customize rollback behavior.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Transactional(rollbackFor = RuntimeException.class, noRollbackFor = IllegalArgumentException.class)
      public void deleteUser(Long id) {
          userRepository.deleteById(id);
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Transaction Management</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use declarative transactions (<code>@Transactional</code>) for simplicity and readability.</li>
    <li>Keep transactions short and focused to minimize locking and improve performance.</li>
    <li>Choose appropriate propagation and isolation levels based on your application's requirements.</li>
    <li>Handle exceptions properly to ensure transactions are rolled back when necessary.</li>
    <li>Avoid long-running transactions, as they can lead to deadlocks and performance issues.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Transaction management is a fundamental aspect of building reliable and consistent Spring Boot applications. By leveraging Spring's transaction abstraction, you can ensure that your database operations are atomic, consistent, isolated, and durable. Whether you're working with a single database or distributed systems, proper transaction management practices will enhance the integrity, performance, and scalability of your application.
  </p>
</div>`
},
{
  title:`Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Best Practices in Spring Boot Development</h2>
  <p style="font-size: 16px; color: #34495e;">
    Developing robust and scalable Spring Boot applications requires following best practices. These guidelines ensure maintainability, performance, and security while simplifying development. Let's explore the key best practices for Spring Boot development.
  </p>

  <h3 style="color: #16a085;">1. Project Structure and Organization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Follow Layered Architecture</strong>: Organize code into Controller, Service, Repository, and Model layers for better maintainability.</li>
    <li><strong>Use a Proper Package Structure</strong>: Follow a standard package structure like <code>com.example.project</code> to ensure clarity.</li>
    <li><strong>Modularize Code</strong>: Divide large applications into smaller modules or microservices for scalability.</li>
  </ul>

  <h3 style="color: #e67e22;">2. Configuration Management</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Externalize Configuration</strong>: Use <code>application.properties</code> or <code>application.yml</code> to keep configurations separate from code.</li>
    <li><strong>Use Profiles</strong>: Define separate profiles (e.g., <code>dev</code>, <code>prod</code>, <code>test</code>) for different environments.</li>
    <li><strong>Secure Sensitive Data</strong>: Avoid hardcoding passwords or API keys; use environment variables or encrypted secrets.</li>
  </ul>

  <h3 style="color: #2980b9;">3. REST API Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Follow RESTful Principles</strong>: Use proper HTTP methods (GET, POST, PUT, DELETE) for API operations.</li>
    <li><strong>Return Proper HTTP Status Codes</strong>: Ensure APIs return appropriate status codes (e.g., 200 OK, 400 Bad Request, 404 Not Found).</li>
    <li><strong>Handle Errors Gracefully</strong>: Implement global exception handling using <code>@ControllerAdvice</code>.</li>
    <li><strong>Use Pagination</strong>: Implement pagination for large datasets using Spring Data JPA.</li>
  </ul>

  <h3 style="color: #8e44ad;">4. Database and Transaction Management</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use JPA and Hibernate Effectively</strong>: Follow proper entity mapping and avoid unnecessary queries.</li>
    <li><strong>Enable Connection Pooling</strong>: Use HikariCP for better database connection management.</li>
    <li><strong>Use Transactions</strong>: Apply <code>@Transactional</code> to ensure atomicity and consistency.</li>
  </ul>

  <h3 style="color: #d35400;">5. Security Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Enable Authentication and Authorization</strong>: Use Spring Security for role-based access control.</li>
    <li><strong>Protect APIs</strong>: Use OAuth2, JWT, or API keys for securing REST APIs.</li>
    <li><strong>Prevent SQL Injection</strong>: Use parameterized queries and avoid dynamic queries.</li>
    <li><strong>Validate Input</strong>: Implement data validation to prevent XSS and CSRF attacks.</li>
  </ul>

  <h3 style="color: #2c3e50;">6. Performance Optimization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use Caching</strong>: Implement caching with Redis or Ehcache to improve response times.</li>
    <li><strong>Optimize Queries</strong>: Use indexing, fetch joins, and batch processing to optimize database performance.</li>
    <li><strong>Reduce Startup Time</strong>: Use lazy initialization and exclude unnecessary dependencies.</li>
  </ul>

  <h3 style="color: #16a085;">7. Logging and Monitoring</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use SLF4J and Logback</strong>: Follow structured logging practices for better debugging.</li>
    <li><strong>Enable Actuator</strong>: Monitor application health and performance with Spring Boot Actuator.</li>
    <li><strong>Integrate with Monitoring Tools</strong>: Use Prometheus, Grafana, or ELK Stack for observability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Following best practices in Spring Boot development helps build scalable, secure, and high-performance applications. By structuring projects well, managing configurations efficiently, optimizing performance, and ensuring security, developers can create maintainable and robust applications that meet modern software requirements.
  </p>
</div>
  `
},
{
  title:`Business Logic`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Business Logic in Software Development</h2>
  <p style="font-size: 16px; color: #34495e;">
    Business logic is the core of any software application. It represents the rules and operations that define how data is processed and decisions are made within a system. Effective business logic ensures that an application functions correctly and delivers the expected outcomes to users.
  </p>

  <h3 style="color: #16a085;">What is Business Logic?</h3>
  <p style="color: #2c3e50;">
    Business logic refers to the part of a software application that encodes real-world business rules and operations. It governs how data flows through the application and dictates the interactions between various system components.
  </p>

  <h3 style="color: #e67e22;">Why is Business Logic Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensures Accuracy:</strong> Enforces correct processing of data based on business rules.</li>
    <li><strong>Maintains Consistency:</strong> Provides a single source of truth for decision-making processes.</li>
    <li><strong>Enhances Maintainability:</strong> Separates business rules from UI and database logic, making the code easier to manage.</li>
    <li><strong>Supports Scalability:</strong> Allows for modifications and extensions without impacting other components.</li>
    <li><strong>Improves Security:</strong> Controls access to data and prevents unauthorized actions.</li>
  </ul>

  <h3 style="color: #2980b9;">Best Practices for Implementing Business Logic</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use a Layered Architecture:</strong> Separate business logic from UI and data layers.</li>
    <li><strong>Leverage Design Patterns:</strong> Apply patterns like MVC, Service Layer, or Repository to structure your logic effectively.</li>
    <li><strong>Keep Logic Modular:</strong> Break down complex logic into smaller, reusable components.</li>
    <li><strong>Write Unit Tests:</strong> Ensure the reliability of business rules by testing edge cases and expected behaviors.</li>
    <li><strong>Use Domain-Driven Design (DDD):</strong> Model business entities and processes based on real-world scenarios.</li>
    <li><strong>Minimize Duplication:</strong> Avoid redundant logic by centralizing common business rules.</li>
  </ul>

  <h3 style="color: #d35400;">Example: Implementing Business Logic in a Spring Boot Service</h3>
  <p style="color: #2c3e50;">
    Below is an example of a well-structured business logic implementation in a Spring Boot service class.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.Optional;

      @Service
      public class OrderService {
          private final OrderRepository orderRepository;
          
          public OrderService(OrderRepository orderRepository) {
              this.orderRepository = orderRepository;
          }
          
          public String processOrder(Long orderId) {
              Optional<Order> order = orderRepository.findById(orderId);
              
              if (order.isEmpty()) {
                  throw new RuntimeException("Order not found");
              }
              
              if (!order.get().isPaymentComplete()) {
                  return "Payment pending. Order cannot be processed.";
              }
              
              order.get().setStatus("Processed");
              orderRepository.save(order.get());
              return "Order processed successfully";
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Business logic is the backbone of any software application, ensuring that processes follow predefined rules and deliver the expected outcomes. By applying best practices such as separation of concerns, modular design, and thorough testing, developers can create maintainable, scalable, and robust applications. A well-structured business logic layer enhances the overall quality of software and ensures smooth functionality across different components.
  </p>
</div>
`
},
{
  title:`Unit Testing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Unit Testing</h2>
  <p style="font-size: 16px; color: #34495e;">
    Unit testing is a fundamental aspect of software development that ensures individual components of an application work as expected. By testing each unit of code independently, developers can catch bugs early, maintain code quality, and simplify debugging. Unit testing is widely used in agile development, continuous integration, and test-driven development (TDD) methodologies.
  </p>

  <h3 style="color: #16a085;">Why is Unit Testing Important?</h3>
  <p style="color: #2c3e50;">
    Unit testing plays a crucial role in software development for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Early Bug Detection</strong>: Catches errors at the initial stages, reducing debugging efforts later.</li>
    <li><strong>Code Maintainability</strong>: Makes it easier to refactor and update code without breaking existing functionality.</li>
    <li><strong>Improved Code Quality</strong>: Encourages writing modular and testable code.</li>
    <li><strong>Faster Development</strong>: Reduces time spent on fixing production issues.</li>
    <li><strong>Supports Continuous Integration</strong>: Helps automate testing in CI/CD pipelines.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Unit Testing</h3>
  <p style="color: #2c3e50;">
    Unit testing revolves around the following principles:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Isolation</strong>: Tests should focus on a single unit (method or function) and not depend on external systems.</li>
    <li><strong>Assertions</strong>: Validates the expected output of a unit against actual results.</li>
    <li><strong>Mocks & Stubs</strong>: Simulates dependencies to isolate the test scope.</li>
    <li><strong>Code Coverage</strong>: Measures how much of the code is tested.</li>
    <li><strong>Automated Execution</strong>: Enables running tests frequently without manual intervention.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Writing Unit Tests in Java with JUnit</h3>
  <p style="color: #2c3e50;">
    JUnit is a popular testing framework for Java applications. Below is an example of a simple unit test using JUnit.
  </p>

  <h4 style="color: #8e44ad;">1. Add JUnit Dependency</h4>
  <p style="color: #2c3e50;">
    If you're using Maven, include the following dependency in your <code>pom.xml</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;junit&lt;/groupId&gt;
          &lt;artifactId&gt;junit&lt;/artifactId&gt;
          &lt;version&gt;4.13.2&lt;/version&gt;
          &lt;scope&gt;test&lt;/scope&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create a Simple Java Class</h4>
  <p style="color: #2c3e50;">
    Here’s a simple calculator class that we will test.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class Calculator {
          public int add(int a, int b) {
              return a + b;
          }

          public int subtract(int a, int b) {
              return a - b;
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Write a JUnit Test</h4>
  <p style="color: #2c3e50;">
    Now, let’s write a JUnit test for the <code>Calculator</code> class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.junit.Test;
      import static org.junit.Assert.*;

      public class CalculatorTest {

          @Test
          public void testAddition() {
              Calculator calculator = new Calculator();
              assertEquals(10, calculator.add(5, 5));
          }

          @Test
          public void testSubtraction() {
              Calculator calculator = new Calculator();
              assertEquals(3, calculator.subtract(8, 5));
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Run the Test</h4>
  <p style="color: #2c3e50;">
    You can run the test using the following command in the terminal:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-bash">
      mvn test
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Unit Testing</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Write tests for every function with meaningful test cases.</li>
    <li>Ensure tests run independently without dependencies.</li>
    <li>Use mocks to isolate units and avoid external dependencies.</li>
    <li>Follow naming conventions like <code>testMethodName_shouldExpectedBehavior</code>.</li>
    <li>Keep tests simple, clear, and well-documented.</li>
    <li>Run tests frequently in CI/CD pipelines.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Unit testing is a crucial practice for developing robust, error-free software. By writing effective unit tests, developers can improve code quality, enhance maintainability, and accelerate the development process. Whether you’re using JUnit, Mockito, or other testing frameworks, adopting a test-first approach will lead to better and more reliable applications.
  </p>
</div>
`
},
{
title:`Logging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Logging</h2>
  <p style="font-size: 16px; color: #34495e;">
    Logging is an essential aspect of software development that helps track application behavior, debug issues, and monitor performance. It provides a structured way to record events, errors, and informational messages during application execution. Effective logging improves system reliability, security, and troubleshooting efficiency.
  </p>

  <h3 style="color: #16a085;">Why is Logging Important?</h3>
  <p style="color: #2c3e50;">
    Logging plays a crucial role in software development for various reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Debugging</strong>: Helps identify and resolve issues in code by analyzing log entries.</li>
    <li><strong>Performance Monitoring</strong>: Tracks system performance and detects bottlenecks.</li>
    <li><strong>Error Tracking</strong>: Logs errors and exceptions for quick diagnosis.</li>
    <li><strong>Security Auditing</strong>: Records user actions and security-related events.</li>
    <li><strong>Compliance</strong>: Provides logs required for regulatory and security compliance.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Logging</h3>
  <p style="color: #2c3e50;">
    Different types of logs serve various purposes in software applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Error Logs</strong>: Captures errors and exceptions for troubleshooting.</li>
    <li><strong>Debug Logs</strong>: Provides detailed information for developers during debugging.</li>
    <li><strong>Audit Logs</strong>: Records security and access-related events.</li>
    <li><strong>Transaction Logs</strong>: Logs database transactions for consistency tracking.</li>
    <li><strong>Performance Logs</strong>: Tracks system metrics and resource utilization.</li>
  </ul>

  <h3 style="color: #2980b9;">Logging Levels</h3>
  <p style="color: #2c3e50;">
    Logging levels determine the severity of log messages. Common logging levels include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>DEBUG</strong>: Detailed information for debugging.</li>
    <li><strong>INFO</strong>: General operational messages.</li>
    <li><strong>WARN</strong>: Potential issues that require attention.</li>
    <li><strong>ERROR</strong>: Errors that need immediate investigation.</li>
    <li><strong>FATAL</strong>: Critical errors causing system failure.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Logging in Java with Log4j</h3>
  <p style="color: #2c3e50;">
    Log4j is a popular logging framework for Java applications. Below is an example of how to set up and use Log4j.
  </p>

  <h4 style="color: #8e44ad;">1. Add Log4j Dependency</h4>
  <p style="color: #2c3e50;">
    If you're using Maven, include the following dependency in your <code>pom.xml</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
          &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
          &lt;version&gt;2.17.1&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Configure Log4j</h4>
  <p style="color: #2c3e50;">
    Create a Log4j configuration file named <code>log4j2.xml</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;Configuration status="WARN"&gt;
          &lt;Appenders&gt;
              &lt;Console name="Console" target="SYSTEM_OUT"&gt;
                  &lt;PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %c{1} - %msg%n"/&gt;
              &lt;/Console&gt;
          &lt;/Appenders&gt;
          &lt;Loggers&gt;
              &lt;Root level="info"&gt;
                  &lt;AppenderRef ref="Console"/&gt;
              &lt;/Root&gt;
          &lt;/Loggers&gt;
      &lt;/Configuration&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Implement Logging in Java</h4>
  <p style="color: #2c3e50;">
    Use Log4j in a Java application.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.apache.logging.log4j.LogManager;
      import org.apache.logging.log4j.Logger;

      public class LoggingExample {
          private static final Logger logger = LogManager.getLogger(LoggingExample.class);

          public static void main(String[] args) {
              logger.debug("This is a DEBUG message.");
              logger.info("This is an INFO message.");
              logger.warn("This is a WARNING message.");
              logger.error("This is an ERROR message.");
              logger.fatal("This is a FATAL message.");
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Run the Application</h4>
  <p style="color: #2c3e50;">
    When executed, the program outputs log messages based on the configured log level.
  </p>

  <h3 style="color: #d35400;">Best Practices for Logging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use appropriate log levels to filter relevant information.</li>
    <li>Avoid logging sensitive data such as passwords and user credentials.</li>
    <li>Implement structured logging to make logs more readable and searchable.</li>
    <li>Use log rotation to manage log file size.</li>
    <li>Integrate logging with monitoring tools like ELK Stack or Splunk.</li>
    <li>Ensure logs are stored securely and accessible only to authorized users.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Logging is a critical component of software development that provides visibility into an application’s behavior. By using structured logging frameworks like Log4j, developers can track system performance, diagnose issues, and enhance security. Implementing effective logging strategies ensures robust, maintainable, and secure applications.
  </p>
</div>
`
},
{
  title:`Integration Testing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Integration Testing</h2>
  <p style="font-size: 16px; color: #34495e;">
    Integration Testing is a crucial phase of software testing where individual units or components are combined and tested as a group. The goal is to verify the interaction between different modules and ensure they work together as expected. It helps identify issues related to data flow, communication, and functionality across integrated components.
  </p>

  <h3 style="color: #16a085;">Why is Integration Testing Important?</h3>
  <p style="color: #2c3e50;">
    Integration Testing plays a vital role in ensuring software reliability and smooth functionality across modules. Its key benefits include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Detects Interface Issues</strong>: Ensures seamless communication between different components.</li>
    <li><strong>Improves System Reliability</strong>: Helps in early detection of data flow errors.</li>
    <li><strong>Enhances Functional Accuracy</strong>: Validates whether integrated modules function as expected.</li>
    <li><strong>Reduces Debugging Complexity</strong>: Identifies issues at an early stage, reducing cost and effort in debugging.</li>
    <li><strong>Ensures Data Consistency</strong>: Tests data exchange between modules for correctness.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Integration Testing</h3>
  <p style="color: #2c3e50;">
    There are several approaches to performing Integration Testing:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Big Bang Integration Testing</strong>: All modules are integrated and tested together at once.</li>
    <li><strong>Incremental Integration Testing</strong>: Modules are tested step by step as they are integrated.</li>
    <li><strong>Top-Down Integration Testing</strong>: Testing starts from the top-level modules and progresses downward.</li>
    <li><strong>Bottom-Up Integration Testing</strong>: Testing begins with lower-level modules and moves upward.</li>
    <li><strong>Hybrid (Sandwich) Integration Testing</strong>: A combination of top-down and bottom-up approaches.</li>
  </ul>

  <h3 style="color: #2980b9;">Integration Testing Techniques</h3>
  <p style="color: #2c3e50;">
    Different techniques are used to perform integration testing efficiently:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Interface Testing</strong>: Ensures data exchange between modules is correct.</li>
    <li><strong>Data Flow Testing</strong>: Verifies data input and output between integrated units.</li>
    <li><strong>API Testing</strong>: Tests communication between services using APIs.</li>
    <li><strong>Middleware Testing</strong>: Examines the interaction between databases and applications.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Integration Testing in Java with JUnit</h3>
  <p style="color: #2c3e50;">
    JUnit is a popular framework for writing integration tests in Java applications. Below is an example demonstrating an integration test for a user authentication service.
  </p>

  <h4 style="color: #8e44ad;">1. Add JUnit and Spring Boot Dependencies</h4>
  <p style="color: #2c3e50;">
    If you're using Maven, include the following dependencies in your <code>pom.xml</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
          &lt;scope&gt;test&lt;/scope&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create a Sample Authentication Service</h4>
  <p style="color: #2c3e50;">
    Below is a simple authentication service that checks if a user exists.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.Arrays;
      import java.util.List;

      @Service
      public class AuthService {
          private List&lt;String&gt; users = Arrays.asList("admin", "user", "test");

          public boolean authenticate(String username) {
              return users.contains(username);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Write an Integration Test</h4>
  <p style="color: #2c3e50;">
    The integration test checks if the authentication service works correctly.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import static org.junit.jupiter.api.Assertions.*;
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.context.SpringBootTest;

      @SpringBootTest
      public class AuthServiceTest {

          @Autowired
          private AuthService authService;

          @Test
          public void testAuthentication() {
              assertTrue(authService.authenticate("admin"));
              assertFalse(authService.authenticate("unknownUser"));
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Run the Test</h4>
  <p style="color: #2c3e50;">
    Execute the test using JUnit, and it will validate the authentication service.
  </p>

  <h3 style="color: #d35400;">Best Practices for Integration Testing</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use mock data to simulate real-world scenarios.</li>
    <li>Ensure database integrity by cleaning up test data after execution.</li>
    <li>Automate integration tests to catch issues early.</li>
    <li>Use logging to track test execution and failures.</li>
    <li>Test error handling and exception scenarios.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Integration Testing ensures that different modules of an application work together seamlessly. By using techniques like top-down, bottom-up, and API testing, developers can identify interface issues early. With tools like JUnit and Spring Boot Test, integration tests can be automated for efficient debugging and reliable application performance.
  </p>
</div>
`
},
{
  title:`Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Security is the practice of protecting systems, networks, and data from cyber threats, unauthorized access, and attacks. In the digital world, security plays a critical role in ensuring confidentiality, integrity, and availability of information. Organizations and individuals must implement strong security measures to safeguard their sensitive data from hackers, malware, and other cyber threats.
  </p>

  <h3 style="color: #16a085;">Why is Security Important?</h3>
  <p style="color: #2c3e50;">
    Security is essential in preventing data breaches, cyber attacks, and financial losses. Here are key reasons why security is crucial:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Protects Sensitive Data</strong>: Prevents unauthorized access to personal and business information.</li>
    <li><strong>Ensures Business Continuity</strong>: Helps prevent downtime and data loss due to cyber threats.</li>
    <li><strong>Maintains Customer Trust</strong>: Secure systems build customer confidence in businesses.</li>
    <li><strong>Prevents Financial Loss</strong>: Reduces risks of cyber fraud and ransomware attacks.</li>
    <li><strong>Complies with Regulations</strong>: Organizations must follow security laws like GDPR and HIPAA.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Security</h3>
  <p style="color: #2c3e50;">
    Security is categorized into different types based on protection areas:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Network Security</strong>: Protects networks from cyber threats using firewalls, intrusion detection, and encryption.</li>
    <li><strong>Application Security</strong>: Secures software applications from vulnerabilities like SQL injection and XSS attacks.</li>
    <li><strong>Information Security</strong>: Protects sensitive data from unauthorized access and leaks.</li>
    <li><strong>Endpoint Security</strong>: Safeguards devices like computers, mobile phones, and IoT devices.</li>
    <li><strong>Cloud Security</strong>: Ensures the safety of data and services stored in cloud environments.</li>
    <li><strong>Physical Security</strong>: Protects hardware and infrastructure from theft or damage.</li>
  </ul>

  <h3 style="color: #2980b9;">Common Cyber Threats</h3>
  <p style="color: #2c3e50;">
    Organizations and individuals face various cyber threats, including:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Malware</strong>: Malicious software like viruses, ransomware, and spyware that disrupt systems.</li>
    <li><strong>Phishing</strong>: Deceptive emails or messages trick users into revealing personal information.</li>
    <li><strong>Denial-of-Service (DoS) Attacks</strong>: Overloads systems to make them unavailable.</li>
    <li><strong>SQL Injection</strong>: Attackers manipulate databases by injecting malicious SQL queries.</li>
    <li><strong>Man-in-the-Middle (MitM) Attacks</strong>: Intercepts communication between two parties.</li>
    <li><strong>Password Attacks</strong>: Hackers attempt to crack passwords using brute force or dictionary attacks.</li>
  </ul>

  <h3 style="color: #8e44ad;">Security Best Practices</h3>
  <p style="color: #2c3e50;">
    To ensure robust security, organizations and individuals should follow best practices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use Strong Passwords</strong>: Implement complex passwords and enable multi-factor authentication (MFA).</li>
    <li><strong>Regular Software Updates</strong>: Keep software and systems updated to patch vulnerabilities.</li>
    <li><strong>Implement Firewalls</strong>: Use firewalls to monitor and filter network traffic.</li>
    <li><strong>Encrypt Sensitive Data</strong>: Protect data using encryption to prevent unauthorized access.</li>
    <li><strong>Backup Data Regularly</strong>: Maintain backups to restore data in case of cyber attacks.</li>
    <li><strong>Employee Training</strong>: Educate employees on security threats and safe online practices.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Secure Login System in Java</h3>
  <p style="color: #2c3e50;">
    Below is an example of a secure user authentication system using Java and BCrypt password hashing.
  </p>

  <h4 style="color: #8e44ad;">1. Add Dependencies</h4>
  <p style="color: #2c3e50;">
    Include the following dependency in <code>pom.xml</code> for password hashing.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
          &lt;artifactId&gt;spring-security-crypto&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Hash Passwords Using BCrypt</h4>
  <p style="color: #2c3e50;">
    BCrypt is a secure way to hash passwords before storing them.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

      public class SecurityDemo {
          public static void main(String[] args) {
              BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
              String rawPassword = "securePassword123";
              String hashedPassword = encoder.encode(rawPassword);
              System.out.println("Hashed Password: " + hashedPassword);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Verify Passwords</h4>
  <p style="color: #2c3e50;">
    The hashed password can be verified using the <code>matches()</code> method.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String rawPassword = "securePassword123";
      boolean isMatch = encoder.matches(rawPassword, hashedPassword);
      System.out.println("Password Match: " + isMatch);
    </code>
  </pre>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Security is an essential aspect of modern technology, protecting data, systems, and users from cyber threats. By following best practices like strong authentication, encryption, and regular updates, individuals and organizations can enhance their security posture. Implementing secure coding techniques, such as hashing passwords with BCrypt, helps in reducing vulnerabilities and improving overall system security.
  </p>
</div>
`
},
{
  title:`Caching`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Caching</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching is a technique used to store frequently accessed data temporarily to reduce response time and improve performance. By keeping a copy of data in a faster-access storage layer, caching minimizes redundant computations, network requests, and database queries, enhancing the overall efficiency of applications.
  </p>

  <h3 style="color: #16a085;">Why is Caching Important?</h3>
  <p style="color: #2c3e50;">
    Caching improves system performance and scalability by:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reducing Latency</strong>: Speeds up data retrieval by storing frequently used data in memory.</li>
    <li><strong>Minimizing Database Load</strong>: Reduces the number of database queries, preventing performance bottlenecks.</li>
    <li><strong>Improving Scalability</strong>: Helps applications handle increased user loads efficiently.</li>
    <li><strong>Enhancing User Experience</strong>: Faster responses lead to a smoother experience for end users.</li>
    <li><strong>Optimizing Bandwidth Usage</strong>: Reduces redundant network requests by caching API responses.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Caching</h3>
  <p style="color: #2c3e50;">
    Caching can be implemented at different levels, including:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Client-Side Caching</strong>: Stores data on the client, such as browser cache and local storage.</li>
    <li><strong>Server-Side Caching</strong>: Caches data at the server level to optimize backend performance.</li>
    <li><strong>Database Caching</strong>: Stores frequently queried results in memory to reduce database load.</li>
    <li><strong>Application Caching</strong>: Temporarily stores processed data in memory (e.g., using in-memory stores like Redis or Memcached).</li>
    <li><strong>CDN (Content Delivery Network) Caching</strong>: Distributes cached content across multiple servers worldwide for faster access.</li>
  </ul>

  <h3 style="color: #2980b9;">Common Caching Strategies</h3>
  <p style="color: #2c3e50;">
    Different caching strategies help balance performance and data accuracy:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Write-Through Cache</strong>: Data is written to both the cache and the database simultaneously.</li>
    <li><strong>Write-Back Cache</strong>: Data is written to the cache first and later updated in the database.</li>
    <li><strong>Cache-aside (Lazy Loading)</strong>: Data is loaded into the cache only when requested.</li>
    <li><strong>Time-to-Live (TTL)</strong>: Cached data expires after a predefined time to ensure freshness.</li>
    <li><strong>Least Recently Used (LRU)</strong>: The oldest unused data is removed when the cache reaches its limit.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Caching in Java Using Redis</h3>
  <p style="color: #2c3e50;">
    Redis is a popular in-memory data store used for caching. Below is an example of how to integrate Redis caching in a Java application using Spring Boot.
  </p>

  <h4 style="color: #8e44ad;">1. Add Dependencies</h4>
  <p style="color: #2c3e50;">
    Include the following dependencies in <code>pom.xml</code> for Redis integration.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Enable Caching</h4>
  <p style="color: #2c3e50;">
    Enable caching in the Spring Boot application by adding the <code>@EnableCaching</code> annotation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.EnableCaching;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      @EnableCaching
      public class CacheConfig {
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Implement Redis Caching</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Cacheable</code> annotation to cache method results.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          
          @Cacheable(value = "products", key = "#id")
          public Product getProductById(String id) {
              // Simulating a database call
              return new Product(id, "Sample Product", 100.0);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Caching is a powerful technique for optimizing application performance and scalability. By using caching strategies like write-through, lazy loading, and TTL, applications can improve response times and reduce server load. Tools like Redis and Memcached provide efficient caching mechanisms, helping developers build high-performance applications.
  </p>
</div>
`
},
{
  title:`External API Calls`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding External API Calls</h2>
  <p style="font-size: 16px; color: #34495e;">
    External API calls refer to requests made from an application to third-party services or external servers to retrieve or send data. These APIs (Application Programming Interfaces) enable seamless integration with external systems, allowing applications to access functionalities like weather updates, payment processing, authentication, and more.
  </p>

  <h3 style="color: #16a085;">Why Are External API Calls Important?</h3>
  <p style="color: #2c3e50;">
    External API calls play a crucial role in modern software development by:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Enhancing Functionality</strong>: Applications can integrate features like maps, payments, or social logins without building them from scratch.</li>
    <li><strong>Data Exchange</strong>: Enables communication between different applications and services.</li>
    <li><strong>Scalability</strong>: Reduces development effort by leveraging third-party services.</li>
    <li><strong>Real-Time Data</strong>: Provides access to up-to-date information from external sources.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of External API Calls</h3>
  <p style="color: #2c3e50;">
    APIs can be categorized based on their architecture and communication methods:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>REST API (Representational State Transfer)</strong>: Uses HTTP methods like GET, POST, PUT, DELETE.</li>
    <li><strong>SOAP API (Simple Object Access Protocol)</strong>: Uses XML-based communication.</li>
    <li><strong>GraphQL API</strong>: Allows clients to request specific data fields, reducing over-fetching.</li>
    <li><strong>Webhooks</strong>: Event-driven API calls that send data when a specific action occurs.</li>
  </ul>

  <h3 style="color: #2980b9;">Common Challenges in External API Calls</h3>
  <p style="color: #2c3e50;">
    While API calls improve functionality, they also come with challenges:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Network Latency</strong>: API response time depends on internet speed and server performance.</li>
    <li><strong>Rate Limits</strong>: Many APIs impose limits on the number of requests per second/minute.</li>
    <li><strong>Authentication</strong>: APIs often require authentication using API keys, OAuth, or tokens.</li>
    <li><strong>Error Handling</strong>: APIs may return errors like 404 (Not Found) or 500 (Server Error).</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Making an External API Call in Java Using RestTemplate</h3>
  <p style="color: #2c3e50;">
    Below is an example of calling an external API in a Java Spring Boot application using <code>RestTemplate</code>.
  </p>

  <h4 style="color: #8e44ad;">1. Add Dependencies</h4>
  <p style="color: #2c3e50;">
    Add the required Spring Boot dependencies in <code>pom.xml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create a Service for API Calls</h4>
  <p style="color: #2c3e50;">
    Implement a service to fetch data from an external API.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.web.client.RestTemplate;

      @Service
      public class ApiService {
          private final RestTemplate restTemplate = new RestTemplate();

          public String getWeatherData() {
              String apiUrl = "https://api.openweathermap.org/data/2.5/weather?q=London&appid=your_api_key";
              return restTemplate.getForObject(apiUrl, String.class);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Create a Controller to Call the API</h4>
  <p style="color: #2c3e50;">
    Define an endpoint that fetches and returns data from the external API.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class ApiController {
          private final ApiService apiService;

          public ApiController(ApiService apiService) {
              this.apiService = apiService;
          }

          @GetMapping("/weather")
          public String getWeather() {
              return apiService.getWeatherData();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for External API Calls</h3>
  <p style="color: #2c3e50;">
    To ensure reliability and efficiency, follow these best practices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use Caching</strong>: Reduce unnecessary API calls by storing responses temporarily.</li>
    <li><strong>Implement Rate Limiting</strong>: Avoid exceeding API request limits to prevent being blocked.</li>
    <li><strong>Use Circuit Breakers</strong>: Handle failures gracefully using tools like <code>Resilience4j</code>.</li>
    <li><strong>Secure API Keys</strong>: Never expose API keys in the frontend; store them in environment variables.</li>
    <li><strong>Handle Errors Properly</strong>: Implement robust error handling for API failures.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    External API calls allow applications to integrate with third-party services efficiently. By understanding different types of APIs, handling potential challenges, and following best practices, developers can ensure seamless API communication in their applications. Whether fetching weather data, processing payments, or integrating authentication, external APIs are a crucial part of modern software development.
  </p>
</div>
`
},
{
  title:`Feign Client`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Feign Client in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Feign Client is a declarative web service client in Spring Boot that simplifies calling REST APIs by reducing boilerplate code. Instead of manually creating HTTP requests, Feign provides a way to define an interface and automatically map it to an external service.
  </p>

  <h3 style="color: #16a085;">Why Use Feign Client?</h3>
  <p style="color: #2c3e50;">
    Feign Client is widely used in microservices architecture due to its benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Declarative Syntax</strong>: API calls are defined as interfaces, making the code more readable.</li>
    <li><strong>Integration with Spring Boot</strong>: Works seamlessly with <code>Spring Cloud</code> and <code>Load Balancer</code>.</li>
    <li><strong>Built-in Error Handling</strong>: Reduces the need for manual exception handling.</li>
    <li><strong>Support for Load Balancing</strong>: Works with Ribbon and Eureka for service discovery.</li>
    <li><strong>Interceptors and Logging</strong>: Allows customization of request headers and response handling.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use Feign Client in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Follow these steps to integrate Feign Client into a Spring Boot application.
  </p>

  <h4 style="color: #e67e22;">1. Add Dependencies</h4>
  <p style="color: #2c3e50;">
    Include the required dependencies in <code>pom.xml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #e67e22;">2. Enable Feign Client</h4>
  <p style="color: #2c3e50;">
    In your main application class, enable Feign Client using the <code>@EnableFeignClients</code> annotation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cloud.openfeign.EnableFeignClients;

      @SpringBootApplication
      @EnableFeignClients
      public class FeignClientApplication {
          public static void main(String[] args) {
              SpringApplication.run(FeignClientApplication.class, args);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">3. Create a Feign Client Interface</h4>
  <p style="color: #2c3e50;">
    Define an interface with <code>@FeignClient</code> annotation to specify the external API.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cloud.openfeign.FeignClient;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.PathVariable;

      @FeignClient(name = "weather-service", url = "https://api.openweathermap.org/data/2.5")
      public interface WeatherClient {
          @GetMapping("/weather?q={city}&appid={apiKey}")
          String getWeather(@PathVariable("city") String city, @PathVariable("apiKey") String apiKey);
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">4. Use the Feign Client in a Service</h4>
  <p style="color: #2c3e50;">
    Inject the Feign Client into a service and use it to make API calls.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class WeatherService {
          private final WeatherClient weatherClient;

          public WeatherService(WeatherClient weatherClient) {
              this.weatherClient = weatherClient;
          }

          public String getWeather(String city) {
              String apiKey = "your_api_key";
              return weatherClient.getWeather(city, apiKey);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">5. Create a Controller</h4>
  <p style="color: #2c3e50;">
    Define a REST controller that calls the Feign Client.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.PathVariable;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      public class WeatherController {
          private final WeatherService weatherService;

          public WeatherController(WeatherService weatherService) {
              this.weatherService = weatherService;
          }

          @GetMapping("/weather/{city}")
          public String getWeather(@PathVariable String city) {
              return weatherService.getWeather(city);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Best Practices for Using Feign Client</h3>
  <p style="color: #2c3e50;">
    To ensure efficiency and security, follow these best practices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use Load Balancing</strong>: Enable Ribbon or Spring Cloud LoadBalancer for better performance.</li>
    <li><strong>Handle Timeouts</strong>: Configure timeouts using <code>feign.client.config.default.connectTimeout</code>.</li>
    <li><strong>Implement Circuit Breakers</strong>: Use <code>Resilience4j</code> or <code>Hystrix</code> to handle failures.</li>
    <li><strong>Secure API Calls</strong>: Store API keys in environment variables or configuration files.</li>
    <li><strong>Enable Logging</strong>: Use <code>logging.level.feign=DEBUG</code> for debugging API requests.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Feign Client simplifies external API calls in Spring Boot applications by providing a declarative approach. It reduces boilerplate code, improves readability, and integrates well with microservices. By following best practices like load balancing, circuit breaking, and logging, developers can enhance API performance and reliability.
  </p>
</div>
`
},
{
  title:`Asynchronous Processing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Asynchronous Processing in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Asynchronous processing allows applications to execute tasks in the background without blocking the main thread. In Spring Boot, this is achieved using the <code>@Async</code> annotation, which helps improve performance, scalability, and responsiveness in web applications.
  </p>

  <h3 style="color: #16a085;">Why Use Asynchronous Processing?</h3>
  <p style="color: #2c3e50;">
    Asynchronous processing is beneficial in many scenarios, including:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improved Performance</strong>: Tasks are executed in parallel, reducing response time.</li>
    <li><strong>Non-Blocking Operations</strong>: The main thread is free to handle other requests.</li>
    <li><strong>Better User Experience</strong>: Ensures that long-running tasks do not slow down the application.</li>
    <li><strong>Efficient Resource Utilization</strong>: Reduces CPU and memory bottlenecks.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Asynchronous Processing in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Follow these steps to enable and use asynchronous processing in a Spring Boot application.
  </p>

  <h4 style="color: #e67e22;">1. Enable Async Support</h4>
  <p style="color: #2c3e50;">
    First, enable async support by adding the <code>@EnableAsync</code> annotation in the main application class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.scheduling.annotation.EnableAsync;

      @SpringBootApplication
      @EnableAsync
      public class AsyncApplication {
          public static void main(String[] args) {
              SpringApplication.run(AsyncApplication.class, args);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">2. Create an Asynchronous Method</h4>
  <p style="color: #2c3e50;">
    Mark methods with the <code>@Async</code> annotation to make them run asynchronously.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;

      @Service
      public class EmailService {
          @Async
          public void sendEmail(String recipient) {
              System.out.println("Sending email to " + recipient + " - " + Thread.currentThread().getName());
              try {
                  Thread.sleep(3000); // Simulate email sending delay
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println("Email sent to " + recipient);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">3. Call the Asynchronous Method</h4>
  <p style="color: #2c3e50;">
    Inject the async-enabled service into a controller and call the method.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestParam;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      public class EmailController {
          private final EmailService emailService;

          public EmailController(EmailService emailService) {
              this.emailService = emailService;
          }

          @GetMapping("/send-email")
          public String sendEmail(@RequestParam String recipient) {
              emailService.sendEmail(recipient);
              return "Email is being sent asynchronously to " + recipient;
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">4. Using CompletableFuture for Async Processing</h4>
  <p style="color: #2c3e50;">
    The <code>CompletableFuture</code> class allows handling async results.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;
      import java.util.concurrent.CompletableFuture;

      @Service
      public class DataService {
          @Async
          public CompletableFuture<String> fetchData() {
              try {
                  Thread.sleep(2000); // Simulate delay
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              return CompletableFuture.completedFuture("Data processed");
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">5. Calling an Async Method with CompletableFuture</h4>
  <p style="color: #2c3e50;">
    Fetching async data in a controller:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RestController;
      import java.util.concurrent.CompletableFuture;

      @RestController
      public class DataController {
          private final DataService dataService;

          public DataController(DataService dataService) {
              this.dataService = dataService;
          }

          @GetMapping("/fetch-data")
          public CompletableFuture<String> fetchData() {
              return dataService.fetchData();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Best Practices for Asynchronous Processing</h3>
  <p style="color: #2c3e50;">
    To ensure efficient async execution, follow these best practices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Define Thread Pool</strong>: Use <code>TaskExecutor</code> to manage concurrent threads.</li>
    <li><strong>Handle Exceptions</strong>: Use <code>CompletableFuture.exceptionally()</code> to catch errors.</li>
    <li><strong>Avoid Overloading Threads</strong>: Use proper thread pool configurations.</li>
    <li><strong>Use Asynchronous Logging</strong>: Ensure logging does not block the main thread.</li>
    <li><strong>Monitor Async Tasks</strong>: Use monitoring tools to track async task performance.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Asynchronous processing in Spring Boot allows better performance, responsiveness, and resource utilization. By using the <code>@Async</code> annotation and <code>CompletableFuture</code>, developers can efficiently handle background tasks without blocking the main thread.
  </p>
</div>
`
},
{
title:`Event-Driven Communication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Event-Driven Communication in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Event-driven communication is an architectural pattern where components communicate by producing and consuming events. Instead of direct method calls, services react to changes asynchronously, making the system more scalable and loosely coupled.
  </p>

  <h3 style="color: #16a085;">Why Use Event-Driven Communication?</h3>
  <p style="color: #2c3e50;">
    Event-driven communication offers several benefits, including:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Loose Coupling</strong>: Services interact without being tightly dependent on each other.</li>
    <li><strong>Scalability</strong>: Events allow horizontal scaling as multiple services handle different concerns.</li>
    <li><strong>Asynchronous Processing</strong>: Events can be processed in the background, improving system performance.</li>
    <li><strong>Resilience</strong>: If an event listener fails, it can retry processing later without affecting other services.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Event-Driven Communication in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides a built-in event publishing mechanism using <code>ApplicationEvent</code> and <code>ApplicationListener</code>.
  </p>

  <h4 style="color: #e67e22;">1. Create a Custom Event</h4>
  <p style="color: #2c3e50;">
    Define a custom event class that extends <code>ApplicationEvent</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.ApplicationEvent;

      public class OrderCreatedEvent extends ApplicationEvent {
          private final String orderId;

          public OrderCreatedEvent(Object source, String orderId) {
              super(source);
              this.orderId = orderId;
          }

          public String getOrderId() {
              return orderId;
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">2. Publish an Event</h4>
  <p style="color: #2c3e50;">
    Use <code>ApplicationEventPublisher</code> to publish the event.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.ApplicationEventPublisher;
      import org.springframework.stereotype.Service;

      @Service
      public class OrderService {
          private final ApplicationEventPublisher eventPublisher;

          public OrderService(ApplicationEventPublisher eventPublisher) {
              this.eventPublisher = eventPublisher;
          }

          public void createOrder(String orderId) {
              System.out.println("Order Created: " + orderId);
              eventPublisher.publishEvent(new OrderCreatedEvent(this, orderId));
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">3. Listen for Events</h4>
  <p style="color: #2c3e50;">
    Create an event listener using <code>@EventListener</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.event.EventListener;
      import org.springframework.stereotype.Component;

      @Component
      public class OrderEventListener {
          @EventListener
          public void handleOrderCreatedEvent(OrderCreatedEvent event) {
              System.out.println("Processing order: " + event.getOrderId());
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">4. Trigger the Event from a Controller</h4>
  <p style="color: #2c3e50;">
    Expose an endpoint to create orders and trigger the event.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestParam;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      public class OrderController {
          private final OrderService orderService;

          public OrderController(OrderService orderService) {
              this.orderService = orderService;
          }

          @GetMapping("/create-order")
          public String createOrder(@RequestParam String orderId) {
              orderService.createOrder(orderId);
              return "Order creation event published!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Event-Driven Communication with Message Brokers</h3>
  <p style="color: #2c3e50;">
    In microservices architectures, events are often handled using message brokers like Kafka or RabbitMQ instead of in-memory events.
  </p>

  <h4 style="color: #e67e22;">1. Kafka Event Publishing</h4>
  <p style="color: #2c3e50;">
    You can publish events to Apache Kafka using the <code>KafkaTemplate</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.kafka.core.KafkaTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class OrderEventProducer {
          private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;

          public OrderEventProducer(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
              this.kafkaTemplate = kafkaTemplate;
          }

          public void sendEvent(String orderId) {
              kafkaTemplate.send("order-events", orderId);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">2. Kafka Event Consumption</h4>
  <p style="color: #2c3e50;">
    Consumers listen for events on a Kafka topic.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.apache.kafka.clients.consumer.ConsumerRecord;
      import org.springframework.kafka.annotation.KafkaListener;
      import org.springframework.stereotype.Component;

      @Component
      public class OrderEventConsumer {
          @KafkaListener(topics = "order-events", groupId = "order-group")
          public void listen(ConsumerRecord&lt;String, String&gt; record) {
              System.out.println("Received Order Event: " + record.value());
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Event-driven communication makes applications more scalable and responsive by enabling asynchronous processing. Whether using Spring's built-in event system or integrating with Kafka/RabbitMQ, implementing event-driven architecture enhances the flexibility and resilience of modern applications.
  </p>
</div>
`
},
{
  title:`Microservices Communication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Microservices Communication in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Microservices architecture involves breaking down a monolithic application into smaller, independent services that communicate with each other. These services must exchange data effectively while maintaining loose coupling and scalability.
  </p>

  <h3 style="color: #16a085;">Types of Microservices Communication</h3>
  <p style="color: #2c3e50;">
    Microservices communicate using either synchronous or asynchronous methods:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Synchronous Communication</strong>: The caller waits for a response (e.g., REST, gRPC).</li>
    <li><strong>Asynchronous Communication</strong>: The caller does not wait for an immediate response (e.g., Messaging, Event-Driven Architecture).</li>
  </ul>

  <h3 style="color: #e67e22;">1. Synchronous Communication (REST APIs)</h3>
  <p style="color: #2c3e50;">
    The most common way microservices communicate is through RESTful APIs using HTTP.
  </p>

  <h4 style="color: #e67e22;">Using RestTemplate (Deprecated in Spring Boot 3)</h4>
  <p style="color: #2c3e50;">
    <code>RestTemplate</code> was used for synchronous communication but is now replaced by <code>WebClient</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.web.client.RestTemplate;

      @Service
      public class OrderService {
          private final RestTemplate restTemplate = new RestTemplate();

          public String getCustomerDetails(String customerId) {
              return restTemplate.getForObject("http://customer-service/customers/" + customerId, String.class);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Using WebClient (Recommended)</h4>
  <p style="color: #2c3e50;">
    Spring WebFlux <code>WebClient</code> is a non-blocking alternative to RestTemplate.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.web.reactive.function.client.WebClient;

      @Service
      public class OrderService {
          private final WebClient webClient = WebClient.create("http://customer-service");

          public String getCustomerDetails(String customerId) {
              return webClient.get()
                      .uri("/customers/{id}", customerId)
                      .retrieve()
                      .bodyToMono(String.class)
                      .block();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">2. Asynchronous Communication (Message Queues)</h3>
  <p style="color: #2c3e50;">
    Asynchronous messaging allows microservices to communicate without waiting for a direct response.
  </p>

  <h4 style="color: #e67e22;">Using RabbitMQ</h4>
  <p style="color: #2c3e50;">
    RabbitMQ is a message broker used for asynchronous communication.
  </p>

  <h5 style="color: #e67e22;">Producer</h5>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.amqp.rabbit.core.RabbitTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class OrderEventPublisher {
          private final RabbitTemplate rabbitTemplate;

          public OrderEventPublisher(RabbitTemplate rabbitTemplate) {
              this.rabbitTemplate = rabbitTemplate;
          }

          public void sendOrderCreatedEvent(String orderId) {
              rabbitTemplate.convertAndSend("order-exchange", "order.created", orderId);
          }
      }
    </code>
  </pre>

  <h5 style="color: #e67e22;">Consumer</h5>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.amqp.rabbit.annotation.RabbitListener;
      import org.springframework.stereotype.Component;

      @Component
      public class OrderEventListener {
          @RabbitListener(queues = "order-queue")
          public void handleOrderCreatedEvent(String orderId) {
              System.out.println("Processing order: " + orderId);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Using Apache Kafka</h4>
  <p style="color: #2c3e50;">
    Kafka is a distributed streaming platform used for event-driven communication.
  </p>

  <h5 style="color: #e67e22;">Kafka Producer</h5>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.kafka.core.KafkaTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class OrderEventProducer {
          private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;

          public OrderEventProducer(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
              this.kafkaTemplate = kafkaTemplate;
          }

          public void sendOrderEvent(String orderId) {
              kafkaTemplate.send("order-events", orderId);
          }
      }
    </code>
  </pre>

  <h5 style="color: #e67e22;">Kafka Consumer</h5>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.apache.kafka.clients.consumer.ConsumerRecord;
      import org.springframework.kafka.annotation.KafkaListener;
      import org.springframework.stereotype.Component;

      @Component
      public class OrderEventConsumer {
          @KafkaListener(topics = "order-events", groupId = "order-group")
          public void listen(ConsumerRecord&lt;String, String&gt; record) {
              System.out.println("Received Order Event: " + record.value());
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Choosing the Right Communication Strategy</h3>
  <p style="color: #2c3e50;">
    - Use **REST APIs** for synchronous interactions when real-time responses are needed.<br>
    - Use **RabbitMQ/Kafka** for asynchronous event-driven communication to improve scalability.<br>
    - Use **gRPC** for high-performance, low-latency calls between microservices.
  </p>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Effective microservices communication is crucial for building scalable applications. By using REST APIs for synchronous calls and message brokers like Kafka or RabbitMQ for asynchronous events, developers can design resilient and efficient systems.
  </p>
</div>
`
},
{
  title:`Large Data Handling`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Efficient Large Data Handling in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Handling large datasets efficiently is crucial for building high-performance applications. In Spring Boot, proper data management techniques help prevent memory overload, improve response times, and ensure scalability.
  </p>

  <h3 style="color: #16a085;">Challenges in Large Data Handling</h3>
  <p style="color: #2c3e50;">
    When dealing with large datasets, applications may face the following issues:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>High memory consumption due to loading large datasets at once.</li>
    <li>Slow response times due to inefficient database queries.</li>
    <li>Network congestion when transferring large payloads.</li>
    <li>Scalability issues in monolithic architectures.</li>
  </ul>

  <h3 style="color: #e67e22;">1. Pagination for Large Data Queries</h3>
  <p style="color: #2c3e50;">
    Instead of fetching all records at once, use pagination to retrieve data in smaller chunks.
  </p>

  <h4 style="color: #e67e22;">Using Spring Data JPA Pagination</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.domain.Page;
      import org.springframework.data.domain.Pageable;
      import org.springframework.data.jpa.repository.JpaRepository;

      public interface ProductRepository extends JpaRepository<Product, Long> {
          Page<Product> findAll(Pageable pageable);
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Service Method for Pagination</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.domain.Page;
      import org.springframework.data.domain.PageRequest;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          private final ProductRepository productRepository;

          public ProductService(ProductRepository productRepository) {
              this.productRepository = productRepository;
          }

          public Page<Product> getProducts(int page, int size) {
              return productRepository.findAll(PageRequest.of(page, size));
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">2. Streaming Large Data Using Spring Data JPA</h3>
  <p style="color: #2c3e50;">
    Streaming is useful when dealing with millions of records to avoid memory overload.
  </p>

  <h4 style="color: #e67e22;">Using Java Streams for Efficient Query Execution</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.Query;
      import org.springframework.data.repository.CrudRepository;
      import java.util.stream.Stream;

      public interface ProductRepository extends CrudRepository<Product, Long> {
          @Query("SELECT p FROM Product p")
          Stream<Product> streamAllProducts();
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">3. Batch Processing for Large Data</h3>
  <p style="color: #2c3e50;">
    Instead of inserting or updating records one by one, use batch processing to optimize performance.
  </p>

  <h4 style="color: #e67e22;">Using JDBC Batch Update</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.jdbc.core.JdbcTemplate;
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class ProductService {
          private final JdbcTemplate jdbcTemplate;

          public ProductService(JdbcTemplate jdbcTemplate) {
              this.jdbcTemplate = jdbcTemplate;
          }

          public void batchInsert(List<Product> products) {
              String sql = "INSERT INTO products (name, price) VALUES (?, ?)";
              jdbcTemplate.batchUpdate(sql, products, 1000, (ps, product) -> {
                  ps.setString(1, product.getName());
                  ps.setBigDecimal(2, product.getPrice());
              });
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">4. Asynchronous Data Processing</h3>
  <p style="color: #2c3e50;">
    When dealing with heavy computations, using asynchronous processing improves efficiency.
  </p>

  <h4 style="color: #e67e22;">Using @Async in Spring Boot</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;

      @Service
      public class DataProcessingService {
          @Async
          public void processLargeData() {
              // Perform heavy computations here
              System.out.println("Processing data asynchronously...");
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">5. Using Caching to Improve Performance</h3>
  <p style="color: #2c3e50;">
    Caching helps reduce repeated queries by storing frequently accessed data in memory.
  </p>

  <h4 style="color: #e67e22;">Using Spring Boot Cache</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          @Cacheable("products")
          public List<Product> getAllProducts() {
              return productRepository.findAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Choosing the Right Strategy</h3>
  <p style="color: #2c3e50;">
    - Use **pagination** to limit query results.<br>
    - Use **streaming** for processing large datasets efficiently.<br>
    - Use **batch processing** for bulk inserts and updates.<br>
    - Use **asynchronous processing** for long-running tasks.<br>
    - Use **caching** to store frequently accessed data.
  </p>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Efficient handling of large data is essential for high-performance applications. By leveraging pagination, batch processing, asynchronous execution, and caching, developers can ensure scalability and responsiveness in Spring Boot applications.
  </p>
</div>
`
},
{
  title:`Performance Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Performance Optimization in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Performance optimization in Spring Boot applications is essential for ensuring scalability, responsiveness, and efficient resource utilization. By applying various techniques, developers can enhance speed and reduce latency.
  </p>

  <h3 style="color: #16a085;">Key Performance Challenges</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Slow database queries leading to high response times.</li>
    <li>Excessive memory consumption due to inefficient data handling.</li>
    <li>Poor concurrency handling affecting scalability.</li>
    <li>Blocking I/O operations causing delays.</li>
  </ul>

  <h3 style="color: #e67e22;">1. Optimizing Database Queries</h3>
  <p style="color: #2c3e50;">
    Efficient database interactions play a critical role in improving application speed.
  </p>

  <h4 style="color: #e67e22;">Using Indexes for Faster Queries</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-sql">
      CREATE INDEX idx_product_name ON products(name);
    </code>
  </pre>

  <h4 style="color: #e67e22;">Using Lazy Loading</h4>
  <p style="color: #2c3e50;">
    Instead of fetching all related data, use lazy loading for better performance.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Order {
          @OneToMany(fetch = FetchType.LAZY)
          private List<Item> items;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">2. Caching Frequently Accessed Data</h3>
  <p style="color: #2c3e50;">
    Reduce database load by caching commonly requested data.
  </p>

  <h4 style="color: #e67e22;">Using Spring Boot Cache</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          @Cacheable("products")
          public List<Product> getAllProducts() {
              return productRepository.findAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">3. Asynchronous Processing</h3>
  <p style="color: #2c3e50;">
    Prevent blocking operations by using asynchronous execution.
  </p>

  <h4 style="color: #e67e22;">Using @Async for Background Tasks</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;

      @Service
      public class NotificationService {
          @Async
          public void sendEmail(String email) {
              // Simulate email sending
              System.out.println("Sending email to " + email);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">4. Connection Pooling</h3>
  <p style="color: #2c3e50;">
    Reduce the overhead of creating database connections by using connection pooling.
  </p>

  <h4 style="color: #e67e22;">Configuring HikariCP in application.properties</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      spring.datasource.hikari.maximum-pool-size=10
      spring.datasource.hikari.minimum-idle=5
    </code>
  </pre>

  <h3 style="color: #e67e22;">5. Reducing Memory Footprint</h3>
  <p style="color: #2c3e50;">
    Optimize memory usage to prevent application crashes.
  </p>

  <h4 style="color: #e67e22;">Using Java 17 Compact Strings</h4>
  <p style="color: #2c3e50;">
    Java 17's Compact Strings feature helps reduce memory consumption.
  </p>

  <h3 style="color: #e67e22;">6. Profiling and Monitoring</h3>
  <p style="color: #2c3e50;">
    Regularly monitor application performance to detect bottlenecks.
  </p>

  <h4 style="color: #e67e22;">Using Actuator for Health Checks</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      management.endpoints.web.exposure.include=health,metrics
    </code>
  </pre>

  <h3 style="color: #2980b9;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Optimize database queries and use indexing.</li>
    <li>Use caching for frequently accessed data.</li>
    <li>Leverage asynchronous processing for non-blocking operations.</li>
    <li>Use connection pooling for efficient database interactions.</li>
    <li>Regularly profile and monitor the application.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Performance optimization is essential for maintaining a fast and scalable Spring Boot application. By applying caching, database optimizations, asynchronous execution, and monitoring, developers can ensure efficient resource utilization and better user experience.
  </p>
</div>
`
},
{
  title:`Anti-Patterns`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Anti-Patterns in Software Development</h2>
  <p style="font-size: 16px; color: #34495e;">
    In software development, an anti-pattern is a common but ineffective or counterproductive way of solving a problem. Unlike best practices, anti-patterns often introduce technical debt, inefficiencies, and maintenance difficulties.
  </p>

  <h3 style="color: #16a085;">Common Software Anti-Patterns</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Spaghetti Code</li>
    <li>God Object</li>
    <li>Hardcoding</li>
    <li>Magic Numbers</li>
    <li>Golden Hammer</li>
    <li>Copy-Paste Programming</li>
    <li>Dead Code</li>
    <li>Premature Optimization</li>
  </ul>

  <h3 style="color: #e67e22;">1. Spaghetti Code</h3>
  <p style="color: #2c3e50;">
    Spaghetti code is unstructured, hard-to-read code with no clear separation of concerns, making it difficult to maintain and debug.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class Order {
          public void processOrder() {
              if (user.isLoggedIn()) {
                  if (cart.isNotEmpty()) {
                      if (payment.isValid()) {
                          // Order processing logic
                      }
                  }
              }
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Follow modular design principles such as SOLID and use well-structured functions.</p>

  <h3 style="color: #e67e22;">2. God Object</h3>
  <p style="color: #2c3e50;">
    A "God Object" is a class that does too much and holds excessive responsibilities, leading to poor maintainability.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class OrderManager {
          public void createOrder() { /* ... */ }
          public void validatePayment() { /* ... */ }
          public void generateInvoice() { /* ... */ }
          public void sendEmailNotification() { /* ... */ }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Follow the Single Responsibility Principle (SRP) and break down large classes into smaller, focused components.</p>

  <h3 style="color: #e67e22;">3. Hardcoding</h3>
  <p style="color: #2c3e50;">
    Hardcoding values directly into code reduces flexibility and makes future updates difficult.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class Config {
          public static final String DATABASE_URL = "jdbc:mysql://localhost:3306/mydb";
      }
    </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Use configuration files or environment variables for better maintainability.</p>

  <h3 style="color: #e67e22;">4. Magic Numbers</h3>
  <p style="color: #2c3e50;">
    Magic numbers are hardcoded numeric values that lack meaning, making the code difficult to understand.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      if (userAge > 18) {
          // Allow access
      }
    </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Use named constants to improve readability.</p>

  <h3 style="color: #e67e22;">5. Golden Hammer</h3>
  <p style="color: #2c3e50;">
    The "Golden Hammer" anti-pattern occurs when a developer uses the same tool or technology for every problem, even when it's not the best fit.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <p style="color: #2c3e50;">
    Always using relational databases even when a NoSQL database might be a better choice.
  </p>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Choose technologies based on the problem at hand rather than familiarity.</p>

  <h3 style="color: #e67e22;">6. Copy-Paste Programming</h3>
  <p style="color: #2c3e50;">
    Repeating the same code in multiple places instead of reusing functions leads to redundant and hard-to-maintain code.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public void processPayment() { /* Same logic */ }
      public void validateTransaction() { /* Same logic */ }
    </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Follow the DRY (Don't Repeat Yourself) principle and use reusable functions or classes.</p>

  <h3 style="color: #e67e22;">7. Dead Code</h3>
  <p style="color: #2c3e50;">
    Dead code is code that is never executed but still exists in the codebase, leading to unnecessary complexity.
  </p>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Regularly refactor and remove unused code.</p>

  <h3 style="color: #e67e22;">8. Premature Optimization</h3>
  <p style="color: #2c3e50;">
    Optimizing code too early can make it more complex than necessary, without real performance benefits.
  </p>
  <p style="color: #2c3e50;"><strong>Solution:</strong> Follow the "optimize later" approach and prioritize maintainability.</p>

  <h3 style="color: #2980b9;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Follow SOLID principles for maintainable code.</li>
    <li>Avoid excessive class responsibilities (God Object).</li>
    <li>Use proper configuration management instead of hardcoding.</li>
    <li>Refactor code regularly to remove dead or redundant logic.</li>
    <li>Choose the right tool for the job instead of a "one-size-fits-all" approach.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Identifying and avoiding anti-patterns helps maintain cleaner, more efficient, and scalable software. By following best practices, developers can reduce technical debt and improve code quality.
  </p>
</div>
`
},
{
  title:`JPA Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Persistence API (JPA) is a standard specification for object-relational mapping (ORM) in Java applications. It simplifies database interactions by allowing developers to work with Java objects instead of SQL queries.
  </p>

  <h3 style="color: #16a085;">Key Concepts in JPA</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Entities</li>
    <li>EntityManager</li>
    <li>Persistence Context</li>
    <li>Persistence Unit</li>
    <li>JPQL (Java Persistence Query Language)</li>
    <li>Annotations in JPA</li>
  </ul>

  <h3 style="color: #e67e22;">1. Entity in JPA</h3>
  <p style="color: #2c3e50;">
    An entity represents a table in a database, and each instance of the entity represents a row in the table.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          
          @Column(name = "username", nullable = false)
          private String username;
          
          @Column(name = "email", nullable = false)
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">2. EntityManager</h3>
  <p style="color: #2c3e50;">
    The <strong>EntityManager</strong> is the primary interface for interacting with the database in JPA.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      public class UserService {
          private EntityManagerFactory emf = Persistence.createEntityManagerFactory("my-persistence-unit");
          private EntityManager em = emf.createEntityManager();

          public void saveUser(User user) {
              em.getTransaction().begin();
              em.persist(user);
              em.getTransaction().commit();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">3. Persistence Context</h3>
  <p style="color: #2c3e50;">
    The Persistence Context is the set of managed entity instances in JPA. It ensures that changes to entities are automatically synchronized with the database.
  </p>

  <h3 style="color: #e67e22;">4. JPQL (Java Persistence Query Language)</h3>
  <p style="color: #2c3e50;">
    JPQL is used to query entities using object-oriented syntax instead of raw SQL.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public List<User> getUsers() {
          return em.createQuery("SELECT u FROM User u", User.class).getResultList();
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">5. Common JPA Annotations</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@Entity</code> - Marks a class as an entity.</li>
    <li><code>@Table(name = "table_name")</code> - Maps the entity to a specific table.</li>
    <li><code>@Id</code> - Specifies the primary key.</li>
    <li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code> - Auto-generates primary key values.</li>
    <li><code>@Column(name = "column_name")</code> - Maps a field to a specific column.</li>
    <li><code>@OneToOne, @OneToMany, @ManyToOne, @ManyToMany</code> - Defines relationships between entities.</li>
  </ul>

  <h3 style="color: #2980b9;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Entity</code> and define proper primary keys.</li>
    <li>Use <code>@Transactional</code> for atomic operations.</li>
    <li>Avoid unnecessary queries by using fetch strategies.</li>
    <li>Use batch processing for bulk operations.</li>
    <li>Enable caching for performance optimization.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JPA simplifies database operations in Java applications, reducing the need for complex SQL queries. By using JPA effectively, developers can create scalable and maintainable applications.
  </p>
</div>
`
},
{
  title:`Entity Mapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Mapping in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity mapping in JPA (Java Persistence API) is the process of defining how Java objects (entities) relate to database tables. It uses annotations or XML configuration to specify table relationships, column mappings, and constraints.
  </p>

  <h3 style="color: #16a085;">Types of Entity Mapping</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Basic Mapping</li>
    <li>One-to-One Mapping</li>
    <li>One-to-Many Mapping</li>
    <li>Many-to-One Mapping</li>
    <li>Many-to-Many Mapping</li>
    <li>Embedded Mapping</li>
  </ul>

  <h3 style="color: #e67e22;">1. Basic Entity Mapping</h3>
  <p style="color: #2c3e50;">
    The simplest mapping is between an entity class and a database table using the <code>@Entity</code> and <code>@Table</code> annotations.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      @Table(name = "employees")
      public class Employee {

          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(name = "name", nullable = false)
          private String name;

          @Column(name = "salary")
          private Double salary;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">2. One-to-One Mapping</h3>
  <p style="color: #2c3e50;">
    A one-to-one relationship means that one entity is associated with exactly one other entity.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          
          @OneToOne
          @JoinColumn(name = "address_id")
          private Address address;
      }

      @Entity
      public class Address {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(name = "city")
          private String city;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">3. One-to-Many Mapping</h3>
  <p style="color: #2c3e50;">
    A one-to-many relationship means that one entity is related to multiple instances of another entity.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
          private List<Employee> employees = new ArrayList<>();
      }

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">4. Many-to-One Mapping</h3>
  <p style="color: #2c3e50;">
    This is the inverse of one-to-many, where multiple entities are related to a single entity.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">5. Many-to-Many Mapping</h3>
  <p style="color: #2c3e50;">
    In a many-to-many relationship, multiple entities are associated with multiple other entities.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Student {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @ManyToMany
          @JoinTable(
              name = "student_course",
              joinColumns = @JoinColumn(name = "student_id"),
              inverseJoinColumns = @JoinColumn(name = "course_id")
          )
          private List<Course> courses = new ArrayList<>();
      }

      @Entity
      public class Course {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">6. Embedded Mapping</h3>
  <p style="color: #2c3e50;">
    Embedded mapping allows an entity to contain another class as an embedded object.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Embeddable
      public class Address {
          private String city;
          private String street;
      }

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Embedded
          private Address address;
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use appropriate mapping annotations to reflect real-world relationships.</li>
    <li>Always define <code>mappedBy</code> in bidirectional relationships to avoid extra tables.</li>
    <li>Use <code>cascade</code> options carefully to avoid unintended deletes or updates.</li>
    <li>Use <code>fetch</code> types properly to optimize performance.</li>
    <li>Normalize relationships to avoid redundancy and improve maintainability.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity mapping in JPA enables efficient database operations by defining relationships between objects. Proper mapping techniques improve application performance and maintainability.
  </p>
</div>
`
},
{
  title:`Entity Lifecycle`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Lifecycle in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    In JPA (Java Persistence API), an entity goes through different lifecycle states during its interaction with the persistence context. Understanding these lifecycle states is crucial for managing database operations efficiently.
  </p>

  <h3 style="color: #16a085;">JPA Entity Lifecycle States</h3>
  <p style="color: #2c3e50;">
    The JPA entity lifecycle consists of four main states:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Transient</strong></li>
    <li><strong>Persistent</strong></li>
    <li><strong>Detached</strong></li>
    <li><strong>Removed</strong></li>
  </ul>

  <h3 style="color: #e67e22;">1. Transient State</h3>
  <p style="color: #2c3e50;">
    When an entity object is created but not yet associated with any persistence context, it is in the <strong>Transient</strong> state. At this stage:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>It does not exist in the database.</li>
    <li>JPA does not manage it.</li>
    <li>Changes to it will not be persisted.</li>
  </ul>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Employee emp = new Employee(); // Transient state
      emp.setName("John Doe");
      emp.setSalary(50000.0);
    </code>
  </pre>

  <h3 style="color: #e67e22;">2. Persistent State</h3>
  <p style="color: #2c3e50;">
    When an entity is managed by the persistence context, it enters the <strong>Persistent</strong> state. This happens when:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>It is saved using <code>EntityManager.persist()</code>.</li>
    <li>It is retrieved from the database using <code>EntityManager.find()</code> or <code>EntityManager.merge()</code>.</li>
  </ul>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      EntityManager em = emf.createEntityManager();
      em.getTransaction().begin();

      Employee emp = new Employee();
      emp.setName("John Doe");
      emp.setSalary(50000.0);
      em.persist(emp); // Now in Persistent state

      em.getTransaction().commit();
    </code>
  </pre>

  <h3 style="color: #e67e22;">3. Detached State</h3>
  <p style="color: #2c3e50;">
    An entity becomes <strong>Detached</strong> when it is no longer managed by the persistence context. This happens when:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>The persistence context is closed.</li>
    <li>The entity is manually detached using <code>EntityManager.detach()</code>.</li>
    <li>The transaction is committed.</li>
  </ul>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      EntityManager em = emf.createEntityManager();
      Employee emp = em.find(Employee.class, 1L); // Persistent state

      em.detach(emp); // Now in Detached state
      emp.setSalary(60000.0); // Change won't be persisted

      em.merge(emp); // Merges back to Persistent state
    </code>
  </pre>

  <h3 style="color: #e67e22;">4. Removed State</h3>
  <p style="color: #2c3e50;">
    An entity enters the <strong>Removed</strong> state when it is scheduled for deletion using <code>EntityManager.remove()</code>.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      EntityManager em = emf.createEntityManager();
      em.getTransaction().begin();

      Employee emp = em.find(Employee.class, 1L);
      em.remove(emp); // Now in Removed state

      em.getTransaction().commit();
    </code>
  </pre>

  <h3 style="color: #2980b9;">Entity Lifecycle Events</h3>
  <p style="color: #2c3e50;">
    JPA provides lifecycle callback annotations to execute logic at different lifecycle stages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@PrePersist</code> - Before entity is inserted.</li>
    <li><code>@PostPersist</code> - After entity is inserted.</li>
    <li><code>@PreUpdate</code> - Before entity is updated.</li>
    <li><code>@PostUpdate</code> - After entity is updated.</li>
    <li><code>@PreRemove</code> - Before entity is removed.</li>
    <li><code>@PostRemove</code> - After entity is removed.</li>
    <li><code>@PostLoad</code> - After entity is loaded.</li>
  </ul>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="backg
`
},
{
  title:`Primary Keys & Generation Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Primary Keys & Generation Strategies in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    In JPA (Java Persistence API), the primary key uniquely identifies each entity in the database. It is essential for database operations such as retrieval, updates, and deletions. JPA provides different strategies to generate primary keys automatically.
  </p>

  <h3 style="color: #16a085;">Defining Primary Keys in JPA</h3>
  <p style="color: #2c3e50;">
    In JPA, we use the <code>@Id</code> annotation to mark a field as the primary key. A primary key can be a simple field (single column) or a composite key (multiple columns).
  </p>

  <h4 style="color: #e67e22;">Example of a Simple Primary Key:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Primary Key Generation Strategies</h3>
  <p style="color: #2c3e50;">
    JPA provides different ways to generate primary keys automatically using the <code>@GeneratedValue</code> annotation. The available strategies are:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>IDENTITY</strong> - Uses database auto-increment columns.</li>
    <li><strong>SEQUENCE</strong> - Uses a database sequence.</li>
    <li><strong>TABLE</strong> - Uses a separate table to maintain primary key values.</li>
    <li><strong>AUTO</strong> - Automatically selects a strategy based on the database.</li>
  </ul>

  <h3 style="color: #2980b9;">1. IDENTITY Strategy</h3>
  <p style="color: #2c3e50;">
    The <strong>IDENTITY</strong> strategy relies on the database’s auto-increment feature to generate unique primary key values.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Works well with MySQL, PostgreSQL, and SQL Server.<br>
    - Does not require extra queries to fetch the next ID.<br>
    - Not recommended for batch inserts.
  </p>

  <h3 style="color: #2980b9;">2. SEQUENCE Strategy</h3>
  <p style="color: #2c3e50;">
    The <strong>SEQUENCE</strong> strategy uses a database sequence to generate primary keys. It is commonly used in databases like Oracle and PostgreSQL.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @SequenceGenerator(name = "employee_seq", sequenceName = "EMPLOYEE_SEQUENCE", allocationSize = 1)
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "employee_seq")
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Better performance for batch inserts.<br>
    - Requires defining a sequence in the database.
  </p>

  <h3 style="color: #2980b9;">3. TABLE Strategy</h3>
  <p style="color: #2c3e50;">
    The <strong>TABLE</strong> strategy stores primary key values in a separate table. It is useful when sequences or auto-increment are not available.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @TableGenerator(name = "employee_table", table = "ID_GENERATOR", pkColumnName = "GEN_NAME",
                      valueColumnName = "GEN_VALUE", pkColumnValue = "EMP_ID", allocationSize = 1)
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.TABLE, generator = "employee_table")
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Works with all databases.<br>
    - Slower than IDENTITY and SEQUENCE.<br>
    - Requires a dedicated key-generation table.
  </p>

  <h3 style="color: #2980b9;">4. AUTO Strategy</h3>
  <p style="color: #2c3e50;">
    The <strong>AUTO</strong> strategy allows JPA to choose the best strategy based on the database being used.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.AUTO)
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Default strategy in JPA.<br>
    - Uses IDENTITY, SEQUENCE, or TABLE depending on the database.
  </p>

  <h3 style="color: #d35400;">Choosing the Right Strategy</h3>
  <p style="color: #2c3e50;">
    The choice of primary key strategy depends on database type, performance needs, and scalability requirements.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use IDENTITY</strong> if the database supports auto-increment.</li>
    <li><strong>Use SEQUENCE</strong> for better batch insert performance.</li>
    <li><strong>Use TABLE</strong> when sequences or auto-increment are not available.</li>
    <li><strong>Use AUTO</strong> for database-independent applications.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Primary keys are essential for uniquely identifying entities in JPA. Understanding different generation strategies helps in optimizing performance and ensuring compatibility across databases.
  </p>
</div>
`
},
{
  title:`JPA Annotations (@Entity, @Table, @Id, @Column)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA Annotations: @Entity, @Table, @Id, @Column</h2>
  <p style="font-size: 16px; color: #34495e;">
    JPA (Java Persistence API) provides several annotations to map Java objects to database tables. The most commonly used annotations include <strong>@Entity</strong>, <strong>@Table</strong>, <strong>@Id</strong>, and <strong>@Column</strong>. These annotations help define how an entity class interacts with the database.
  </p>

  <h3 style="color: #16a085;">1. @Entity Annotation</h3>
  <p style="color: #2c3e50;">
    The <strong>@Entity</strong> annotation marks a Java class as a JPA entity, meaning it is mapped to a table in the database.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;

      @Entity
      public class Employee {
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Every entity class must have a primary key.<br>
    - The class must have a no-argument constructor.<br>
    - Entities should not be final or contain final fields.
  </p>

  <h3 style="color: #2980b9;">2. @Table Annotation</h3>
  <p style="color: #2c3e50;">
    The <strong>@Table</strong> annotation specifies the database table name for the entity. If omitted, the default table name is the class name.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.Table;

      @Entity
      @Table(name = "EMPLOYEES")
      public class Employee {
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Allows specifying a custom table name.<br>
    - Can define unique constraints using <code>uniqueConstraints</code>.<br>
    - Can set schema using <code>schema</code> attribute.
  </p>

  <h3 style="color: #2980b9;">3. @Id Annotation</h3>
  <p style="color: #2c3e50;">
    The <strong>@Id</strong> annotation marks a field as the primary key of the entity.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.Id;

      @Entity
      public class Employee {
          @Id
          private Long id;
          private String name;
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Every entity must have a primary key.<br>
    - Can be used with <code>@GeneratedValue</code> for auto-generated IDs.<br>
    - Supports composite keys when used with <code>@EmbeddedId</code> or <code>@IdClass</code>.
  </p>

  <h3 style="color: #2980b9;">4. @Column Annotation</h3>
  <p style="color: #2c3e50;">
    The <strong>@Column</strong> annotation customizes the mapping of a field to a database column.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.Id;
      import jakarta.persistence.Column;

      @Entity
      public class Employee {
          @Id
          private Long id;

          @Column(name = "EMPLOYEE_NAME", length = 50, nullable = false)
          private String name;

          @Column(name = "EMPLOYEE_SALARY", precision = 10, scale = 2)
          private Double salary;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - <code>name</code>: Specifies the column name in the table.<br>
    - <code>length</code>: Defines the maximum length (for String fields).<br>
    - <code>nullable</code>: Determines whether the column allows null values.<br>
    - <code>precision</code> and <code>scale</code>: Define decimal precision for numeric fields.
  </p>

  <h3 style="color: #d35400;">Key Takeaways</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>@Entity</strong>: Marks a class as a JPA entity.</li>
    <li><strong>@Table</strong>: Specifies the database table name.</li>
    <li><strong>@Id</strong>: Defines the primary key field.</li>
    <li><strong>@Column</strong>: Customizes column properties in the table.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JPA annotations help define how Java objects are mapped to database tables. Using <strong>@Entity</strong>, <strong>@Table</strong>, <strong>@Id</strong>, and <strong>@Column</strong>, developers can effectively control database interactions and structure their entities efficiently.
  </p>
</div>
`
},
{
  title:`Relationships (OneToOne, OneToMany, ManyToOne, ManyToMany)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA Relationships: OneToOne, OneToMany, ManyToOne, ManyToMany</h2>
  <p style="font-size: 16px; color: #34495e;">
    In JPA (Java Persistence API), relationships define how entities are connected in a database. JPA provides four types of relationships: <strong>OneToOne</strong>, <strong>OneToMany</strong>, <strong>ManyToOne</strong>, and <strong>ManyToMany</strong>. These relationships help establish meaningful connections between entities while ensuring efficient data management.
  </p>

  <h3 style="color: #16a085;">1. OneToOne Relationship</h3>
  <p style="color: #2c3e50;">
    A <strong>OneToOne</strong> relationship means one entity is associated with only one other entity.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      public class Employee {
          @Id @GeneratedValue
          private Long id;
          private String name;

          @OneToOne
          @JoinColumn(name = "address_id")
          private Address address;
      }

      @Entity
      public class Address {
          @Id @GeneratedValue
          private Long id;
          private String street;
          private String city;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Each employee has exactly one address.<br>
    - <code>@JoinColumn</code> creates a foreign key <strong>address_id</strong> in the <strong>Employee</strong> table.
  </p>

  <h3 style="color: #2980b9;">2. OneToMany Relationship</h3>
  <p style="color: #2c3e50;">
    A <strong>OneToMany</strong> relationship means one entity is related to multiple entities.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;
      import java.util.List;

      @Entity
      public class Department {
          @Id @GeneratedValue
          private Long id;
          private String name;

          @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
          private List<Employee> employees;
      }

      @Entity
      public class Employee {
          @Id @GeneratedValue
          private Long id;
          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - A <strong>Department</strong> can have multiple employees.<br>
    - The <code>mappedBy</code> attribute in <strong>OneToMany</strong> tells JPA that the relationship is managed by the <code>department</code> field in <strong>Employee</strong>.
  </p>

  <h3 style="color: #2980b9;">3. ManyToOne Relationship</h3>
  <p style="color: #2c3e50;">
    A <strong>ManyToOne</strong> relationship means multiple entities are linked to a single entity.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id @GeneratedValue
          private Long id;
          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;
      }

      @Entity
      public class Department {
          @Id @GeneratedValue
          private Long id;
          private String name;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - Multiple employees belong to the same department.<br>
    - The <code>@ManyToOne</code> annotation is placed in the entity that holds the foreign key.
  </p>

  <h3 style="color: #2980b9;">4. ManyToMany Relationship</h3>
  <p style="color: #2c3e50;">
    A <strong>ManyToMany</strong> relationship means multiple entities can be related to multiple entities.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;
      import java.util.List;

      @Entity
      public class Student {
          @Id @GeneratedValue
          private Long id;
          private String name;

          @ManyToMany
          @JoinTable(
              name = "student_course",
              joinColumns = @JoinColumn(name = "student_id"),
              inverseJoinColumns = @JoinColumn(name = "course_id")
          )
          private List<Course> courses;
      }

      @Entity
      public class Course {
          @Id @GeneratedValue
          private Long id;
          private String name;

          @ManyToMany(mappedBy = "courses")
          private List<Student> students;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    - A <strong>Student</strong> can enroll in multiple courses, and a <strong>Course</strong> can have multiple students.<br>
    - A join table <strong>student_course</strong> is created with <code>student_id</code> and <code>course_id</code> as foreign keys.
  </p>

  <h3 style="color: #d35400;">Key Takeaways</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>OneToOne</strong>: One entity is linked to exactly one other entity.</li>
    <li><strong>OneToMany</strong>: One entity is linked to multiple entities.</li>
    <li><strong>ManyToOne</strong>: Multiple entities are linked to a single entity.</li>
    <li><strong>ManyToMany</strong>: Multiple entities are linked to multiple entities.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JPA relationships help in structuring database interactions efficiently. By using <strong>@OneToOne</strong>, <strong>@OneToMany</strong>, <strong>@ManyToOne</strong>, and <strong>@ManyToMany</strong>, developers can ensure clear and optimized entity connections in their applications.
  </p>
</div>
`
},
{
  title:`JPQL (Java Persistence Query Language)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to JPQL (Java Persistence Query Language)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Persistence Query Language (JPQL) is a platform-independent object-oriented query language defined as part of the Java Persistence API (JPA) specification. It is used to perform database operations on entities and their persistent state, rather than directly on database tables. JPQL is similar to SQL but operates on entity objects instead of tables, making it a powerful tool for working with JPA in Spring Boot applications.
  </p>

  <h3 style="color: #16a085;">Why Use JPQL?</h3>
  <p style="color: #2c3e50;">
    JPQL offers several advantages for working with JPA entities:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Database Independence</strong>: JPQL queries are database-agnostic, allowing you to write queries that work across different databases.</li>
    <li><strong>Object-Oriented</strong>: JPQL operates on entities and their relationships, making it easier to work with object-oriented data models.</li>
    <li><strong>Type Safety</strong>: JPQL queries are type-safe, reducing the risk of runtime errors.</li>
    <li><strong>Integration with JPA</strong>: JPQL integrates seamlessly with JPA, enabling features like lazy loading, caching, and pagination.</li>
    <li><strong>Flexibility</strong>: JPQL supports complex queries, including joins, aggregations, and subqueries.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of JPQL</h3>
  <p style="color: #2c3e50;">
    When working with JPQL, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Entities</strong>: JPQL queries operate on JPA entities, which represent database tables.</li>
    <li><strong>Query Structure</strong>: JPQL queries are similar to SQL but use entity and field names instead of table and column names.</li>
    <li><strong>Named Queries</strong>: JPQL queries can be predefined and reused using named queries.</li>
    <li><strong>Parameters</strong>: JPQL supports both positional and named parameters for dynamic queries.</li>
    <li><strong>Pagination</strong>: JPQL queries can be paginated using the <code>setFirstResult</code> and <code>setMaxResults</code> methods.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using JPQL in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use JPQL in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity</h4>
  <p style="color: #2c3e50;">
    Create a JPA entity to represent a database table.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create a Repository with JPQL Queries</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Query</code> annotation to define JPQL queries in a repository.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.data.jpa.repository.Query;
      import org.springframework.data.repository.query.Param;

      import java.util.List;

      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

          // Simple JPQL query
          @Query("SELECT u FROM User u WHERE u.email = :email")
          User findByEmail(@Param("email") String email);

          // JPQL query with join
          @Query("SELECT u FROM User u JOIN u.orders o WHERE o.status = :status")
          List&lt;User&gt; findUsersByOrderStatus(@Param("status") String status);

          // JPQL query with pagination
          @Query("SELECT u FROM User u ORDER BY u.name")
          List&lt;User&gt; findAllUsersWithPagination(Pageable pageable);
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Repository in a Service</h4>
  <p style="color: #2c3e50;">
    Use the repository methods in a service to perform database operations.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      import java.util.List;

      @Service
      public class UserService {

          @Autowired
          private UserRepository userRepository;

          public User getUserByEmail(String email) {
              return userRepository.findByEmail(email);
          }

          public List&lt;User&gt; getUsersByOrderStatus(String status) {
              return userRepository.findUsersByOrderStatus(status);
          }

          public List&lt;User&gt; getAllUsers(int page, int size) {
              return userRepository.findAllUsersWithPagination(PageRequest.of(page, size));
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using JPQL</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use named queries for frequently used queries to improve readability and maintainability.</li>
    <li>Leverage pagination for large datasets to improve performance.</li>
    <li>Use parameters to make queries dynamic and reusable.</li>
    <li>Test JPQL queries thoroughly to ensure they work as expected.</li>
    <li>Optimize queries to minimize database load and improve performance.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JPQL is a powerful tool for working with JPA entities in Spring Boot applications. By leveraging JPQL, you can write database-agnostic, object-oriented queries that integrate seamlessly with JPA. Whether you're performing simple queries or complex joins, JPQL provides the flexibility and functionality needed to work with your data effectively. By following best practices, you can ensure that your JPQL queries are efficient, maintainable, and scalable.
  </p>
</div>
`
},
{
  title:`Criteria API`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Criteria API in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The Criteria API is a type-safe and programmatic way to construct database queries using the Java Persistence API (JPA). Unlike JPQL, which is a string-based query language, the Criteria API allows developers to build queries dynamically using Java objects, providing flexibility and reducing the risk of syntax errors.
  </p>

  <h3 style="color: #16a085;">Why Use Criteria API?</h3>
  <p style="color: #2c3e50;">
    The Criteria API provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Type Safety</strong>: Prevents runtime errors by ensuring type correctness at compile time.</li>
    <li><strong>Dynamic Querying</strong>: Allows dynamic query creation based on runtime conditions.</li>
    <li><strong>Readable and Maintainable</strong>: Queries are constructed using Java methods, making them easier to read and modify.</li>
    <li><strong>Integration with JPA</strong>: Works seamlessly with JPA entity management and persistence context.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Components of the Criteria API</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>CriteriaBuilder</strong>: Used to create query objects and define query conditions.</li>
    <li><strong>CriteriaQuery</strong>: Represents the actual query that will be executed.</li>
    <li><strong>Root</strong>: Defines the entity being queried.</li>
    <li><strong>Predicate</strong>: Represents filter conditions applied to queries.</li>
    <li><strong>TypedQuery</strong>: Executes the query and retrieves results.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Criteria API in Spring Boot</h3>

  <h4 style="color: #8e44ad;">1. Define an Entity</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Implement a Repository with Criteria API</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import jakarta.persistence.EntityManager;
      import jakarta.persistence.criteria.CriteriaBuilder;
      import jakarta.persistence.criteria.CriteriaQuery;
      import jakarta.persistence.criteria.Predicate;
      import jakarta.persistence.criteria.Root;
      import org.springframework.stereotype.Repository;
      import java.util.List;

      @Repository
      public class UserRepository {
          private final EntityManager entityManager;

          public UserRepository(EntityManager entityManager) {
              this.entityManager = entityManager;
          }

          public List<User> findUsersByEmail(String email) {
              CriteriaBuilder cb = entityManager.getCriteriaBuilder();
              CriteriaQuery<User> cq = cb.createQuery(User.class);
              Root<User> user = cq.from(User.class);
              Predicate emailPredicate = cb.equal(user.get("email"), email);
              cq.where(emailPredicate);

              return entityManager.createQuery(cq).getResultList();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Repository in a Service</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          
          @Autowired
          private UserRepository userRepository;

          public List<User> getUsersByEmail(String email) {
              return userRepository.findUsersByEmail(email);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Criteria API</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use Criteria API for dynamic queries instead of string-based JPQL.</li>
    <li>Combine multiple predicates using CriteriaBuilder for complex conditions.</li>
    <li>Use pagination to limit large query results and improve performance.</li>
    <li>Ensure queries are optimized to avoid performance bottlenecks.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The Criteria API is a powerful tool in JPA that allows developers to construct type-safe and dynamic queries. By leveraging the Criteria API, you can build queries programmatically while ensuring flexibility, maintainability, and performance optimization in Spring Boot applications.
  </p>
</div>
`
},
{
  title:`Native SQL Queries`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Native SQL Queries in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Native SQL queries allow developers to execute raw SQL statements directly in Java Persistence API (JPA). Unlike JPQL or Criteria API, native queries give complete control over SQL execution, making them useful for complex queries, database-specific operations, or when performance tuning is necessary.
  </p>

  <h3 style="color: #16a085;">Why Use Native SQL Queries?</h3>
  <p style="color: #2c3e50;">
    Native SQL queries offer several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Direct SQL Execution</strong>: Enables the execution of complex SQL queries, including joins and stored procedures.</li>
    <li><strong>Database-Specific Features</strong>: Allows the use of vendor-specific SQL functions and optimizations.</li>
    <li><strong>Performance Optimization</strong>: Can be used for performance tuning when JPQL or Criteria API falls short.</li>
    <li><strong>Flexibility</strong>: Ideal for queries that cannot be easily represented in JPQL.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Components of Native SQL Queries</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>@Query Annotation</strong>: Used in Spring Data JPA to execute native SQL queries.</li>
    <li><strong>EntityManager.createNativeQuery</strong>: Manually executes native SQL queries.</li>
    <li><strong>Result Mapping</strong>: Maps SQL query results to entity objects.</li>
    <li><strong>Parameter Binding</strong>: Allows safe injection of parameters to prevent SQL injection.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Native SQL Queries in Spring Boot</h3>

  <h4 style="color: #8e44ad;">1. Define an Entity</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String department;
          private double salary;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Using @Query Annotation in a Repository</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.data.jpa.repository.Query;
      import org.springframework.data.repository.query.Param;
      import java.util.List;

      public interface EmployeeRepository extends JpaRepository<Employee, Long> {

          @Query(value = "SELECT * FROM Employee WHERE department = :department", nativeQuery = true)
          List<Employee> findByDepartment(@Param("department") String department);
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Using EntityManager for Native Queries</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import jakarta.persistence.EntityManager;
      import jakarta.persistence.PersistenceContext;
      import jakarta.persistence.Query;
      import org.springframework.stereotype.Repository;
      import java.util.List;

      @Repository
      public class EmployeeNativeRepository {
          
          @PersistenceContext
          private EntityManager entityManager;

          public List<Object[]> getEmployeesWithHighSalary(double salary) {
              String sql = "SELECT id, name, salary FROM Employee WHERE salary > :salary";
              Query query = entityManager.createNativeQuery(sql);
              query.setParameter("salary", salary);
              return query.getResultList();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Calling the Repository in a Service</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class EmployeeService {
          
          @Autowired
          private EmployeeRepository employeeRepository;
          
          @Autowired
          private EmployeeNativeRepository employeeNativeRepository;

          public List<Employee> getEmployeesByDepartment(String department) {
              return employeeRepository.findByDepartment(department);
          }

          public List<Object[]> getHighSalaryEmployees(double salary) {
              return employeeNativeRepository.getEmployeesWithHighSalary(salary);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Native SQL Queries</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use native queries only when necessary; prefer JPQL or Criteria API for portability.</li>
    <li>Always use parameterized queries to prevent SQL injection.</li>
    <li>Ensure result mappings are correct to avoid data integrity issues.</li>
    <li>Optimize queries with proper indexing and performance tuning techniques.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Native SQL queries in JPA provide developers with the flexibility to execute complex database operations while leveraging the power of SQL. When used wisely, they can enhance performance and handle advanced query scenarios efficiently in Spring Boot applications.
  </p>
</div>
 `

},
{
  title:`Named Queries`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Named Queries in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Named Queries in JPA allow developers to define queries statically using annotations or XML configurations. These pre-defined queries improve performance and maintainability by enabling the reuse of queries throughout the application.
  </p>

  <h3 style="color: #16a085;">Why Use Named Queries?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulates query logic within entity classes, improving modularity.</li>
    <li>Optimized by the persistence provider at startup, leading to better performance.</li>
    <li>Enhances code readability and reduces duplication.</li>
    <li>Easy to maintain and modify in large-scale applications.</li>
  </ul>

  <h3 style="color: #e67e22;">Defining Named Queries</h3>
  <p style="color: #2c3e50;">Named Queries can be defined using the <code>@NamedQuery</code> annotation or XML configuration.</p>

  <h4 style="color: #8e44ad;">1. Using @NamedQuery Annotation</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import jakarta.persistence.*;

      @Entity
      @NamedQuery(name = "User.findByEmail", query = "SELECT u FROM User u WHERE u.email = :email")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Executing Named Query</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      import jakarta.persistence.*;
      import java.util.List;

      public class UserRepository {
          private final EntityManager entityManager;

          public UserRepository(EntityManager entityManager) {
              this.entityManager = entityManager;
          }

          public List<User> findUsersByEmail(String email) {
              return entityManager.createNamedQuery("User.findByEmail", User.class)
                  .setParameter("email", email)
                  .getResultList();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Defining Named Queries in XML (Optional)</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      &lt;named-query name="User.findByEmail"&gt;
          &lt;query&gt;SELECT u FROM User u WHERE u.email = :email&lt;/query&gt;
      &lt;/named-query&gt;
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Best Practices for Named Queries</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful query names for clarity and maintainability.</li>
    <li>Leverage indexed parameters (<code>?1, ?2</code>) for simplicity in complex queries.</li>
    <li>Use <code>@NamedNativeQuery</code> for raw SQL queries when needed.</li>
    <li>Ensure queries are optimized to avoid performance bottlenecks.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Named Queries in JPA provide a structured way to define and reuse database queries efficiently. By implementing them correctly, developers can achieve cleaner, more maintainable, and performant code in their Spring Boot applications.
  </p>
</div>

 `
},
{
  title:`Transaction Management`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Management in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction management ensures data consistency and integrity in Spring Boot applications, especially when multiple database operations need to be executed as a single unit of work.
  </p>

  <h3 style="color: #16a085;">Key Concepts of Transaction Management:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>A transaction groups multiple database operations into a single unit.</li>
    <li>Spring provides declarative transaction management using <code>@Transactional</code>.</li>
    <li>Transactions follow ACID properties: Atomicity, Consistency, Isolation, and Durability.</li>
    <li>Propagation behavior controls how transactions interact with each other.</li>
    <li>Rollback policies determine when to revert changes due to errors.</li>
    <li>Spring supports programmatic and declarative transaction management.</li>
  </ul>

  <h3 style="color: #e67e22;">Declarative Transaction Management Example</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class BankService {

          private final AccountRepository accountRepository;

          public BankService(AccountRepository accountRepository) {
              this.accountRepository = accountRepository;
          }

          @Transactional
          public void transferMoney(Long fromAccountId, Long toAccountId, double amount) {
              Account fromAccount = accountRepository.findById(fromAccountId).orElseThrow();
              Account toAccount = accountRepository.findById(toAccountId).orElseThrow();
              
              fromAccount.debit(amount);
              toAccount.credit(amount);
              
              accountRepository.save(fromAccount);
              accountRepository.save(toAccount);
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Propagation and Isolation Levels</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Propagation:</b> Defines how a transaction should behave when a method is called within an existing transaction.</li>
    <ul>
      <li><code>REQUIRED</code>: Uses the existing transaction or creates a new one.</li>
      <li><code>REQUIRES_NEW</code>: Always creates a new transaction.</li>
      <li><code>SUPPORTS</code>: Runs within a transaction if available.</li>
    </ul>
    <li><b>Isolation Levels:</b> Determines how transaction operations are isolated from each other.</li>
    <ul>
      <li><code>READ_COMMITTED</code>: Prevents dirty reads.</li>
      <li><code>REPEATABLE_READ</code>: Prevents non-repeatable reads.</li>
      <li><code>SERIALIZABLE</code>: Ensures full isolation but reduces concurrency.</li>
    </ul>
  </ul>

  <h3 style="color: #e74c3c;">Handling Rollbacks</h3>
  <p style="color: #2c3e50;">
    Transactions can be rolled back automatically when an exception occurs. By default, Spring rolls back for unchecked exceptions (<code>RuntimeException</code>), but you can customize rollback behavior:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Transactional(rollbackFor = Exception.class)
      public void processTransaction() throws Exception {
          // Transactional operations
          if (someCondition) {
              throw new Exception("Force rollback");
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Effective transaction management in Spring Boot enhances data integrity and consistency. By understanding propagation, isolation, and rollback strategies, developers can build robust applications with efficient database operations.
  </p>
</div>
`
},
{
  title:`Lazy vs Eager Loading`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Lazy Loading vs Eager Loading in JPA/Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    In JPA and Hibernate, lazy and eager loading determine how related entities are fetched from the database.
    Choosing the right strategy can impact performance and resource utilization.
  </p>

  <h3 style="color: #16a085;">Lazy Loading</h3>
  <p style="color: #2c3e50;">
    Lazy loading means that related entities are not fetched immediately from the database but only when they are explicitly accessed.
    This improves performance by reducing unnecessary data retrieval but can lead to the "LazyInitializationException" if not handled properly.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Default behavior in JPA relationships (<code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>).</li>
    <li>Loads associated entities only when accessed.</li>
    <li>Reduces initial query load but can cause multiple queries later.</li>
    <li>Risk of <code>LazyInitializationException</code> outside of a transaction.</li>
  </ul>

  <h3 style="color: #e67e22;">Eager Loading</h3>
  <p style="color: #2c3e50;">
    Eager loading retrieves all related entities immediately, avoiding additional queries later but potentially fetching unnecessary data.
    This strategy is useful when related entities are always required together.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Explicitly defined using <code>fetch = FetchType.EAGER</code>.</li>
    <li>All related entities are retrieved in a single query.</li>
    <li>May lead to performance issues due to excessive data retrieval.</li>
    <li>Increased memory usage if fetching large datasets.</li>
  </ul>

  <h3 style="color: #9b59b6;">Example: Lazy vs Eager Loading</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;
      import java.util.List;

      @Entity
      public class Department {

          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToMany(mappedBy = "department", fetch = FetchType.LAZY) // Lazy Loading
          private List<Employee> employees;
      }

      @Entity
      public class Employee {

          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;

          @ManyToOne(fetch = FetchType.EAGER) // Eager Loading
          private Department department;
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **Lazy Loading** for collections to optimize performance.</li>
    <li>Use **Eager Loading** when related data is always required.</li>
    <li>Leverage <code>JOIN FETCH</code> in JPQL to avoid multiple queries.</li>
    <li>Use DTOs (Data Transfer Objects) to fetch only required fields.</li>
  </ul>

  <p style="color: #2c3e50;">
    Choosing between lazy and eager loading depends on the use case. A well-balanced approach ensures optimized performance and efficient data retrieval.
  </p>
</div>

`
},
{
title:`Caching (First-Level & Second-Level)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Caching in Hibernate: First-Level & Second-Level</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching in Hibernate improves performance by reducing database access. Hibernate provides two levels of caching:
    <strong>First-Level Cache</strong> and <strong>Second-Level Cache</strong>. Understanding their differences and how they work is crucial for efficient data retrieval.
  </p>

  <h3 style="color: #16a085;">1. First-Level Cache (Session Cache)</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Enabled by default and tied to the Hibernate <code>Session</code>.</li>
    <li>Stores entities within the same session, avoiding redundant database queries.</li>
    <li>Cache is cleared when the session is closed.</li>
    <li>No special configuration is required.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: First-Level Caching</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Session session = sessionFactory.openSession();
      Transaction tx = session.beginTransaction();
      
      User user1 = session.get(User.class, 1); // Fetches from DB
      User user2 = session.get(User.class, 1); // Fetches from Cache
      
      tx.commit();
      session.close();
    </code>
  </pre>

  <h3 style="color: #16a085;">2. Second-Level Cache</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Not enabled by default; needs explicit configuration.</li>
    <li>Stores entities beyond a single session, making them accessible across multiple sessions.</li>
    <li>Requires a caching provider such as EhCache, Hazelcast, or Infinispan.</li>
    <li>Configured using annotations like <code>@Cacheable</code> and <code>@Cache</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Second-Level Caching Configuration</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @Cacheable
      @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Enabling Second-Level Cache in Hibernate</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      hibernate.cache.use_second_level_cache=true
      hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
    </code>
  </pre>

  <p style="color: #2c3e50;">
    By implementing both caching levels efficiently, you can significantly reduce database load and enhance application performance.
  </p>
</div>
`
},
{
  title:`JPA with Spring Data`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to JPA with Spring Data</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Persistence API (JPA) is a standard specification for object-relational mapping (ORM) in Java, enabling developers to manage relational data in applications using object-oriented principles. Spring Data JPA, a part of the larger Spring Data family, simplifies the implementation of JPA-based repositories by reducing boilerplate code and providing powerful features like query methods, pagination, and auditing. Together, JPA and Spring Data JPA make it easier to build data access layers in Spring Boot applications.
  </p>

  <h3 style="color: #16a085;">Why Use JPA with Spring Data?</h3>
  <p style="color: #2c3e50;">
    Using JPA with Spring Data offers several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduced Boilerplate Code</strong>: Spring Data JPA eliminates the need for manual implementation of common CRUD operations.</li>
    <li><strong>Query Methods</strong>: Automatically generates queries based on method names, reducing the need for writing JPQL or SQL.</li>
    <li><strong>Pagination and Sorting</strong>: Provides built-in support for pagination and sorting, making it easier to handle large datasets.</li>
    <li><strong>Auditing</strong>: Automatically tracks entity creation and modification timestamps.</li>
    <li><strong>Integration with Spring Ecosystem</strong>: Seamlessly integrates with other Spring components like Spring Boot, Spring Security, and Spring MVC.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of JPA with Spring Data</h3>
  <p style="color: #2c3e50;">
    When working with JPA and Spring Data, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Entities</strong>: Represent database tables as Java objects using JPA annotations like <code>@Entity</code>, <code>@Id</code>, and <code>@GeneratedValue</code>.</li>
    <li><strong>Repositories</strong>: Interfaces that extend <code>JpaRepository</code> to provide CRUD operations and custom query methods.</li>
    <li><strong>Query Methods</strong>: Methods in repositories that automatically generate queries based on their names.</li>
    <li><strong>Pagination</strong>: Supports paginated queries using the <code>Pageable</code> interface.</li>
    <li><strong>Auditing</strong>: Automatically tracks entity creation and modification using annotations like <code>@CreatedDate</code> and <code>@LastModifiedDate</code>.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using JPA with Spring Data in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use JPA with Spring Data in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity</h4>
  <p style="color: #2c3e50;">
    Create a JPA entity to represent a database table.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create a Repository</h4>
  <p style="color: #2c3e50;">
    Extend <code>JpaRepository</code> to create a repository for the entity.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;

      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          // Custom query method
          User findByEmail(String email);
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Repository in a Service</h4>
  <p style="color: #2c3e50;">
    Use the repository methods in a service to perform database operations.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          @Autowired
          private UserRepository userRepository;

          public User getUserByEmail(String email) {
              return userRepository.findByEmail(email);
          }

          public User createUser(User user) {
              return userRepository.save(user);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Enable JPA Auditing</h4>
  <p style="color: #2c3e50;">
    Enable JPA auditing to automatically track entity creation and modification timestamps.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

      @Configuration
      @EnableJpaAuditing
      public class JpaConfig {
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">5. Add Auditing Fields to the Entity</h4>
  <p style="color: #2c3e50;">
    Add fields to the entity to track creation and modification timestamps.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;
      import org.springframework.data.annotation.CreatedDate;
      import org.springframework.data.annotation.LastModifiedDate;

      import java.time.LocalDateTime;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          @CreatedDate
          private LocalDateTime createdAt;

          @LastModifiedDate
          private LocalDateTime updatedAt;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using JPA with Spring Data</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use query methods for simple queries to reduce boilerplate code.</li>
    <li>Leverage pagination and sorting for large datasets to improve performance.</li>
    <li>Enable JPA auditing to automatically track entity changes.</li>
    <li>Use <code>@Query</code> for complex queries that cannot be expressed using query methods.</li>
    <li>Optimize entity relationships (e.g., lazy loading) to avoid performance issues.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JPA with Spring Data is a powerful combination for building data access layers in Spring Boot applications. By leveraging Spring Data JPA, you can reduce boilerplate code, simplify query creation, and enhance the functionality of your repositories. Whether you're performing basic CRUD operations or complex queries, JPA and Spring Data provide the tools and features needed to work with your data efficiently and effectively. By following best practices, you can ensure that your application is scalable, maintainable, and performant.
  </p>
</div>`
},
{
  title:`Repository Pattern`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding the Repository Pattern in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The Repository Pattern is a design pattern that helps abstract data access logic, promoting separation of concerns.
    In Spring Boot, it is commonly implemented using Spring Data JPA, making data operations easier and more structured.
  </p>

  <h3 style="color: #16a085;">Key Benefits of Repository Pattern:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulates database logic for better maintainability.</li>
    <li>Reduces boilerplate code when using Spring Data JPA.</li>
    <li>Improves testability by allowing mocking of repositories.</li>
    <li>Enhances scalability by abstracting persistence logic.</li>
  </ul>

  <h3 style="color: #e67e22;">Implementing Repository Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.stereotype.Repository;

      @Repository
      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          User findByEmail(String email);
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Service Layer Using Repository</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List&lt;User&gt; getAllUsers() {
              return userRepository.findAll();
          }

          public User getUserByEmail(String email) {
              return userRepository.findByEmail(email);
          }
      }
    </code>
  </pre>

  <h3 style="color: #c0392b;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful method names in repositories.</li>
    <li>Leverage Spring Data JPA’s built-in query methods.</li>
    <li>Avoid placing business logic inside repository classes.</li>
    <li>Use pagination and sorting to optimize performance.</li>
  </ul>

  <p style="color: #2c3e50;">
    The Repository Pattern simplifies database interactions, making applications more modular, testable, and maintainable.
  </p>
</div>

 `
},
{
  title:`Spring Data JPA Repositories`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Data JPA Repositories</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Data JPA simplifies database access by providing a standard way to define repositories.
    It abstracts the persistence layer, reducing boilerplate code and enhancing maintainability.
  </p>

  <h3 style="color: #16a085;">Key Features of Spring Data JPA Repositories:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Eliminates boilerplate DAO code.</li>
    <li>Provides built-in CRUD operations.</li>
    <li>Supports derived query methods.</li>
    <li>Allows the use of custom JPQL and native queries.</li>
    <li>Integrates seamlessly with Spring Boot and Hibernate.</li>
    <li>Offers pagination and sorting functionalities.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Defining a JPA Repository</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.stereotype.Repository;

      @Repository
      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          User findByUsername(String username);
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Example: Using the Repository in a Service</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public List&lt;User&gt; getAllUsers() {
              return userRepository.findAll();
          }

          public User getUserByUsername(String username) {
              return userRepository.findByUsername(username);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Example: Custom Query with @Query Annotation</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.Query;
      import org.springframework.data.repository.query.Param;

      @Repository
      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          @Query("SELECT u FROM User u WHERE u.email = :email")
          User findUserByEmail(@Param("email") String email);
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Example: Pagination and Sorting</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.domain.Page;
      import org.springframework.data.domain.Pageable;

      @Repository
      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          Page&lt;User&gt; findByRole(String role, Pageable pageable);
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    By leveraging Spring Data JPA repositories, developers can streamline database interactions
    while maintaining clean, modular, and efficient code.
  </p>
</div>
`
},
{ 
  title:`Paging & Sorting`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Paging and Sorting in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Paging and sorting are essential features for handling large datasets in Spring Boot applications. Paging allows you to retrieve data in smaller, manageable chunks (pages), while sorting enables you to order the data based on specific criteria. Together, these features improve performance, reduce memory usage, and enhance the user experience by providing structured and organized data. Spring Data JPA provides built-in support for paging and sorting, making it easy to implement these features in your application.
  </p>

  <h3 style="color: #16a085;">Why Use Paging and Sorting?</h3>
  <p style="color: #2c3e50;">
    Paging and sorting offer several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improved Performance</strong>: Retrieving smaller subsets of data reduces the load on the database and improves response times.</li>
    <li><strong>Reduced Memory Usage</strong>: Processing smaller datasets minimizes memory consumption on the server and client sides.</li>
    <li><strong>Enhanced User Experience</strong>: Users can navigate through data more efficiently with paginated and sorted results.</li>
    <li><strong>Scalability</strong>: Paging and sorting make it easier to handle large datasets as your application grows.</li>
    <li><strong>Flexibility</strong>: Allows users to customize how data is displayed based on their preferences.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Paging and Sorting</h3>
  <p style="color: #2c3e50;">
    When working with paging and sorting in Spring Boot, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Pageable</strong>: An interface in Spring Data that represents a request for a specific page of data, including page number, page size, and sorting criteria.</li>
    <li><strong>Page</strong>: A Spring Data class that represents a single page of data, including the content, total number of pages, and total number of elements.</li>
    <li><strong>Sort</strong>: A class that defines the sorting criteria, such as the field to sort by and the direction (ascending or descending).</li>
    <li><strong>Repository Methods</strong>: Methods in Spring Data repositories that accept <code>Pageable</code> or <code>Sort</code> parameters to return paginated or sorted results.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Paging and Sorting in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement paging and sorting in a Spring Boot application using Spring Data JPA.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity</h4>
  <p style="color: #2c3e50;">
    Create a JPA entity to represent a database table.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create a Repository</h4>
  <p style="color: #2c3e50;">
    Extend <code>JpaRepository</code> to create a repository for the entity.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.domain.Page;
      import org.springframework.data.domain.Pageable;
      import org.springframework.data.jpa.repository.JpaRepository;

      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          // Paginated query
          Page&lt;User&gt; findAll(Pageable pageable);

          // Paginated and sorted query
          Page&lt;User&gt; findByNameContaining(String name, Pageable pageable);
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Repository in a Service</h4>
  <p style="color: #2c3e50;">
    Use the repository methods in a service to perform paginated and sorted queries.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.data.domain.Page;
      import org.springframework.data.domain.PageRequest;
      import org.springframework.data.domain.Sort;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          @Autowired
          private UserRepository userRepository;

          public Page&lt;User&gt; getAllUsers(int page, int size, String sortBy, String sortDir) {
              Sort sort = Sort.by(Sort.Direction.fromString(sortDir), sortBy);
              PageRequest pageRequest = PageRequest.of(page, size, sort);
              return userRepository.findAll(pageRequest);
          }

          public Page&lt;User&gt; searchUsersByName(String name, int page, int size, String sortBy, String sortDir) {
              Sort sort = Sort.by(Sort.Direction.fromString(sortDir), sortBy);
              PageRequest pageRequest = PageRequest.of(page, size, sort);
              return userRepository.findByNameContaining(name, pageRequest);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Create a Controller</h4>
  <p style="color: #2c3e50;">
    Expose the paginated and sorted data through a REST controller.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.data.domain.Page;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @Autowired
          private UserService userService;

          @GetMapping
          public Page&lt;User&gt; getAllUsers(
                  @RequestParam(defaultValue = "0") int page,
                  @RequestParam(defaultValue = "10") int size,
                  @RequestParam(defaultValue = "name") String sortBy,
                  @RequestParam(defaultValue = "asc") String sortDir) {
              return userService.getAllUsers(page, size, sortBy, sortDir);
          }

          @GetMapping("/search")
          public Page&lt;User&gt; searchUsersByName(
                  @RequestParam String name,
                  @RequestParam(defaultValue = "0") int page,
                  @RequestParam(defaultValue = "10") int size,
                  @RequestParam(defaultValue = "name") String sortBy,
                  @RequestParam(defaultValue = "asc") String sortDir) {
              return userService.searchUsersByName(name, page, size, sortBy, sortDir);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Paging and Sorting</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use sensible default values for page size and sorting criteria to improve usability.</li>
    <li>Limit the maximum page size to prevent performance issues.</li>
    <li>Cache frequently accessed pages to reduce database load.</li>
    <li>Use indexes on sorted fields to improve query performance.</li>
    <li>Provide clear documentation for paginated and sorted endpoints.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Paging and sorting are essential features for handling large datasets in Spring Boot applications. By leveraging Spring Data JPA's built-in support for paging and sorting, you can improve performance, reduce memory usage, and enhance the user experience. Whether you're building RESTful APIs or complex web applications, paging and sorting provide the tools and flexibility needed to work with your data efficiently and effectively. By following best practices, you can ensure that your application is scalable, maintainable, and performant.
  </p>
</div>`

},
{
  title:`JPA Performance Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA Performance Optimization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Optimizing JPA performance is crucial for efficient database interactions and scalable applications.
    Following best practices ensures reduced query execution time, lower memory consumption, and better responsiveness.
  </p>

  <h3 style="color: #16a085;">Key Performance Optimization Techniques:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>FetchType.LAZY</code> for collections to avoid unnecessary data loading.</li>
    <li>Leverage <code>@BatchSize</code> for optimized lazy loading.</li>
    <li>Optimize queries using <code>@Query</code> and native queries.</li>
    <li>Use indexing on frequently searched columns.</li>
    <li>Avoid N+1 query problems with <code>JOIN FETCH</code>.</li>
    <li>Use the second-level cache (<code>@Cacheable</code>) for frequently accessed entities.</li>
    <li>Use projections (<code>DTO Projections</code>) for fetching only required fields.</li>
    <li>Limit query results with <code>setMaxResults()</code> or <code>Pageable</code>.</li>
    <li>Optimize bulk inserts and updates using batch processing.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using FetchType.LAZY to Avoid Overloading</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.persistence.*;
      import java.util.List;

      @Entity
      public class User {
          @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;

          @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
          private List<Order> orders;
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Example: Solving N+1 Problem with JOIN FETCH</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.data.jpa.repository.Query;
      import org.springframework.data.repository.CrudRepository;
      import java.util.List;

      public interface UserRepository extends CrudRepository<User, Long> {
          @Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :userId")
          User findUserWithOrders(Long userId);
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Example: Using DTO Projections for Performance</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      public interface UserDTO {
          String getName();
          int getOrderCount();
      }

      @Query("SELECT new com.example.dto.UserDTO(u.name, COUNT(o)) FROM User u LEFT JOIN u.orders o GROUP BY u.id")
      List<UserDTO> findUserSummary();
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Implementing these optimizations ensures high performance and scalability in JPA-based applications.
  </p>
</div>
`
},
{
  title:`Auditing in JPA (Envers)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Auditing in JPA (Envers)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate Envers is a powerful auditing framework for JPA that allows tracking entity changes over time.
    It enables versioning of entity data and provides a way to retrieve historical records efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use JPA Envers?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Tracks changes to entity records automatically.</li>
    <li>Stores historical data in audit tables.</li>
    <li>Provides a simple way to retrieve previous versions of entities.</li>
    <li>Works seamlessly with Spring Data JPA.</li>
  </ul>

  <h3 style="color: #e67e22;">Adding Envers to a Spring Boot Application</h3>
  <p style="color: #2c3e50;">To enable Envers, add the following dependency in your <code>pom.xml</code>:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
          &lt;artifactId&gt;hibernate-envers&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Configuring an Auditable Entity</h3>
  <p style="color: #2c3e50;">Use the <code>@Audited</code> annotation to enable auditing on an entity:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.hibernate.envers.Audited;
      import javax.persistence.*;

      @Entity
      @Audited
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String department;
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Retrieving Historical Data</h3>
  <p style="color: #2c3e50;">Use the <code>AuditReader</code> to fetch historical entity versions:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.hibernate.envers.AuditReader;
      import org.hibernate.envers.AuditReaderFactory;
      import org.hibernate.Session;
      import javax.persistence.EntityManager;
      import javax.persistence.PersistenceContext;
      import java.util.List;

      public class AuditService {

          @PersistenceContext
          private EntityManager entityManager;

          public List<Employee> getEmployeeRevisions(Long id) {
              AuditReader auditReader = AuditReaderFactory.get(entityManager.unwrap(Session.class));
              return auditReader.createQuery()
                      .forRevisionsOfEntity(Employee.class, false, true)
                      .add(org.hibernate.envers.query.criteria.Restrictions.idEq(id))
                      .getResultList();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Hibernate Envers simplifies auditing in JPA, making it easy to track and retrieve historical data.
    By integrating Envers into your Spring Boot application, you can maintain an audit trail effortlessly.
  </p>
</div>
`
},
{
  title:`JPA Query Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA Query Optimization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Optimizing JPA queries is crucial for enhancing application performance and reducing database load. 
    Poorly optimized queries can lead to performance bottlenecks, excessive memory usage, and slow response times.
  </p>

  <h3 style="color: #16a085;">Key Techniques for JPA Query Optimization:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **pagination** with <code>setMaxResults()</code> and <code>setFirstResult()</code> for large datasets.</li>
    <li>Prefer **JPQL or Criteria API** over native queries for better maintainability.</li>
    <li>Optimize **SELECT queries** by fetching only required columns using **projections**.</li>
    <li>Leverage **@NamedQuery** and **@NamedNativeQuery** for precompiled queries.</li>
    <li>Use **batch fetching** and **JOIN FETCH** to prevent the N+1 problem.</li>
    <li>Enable **second-level cache** using Hibernate caching strategies.</li>
    <li>Index frequently queried columns in the database.</li>
    <li>Use **query hints** for fine-tuning execution plans.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using JOIN FETCH to Prevent N+1 Problem</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Query("SELECT u FROM User u JOIN FETCH u.roles WHERE u.id = :id")
      User findUserWithRoles(@Param("id") Long id);
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Example: Pagination in JPA</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Pageable pageable = PageRequest.of(0, 10, Sort.by("name"));
      Page<User> users = userRepository.findAll(pageable);
    </code>
  </pre>

  <h3 style="color: #2980b9;">Example: Using Query Hints</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @QueryHints({ @QueryHint(name = "org.hibernate.readOnly", value = "true") })
      @Query("SELECT u FROM User u WHERE u.email = :email")
      User findByEmail(@Param("email") String email);
    </code>
  </pre>

  <p style="color: #2c3e50;">
    By implementing these optimization techniques, you can significantly improve JPA query performance, 
    reduce database load, and ensure a smoother user experience.
  </p>
</div>
`
},
{
  title:`JPA Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA Best Practices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Persistence API (JPA) is a powerful framework for managing relational data in Java applications.
    Following best practices ensures efficiency, maintainability, and optimal performance.
  </p>

  <h3 style="color: #16a085;">Key JPA Best Practices:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Entity</code> annotations correctly to map classes to database tables.</li>
    <li>Define a proper <code>@Id</code> with <code>@GeneratedValue</code> for primary keys.</li>
    <li>Use **DTOs (Data Transfer Objects)** to avoid exposing entity classes directly.</li>
    <li>Leverage **lazy loading** for associations to prevent unnecessary data fetching.</li>
    <li>Optimize queries using **JPQL, Criteria API, or native SQL** where needed.</li>
    <li>Use **batch processing** for bulk inserts and updates.</li>
    <li>Apply caching mechanisms like **Hibernate's second-level cache** for better performance.</li>
    <li>Manage transactions effectively with **@Transactional** annotation.</li>
    <li>Use **connection pooling** to optimize database connections.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Proper Entity Mapping</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String name;

          @Column(unique = true, nullable = false)
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Example: Optimized Querying</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.data.jpa.repository.Query;
      import org.springframework.stereotype.Repository;

      @Repository
      public interface UserRepository extends JpaRepository<User, Long> {
          @Query("SELECT u FROM User u WHERE u.email = :email")
          User findByEmail(String email);
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Example: Using Transactions</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class UserService {

          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          @Transactional
          public void registerUser(User user) {
              userRepository.save(user);
              // Additional logic can be added here
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    By following these best practices, you can ensure that your JPA-based applications are efficient, scalable, and maintainable.
  </p>
</div>
`
},
{
title:`Testing JPA with Spring`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Testing JPA with Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Testing is a critical part of developing robust and reliable Spring Boot applications. When working with JPA (Java Persistence API), it is essential to test your data access layer to ensure that your entities, repositories, and queries behave as expected. Spring Boot provides excellent support for testing JPA components, including in-memory databases, test annotations, and utilities to simplify the testing process. This article explores how to effectively test JPA components in a Spring Boot application.
  </p>

  <h3 style="color: #16a085;">Why Test JPA Components?</h3>
  <p style="color: #2c3e50;">
    Testing JPA components is important for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensure Data Integrity</strong>: Verify that your entities and repositories correctly persist and retrieve data.</li>
    <li><strong>Validate Queries</strong>: Ensure that your JPQL or native queries return the expected results.</li>
    <li><strong>Catch Bugs Early</strong>: Identify and fix issues in the data access layer before they reach production.</li>
    <li><strong>Improve Code Quality</strong>: Writing tests encourages better design and maintainability of your code.</li>
    <li><strong>Support Refactoring</strong>: Tests provide a safety net when making changes to your data access logic.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Testing JPA with Spring</h3>
  <p style="color: #2c3e50;">
    When testing JPA components in Spring Boot, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>In-Memory Databases</strong>: Use databases like H2 for fast and isolated testing.</li>
    <li><strong>Test Annotations</strong>: Annotations like <code>@DataJpaTest</code>, <code>@SpringBootTest</code>, and <code>@Transactional</code> simplify testing.</li>
    <li><strong>Test Data Setup</strong>: Use tools like <code>TestEntityManager</code> or SQL scripts to populate test data.</li>
    <li><strong>Assertions</strong>: Use assertions to verify the expected behavior of your JPA components.</li>
    <li><strong>Integration vs. Unit Testing</strong>: Decide whether to test individual components in isolation or as part of a larger system.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Testing JPA Components in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to test JPA components in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity and Repository</h4>
  <p style="color: #2c3e50;">
    Create a JPA entity and a repository to test.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }

      import org.springframework.data.jpa.repository.JpaRepository;

      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          User findByEmail(String email);
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Write a Test Class</h4>
  <p style="color: #2c3e50;">
    Use the <code>@DataJpaTest</code> annotation to test the repository with an in-memory database.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
      import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;

      import static org.assertj.core.api.Assertions.assertThat;

      @DataJpaTest
      public class UserRepositoryTest {

          @Autowired
          private TestEntityManager entityManager;

          @Autowired
          private UserRepository userRepository;

          @Test
          public void testFindByEmail() {
              // Arrange
              User user = new User();
              user.setName("John Doe");
              user.setEmail("john.doe@example.com");
              entityManager.persist(user);
              entityManager.flush();

              // Act
              User found = userRepository.findByEmail(user.getEmail());

              // Assert
              assertThat(found.getEmail()).isEqualTo(user.getEmail());
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Test Query Methods</h4>
  <p style="color: #2c3e50;">
    Test custom query methods in the repository.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Test
      public void testFindByName() {
          // Arrange
          User user = new User();
          user.setName("Jane Doe");
          user.setEmail("jane.doe@example.com");
          entityManager.persist(user);
          entityManager.flush();

          // Act
          User found = userRepository.findByName(user.getName());

          // Assert
          assertThat(found.getName()).isEqualTo(user.getName());
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Test Transactions</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Transactional</code> annotation to test transactional behavior.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.transaction.annotation.Transactional;

      @Test
      @Transactional
      public void testTransactionalBehavior() {
          // Arrange
          User user = new User();
          user.setName("Alice");
          user.setEmail("alice@example.com");
          entityManager.persist(user);
          entityManager.flush();

          // Act
          User found = userRepository.findByEmail(user.getEmail());

          // Assert
          assertThat(found).isNotNull();
          assertThat(found.getEmail()).isEqualTo(user.getEmail());
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Testing JPA with Spring</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use in-memory databases like H2 for fast and isolated testing.</li>
    <li>Leverage <code>@DataJpaTest</code> for repository testing and <code>@SpringBootTest</code> for integration testing.</li>
    <li>Use <code>TestEntityManager</code> to set up test data and verify persistence behavior.</li>
    <li>Test both positive and negative scenarios to ensure robustness.</li>
    <li>Keep tests independent and avoid relying on the state of other tests.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Testing JPA components is a crucial part of building reliable Spring Boot applications. By leveraging Spring Boot's testing support, you can ensure that your entities, repositories, and queries behave as expected. Whether you're writing unit tests for individual components or integration tests for the entire data access layer, following best practices will help you build a robust and maintainable application. Proper testing ensures data integrity, catches bugs early, and provides confidence when refactoring or extending your code.
  </p>
</div>
`},

  {
    title:`Testing JPA with Spring`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Hibernate Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate is an Object-Relational Mapping (ORM) framework for Java applications, simplifying database interactions
    by mapping Java objects to database tables. It provides a powerful abstraction layer over JDBC and allows developers
    to work with databases using Java objects rather than SQL queries.
  </p>

  <h3 style="color: #16a085;">Key Features of Hibernate:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Eliminates boilerplate JDBC code and manages database connections.</li>
    <li>Supports automatic table generation and schema validation.</li>
    <li>Provides a powerful query language known as HQL (Hibernate Query Language).</li>
    <li>Ensures database portability with minimal changes.</li>
    <li>Supports caching mechanisms to improve performance.</li>
    <li>Manages transactions efficiently with ACID compliance.</li>
  </ul>

  <h3 style="color: #e67e22;">Basic Hibernate Architecture</h3>
  <p style="color: #34495e;">Hibernate consists of several core components:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>SessionFactory:</b> Provides factory methods to create Hibernate sessions.</li>
    <li><b>Session:</b> Represents a unit of work and handles database interactions.</li>
    <li><b>Transaction:</b> Manages atomic operations in Hibernate.</li>
    <li><b>Query:</b> Helps execute HQL or SQL queries.</li>
    <li><b>Configuration:</b> Defines database connection properties.</li>
  </ul>

  <h3 style="color: #9b59b6;">Example: Hibernate Entity and Configuration</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Basic Hibernate Configuration (hibernate.cfg.xml)</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;hibernate-configuration&gt;
          &lt;session-factory&gt;
              &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;
              &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/mydb&lt;/property&gt;
              &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;
              &lt;property name="hibernate.connection.password"&gt;password&lt;/property&gt;
              &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
              &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;
          &lt;/session-factory&gt;
      &lt;/hibernate-configuration&gt;
    </code>
  </pre>

  <h3 style="color: #e67e22;">Basic CRUD Operations in Hibernate</h3>
  <p style="color: #34495e;">Below is an example of performing basic CRUD operations using Hibernate:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.Session;
      import org.hibernate.SessionFactory;
      import org.hibernate.Transaction;
      import org.hibernate.cfg.Configuration;

      public class HibernateExample {
          public static void main(String[] args) {
              SessionFactory factory = new Configuration().configure().buildSessionFactory();
              Session session = factory.openSession();
              Transaction tx = session.beginTransaction();

              User user = new User();
              user.setName("John Doe");
              user.setEmail("john@example.com");

              session.save(user);
              tx.commit();
              session.close();
              factory.close();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Hibernate simplifies database interactions by providing an ORM framework that eliminates the need for complex SQL queries.
    By leveraging Hibernate, developers can efficiently manage database operations, ensuring maintainability and performance
    in Java applications.
  </p>
</div>
`
},
{
title:`Hibernate Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Hibernate Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate is an Object-Relational Mapping (ORM) framework for Java applications, simplifying database interactions
    by mapping Java objects to database tables. It provides a powerful abstraction layer over JDBC and allows developers
    to work with databases using Java objects rather than SQL queries.
  </p>

  <h3 style="color: #16a085;">Key Features of Hibernate:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Eliminates boilerplate JDBC code and manages database connections.</li>
    <li>Supports automatic table generation and schema validation.</li>
    <li>Provides a powerful query language known as HQL (Hibernate Query Language).</li>
    <li>Ensures database portability with minimal changes.</li>
    <li>Supports caching mechanisms to improve performance.</li>
    <li>Manages transactions efficiently with ACID compliance.</li>
  </ul>

  <h3 style="color: #e67e22;">Basic Hibernate Architecture</h3>
  <p style="color: #34495e;">Hibernate consists of several core components:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>SessionFactory:</b> Provides factory methods to create Hibernate sessions.</li>
    <li><b>Session:</b> Represents a unit of work and handles database interactions.</li>
    <li><b>Transaction:</b> Manages atomic operations in Hibernate.</li>
    <li><b>Query:</b> Helps execute HQL or SQL queries.</li>
    <li><b>Configuration:</b> Defines database connection properties.</li>
  </ul>

  <h3 style="color: #9b59b6;">Example: Hibernate Entity and Configuration</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Basic Hibernate Configuration (hibernate.cfg.xml)</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;hibernate-configuration&gt;
          &lt;session-factory&gt;
              &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;
              &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/mydb&lt;/property&gt;
              &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;
              &lt;property name="hibernate.connection.password"&gt;password&lt;/property&gt;
              &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
              &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;
          &lt;/session-factory&gt;
      &lt;/hibernate-configuration&gt;
    </code>
  </pre>

  <h3 style="color: #e67e22;">Basic CRUD Operations in Hibernate</h3>
  <p style="color: #34495e;">Below is an example of performing basic CRUD operations using Hibernate:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.Session;
      import org.hibernate.SessionFactory;
      import org.hibernate.Transaction;
      import org.hibernate.cfg.Configuration;

      public class HibernateExample {
          public static void main(String[] args) {
              SessionFactory factory = new Configuration().configure().buildSessionFactory();
              Session session = factory.openSession();
              Transaction tx = session.beginTransaction();

              User user = new User();
              user.setName("John Doe");
              user.setEmail("john@example.com");

              session.save(user);
              tx.commit();
              session.close();
              factory.close();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Hibernate simplifies database interactions by providing an ORM framework that eliminates the need for complex SQL queries.
    By leveraging Hibernate, developers can efficiently manage database operations, ensuring maintainability and performance
    in Java applications.
  </p>
</div>
`
},
{
  title:`Hibernate vs JDBC`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Hibernate vs JDBC</h2>
  <p style="font-size: 16px; color: #34495e;">
    When building Java applications that require interaction with databases, developers often choose between two primary approaches: Hibernate and JDBC. While both methods enable database operations, they differ significantly in terms of ease of use, flexibility, and functionality. This article explores the key differences between Hibernate and JDBC, helping developers understand which option suits their project needs.
  </p>

  <h3 style="color: #16a085;">JDBC (Java Database Connectivity) Overview</h3>
  <p style="font-size: 16px; color: #34495e;">
    JDBC is a low-level API for connecting and interacting with relational databases in Java. It allows developers to execute SQL queries directly against a database using Java code. The JDBC API provides a set of interfaces and classes for working with relational databases, including establishing connections, executing queries, and processing result sets.
  </p>
  
  <h3 style="color: #16a085;">Hibernate Overview</h3>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate, on the other hand, is an Object-Relational Mapping (ORM) framework that abstracts away the complexities of interacting with relational databases. Hibernate maps Java objects to database tables and provides a high-level interface for database operations. It offers an abstraction layer over JDBC, enabling developers to work with objects instead of writing complex SQL queries.
  </p>

  <h3 style="color: #e67e22;">Key Differences Between Hibernate and JDBC</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Level of Abstraction:</b> JDBC is a low-level API that requires developers to write raw SQL queries and handle result sets manually. Hibernate, however, provides a higher level of abstraction by mapping Java objects to database tables, allowing developers to focus on business logic instead of SQL.</li>
    <li><b>SQL Management:</b> With JDBC, developers must write and maintain SQL queries explicitly for CRUD operations. In Hibernate, queries are automatically generated based on object mapping, and developers can use Hibernate Query Language (HQL) or Criteria API to perform database operations.</li>
    <li><b>Code Complexity:</b> JDBC often involves writing repetitive code for establishing connections, executing queries, and processing results. Hibernate reduces this complexity by managing connections, transactions, and SQL generation internally.</li>
    <li><b>Transaction Management:</b> In JDBC, developers need to manually manage transactions, ensuring that operations are executed within a transaction context. Hibernate automatically manages transactions and provides support for declarative transaction handling.</li>
    <li><b>Database Portability:</b> JDBC queries are database-dependent, meaning the same SQL might not work across different database systems. Hibernate abstracts database-specific details and allows applications to be more database-agnostic, making it easier to switch between different databases.</li>
    <li><b>Performance Optimization:</b> Hibernate provides built-in caching mechanisms to optimize performance by reducing database queries. JDBC requires manual optimization techniques such as connection pooling and result set caching.</li>
  </ul>

  <h3 style="color: #9b59b6;">Hibernate vs JDBC - Pros and Cons</h3>
  <h4 style="color: #e67e22;">JDBC Pros:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Offers complete control over database operations, allowing fine-grained optimization.</li>
    <li>Direct access to SQL, making it suitable for complex queries where fine-tuned SQL is necessary.</li>
    <li>Does not require any additional frameworks or libraries, making it a lightweight option.</li>
  </ul>

  <h4 style="color: #e67e22;">JDBC Cons:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Requires writing boilerplate code for database connections, transactions, and SQL management.</li>
    <li>Harder to maintain as the application grows, especially with complex SQL statements.</li>
    <li>Does not provide built-in mechanisms for caching, object-relational mapping, or transaction management.</li>
  </ul>

  <h4 style="color: #e67e22;">Hibernate Pros:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Reduces the need for writing SQL and handling database connections, transactions, and object-relational mapping.</li>
    <li>Provides automatic CRUD operations and advanced features like caching, lazy loading, and batch processing.</li>
    <li>Ensures database portability and supports multiple database systems with minimal changes to the code.</li>
  </ul>

  <h4 style="color: #e67e22;">Hibernate Cons:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Can introduce performance overhead due to additional abstraction layers and automatic operations.</li>
    <li>Requires learning the framework and its conventions, especially for advanced features like HQL and caching.</li>
    <li>In some scenarios, Hibernate’s automatic behavior might not be as efficient as a well-written, hand-crafted SQL query.</li>
  </ul>

  <h3 style="color: #2c3e50;">When to Use JDBC?</h3>
  <p style="color: #34495e;">
    JDBC is suitable for applications that require fine-grained control over SQL queries and database interactions. It is ideal for performance-critical applications or scenarios where the developer needs to execute complex, custom SQL queries. JDBC is also a good choice for simple applications with limited database operations.
  </p>

  <h3 style="color: #2c3e50;">When to Use Hibernate?</h3>
  <p style="color: #34495e;">
    Hibernate is best for applications that require a high level of abstraction, simplified CRUD operations, and database portability. If your application has complex object models or requires automatic persistence management, Hibernate is a more efficient solution. It is also recommended when working with large-scale applications where transaction management, caching, and performance optimization are important.
  </p>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #34495e;">
    Both JDBC and Hibernate have their place in Java development, and the decision between them depends on the specific needs of the project. JDBC provides greater control and efficiency for low-level database interactions, while Hibernate simplifies the development process by handling object-relational mapping and providing powerful abstraction features. Understanding the strengths and limitations of each will help developers choose the right tool for their application.
  </p>
</div>
`
},
{
  title:`Architecture & Workflow`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Hibernate Architecture & Workflow</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate is a powerful Object-Relational Mapping (ORM) framework that abstracts database interactions, allowing developers to work with Java objects instead of raw SQL queries. To better understand how Hibernate operates, it’s crucial to grasp its architecture and the overall workflow involved in managing database operations.
  </p>

  <h3 style="color: #16a085;">Hibernate Architecture Overview</h3>
  <p style="font-size: 16px; color: #34495e;">
    The architecture of Hibernate consists of several core components that collaborate to handle tasks such as object-relational mapping, transaction management, and query execution. Each of these components plays a vital role in simplifying database interactions within Java applications.
  </p>

  <h3 style="color: #e67e22;">Core Components of Hibernate Architecture</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>SessionFactory:</b> The SessionFactory is a central component in Hibernate. It is responsible for creating Session objects and managing the lifecycle of these objects. A SessionFactory is typically configured once per application, as it can be costly to create multiple instances.</li>
    <li><b>Session:</b> A Session represents a single unit of work, and it is used to interact with the database. It is responsible for CRUD operations (Create, Read, Update, Delete) and the query execution. The Session is short-lived and typically tied to a single transaction.</li>
    <li><b>Transaction:</b> Transactions ensure that database operations are atomic and consistent. Hibernate handles transaction management automatically, ensuring ACID (Atomicity, Consistency, Isolation, Durability) compliance for database operations.</li>
    <li><b>Query:</b> Hibernate provides powerful query options, such as Hibernate Query Language (HQL) and the Criteria API, which abstract away the need for complex SQL queries. These queries are executed using the Session object.</li>
    <li><b>Configuration:</b> The Configuration class in Hibernate is responsible for setting up Hibernate’s runtime environment, including database connection properties and mapping of Java classes to database tables.</li>
    <li><b>Mapping:</b> Mapping is the process of associating Java objects with database tables. Hibernate uses annotations or XML files to map class properties to database columns.</li>
  </ul>

  <h3 style="color: #9b59b6;">Hibernate Workflow</h3>
  <p style="color: #34495e;">
    The Hibernate workflow revolves around several key steps, from the initialization of a session to performing CRUD operations and managing transactions. Below is an outline of the basic steps involved in the Hibernate workflow.
  </p>

  <h4 style="color: #e67e22;">Step 1: Configuration</h4>
  <p style="color: #34495e;">
    Before interacting with the database, Hibernate requires configuration to specify how it will connect to the database and manage sessions. This is typically done using the <code>hibernate.cfg.xml</code> configuration file, which contains properties such as database URL, username, password, and Hibernate dialect.
  </p>

  <h4 style="color: #e67e22;">Step 2: SessionFactory Creation</h4>
  <p style="color: #34495e;">
    Once the configuration is set up, the <b>SessionFactory</b> is created. This object is responsible for providing <b>Session</b> instances and is typically created once per application. The SessionFactory is thread-safe and can be shared across the application.
  </p>

  <h4 style="color: #e67e22;">Step 3: Open Session</h4>
  <p style="color: #34495e;">
    To perform database operations, a <b>Session</b> is opened. The Session object is the interface for interacting with the database. Each session represents a single unit of work and is tied to a transaction.
  </p>

  <h4 style="color: #e67e22;">Step 4: Begin Transaction</h4>
  <p style="color: #34495e;">
    Transactions ensure that a group of database operations are executed atomically. In Hibernate, you begin a transaction using the <code>beginTransaction()</code> method on the Session object. If the transaction is committed, all operations are saved to the database; otherwise, the operations are rolled back to maintain data consistency.
  </p>

  <h4 style="color: #e67e22;">Step 5: Perform CRUD Operations</h4>
  <p style="color: #34495e;">
    With the session and transaction in place, you can now perform CRUD operations on your Java objects. Hibernate automatically persists, retrieves, updates, and deletes objects from the database based on the mappings between the Java objects and database tables. These operations are carried out using the <code>save()</code>, <code>load()</code>, <code>update()</code>, and <code>delete()</code> methods on the session.
  </p>

  <h4 style="color: #e67e22;">Step 6: Commit or Rollback</h4>
  <p style="color: #34495e;">
    After performing the required database operations, you must commit the transaction to make the changes permanent. If an error occurs, you can roll back the transaction to undo any changes. This step ensures data consistency and integrity.
  </p>

  <h4 style="color: #
`
},
{
  title:`Configuration`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Hibernate Configuration</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate configuration is a crucial step when setting up Hibernate for Java applications. It defines the environment, the connection to the database, and the mapping between Java classes and database tables. Proper configuration is essential for the smooth operation of Hibernate, ensuring the ORM layer works efficiently and effectively with the database.
  </p>

  <h3 style="color: #16a085;">Types of Hibernate Configuration</h3>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate offers different ways to configure the framework, including XML-based configuration and annotation-based configuration. Both approaches are used to set up the Hibernate environment, but the XML-based configuration is the most common.
  </p>

  <h3 style="color: #e67e22;">1. XML-Based Configuration</h3>
  <p style="color: #34495e;">
    The <b>hibernate.cfg.xml</b> file is the most commonly used configuration file in Hibernate. It contains important configuration details, such as the database connection properties, Hibernate-specific settings, and the mapping of Java classes to database tables.
  </p>

  <h4 style="color: #e67e22;">hibernate.cfg.xml Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;hibernate-configuration&gt;
          &lt;session-factory&gt;
              &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;
              &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/mydb&lt;/property&gt;
              &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;
              &lt;property name="hibernate.connection.password"&gt;password&lt;/property&gt;
              &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
              &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;
              &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt;
              &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;
          &lt;/session-factory&gt;
      &lt;/hibernate-configuration&gt;
    </code>
  </pre>

  <h4 style="color: #34495e;">Explanation of Key Properties:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>hibernate.connection.driver_class:</b> Specifies the JDBC driver class for the database (e.g., MySQL, PostgreSQL).</li>
    <li><b>hibernate.connection.url:</b> The URL to connect to the database.</li>
    <li><b>hibernate.connection.username:</b> The database username.</li>
    <li><b>hibernate.connection.password:</b> The password to access the database.</li>
    <li><b>hibernate.dialect:</b> Defines the database dialect Hibernate should use (e.g., MySQL, PostgreSQL, Oracle).</li>
    <li><b>hibernate.hbm2ddl.auto:</b> Specifies the schema generation strategy. Common values include <code>update</code>, <code>create</code>, or <code>validate</code>.</li>
    <li><b>hibernate.show_sql:</b> If set to <code>true</code>, Hibernate will log SQL statements to the console.</li>
    <li><b>hibernate.format_sql:</b> If set to <code>true</code>, SQL queries will be formatted for better readability.</li>
  </ul>

  <h3 style="color: #9b59b6;">2. Annotation-Based Configuration</h3>
  <p style="color: #34495e;">
    In addition to the XML-based configuration, Hibernate also supports annotation-based configuration, which allows developers to configure the database mappings directly in the Java code using annotations. This eliminates the need for an external configuration file.
  </p>

  <h4 style="color: #e67e22;">Annotation-Based Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(name = "user_name")
          private String name;

          @Column(name = "user_email")
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #34495e;">Explanation of Annotations:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>@Entity:</b> Marks the class as a persistent entity that Hibernate will map to a database table.</li>
    <li><b>@Table:</b> Specifies the database table name associated with the entity.</li>
    <li><b>@Id:</b> Denotes the primary key of the entity.</li>
    <li><b>@GeneratedValue:</b> Defines how the primary key value is generated (e.g., auto-increment).</li>
    <li><b>@Column:</b> Maps the class attributes to the respective database columns.</li>
  </ul>

  <h3 style="color: #e67e22;">3. Programmatic Configuration</h3>
  <p style="color: #34495e;">
    Hibernate can also be configured programmatically, which allows developers to set configuration properties and build the <b>SessionFactory</b> object through Java code. This approach is typically used for more complex configurations or when you need more control over the configuration process.
  </p>

  <h4 style="color: #e67e22;">Programmatic Configuration Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.SessionFactory;
      import org.hibernate.cfg.Configuration;

      public class HibernateUtil {
          private static SessionFactory factory;

          static {
              try {
                  // Create the SessionFactory from hibernate.cfg.xml
                  factory = new Configuration().configure("hibernate.cfg.xml").buildSessionFactory();
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }

          public static SessionFactory getSessionFactory() {
              return factory;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Understanding Configuration Options</h3>
  <p style="color: #34495e;">
    In addition to specifying connection properties and mappings, Hibernate provides several other configuration options that allow fine-tuning of behavior. These options include enabling caching, configuring transaction management, setting batch sizes for SQL operations, and more.
  </p>

  <h4 style="color: #e67e22;">Some Important Hibernate Configuration Properties:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>hibernate.cache.use_second_level_cache:</b> Enables/disables the second-level cache.</li>
    <li><b>hibernate.cache.region.factory_class:</b> Specifies the cache provider to use (e.g., Ehcache, Infinispan).</li>
    <li><b>hibernate.jdbc.batch_size:</b> Defines the batch size for JDBC operations, improving performance during bulk inserts/updates.</li>
    <li><b>hibernate.current_session_context_class:</b> Defines how sessions are managed in a multi-threaded environment (e.g., <code>thread</code>, <code>jta</code>).</li>
    <li><b>hibernate.hbm2ddl.auto:</b> Controls how Hibernate handles schema generation (e.g., <code>update</code>, <code>create</code>, <code>validate</code>).</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Proper Hibernate configuration is crucial for efficient and optimal database interaction in Java applications. By choosing the appropriate configuration method—XML-based, annotation-based, or programmatic—you can tailor Hibernate to fit your project's needs. Understanding configuration properties and how they affect Hibernate’s behavior is key to leveraging its full potential, ensuring that your database interactions are seamless, scalable, and performant.
  </p>
</div>
`
},
{
  title:`SessionFactory & Session`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">SessionFactory & Session</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Hibernate, <b>SessionFactory</b> and <b>Session</b> are two key components used to interact with the database. The <b>SessionFactory</b> is a factory object that creates <b>Session</b> instances, while the <b>Session</b> represents a single unit of work with the database. These components form the backbone of Hibernate’s database interaction process.
  </p>

  <h3 style="color: #16a085;">SessionFactory</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>SessionFactory</b> is a thread-safe object that is responsible for creating <b>Session</b> instances. It is an expensive object to create, and therefore, it should be instantiated once per application. It is usually created during the application startup and used throughout the application’s lifecycle to obtain <b>Session</b> objects.
  </p>

  <h4 style="color: #e67e22;">SessionFactory Initialization</h4>
  <p style="color: #34495e;">
    The <b>SessionFactory</b> is typically created using the <code>Configuration</code> object, which loads configuration properties (e.g., hibernate.cfg.xml) and creates the <b>SessionFactory</b> instance. Once the <b>SessionFactory</b> is created, it can be used to open multiple <b>Session</b> objects.
  </p>

  <h4 style="color: #e67e22;">SessionFactory Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.SessionFactory;
      import org.hibernate.cfg.Configuration;

      public class HibernateUtil {
          private static SessionFactory factory;

          static {
              try {
                  // Create the SessionFactory from hibernate.cfg.xml
                  factory = new Configuration().configure("hibernate.cfg.xml").buildSessionFactory();
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }

          public static SessionFactory getSessionFactory() {
              return factory;
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Session</h3>
  <p style="font-size: 16px; color: #34495e;">
    A <b>Session</b> is a single-threaded unit of work in Hibernate that is used to interact with the database. It is the main interface for database operations like saving, updating, deleting, and querying entities. It acts as a bridge between the application and the Hibernate ORM framework.
  </p>

  <h4 style="color: #e67e22;">Creating a Session</h4>
  <p style="color: #34495e;">
    A <b>Session</b> is created from the <b>SessionFactory</b> using the <code>openSession()</code> method. It is essential to open a session before performing any database operations and close it once the operations are complete.
  </p>

  <h4 style="color: #e67e22;">Session Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.Session;
      import org.hibernate.SessionFactory;
      import org.hibernate.Transaction;

      public class HibernateExample {
          public static void main(String[] args) {
              SessionFactory factory = HibernateUtil.getSessionFactory();
              Session session = factory.openSession();
              Transaction tx = session.beginTransaction();

              User user = new User();
              user.setName("John Doe");
              user.setEmail("john@example.com");

              session.save(user);
              tx.commit();
              session.close();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Session Methods</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>Session</b> interface provides several methods for CRUD operations, transaction management, and querying. Some commonly used methods include:
  </p>

  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>save():</b> Persists an object in the database (insert operation).</li>
    <li><b>update():</b> Updates an existing object in the database.</li>
    <li><b>delete():</b> Deletes an object from the database.</li>
    <li><b>get():</b> Retrieves an object from the database by its identifier.</li>
    <li><b>load():</b> Loads an object from the database based on its identifier (lazy loading).</li>
    <li><b>beginTransaction():</b> Starts a new transaction.</li>
    <li><b>commit():</b> Commits the current transaction.</li>
    <li><b>rollback():</b> Rolls back the current transaction in case of an error.</li>
    <li><b>createQuery():</b> Creates a query to retrieve data from the database using HQL (Hibernate Query Language).</li>
  </ul>

  <h3 style="color: #e67e22;">Session Lifecycle</h3>
  <p style="color: #34495e;">
    A <b>Session</b> follows a specific lifecycle during its usage:
  </p>

  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Open:</b> A session is created by calling <code>openSession()</code> on the <b>SessionFactory</b>.</li>
    <li><b>Transactional:</b> After the session is opened, the developer can start a transaction using <code>beginTransaction()</code> to manage CRUD operations.</li>
    <li><b>Dirty Checking:</b> During the session, Hibernate automatically tracks changes made to the entities (dirty checking) and applies the changes to the database when the transaction is committed.</li>
    <li><b>Closed:</b> After performing the database operations, the session should be closed using <code>session.close()</code>.</li>
  </ul>

  <h3 style="color: #2c3e50;">Session vs SessionFactory</h3>
  <p style="font-size: 16px; color: #34495e;">
    While both the <b>SessionFactory</b> and <b>Session</b> are critical for Hibernate’s database interaction, they serve different purposes:
  </p>

  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>SessionFactory:</b> A <b>SessionFactory</b> is a factory for creating <b>Session</b> instances. It is created once and used throughout the application.</li>
    <li><b>Session:</b> A <b>Session</b> is used to perform CRUD operations on a single object at a time. It is created and destroyed for each unit of work (transaction).</li>
  </ul>

  <h3 style="color: #9b59b6;">Session & SessionFactory in a Real-World Example</h3>
  <p style="color: #34495e;">
    In a real-world scenario, the <b>SessionFactory</b> is initialized when the application starts up and is reused throughout the application’s lifecycle. On the other hand, a <b>Session</b> is created for each transaction or set of related operations, and it is closed when the operations are complete.
  </p>

  <h4 style="color: #e67e22;">Example of Using Session and SessionFactory:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.Session;
      import org.hibernate.SessionFactory;
      import org.hibernate.Transaction;

      public class HibernateExample {
          public static void main(String[] args) {
              SessionFactory factory = HibernateUtil.getSessionFactory();
              Session session = factory.openSession();
              Transaction tx = session.beginTransaction();

              // Example CRUD operation
              User user = new User();
              user.setName("John Doe");
              user.setEmail("john@example.com");

              session.save(user); // Save the user to the database

              tx.commit(); // Commit the transaction
              session.close(); // Close the session
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>SessionFactory</b> and <b>Session</b> are central to Hibernate’s ORM functionality. The <b>SessionFactory</b> is responsible for creating <b>Session</b> instances and is typically initialized once per application, while the <b>Session</b> is used to perform individual CRUD operations within a transaction. Understanding how these components interact is key to effectively using Hibernate in Java applications.
  </p>
</div>
`
},
{
  title:`Entity Lifecycle`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Lifecycle in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot applications using JPA, entities go through a specific lifecycle. Understanding the entity lifecycle helps in managing data efficiently, improving performance, and avoiding common pitfalls.
  </p>

  <h3 style="color: #16a085;">Phases of Entity Lifecycle:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>New (Transient) State:</strong> The entity is created but not yet associated with the persistence context.</li>
    <li><strong>Managed (Persistent) State:</strong> The entity is associated with the persistence context and synchronized with the database.</li>
    <li><strong>Detached State:</strong> The entity is no longer associated with the persistence context but still exists in memory.</li>
    <li><strong>Removed State:</strong> The entity is marked for deletion and will be removed from the database.</li>
  </ul>

  <h3 style="color: #e67e22;">Key JPA Annotations Affecting Lifecycle</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@PostLoad</code> - Invoked after an entity is loaded from the database.</li>
    <li><code>@PrePersist</code> - Called before an entity is inserted into the database.</li>
    <li><code>@PostPersist</code> - Called after an entity has been inserted.</li>
    <li><code>@PreUpdate</code> - Called before an entity is updated.</li>
    <li><code>@PostUpdate</code> - Called after an entity is updated.</li>
    <li><code>@PreRemove</code> - Called before an entity is removed.</li>
    <li><code>@PostRemove</code> - Called after an entity has been removed.</li>
  </ul>

  <h3 style="color: #9b59b6;">Example: Entity Lifecycle Callbacks</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private LocalDateTime createdAt;
    
    @PrePersist
    public void prePersist() {
        this.createdAt = LocalDateTime.now();
        System.out.println("PrePersist: Setting createdAt timestamp.");
    }
    
    @PostLoad
    public void postLoad() {
        System.out.println("PostLoad: Entity has been loaded.");
    }
    
    @PreUpdate
    public void preUpdate() {
        System.out.println("PreUpdate: Entity is about to be updated.");
    }
    
    @PreRemove
    public void preRemove() {
        System.out.println("PreRemove: Entity is about to be removed.");
    }
}
    </code>
  </pre>

  <h3 style="color: #c0392b;">Best Practices for Managing Entity Lifecycle</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Avoid business logic inside entity lifecycle methods.</li>
    <li>Use <code>@Transactional</code> annotations correctly to manage entity state transitions.</li>
    <li>Detach entities when working with DTOs to prevent unwanted updates.</li>
    <li>Be mindful of performance impacts when using lifecycle callbacks.</li>
  </ul>

  <p style="color: #2c3e50;">
    Understanding and managing the entity lifecycle in Spring Boot improves data integrity and enhances application performance. Proper use of JPA lifecycle events ensures efficient database operations.
  </p>
</div>

`
},

{
  title:`Annotations`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Annotations in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Annotations in Spring Boot play a crucial role in simplifying configuration and enabling various features. They help developers write clean and maintainable code by reducing boilerplate and providing metadata for the Spring framework to process.
  </p>

  <h3 style="color: #16a085;">Common Spring Boot Annotations</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@SpringBootApplication</code> - Marks the main class of a Spring Boot application.</li>
    <li><code>@Component</code> - Denotes a generic Spring-managed component.</li>
    <li><code>@Service</code> - Specialization of <code>@Component</code> for business logic services.</li>
    <li><code>@Repository</code> - Specialization of <code>@Component</code> for data access layers.</li>
    <li><code>@Controller</code> - Marks a class as a web controller in Spring MVC.</li>
    <li><code>@RestController</code> - Combines <code>@Controller</code> and <code>@ResponseBody</code> to return JSON responses.</li>
  </ul>

  <h3 style="color: #e67e22;">Dependency Injection Annotations</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@Autowired</code> - Automatically injects dependencies.</li>
    <li><code>@Qualifier</code> - Specifies the exact bean to inject when multiple beans exist.</li>
    <li><code>@Primary</code> - Indicates the primary bean to use when multiple candidates exist.</li>
  </ul>

  <h3 style="color: #9b59b6;">Spring Boot Configuration Annotations</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@Configuration</code> - Indicates a class with bean definitions.</li>
    <li><code>@Bean</code> - Declares a bean explicitly in a configuration class.</li>
    <li><code>@Value</code> - Injects values from application properties.</li>
    <li><code>@PropertySource</code> - Loads properties from an external file.</li>
  </ul>

  <h3 style="color: #c0392b;">Spring Boot MVC and Request Handling Annotations</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@RequestMapping</code> - Maps HTTP requests to handler methods.</li>
    <li><code>@GetMapping</code> - Maps HTTP GET requests.</li>
    <li><code>@PostMapping</code> - Maps HTTP POST requests.</li>
    <li><code>@PutMapping</code> - Maps HTTP PUT requests.</li>
    <li><code>@DeleteMapping</code> - Maps HTTP DELETE requests.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Annotations in a Spring Boot Application</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
import org.springframework.web.bind.annotation.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.Service;

@RestController
@RequestMapping("/api")
public class ExampleController {
    private final ExampleService exampleService;
    
    @Autowired
    public ExampleController(ExampleService exampleService) {
        this.exampleService = exampleService;
    }
    
    @GetMapping("/message")
    public String getMessage() {
        return exampleService.getMessage();
    }
}

@Service
class ExampleService {
    public String getMessage() {
        return "Hello from Spring Boot!";
    }
}
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Understanding and using annotations effectively can streamline development in Spring Boot, making applications more manageable and reducing configuration overhead.
  </p>
</div>


`
},
{
  title:`Primary Key Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Primary Key Strategies in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    A primary key uniquely identifies each record in a database table. In JPA and Hibernate, different strategies are available to generate primary keys efficiently.
    Choosing the right strategy ensures optimal database performance and scalability.
  </p>

  <h3 style="color: #16a085;">Available Primary Key Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>GenerationType.IDENTITY</code> – Uses auto-increment columns.</li>
    <li><code>GenerationType.SEQUENCE</code> – Uses database sequences for key generation.</li>
    <li><code>GenerationType.TABLE</code> – Uses a table-based key generation strategy.</li>
    <li><code>GenerationType.AUTO</code> – Uses a default strategy based on the database dialect.</li>
  </ul>

  <h3 style="color: #e67e22;">1. Using <code>GenerationType.IDENTITY</code></h3>
  <p style="color: #34495e;">
    This strategy relies on the database's auto-increment feature. The database automatically generates the ID when a new record is inserted.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    Pros: Simple and database-driven.  
    Cons: Not suitable for batch inserts due to potential performance issues.
  </p>

  <h3 style="color: #e67e22;">2. Using <code>GenerationType.SEQUENCE</code></h3>
  <p style="color: #34495e;">
    This strategy uses a database sequence to generate primary keys, improving performance over IDENTITY.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @SequenceGenerator(name = "user_seq", sequenceName = "user_sequence", allocationSize = 1)
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
          private Long id;
          private String name;
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    Pros: Better performance than IDENTITY, supports batch inserts.  
    Cons: Requires database sequence support.
  </p>

  <h3 style="color: #e67e22;">3. Using <code>GenerationType.TABLE</code></h3>
  <p style="color: #34495e;">
    This strategy stores primary keys in a separate table. It is less common due to performance concerns.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @TableGenerator(name = "user_table_gen", table = "id_generator", pkColumnName = "gen_name",
                      valueColum
`
},
{
  title:`Entity Mapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Entity Mapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity mapping is a fundamental concept in JPA (Java Persistence API) that defines how Java objects (entities) are mapped to database tables and how relationships between entities are represented. In Spring Boot, entity mapping is achieved using JPA annotations, which simplify the process of defining the structure of your database schema and the relationships between entities. Proper entity mapping ensures that your application can efficiently store, retrieve, and manage data in a relational database.
  </p>

  <h3 style="color: #16a085;">Why is Entity Mapping Important?</h3>
  <p style="color: #2c3e50;">
    Entity mapping is crucial for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Database Schema Definition</strong>: Maps Java classes to database tables and fields to columns.</li>
    <li><strong>Object-Relational Mapping (ORM)</strong>: Bridges the gap between object-oriented programming and relational databases.</li>
    <li><strong>Relationship Management</strong>: Defines relationships like one-to-one, one-to-many, and many-to-many between entities.</li>
    <li><strong>Data Integrity</strong>: Ensures that data is stored and retrieved consistently and accurately.</li>
    <li><strong>Simplified Development</strong>: Reduces the need for manual SQL queries and boilerplate code.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Entity Mapping</h3>
  <p style="color: #2c3e50;">
    When working with entity mapping in Spring Boot, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Entities</strong>: Java classes annotated with <code>@Entity</code> that represent database tables.</li>
    <li><strong>Primary Keys</strong>: Fields annotated with <code>@Id</code> that uniquely identify an entity.</li>
    <li><strong>Column Mapping</strong>: Annotations like <code>@Column</code> to map fields to database columns.</li>
    <li><strong>Relationships</strong>: Annotations like <code>@OneToOne</code>, <code>@OneToMany</code>, and <code>@ManyToMany</code> to define relationships between entities.</li>
    <li><strong>Inheritance</strong>: Strategies like <code>SINGLE_TABLE</code>, <code>JOINED</code>, and <code>TABLE_PER_CLASS</code> to map inheritance hierarchies.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Entity Mapping in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to define and map entities in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define a Simple Entity</h4>
  <p style="color: #2c3e50;">
    Create a basic entity with a primary key and fields mapped to database columns.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;
      import jakarta.persistence.Column;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String name;

          @Column(unique = true, nullable = false)
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Define Relationships Between Entities</h4>
  <p style="color: #2c3e50;">
    Create entities with relationships like one-to-many and many-to-many.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;
      import java.util.List;

      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String name;

          @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
          private List&lt;Employee&gt; employees;

          // Getters and Setters
      }

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id", nullable = false)
          private Department department;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Define a Many-to-Many Relationship</h4>
  <p style="color: #2c3e50;">
    Create entities with a many-to-many relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;
      import java.util.Set;

      @Entity
      public class Student {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String name;

          @ManyToMany
          @JoinTable(
              name = "student_course",
              joinColumns = @JoinColumn(name = "student_id"),
              inverseJoinColumns = @JoinColumn(name = "course_id"))
          private Set&lt;Course&gt; courses;

          // Getters and Setters
      }

      @Entity
      public class Course {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String title;

          @ManyToMany(mappedBy = "courses")
          private Set&lt;Student&gt; students;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Inheritance Mapping</h4>
  <p style="color: #2c3e50;">
    Use inheritance mapping strategies to represent class hierarchies in the database.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
      @DiscriminatorColumn(name = "type", discriminatorType = DiscriminatorType.STRING)
      public abstract class Vehicle {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String manufacturer;

          // Getters and Setters
      }

      @Entity
      @DiscriminatorValue("CAR")
      public class Car extends Vehicle {
          private int numberOfDoors;

          // Getters and Setters
      }

      @Entity
      @DiscriminatorValue("BIKE")
      public class Bike extends Vehicle {
          private int numberOfGears;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Entity Mapping</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful names for entities, fields, and database columns.</li>
    <li>Leverage lazy loading (<code>FetchType.LAZY</code>) for relationships to improve performance.</li>
    <li>Use cascade operations (<code>CascadeType</code>) to manage entity lifecycles.</li>
    <li>Validate entity mappings using tools like Hibernate's schema validation.</li>
    <li>Keep relationships bidirectional when necessary to simplify navigation.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity mapping is a core aspect of building data-driven Spring Boot applications. By leveraging JPA annotations, you can define how your Java objects map to database tables and how relationships between entities are represented. Whether you're working with simple entities, complex relationships, or inheritance hierarchies, proper entity mapping ensures that your application can efficiently store, retrieve, and manage data. By following best practices, you can create a clean, maintainable, and performant data access layer.
  </p>
</div>`
},
{
  title:`HQL & Criteria API`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">HQL & Criteria API in Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate provides two powerful ways to query databases: 
    <strong>Hibernate Query Language (HQL)</strong> and the <strong>Criteria API</strong>. 
    These approaches allow developers to retrieve data efficiently while keeping the application database-independent.
  </p>

  <h3 style="color: #16a085;">What is HQL (Hibernate Query Language)?</h3>
  <p style="color: #34495e;">
    HQL is an object-oriented query language similar to SQL but designed for Hibernate. 
    Unlike SQL, HQL works with entity objects instead of database tables.
  </p>

  <h4 style="color: #e67e22;">Basic HQL Query</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String hql = "FROM User WHERE name = :name";
      Query query = session.createQuery(hql);
      query.setParameter("name", "John");
      List<User> users = query.list();
    </code>
  </pre>

  <h4 style="color: #e67e22;">HQL Query with Sorting</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String hql = "FROM User ORDER BY name ASC";
      List<User> users = session.createQuery(hql).list();
    </code>
  </pre>

  <h4 style="color: #e67e22;">HQL Query with Joins</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String hql = "SELECT u FROM User u INNER JOIN u.orders o WHERE o.total > :amount";
      Query query = session.createQuery(hql);
      query.setParameter("amount", 1000);
      List<User> users = query.list();
    </code>
  </pre>

  <h3 style="color: #16a085;">What is the Criteria API?</h3>
  <p style="color: #34495e;">
    The Criteria API provides a type-safe, programmatic way to create queries in Hibernate.
    It is useful when dealing with dynamic queries or complex filtering conditions.
  </p>

  <h4 style="color: #e67e22;">Basic Criteria Query</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      CriteriaBuilder cb = session.getCriteriaBuilder();
      CriteriaQuery<User> cq = cb.createQuery(User.class);
      Root<User> root = cq.from(User.class);
      cq.select(root);

      Query<User> query = session.createQuery(cq);
      List<User> users = query.getResultList();
    </code>
  </pre>

  <h4 style="color: #e67e22;">Criteria Query with Filters</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      CriteriaBuilder cb = session.getCriteriaBuilder();
      CriteriaQuery<User> cq = cb.createQuery(User.class);
      Root<User> root = cq.from(User.class);
      cq.select(root).where(cb.equal(root.get("name"), "John"));

      Query<User> query = session.createQuery(cq);
      List<User> users = query.getResultList();
    </code>
  </pre>

  <h4 style="color: #e67e22;">Criteria Query with Sorting</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      CriteriaBuilder cb = session.getCriteriaBuilder();
      CriteriaQuery<User> cq = cb.createQuery(User.class);
      Root<User> root = cq.from(User.class);
      cq.orderBy(cb.asc(root.get("name")));

      Query<User> query = session.createQuery(cq);
      List<User> users = query.getResultList();
    </code>
  </pre>

  <h3 style="color: #9b59b6;">When to Use HQL vs. Criteria API?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use HQL</strong> when writing static queries, especially with joins and aggregations.</li>
    <li><strong>Use Criteria API</strong> when queries are dynamic and require filtering, sorting, or pagination.</li>
  </ul>

  <p style="color: #2c3e50;">
    Both HQL and Criteria API provide powerful ways to query data in Hibernate, each suited for different use cases.
    Understanding these approaches helps in writing efficient and maintainable code.
  </p>
</div>
`
},
{
  title:`Native SQL Queries`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Native SQL Queries in Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate provides different ways to query the database, including HQL and the Criteria API. 
    However, sometimes we need to use raw SQL queries directly. 
    This is where <strong>Native SQL Queries</strong> come in. 
    They allow us to execute plain SQL queries while still leveraging Hibernate’s powerful features.
  </p>

  <h3 style="color: #16a085;">What are Native SQL Queries?</h3>
  <p style="color: #34495e;">
    Native SQL queries allow developers to execute raw SQL statements directly on the database. 
    Unlike HQL, which operates on entity objects, native queries work at the table level.
  </p>

  <h3 style="color: #16a085;">Executing a Simple Native Query</h3>
  <p style="color: #34495e;">
    The <code>createNativeQuery()</code> method in Hibernate can be used to execute SQL queries.
  </p>
  
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String sql = "SELECT * FROM users";
      Query query = session.createNativeQuery(sql, User.class);
      List<User> users = query.getResultList();
    </code>
  </pre>

  <h3 style="color: #16a085;">Using Parameters in Native Queries</h3>
  <p style="color: #34495e;">
    To avoid SQL injection and improve performance, parameters can be used in native queries.
  </p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String sql = "SELECT * FROM users WHERE name = :name";
      Query query = session.createNativeQuery(sql, User.class);
      query.setParameter("name", "John");
      List<User> users = query.getResultList();
    </code>
  </pre>

  <h3 style="color: #16a085;">Executing Insert, Update, and Delete Queries</h3>
  <p style="color: #34495e;">
    Native queries can also be used for modifying data.
  </p>

  <h4 style="color: #e67e22;">Insert Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String sql = "INSERT INTO users (id, name, email) VALUES (:id, :name, :email)";
      Query query = session.createNativeQuery(sql);
      query.setParameter("id", 101);
      query.setParameter("name", "Alice");
      query.setParameter("email", "alice@example.com");
      query.executeUpdate();
    </code>
  </pre>

  <h4 style="color: #e67e22;">Update Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String sql = "UPDATE users SET email = :email WHERE id = :id";
      Query query = session.createNativeQuery(sql);
      query.setParameter("email", "newemail@example.com");
      query.setParameter("id", 101);
      query.executeUpdate();
    </code>
  </pre>

  <h4 style="color: #e67e22;">Delete Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String sql = "DELETE FROM users WHERE id = :id";
      Query query = session.createNativeQuery(sql);
      query.setParameter("id", 101);
      query.executeUpdate();
    </code>
  </pre>

  <h3 style="color: #16a085;">Mapping Native Queries to Entities</h3>
  <p style="color: #34495e;">
    When executing native queries, we can map the result to an entity class using <code>addEntity()</code>.
  </p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String sql = "SELECT * FROM users";
      Query query = session.createNativeQuery(sql).addEntity(User.class);
      List<User> users = query.getResultList();
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Advantages of Native SQL Queries</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Performance:</strong> Can leverage database-specific optimizations.</li>
    <li><strong>Flexibility:</strong> Allows execution of complex queries that may not be possible with HQL or Criteria API.</li>
    <li><strong>Direct Database Access:</strong> Enables operations like stored procedure calls.</li>
  </ul>

  <h3 style="color: #9b59b6;">Disadvantages of Native SQL Queries</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Database Dependency:</strong> Queries may not be portable across different databases.</li>
    <li><strong>Harder to Maintain:</strong> Changing the database structure may require rewriting queries.</li>
    <li><strong>Manual Result Mapping:</strong> If not mapped properly, retrieving results can be tedious.</li>
  </ul>

  <p style="color: #2c3e50;">
    While native queries provide great flexibility and performance benefits, they should be used only when necessary. 
    For most use cases, HQL or Criteria API is preferred for better portability and maintainability.
  </p>
</div>
`
},
{
  title:`Named Queries`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Named Queries in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Named Queries are predefined, reusable queries that are defined at the entity level using annotations or XML configuration. 
    They provide better readability, performance, and maintainability in JPA and Hibernate.
  </p>

  <h3 style="color: #16a085;">What are Named Queries?</h3>
  <p style="color: #34495e;">
    Named Queries allow developers to define queries once and reuse them multiple times. 
    They are compiled and validated at application startup, reducing runtime query parsing overhead.
  </p>

  <h3 style="color: #16a085;">Defining a Named Query</h3>
  <p style="color: #34495e;">
    Named Queries can be defined using the <code>@NamedQuery</code> annotation in JPA or via XML configuration.
  </p>

  <h4 style="color: #e67e22;">Using @NamedQuery Annotation</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @NamedQuery(
          name = "User.findByEmail",
          query = "SELECT u FROM User u WHERE u.email = :email"
      )
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Using @NamedQueries for Multiple Queries</h4>
  <p style="color: #34495e;">
    When defining multiple named queries, use the <code>@NamedQueries</code> annotation.
  </p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @NamedQueries({
          @NamedQuery(name = "User.findByEmail", query = "SELECT u FROM User u WHERE u.email = :email"),
          @NamedQuery(name = "User.findAll", query = "SELECT u FROM User u")
      })
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Executing Named Queries</h3>
  <p style="color: #34495e;">
    Once a Named Query is defined, it can be executed using the <code>EntityManager</code> or <code>Session</code> in Hibernate.
  </p>

  <h4 style="color: #e67e22;">Executing a Named Query in JPA</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      EntityManager em = entityManagerFactory.createEntityManager();
      Query query = em.createNamedQuery("User.findByEmail");
      query.setParameter("email", "john@example.com");
      User user = (User) query.getSingleResult();
    </code>
  </pre>

  <h4 style="color: #e67e22;">Executing a Named Query in Hibernate</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Session session = sessionFactory.openSession();
      Query query = session.getNamedQuery("User.findByEmail");
      query.setParameter("email", "john@example.com");
      User user = (User) query.uniqueResult();
    </code>
  </pre>

  <h3 style="color: #16a085;">Defining Named Native Queries</h3>
  <p style="color: #34495e;">
    Named Queries can also be defined using native SQL by using the <code>@NamedNativeQuery</code> annotation.
  </p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @NamedNativeQuery(
          name = "User.findByEmailNative",
          query = "SELECT * FROM users WHERE email = :email",
          resultClass = User.class
      )
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Advantages of Named Queries</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reusability:</strong> Queries can be defined once and used multiple times.</li>
    <li><strong>Performance:</strong> Queries are parsed and validated at application startup, reducing runtime overhead.</li>
    <li><strong>Readability:</strong> Code is cleaner and easier to maintain.</li>
    <li><strong>Security:</strong> Helps prevent SQL injection when used with parameters.</li>
  </ul>

  <h3 style="color: #9b59b6;">Disadvantages of Named Queries</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Less Dynamic:</strong> Named Queries cannot be modified at runtime.</li>
    <li><strong>Potentially Unused Queries:</strong> If defined but never used, they can add unnecessary overhead.</li>
    <li><strong>Harder Debugging:</strong> Debugging errors in Named Queries can be more challenging than inline queries.</li>
  </ul>

  <p style="color: #2c3e50;">
    Named Queries are a powerful feature in JPA and Hibernate that improve performance and maintainability. 
    While they may not be as flexible as dynamic queries, they provide significant advantages in structured query management.
  </p>
</div>
`
},
{
  title:`Pagination`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Pagination in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Pagination is an essential feature when dealing with large datasets in applications. Instead of retrieving all records at once, 
    pagination allows fetching data in smaller chunks, improving performance and user experience.
  </p>

  <h3 style="color: #16a085;">Why Use Pagination?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Performance Optimization:</strong> Reduces the amount of data fetched at a time, improving response time.</li>
    <li><strong>Efficient Database Queries:</strong> Limits the number of rows retrieved from the database.</li>
    <li><strong>Better User Experience:</strong> Allows users to navigate through large datasets smoothly.</li>
  </ul>

  <h3 style="color: #16a085;">Pagination with JPA Query</h3>
  <p style="color: #34495e;">
    JPA provides the <code>setFirstResult()</code> and <code>setMaxResults()</code> methods to implement pagination.
  </p>

  <h4 style="color: #e67e22;">Example: Paginating with JPA Query</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public List<User> getUsersWithPagination(EntityManager entityManager, int pageNumber, int pageSize) {
          Query query = entityManager.createQuery("SELECT u FROM User u");
          query.setFirstResult((pageNumber - 1) * pageSize);
          query.setMaxResults(pageSize);
          return query.getResultList();
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Pagination with Hibernate Query</h3>
  <p style="color: #34495e;">
    In Hibernate, pagination can be done using <code>setFirstResult()</code> and <code>setMaxResults()</code> on a <code>Query</code> object.
  </p>

  <h4 style="color: #e67e22;">Example: Paginating with Hibernate Query</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public List<User> getUsersWithPagination(Session session, int pageNumber, int pageSize) {
          Query query = session.createQuery("FROM User");
          query.setFirstResult((pageNumber - 1) * pageSize);
          query.setMaxResults(pageSize);
          return query.list();
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Pagination with Spring Data JPA</h3>
  <p style="color: #34495e;">
    Spring Data JPA provides a built-in <code>Pageable</code> interface to handle pagination efficiently.
  </p>

  <h4 style="color: #e67e22;">Example: Paginating with Spring Data JPA</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Repository
      public interface UserRepository extends JpaRepository<User, Long> {
          Page<User> findAll(Pageable pageable);
      }

      public Page<User> getUsersWithPagination(UserRepository userRepository, int pageNumber, int pageSize) {
          Pageable pageable = PageRequest.of(pageNumber, pageSize);
          return userRepository.findAll(pageable);
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Advantages of Pagination</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Optimized Performance:</strong> Reduces the number of records fetched at a time.</li>
    <li><strong>Reduced Memory Usage:</strong> Loads only the required data, preventing memory overflow.</li>
    <li><strong>Scalability:</strong> Allows handling large datasets efficiently.</li>
  </ul>

  <h3 style="color: #9b59b6;">Best Practices for Pagination</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>indexed columns</strong> for better query performance.</li>
    <li>Avoid using <strong>OFFSET with large values</strong> as it can slow down query execution.</li>
    <li>Prefer <strong>Spring Data JPA</strong> for built-in pagination support.</li>
    <li>Use <strong>Keyset Pagination</strong> for improved efficiency with large datasets.</li>
  </ul>

  <p style="color: #2c3e50;">
    Pagination is a crucial technique for managing large datasets in applications. 
    Whether using JPA, Hibernate, or Spring Data JPA, implementing efficient pagination improves performance and user experience.
  </p>
</div>
`
},
{
  title:`Caching`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Caching in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching is a performance optimization technique that helps reduce database access by storing frequently used data in memory. 
    JPA and Hibernate provide different caching levels to speed up data retrieval.
  </p>

  <h3 style="color: #16a085;">Why Use Caching?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduces Database Load:</strong> Minimizes database queries for frequently accessed data.</li>
    <li><strong>Improves Performance:</strong> Speeds up application response time.</li>
    <li><strong>Optimizes Resource Usage:</strong> Reduces network and database overhead.</li>
  </ul>

  <h3 style="color: #16a085;">Types of Caching in Hibernate</h3>
  <p style="color: #34495e;">
    Hibernate supports different levels of caching to store and reuse data efficiently.
  </p>

  <h4 style="color: #e67e22;">1. First-Level Cache (L1 Cache)</h4>
  <p style="color: #34495e;">
    The first-level cache is associated with the Hibernate <code>Session</code>. It is enabled by default and stores entities in memory 
    for the duration of a session.
  </p>

  <h4 style="color: #e67e22;">Example: First-Level Cache</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Session session = sessionFactory.openSession();
      
      // First query - fetched from the database
      User user1 = session.get(User.class, 1);
      
      // Second query - fetched from the cache (no DB hit)
      User user2 = session.get(User.class, 1);

      session.close();
    </code>
  </pre>

  <h4 style="color: #e67e22;">2. Second-Level Cache (L2 Cache)</h4>
  <p style="color: #34495e;">
    The second-level cache is shared across multiple sessions and requires explicit configuration. 
    Hibernate supports various providers like EhCache, Hazelcast, and Infinispan.
  </p>

  <h4 style="color: #e67e22;">Example: Enabling Second-Level Cache with EhCache</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @Cacheable
      @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">3. Query Cache</h4>
  <p style="color: #34495e;">
    The query cache stores the results of frequently executed queries. It works with the second-level cache.
  </p>

  <h4 style="color: #e67e22;">Example: Enabling Query Cache</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Query query = session.createQuery("FROM User");
      query.setCacheable(true);
      List<User> users = query.list();
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Advantages of Caching</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduces Database Calls:</strong> Improves efficiency by fetching data from cache instead of querying the database.</li>
    <li><strong>Speeds Up Application:</strong> Improves response time by storing frequently used data in memory.</li>
    <li><strong>Enhances Scalability:</strong> Reduces database load, allowing more users to access the system without performance issues.</li>
  </ul>

  <h3 style="color: #9b59b6;">Best Practices for Caching</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>First-Level Cache</strong> whenever possible since it’s built-in and automatic.</li>
    <li>Enable <strong>Second-Level Cache</strong> for entities that are frequently accessed.</li>
    <li>Use <strong>Query Cache</strong> cautiously to avoid stale data issues.</li>
    <li>Choose the right cache provider (<strong>EhCache, Hazelcast, Infinispan</strong>) based on your needs.</li>
    <li>Set <strong>cache expiration policies</strong> to prevent outdated data from being served.</li>
  </ul>

  <p style="color: #2c3e50;">
    Caching is a powerful technique to enhance performance in JPA and Hibernate applications. 
    By using first-level cache, second-level cache, and query cache effectively, developers can significantly optimize database interactions.
  </p>
</div>
`
},
{
  title:`Lazy vs Eager Loading`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Lazy vs. Eager Loading in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    In JPA and Hibernate, loading strategies determine how related entities are fetched from the database. 
    The two main loading types are <strong>Lazy Loading</strong> and <strong>Eager Loading</strong>.
  </p>

  <h3 style="color: #16a085;">What is Lazy Loading?</h3>
  <p style="color: #34495e;">
    Lazy Loading means that related entities are not fetched from the database until they are explicitly accessed. 
    It improves performance by avoiding unnecessary data retrieval.
  </p>

  <h4 style="color: #e67e22;">Example: Lazy Loading</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Author {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;

          @OneToMany(mappedBy = "author", fetch = FetchType.LAZY)
          private List<Book> books;
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    In this example, the <code>books</code> collection is fetched only when accessed, avoiding unnecessary queries.
  </p>

  <h3 style="color: #16a085;">What is Eager Loading?</h3>
  <p style="color: #34495e;">
    Eager Loading means that related entities are fetched immediately along with the main entity. 
    It ensures that all required data is available upfront but may lead to performance issues due to large data retrieval.
  </p>

  <h4 style="color: #e67e22;">Example: Eager Loading</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Author {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;

          @OneToMany(mappedBy = "author", fetch = FetchType.EAGER)
          private List<Book> books;
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    Here, the <code>books</code> collection is loaded immediately when the <code>Author</code> entity is fetched.
  </p>

  <h3 style="color: #9b59b6;">Key Differences: Lazy vs. Eager Loading</h3>
  <table style="width:100%; border-collapse: collapse; margin-top: 10px;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px; text-align: left;">Aspect</th>
      <th style="padding: 10px; text-align: left;">Lazy Loading</th>
      <th style="padding: 10px; text-align: left;">Eager Loading</th>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">When are related entities loaded?</td>
      <td style="padding: 10px;">When accessed</td>
      <td style="padding: 10px;">Immediately</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">Database Load</td>
      <td style="padding: 10px;">Lower (only loads when needed)</td>
      <td style="padding: 10px;">Higher (loads everything upfront)</td>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">Performance</td>
      <td style="padding: 10px;">Better for large datasets</td>
      <td style="padding: 10px;">Might slow down queries</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">Risk of Exception</td>
      <td style="padding: 10px;">Yes (LazyInitializationException if accessed outside session)</td>
      <td style="padding: 10px;">No</td>
    </tr>
  </table>

  <h3 style="color: #9b59b6;">Best Practices for Using Lazy and Eager Loading</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>Lazy Loading</strong> when dealing with large datasets to improve performance.</li>
    <li>Use <strong>Eager Loading</strong> when related data is always required.</li>
    <li>Be cautious of <strong>LazyInitializationException</strong> when using Lazy Loading.</li>
    <li>Use <code>JOIN FETCH</code> in queries to optimize Lazy Loading when needed.</li>
  </ul>

  <h4 style="color: #e67e22;">Example: Using JOIN FETCH</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Query query = session.createQuery("SELECT a FROM Author a JOIN FETCH a.books WHERE a.id = :id");
      query.setParameter("id", 1);
      Author author = (Author) query.getSingleResult();
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Choosing between Lazy and Eager Loading depends on your application's needs. 
    Use Lazy Loading for performance and Eager Loading when necessary to prevent extra queries.
  </p>
</div>`
},
{
  title:`Transaction Management`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Management in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction management is a crucial aspect of database operations to ensure data consistency and integrity. 
    JPA and Hibernate provide built-in mechanisms for handling transactions effectively.
  </p>

  <h3 style="color: #16a085;">What is a Transaction?</h3>
  <p style="color: #34495e;">
    A transaction is a sequence of operations performed as a single unit of work. 
    It follows the <strong>ACID (Atomicity, Consistency, Isolation, Durability)</strong> properties to maintain data integrity.
  </p>

  <h3 style="color: #9b59b6;">Managing Transactions in JPA</h3>
  <p style="color: #34495e;">
    JPA uses the <code>EntityTransaction</code> API or declarative transaction management with Spring for handling transactions.
  </p>

  <h4 style="color: #e67e22;">Example: Manual Transaction Management</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      EntityManagerFactory emf = Persistence.createEntityManagerFactory("example-unit");
      EntityManager em = emf.createEntityManager();
      
      em.getTransaction().begin();
      
      Employee emp = new Employee();
      emp.setName("John Doe");
      em.persist(emp);
      
      em.getTransaction().commit();
      em.close();
    </code>
  </pre>

  <p style="color: #34495e;">
    Here, we manually begin and commit the transaction using <code>EntityTransaction</code>.
  </p>

  <h3 style="color: #16a085;">Transaction Management in Spring with @Transactional</h3>
  <p style="color: #34495e;">
    Spring provides declarative transaction management using the <code>@Transactional</code> annotation, 
    which simplifies handling transactions.
  </p>

  <h4 style="color: #e67e22;">Example: Using @Transactional</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Service
      public class EmployeeService {
      
          @PersistenceContext
          private EntityManager entityManager;
      
          @Transactional
          public void addEmployee(Employee employee) {
              entityManager.persist(employee);
          }
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    The <code>@Transactional</code> annotation automatically manages the transaction, 
    committing the changes if successful or rolling them back if an exception occurs.
  </p>

  <h3 style="color: #9b59b6;">Transaction Propagation Levels</h3>
  <p style="color: #34495e;">
    The <code>propagation</code> property of <code>@Transactional</code> determines how transactions interact.
  </p>

  <table style="width:100%; border-collapse: collapse; margin-top: 10px;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px; text-align: left;">Propagation Type</th>
      <th style="padding: 10px; text-align: left;">Description</th>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">REQUIRED</td>
      <td style="padding: 10px;">Uses the existing transaction or creates a new one.</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">REQUIRES_NEW</td>
      <td style="padding: 10px;">Always starts a new transaction.</td>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">MANDATORY</td>
      <td style="padding: 10px;">Requires an existing transaction; throws an exception if none exists.</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">SUPPORTS</td>
      <td style="padding: 10px;">Uses the current transaction if available; otherwise, runs without one.</td>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">NOT_SUPPORTED</td>
      <td style="padding: 10px;">Runs without a transaction.</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">NEVER</td>
      <td style="padding: 10px;">Throws an exception if a transaction exists.</td>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">NESTED</td>
      <td style="padding: 10px;">Creates a nested transaction within an existing one.</td>
    </tr>
  </table>

  <h3 style="color: #16a085;">Rollback Scenarios</h3>
  <p style="color: #34495e;">
    By default, Spring rolls back transactions only for unchecked exceptions (<code>RuntimeException</code>).
    To rollback for checked exceptions, you must specify <code>rollbackFor</code>.
  </p>

  <h4 style="color: #e67e22;">Example: Rollback on a Checked Exception</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Transactional(rollbackFor = SQLException.class)
      public void updateEmployee(Employee employee) throws SQLException {
          entityManager.merge(employee);
          throw new SQLException("Database error occurred");
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    In this case, the transaction will be rolled back even though <code>SQLException</code> is a checked exception.
  </p>

  <h3 style="color: #9b59b6;">Best Practices for Transaction Management</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Transactional</code> at the **service layer** to maintain a clean architecture.</li>
    <li>Prefer **Lazy Loading** for large datasets to avoid unnecessary transactions.</li>
    <li>Use **transaction propagation** carefully to manage nested transactions.</li>
    <li>Rollback transactions for specific exceptions when needed.</li>
    <li>Minimize the **transactional scope** to avoid locking resources for long durations.</li>
  </ul>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Transaction management ensures data consistency in JPA and Hibernate. 
    Using <code>@Transactional</code> simplifies handling transactions, and understanding propagation and rollback behavior 
    helps in building robust applications. 
  </p>
</div>`
},
{
  title:`Locking Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Locking Strategies in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Locking mechanisms in JPA and Hibernate help prevent data inconsistencies and concurrency issues in multi-user environments. 
    JPA supports both **optimistic** and **pessimistic** locking strategies to ensure safe database transactions.
  </p>

  <h3 style="color: #16a085;">Why Locking is Needed?</h3>
  <p style="color: #34495e;">
    When multiple users access the same data, conflicts may arise. Locking strategies help:
  </p>
  <ul style="color: #34495e; padding-left: 20px;">
    <li>Prevent **dirty reads, non-repeatable reads, and lost updates**.</li>
    <li>Ensure **data integrity** in concurrent transactions.</li>
    <li>Manage **transaction isolation levels** effectively.</li>
  </ul>

  <h3 style="color: #9b59b6;">Optimistic Locking</h3>
  <p style="color: #34495e;">
    Optimistic locking allows multiple transactions to proceed without immediate locks. It checks for conflicts only when committing the transaction.
    This is useful when conflicts are rare and performance is a priority.
  </p>

  <h4 style="color: #e67e22;">Example: Optimistic Locking with @Version</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          
          private String name;
          
          @Version
          private int version; // Version column for optimistic locking
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    The <code>@Version</code> field ensures that if two transactions update the same row, 
    the one with an outdated version will fail, preventing inconsistent data.
  </p>

  <h3 style="color: #16a085;">Pessimistic Locking</h3>
  <p style="color: #34495e;">
    Pessimistic locking prevents concurrent modifications by locking the record until a transaction is completed.
    This ensures data integrity but can cause performance issues due to increased waiting time.
  </p>

  <h4 style="color: #e67e22;">Example: Pessimistic Locking in JPA</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Employee emp = entityManager.find(Employee.class, 1L, LockModeType.PESSIMISTIC_WRITE);
      emp.setName("Updated Name");
    </code>
  </pre>

  <p style="color: #34495e;">
    The **PESSIMISTIC_WRITE** lock prevents other transactions from updating or reading the record until the current transaction is committed.
  </p>

  <h3 style="color: #9b59b6;">Lock Modes in JPA</h3>
  <p style="color: #34495e;">
    JPA provides different lock modes to control concurrency.
  </p>

  <table style="width:100%; border-collapse: collapse; margin-top: 10px;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px; text-align: left;">Lock Mode</th>
      <th style="padding: 10px; text-align: left;">Description</th>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">OPTIMISTIC</td>
      <td style="padding: 10px;">Uses versioning to detect conflicts without locking the row.</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">OPTIMISTIC_FORCE_INCREMENT</td>
      <td style="padding: 10px;">Forces version increment even if no updates are made.</td>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">PESSIMISTIC_READ</td>
      <td style="padding: 10px;">Prevents updates but allows reads.</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">PESSIMISTIC_WRITE</td>
      <td style="padding: 10px;">Locks the record for updates, preventing concurrent modifications.</td>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">PESSIMISTIC_FORCE_INCREMENT</td>
      <td style="padding: 10px;">Increments version number, forcing optimistic lock conflict.</td>
    </tr>
  </table>

  <h3 style="color: #16a085;">Choosing the Right Locking Strategy</h3>
  <p style="color: #34495e;">
    The choice between **optimistic** and **pessimistic** locking depends on the use case:
  </p>
  <ul style="color: #34495e; padding-left: 20px;">
    <li>Use **optimistic locking** when conflicts are **rare**, and performance is critical.</li>
    <li>Use **pessimistic locking** when data consistency is **highly important**, and conflicts are frequent.</li>
  </ul>

  <h3 style="color: #9b59b6;">Best Practices for Locking</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **@Version** for optimistic locking to prevent unnecessary database locks.</li>
    <li>Apply **pessimistic locks only when necessary** to avoid performance bottlenecks.</li>
    <li>Choose the **appropriate lock mode** based on your application’s concurrency needs.</li>
    <li>Ensure transactions are **short-lived** to prevent long lock durations.</li>
  </ul>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Locking strategies in JPA and Hibernate help maintain **data integrity** in concurrent environments. 
    **Optimistic locking** is preferred for performance, while **pessimistic locking** ensures strict data consistency. 
    Choosing the right strategy helps improve application efficiency and reliability.
  </p>
</div>`
},
{
  title:`Fetching Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Fetching Strategies in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Fetching strategies in JPA and Hibernate determine how related entities are loaded from the database.
    Choosing the right fetching strategy improves performance and prevents unnecessary database queries.
  </p>

  <h3 style="color: #16a085;">Types of Fetching Strategies</h3>
  <p style="color: #34495e;">
    JPA provides two primary fetching strategies:
  </p>
  <ul style="color: #34495e; padding-left: 20px;">
    <li><b>Lazy Loading</b> – Loads related entities only when accessed.</li>
    <li><b>Eager Loading</b> – Loads related entities immediately.</li>
  </ul>

  <h3 style="color: #9b59b6;">Lazy Loading</h3>
  <p style="color: #34495e;">
    Lazy loading defers the loading of related entities until they are needed, reducing the initial query overhead.
    It is the default strategy in JPA.
  </p>

  <h4 style="color: #e67e22;">Example: Lazy Loading</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          
          private String name;
          
          @OneToMany(mappedBy = "employee", fetch = FetchType.LAZY) // Lazy fetching
          private List<Task> tasks;
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    Here, <code>tasks</code> will not be loaded when an <code>Employee</code> entity is retrieved. 
    They will be fetched only when accessed, avoiding unnecessary database queries.
  </p>

  <h3 style="color: #16a085;">Eager Loading</h3>
  <p style="color: #34495e;">
    Eager loading fetches related entities **immediately** along with the main entity.
    This prevents additional queries but may load unnecessary data.
  </p>

  <h4 style="color: #e67e22;">Example: Eager Loading</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          
          private String name;
          
          @OneToMany(mappedBy = "employee", fetch = FetchType.EAGER) // Eager fetching
          private List<Task> tasks;
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    Here, when fetching an <code>Employee</code>, all related <code>Task</code> entities are loaded immediately.
  </p>

  <h3 style="color: #9b59b6;">When to Use Lazy vs. Eager Loading?</h3>
  <table style="width:100%; border-collapse: collapse; margin-top: 10px;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px; text-align: left;">Strategy</th>
      <th style="padding: 10px; text-align: left;">Best Used When</th>
    </tr>
    <tr style="background-color: #ecf0f1;">
      <td style="padding: 10px;">Lazy Loading</td>
      <td style="padding: 10px;">Related entities are **rarely used** and can be loaded **on demand**.</td>
    </tr>
    <tr style="background-color: #ffffff;">
      <td style="padding: 10px;">Eager Loading</td>
      <td style="padding: 10px;">Related entities are **always needed**, reducing extra queries.</td>
    </tr>
  </table>

  <h3 style="color: #16a085;">Fetching with JOIN FETCH</h3>
  <p style="color: #34495e;">
    To avoid the **N+1 problem** (multiple queries for related entities), we can use **JOIN FETCH** in JPQL.
  </p>

  <h4 style="color: #e67e22;">Example: Using JOIN FETCH</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      String query = "SELECT e FROM Employee e JOIN FETCH e.tasks WHERE e.id = :id";
      Employee emp = entityManager.createQuery(query, Employee.class)
                                  .setParameter("id", 1L)
                                  .getSingleResult();
    </code>
  </pre>

  <p style="color: #34495e;">
    This query fetches **Employee** along with **Task** in a single SQL query, improving performance.
  </p>

  <h3 style="color: #9b59b6;">Using Entity Graphs for Fetching</h3>
  <p style="color: #34495e;">
    Entity graphs allow fine-grained control over which associations to fetch dynamically.
  </p>

  <h4 style="color: #e67e22;">Example: Entity Graph</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @NamedEntityGraph(
          name = "Employee.tasks",
          attributeNodes = @NamedAttributeNode("tasks")
      )
      @Entity
      public class Employee { ... }
      
      EntityGraph<Employee> graph = entityManager.getEntityGraph("Employee.tasks");
      Map<String, Object> hints = new HashMap<>();
      hints.put("javax.persistence.fetchgraph", graph);
      
      Employee emp = entityManager.find(Employee.class, 1L, hints);
    </code>
  </pre>

  <p style="color: #34495e;">
    This method provides more flexibility than **FetchType.EAGER**.
  </p>

  <h3 style="color: #16a085;">Best Practices for Fetching Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **Lazy Loading** by default for better performance.</li>
    <li>Use **JOIN FETCH** or **Entity Graphs** instead of **Eager Fetching**.</li>
    <li>Avoid the **N+1 problem** by using optimized queries.</li>
    <li>Use **pagination** when fetching large datasets.</li>
  </ul>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Choosing the right fetching strategy in JPA and Hibernate can **significantly improve performance**. 
    Use **Lazy Loading** whenever possible and optimize queries using **JOIN FETCH** or **Entity Graphs** for efficient data retrieval.
  </p>
</div>`
},
{
  title:`Interceptors & Listeners`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Interceptors & Listeners in Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Hibernate, <b>Interceptors</b> and <b>Listeners</b> provide a way to hook into the ORM lifecycle and perform operations before or after specific events occur. These mechanisms allow developers to customize Hibernate's behavior, enforce business rules, log changes, or audit database actions efficiently.
  </p>

  <h3 style="color: #16a085;">Interceptors</h3>
  <p style="font-size: 16px; color: #34495e;">
    <b>Interceptors</b> in Hibernate are used to intercept and modify Hibernate operations such as saving, updating, deleting, and loading entities. They provide a centralized way to manipulate or monitor database interactions.
  </p>

  <h4 style="color: #e67e22;">Implementing an Interceptor</h4>
  <p style="color: #34495e;">
    Hibernate provides the <code>Interceptor</code> interface, which developers can implement to override default behavior. Some of the commonly used methods in the <code>Interceptor</code> interface include:
  </p>
  
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>onSave():</b> Called before an entity is saved to the database.</li>
    <li><b>onFlushDirty():</b> Invoked before an entity is updated.</li>
    <li><b>onDelete():</b> Called before an entity is deleted.</li>
    <li><b>preFlush():</b> Executed before Hibernate flushes changes to the database.</li>
    <li><b>postFlush():</b> Executed after Hibernate flushes changes to the database.</li>
  </ul>

  <h4 style="color: #e67e22;">Interceptor Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.EmptyInterceptor;
      import org.hibernate.type.Type;
      import java.io.Serializable;
      
      public class MyInterceptor extends EmptyInterceptor {
          @Override
          public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) {
              System.out.println("Saving entity: " + entity);
              return super.onSave(entity, id, state, propertyNames, types);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Registering an Interceptor</h4>
  <p style="color: #34495e;">
    Interceptors can be applied globally at the <b>SessionFactory</b> level or individually for each session.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      SessionFactory factory = new Configuration().configure().buildSessionFactory();
      Session session = factory.withOptions().interceptor(new MyInterceptor()).openSession();
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Listeners</h3>
  <p style="font-size: 16px; color: #34495e;">
    <b>Listeners</b> in Hibernate are event-driven mechanisms that allow developers to execute logic before or after specific Hibernate events occur. They are more structured than interceptors and follow a declarative approach.
  </p>

  <h4 style="color: #e67e22;">Types of Listeners</h4>
  <p style="color: #34495e;">
    Hibernate provides several event types to listen for, such as:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>PreInsertEventListener:</b> Triggers before an entity is inserted.</li>
    <li><b>PostInsertEventListener:</b> Triggers after an entity is inserted.</li>
    <li><b>PreUpdateEventListener:</b> Triggers before an entity is updated.</li>
    <li><b>PostUpdateEventListener:</b> Triggers after an entity is updated.</li>
    <li><b>PreDeleteEventListener:</b> Triggers before an entity is deleted.</li>
    <li><b>PostDeleteEventListener:</b> Triggers after an entity is deleted.</li>
  </ul>

  <h4 style="color: #e67e22;">Implementing a Listener</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.event.spi.PreInsertEvent;
      import org.hibernate.event.spi.PreInsertEventListener;
      
      public class MyInsertListener implements PreInsertEventListener {
          @Override
          public boolean onPreInsert(PreInsertEvent event) {
              System.out.println("Before inserting entity: " + event.getEntity());
              return false;
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Registering a Listener</h4>
  <p style="color: #34495e;">
    Listeners are typically registered via the Hibernate configuration.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      Configuration config = new Configuration().configure();
      config.getEventListenerRegistry().appendListeners(EventType.PRE_INSERT, new MyInsertListener());
      SessionFactory factory = config.buildSessionFactory();
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Interceptors vs Listeners</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Interceptors:</b> More flexible, can modify SQL operations, and are manually attached to sessions.</li>
    <li><b>Listeners:</b> Event-driven, automatically invoked, and are suitable for lifecycle events like insert/update/delete.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Hibernate provides <b>Interceptors</b> and <b>Listeners</b> to extend ORM behavior dynamically. While interceptors allow flexible manipulation of transactions, listeners provide structured event-driven hooks. Choosing between them depends on the specific needs of the application.
  </p>
</div>`
},
{
  title:`Inheritance Mapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Inheritance Mapping in Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Hibernate, <b>Inheritance Mapping</b> is a technique used to map Java class hierarchies to database tables. Since object-oriented programming supports inheritance but relational databases do not, Hibernate provides different strategies to map inheritance structures effectively.
  </p>

  <h3 style="color: #16a085;">Types of Inheritance Mapping Strategies</h3>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate provides three main strategies for inheritance mapping:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Table Per Hierarchy</b> (Single Table Strategy)</li>
    <li><b>Table Per Concrete Class</b> (Concrete Table Strategy)</li>
    <li><b>Table Per Subclass</b> (Joined Table Strategy)</li>
  </ul>

  <h3 style="color: #e67e22;">1. Table Per Hierarchy (Single Table Strategy)</h3>
  <p style="color: #34495e;">
    In this approach, a single database table is used to store all classes in the inheritance hierarchy. A discriminator column is used to differentiate between different entity types.
  </p>

  <h4 style="color: #e67e22;">Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
      @DiscriminatorColumn(name = "vehicle_type", discriminatorType = DiscriminatorType.STRING)
      public class Vehicle {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private int id;
          private String name;
      }

      @Entity
      @DiscriminatorValue("Car")
      public class Car extends Vehicle {
          private int numberOfDoors;
      }

      @Entity
      @DiscriminatorValue("Bike")
      public class Bike extends Vehicle {
          private boolean hasCarrier;
      }
    </code>
  </pre>
  <p style="color: #34495e;">
    This method is efficient but may result in a lot of unused columns for subclasses.
  </p>

  <h3 style="color: #e67e22;">2. Table Per Concrete Class (Concrete Table Strategy)</h3>
  <p style="color: #34495e;">
    In this approach, each concrete class in the hierarchy has its own separate table with all fields from the superclass copied into each subclass table.
  </p>

  <h4 style="color: #e67e22;">Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
      public class Vehicle {
          @Id
          @GeneratedValue(strategy = GenerationType.AUTO)
          private int id;
          private String name;
      }

      @Entity
      public class Car extends Vehicle {
          private int numberOfDoors;
      }

      @Entity
      public class Bike extends Vehicle {
          private boolean hasCarrier;
      }
    </code>
  </pre>
  <p style="color: #34495e;">
    This approach avoids empty columns but can cause data redundancy and difficulty in querying parent-child relationships.
  </p>

  <h3 style="color: #e67e22;">3. Table Per Subclass (Joined Table Strategy)</h3>
  <p style="color: #34495e;">
    This strategy creates separate tables for the parent and each subclass, linking them with foreign keys. It maintains normalization and avoids redundancy.
  </p>

  <h4 style="color: #e67e22;">Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @Inheritance(strategy = InheritanceType.JOINED)
      public class Vehicle {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private int id;
          private String name;
      }

      @Entity
      @PrimaryKeyJoinColumn(name = "vehicle_id")
      public class Car extends Vehicle {
          private int numberOfDoors;
      }

      @Entity
      @PrimaryKeyJoinColumn(name = "vehicle_id")
      public class Bike extends Vehicle {
          private boolean hasCarrier;
      }
    </code>
  </pre>
  <p style="color: #34495e;">
    This strategy ensures data consistency and normalization but can lead to complex queries.
  </p>

  <h3 style="color: #2c3e50;">Choosing the Right Strategy</h3>
  <p style="font-size: 16px; color: #34495e;">
    The choice of inheritance mapping strategy depends on several factors:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Table Per Hierarchy:</b> Best for simple hierarchies with minimal subclass differences.</li>
    <li><b>Table Per Concrete Class:</b> Suitable when subclasses have distinct data without shared parent attributes.</li>
    <li><b>Table Per Subclass:</b> Ideal when data normalization and structured relationships are priorities.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Hibernate provides flexible inheritance mapping strategies to accommodate different database designs. Choosing the appropriate strategy ensures optimal performance, maintainability, and consistency in database interactions.
  </p>
</div>`
},
{
  title:`Hibernate with Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Hibernate with Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate is one of the most popular ORM (Object-Relational Mapping) frameworks in Java, and Spring Boot provides seamless integration with Hibernate to simplify database interactions. Spring Boot eliminates the need for complex configuration and allows developers to focus on business logic while leveraging Hibernate’s ORM capabilities efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use Hibernate with Spring Boot?</h3>
  <p style="font-size: 16px; color: #34495e;">
    Using Hibernate with Spring Boot offers several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Automatic configuration of Hibernate as the JPA provider.</li>
    <li>Built-in support for database initialization and schema management.</li>
    <li>Seamless integration with Spring Data JPA for repository-based data access.</li>
    <li>Elimination of boilerplate code required for Hibernate setup.</li>
  </ul>

  <h3 style="color: #9b59b6;">Setting Up Hibernate in Spring Boot</h3>
  <h4 style="color: #e67e22;">Step 1: Add Dependencies</h4>
  <p style="color: #34495e;">
    Include the necessary dependencies in your <code>pom.xml</code> (for Maven) or <code>build.gradle</code> (for Gradle).
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;com.h2database&lt;/groupId&gt;
          &lt;artifactId&gt;h2&lt;/artifactId&gt;
          &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #e67e22;">Step 2: Configure Application Properties</h4>
  <p style="color: #34495e;">
    Define database configurations in <code>application.properties</code> or <code>application.yml</code>.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      spring.datasource.url=jdbc:h2:mem:testdb
      spring.datasource.driverClassName=org.h2.Driver
      spring.datasource.username=sa
      spring.datasource.password=
      spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
      spring.jpa.hibernate.ddl-auto=update
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Creating an Entity</h3>
  <p style="color: #34495e;">
    Define a simple entity class using JPA annotations.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Creating a Repository</h3>
  <p style="color: #34495e;">
    Use Spring Data JPA’s <code>JpaRepository</code> to create a data repository without writing implementation code.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.stereotype.Repository;

      @Repository
      public interface UserRepository extends JpaRepository<User, Long> {
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Service Layer</h3>
  <p style="color: #34495e;">
    Implement a service class to handle business logic.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      import java.util.List;

      @Service
      public class UserService {
          @Autowired
          private UserRepository repository;

          public List<User> getAllUsers() {
              return repository.findAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Controller Layer</h3>
  <p style="color: #34495e;">
    Expose REST APIs using Spring Boot’s controller mechanism.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.web.bind.annotation.*;
      import java.util.List;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          @Autowired
          private UserService service;

          @GetMapping
          public List<User> getUsers() {
              return service.getAllUsers();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Hibernate with Spring Boot simplifies database management by integrating ORM functionality seamlessly. With automatic configuration, repository-based data access, and minimal setup, developers can focus on building business logic efficiently. By leveraging Spring Data JPA, Hibernate’s power can be fully utilized within a Spring Boot application.
  </p>
</div>`
},
{
  title:`Hibernate & JPA`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Hibernate & JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate and JPA (Java Persistence API) are both used for ORM (Object-Relational Mapping) in Java applications. While Hibernate is an implementation of JPA, JPA itself is a specification that defines how Java objects should be mapped to relational databases. Using Hibernate with JPA provides a standardized way to interact with databases while leveraging Hibernate’s powerful features.
  </p>

  <h3 style="color: #16a085;">Why Use Hibernate with JPA?</h3>
  <p style="font-size: 16px; color: #34495e;">
    Some key reasons to use Hibernate with JPA include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>JPA provides a standardized API for persistence in Java.</li>
    <li>Hibernate, as a JPA provider, offers advanced ORM capabilities.</li>
    <li>Supports various database management systems with minimal changes.</li>
    <li>Improves code portability by allowing developers to switch JPA providers easily.</li>
  </ul>

  <h3 style="color: #9b59b6;">Setting Up Hibernate with JPA</h3>
  <h4 style="color: #e67e22;">Step 1: Add Dependencies</h4>
  <p style="color: #34495e;">
    Include the necessary dependencies in your <code>pom.xml</code> (for Maven) or <code>build.gradle</code> (for Gradle).
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;javax.persistence&lt;/groupId&gt;
          &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt;
          &lt;version&gt;2.2&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
          &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
          &lt;version&gt;5.6.0.Final&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #e67e22;">Step 2: Configure Persistence</h4>
  <p style="color: #34495e;">
    Define the persistence configuration in <code>persistence.xml</code>.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.1"&gt;
          &lt;persistence-unit name="example-unit"&gt;
              &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
              &lt;properties&gt;
                  &lt;property name="javax.persistence.jdbc.url" value="jdbc:h2:mem:testdb"/&gt;
                  &lt;property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/&gt;
                  &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
              &lt;/properties&gt;
          &lt;/persistence-unit&gt;
      &lt;/persistence&gt;
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Creating an Entity</h3>
  <p style="color: #34495e;">
    Define a JPA entity using annotations.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Using EntityManager</h3>
  <p style="color: #34495e;">
    The <code>EntityManager</code> API is used to interact with the persistence context.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      public class UserService {
          @PersistenceContext
          private EntityManager entityManager;

          public void saveUser(User user) {
              entityManager.persist(user);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Hibernate and JPA work together to provide a powerful ORM solution in Java applications. While JPA standardizes persistence, Hibernate enhances it with additional features. Understanding their integration ensures efficient and scalable database interactions.
  </p>
</div>`
},
{
  title:`Spring Data JPA vs Hibernate`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Data JPA vs Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Data JPA and Hibernate are both widely used frameworks in Java applications for ORM (Object-Relational Mapping). While Hibernate is a full-fledged ORM framework, Spring Data JPA is a part of the Spring ecosystem that simplifies JPA-based data access. Understanding their differences and use cases can help in choosing the right approach for your project.
  </p>

  <h3 style="color: #16a085;">What is Hibernate?</h3>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate is a powerful ORM framework that enables Java applications to interact with databases using object-oriented principles. It provides various features such as lazy loading, caching, and transaction management.
  </p>

  <h3 style="color: #16a085;">What is Spring Data JPA?</h3>
  <p style="font-size: 16px; color: #34495e;">
    Spring Data JPA is a part of the Spring Data project that simplifies database access using JPA. It reduces the need for boilerplate code and provides built-in support for CRUD operations, query derivation, and pagination.
  </p>

  <h3 style="color: #e67e22;">Key Differences</h3>
  <table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;">
    <tr style="background-color: #f4f4f4;">
      <th style="padding: 10px; border: 1px solid #ddd;">Aspect</th>
      <th style="padding: 10px; border: 1px solid #ddd;">Spring Data JPA</th>
      <th style="padding: 10px; border: 1px solid #ddd;">Hibernate</th>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Ease of Use</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Provides built-in repository support with less boilerplate code.</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Requires more configuration and coding for CRUD operations.</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Flexibility</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Less flexible as it abstracts much of Hibernate’s functionality.</td>
      <td style="padding: 10px; border: 1px solid #ddd;">More control over ORM features and configurations.</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Query Handling</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Supports query derivation, JPQL, and native queries.</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Uses HQL, Criteria API, and native queries.</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Transaction Management</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Relies on Spring’s transaction management.</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Manages transactions natively using Hibernate API.</td>
    </tr>
  </table>

  <h3 style="color: #9b59b6;">Example: Spring Data JPA</h3>
  <p style="color: #34495e;">Example of a Spring Data JPA repository.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;

      public interface UserRepository extends JpaRepository<User, Long> {
          User findByEmail(String email);
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Example: Hibernate</h3>
  <p style="color: #34495e;">Example of using Hibernate with EntityManager.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      public class UserService {
          @PersistenceContext
          private EntityManager entityManager;

          public void saveUser(User user) {
              entityManager.persist(user);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Both Spring Data JPA and Hibernate have their advantages and trade-offs. If you want an easy-to-use solution with minimal configuration, Spring Data JPA is a great choice. However, if you need more control over ORM features and performance tuning, Hibernate provides greater flexibility. The choice depends on the complexity and requirements of your project.
  </p>
</div>`
},
{
  title:`Audit Logging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Audit Logging</h2>
  <p style="font-size: 16px; color: #34495e;">
    Audit logging is the process of recording events, changes, or actions performed in an application. It helps in tracking user activities, debugging issues, and ensuring compliance with security and regulatory requirements.
  </p>

  <h3 style="color: #16a085;">Why is Audit Logging Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensures security and detects unauthorized access.</li>
    <li>Helps in compliance with legal and regulatory standards.</li>
    <li>Provides insights into system usage and potential issues.</li>
    <li>Facilitates debugging and troubleshooting.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Audit Logs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Authentication Logs:</b> Tracks login and logout activities.</li>
    <li><b>Transaction Logs:</b> Records changes made to data.</li>
    <li><b>System Logs:</b> Captures application and server-level events.</li>
    <li><b>Access Logs:</b> Logs user interactions with resources.</li>
  </ul>

  <h3 style="color: #9b59b6;">Implementing Audit Logging in Spring Boot</h3>
  <p style="color: #34495e;">Example of using Spring Boot with Hibernate Envers for audit logging.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.envers.Audited;
      import javax.persistence.*;

      @Entity
      @Audited
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Logging Frameworks</h3>
  <p style="color: #34495e;">Popular frameworks for audit logging:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Log4j:</b> Highly configurable and widely used.</li>
    <li><b>SLF4J:</b> Simple facade for various logging frameworks.</li>
    <li><b>Spring Boot Actuator:</b> Provides built-in audit logging features.</li>
  </ul>

  <h3 style="color: #2c3e50;">Best Practices for Audit Logging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Log only necessary information to avoid data overload.</li>
    <li>Ensure logs are tamper-proof by using secure storage.</li>
    <li>Regularly review and analyze audit logs.</li>
    <li>Use structured logging formats (e.g., JSON) for easy parsing.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Audit logging is crucial for security, compliance, and system monitoring. Implementing effective logging strategies ensures better traceability and helps prevent unauthorized access and system failures.
  </p>
</div>`
},
{
  title:`Performance Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Performance Optimization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Performance optimization refers to the practice of enhancing the efficiency of a system, application, or process to achieve faster execution times, reduced resource consumption, and improved user experience.
  </p>

  <h3 style="color: #16a085;">Why is Performance Optimization Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Improves system responsiveness and scalability.</li>
    <li>Reduces costs by optimizing resource usage.</li>
    <li>Enhances user satisfaction by minimizing delays.</li>
    <li>Ensures smooth operation under high loads.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Areas of Performance Optimization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Code Optimization:</b> Improve algorithms, reduce redundant computations.</li>
    <li><b>Database Optimization:</b> Use indexing, caching, and optimized queries.</li>
    <li><b>Network Optimization:</b> Reduce latency through compression and efficient data transfer.</li>
    <li><b>Hardware Utilization:</b> Properly allocate CPU, memory, and storage resources.</li>
  </ul>

  <h3 style="color: #9b59b6;">Performance Optimization in Java Applications</h3>
  <p style="color: #34495e;">Example of optimizing Hibernate queries for better performance.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.Session;
      import org.hibernate.query.Query;

      public class HibernateOptimization {
          public static void main(String[] args) {
              Session session = HibernateUtil.getSessionFactory().openSession();
              Query<User> query = session.createQuery("FROM User WHERE active = :active", User.class);
              query.setParameter("active", true);
              query.setCacheable(true); // Enable caching
              List<User> users = query.list();
              session.close();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Performance Monitoring Tools</h3>
  <p style="color: #34495e;">Popular tools for analyzing and optimizing performance:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>JProfiler:</b> Advanced Java profiling tool.</li>
    <li><b>VisualVM:</b> Monitors and analyzes Java applications.</li>
    <li><b>New Relic:</b> Performance monitoring for cloud and web applications.</li>
    <li><b>Apache JMeter:</b> Load testing tool for analyzing performance bottlenecks.</li>
  </ul>

  <h3 style="color: #2c3e50;">Best Practices for Performance Optimization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Minimize database queries and avoid the N+1 problem.</li>
    <li>Use caching strategies (e.g., Redis, Ehcache).</li>
    <li>Profile and analyze code regularly to identify bottlenecks.</li>
    <li>Optimize frontend performance with lazy loading and efficient rendering.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Performance optimization is essential for building high-performance applications. By focusing on efficient code, database tuning, and leveraging monitoring tools, developers can ensure smooth and scalable application performance.
  </p>
</div>`
},
{
  title:`Testing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing</h2>
  <p style="font-size: 16px; color: #34495e;">
    Testing is a crucial phase in software development that ensures the application functions as expected, is free from defects, and meets business requirements. It involves verifying different aspects of software, such as functionality, security, performance, and usability.
  </p>

  <h3 style="color: #16a085;">Types of Software Testing</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Unit Testing:</b> Tests individual components or functions in isolation.</li>
    <li><b>Integration Testing:</b> Verifies that multiple components work together correctly.</li>
    <li><b>Functional Testing:</b> Ensures the application meets specified functional requirements.</li>
    <li><b>Performance Testing:</b> Assesses system performance under different loads.</li>
    <li><b>Security Testing:</b> Identifies vulnerabilities and security risks.</li>
    <li><b>Usability Testing:</b> Evaluates user-friendliness and ease of use.</li>
    <li><b>Regression Testing:</b> Checks that recent changes do not break existing functionality.</li>
  </ul>

  <h3 style="color: #e67e22;">Unit Testing in Java</h3>
  <p style="color: #34495e;">Example of a JUnit test case in Java.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import static org.junit.jupiter.api.Assertions.*;
      import org.junit.jupiter.api.Test;

      public class CalculatorTest {
          @Test
          void testAddition() {
              Calculator calc = new Calculator();
              assertEquals(5, calc.add(2, 3));
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Testing Frameworks & Tools</h3>
  <p style="color: #34495e;">Popular tools for software testing:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>JUnit:</b> Unit testing framework for Java.</li>
    <li><b>Selenium:</b> Automated testing for web applications.</li>
    <li><b>TestNG:</b> Advanced testing framework for Java.</li>
    <li><b>Postman:</b> API testing tool.</li>
    <li><b>JMeter:</b> Performance and load testing tool.</li>
    <li><b>Mockito:</b> Mocking framework for unit tests.</li>
  </ul>

  <h3 style="color: #e67e22;">Best Practices for Effective Testing</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Write clear and concise test cases covering all scenarios.</li>
    <li>Use automated tests to speed up the testing process.</li>
    <li>Ensure tests are independent and do not rely on external dependencies.</li>
    <li>Regularly review and update test cases as application evolves.</li>
    <li>Incorporate testing early in the development cycle (Shift Left Testing).</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Testing is an essential process in software development that helps deliver high-quality, reliable, and secure applications. By leveraging different testing methodologies, frameworks, and best practices, developers can ensure their software meets the expected standards and performs efficiently in real-world scenarios.
  </p>
</div>`
},
{
  title:`Common Issues & Debugging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Common Issues & Debugging</h2>
  <p style="font-size: 16px; color: #34495e;">
    Debugging is a crucial skill for software developers to identify and fix errors in their applications. Common issues arise due to syntax errors, logical mistakes, configuration problems, or unexpected runtime behaviors. Effective debugging techniques help resolve issues efficiently and improve code quality.
  </p>

  <h3 style="color: #16a085;">Common Issues in Software Development</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Null Pointer Exceptions:</b> Occur when accessing an object reference that is null.</li>
    <li><b>Syntax Errors:</b> Result from incorrect code structure or missing elements like semicolons or brackets.</li>
    <li><b>Logic Errors:</b> Happen when the program runs but produces incorrect results.</li>
    <li><b>Memory Leaks:</b> Arise from improper resource management, leading to excessive memory usage.</li>
    <li><b>Concurrency Issues:</b> Occur in multi-threaded applications due to improper synchronization.</li>
    <li><b>Configuration Errors:</b> Happen when application settings, such as database connections, are incorrect.</li>
  </ul>

  <h3 style="color: #e67e22;">Debugging Techniques</h3>
  <p style="color: #34495e;">Effective debugging strategies to identify and fix issues:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Logging:</b> Use logging frameworks (e.g., Log4j, SLF4J) to track program execution.</li>
    <li><b>Breakpoints:</b> Utilize breakpoints in IDEs like IntelliJ IDEA or Eclipse to pause execution.</li>
    <li><b>Stack Traces:</b> Analyze stack traces to locate the source of an error.</li>
    <li><b>Code Reviews:</b> Peer review code to catch potential issues early.</li>
    <li><b>Unit Tests:</b> Write tests to validate code correctness and detect regressions.</li>
    <li><b>Static Code Analysis:</b> Use tools like SonarQube or Checkstyle to find coding violations.</li>
  </ul>

  <h3 style="color: #9b59b6;">Using a Debugger</h3>
  <p style="color: #34495e;">Example of using a debugger in Java with IntelliJ IDEA.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public class DebugExample {
          public static void main(String[] args) {
              int a = 5;
              int b = 0;
              int result = divide(a, b);
              System.out.println("Result: " + result);
          }
          
          public static int divide(int x, int y) {
              return x / y; // This will cause an exception
          }
      }
    </code>
  </pre>
  <p style="color: #34495e;">Set a breakpoint at the division operation and use the debugger to step through the code.</p>

  <h3 style="color: #e67e22;">Best Practices for Debugging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Reproduce the issue consistently before attempting to fix it.</li>
    <li>Use version control (e.g., Git) to track changes and identify regressions.</li>
    <li>Break down complex problems into smaller, manageable parts.</li>
    <li>Write meaningful error messages and log entries to aid in troubleshooting.</li>
    <li>Keep dependencies and configurations up to date to avoid compatibility issues.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Debugging is an essential skill for developers to ensure software reliability. By understanding common issues and applying effective debugging techniques, developers can efficiently identify and resolve errors, leading to robust and high-quality applications.
  </p>
</div>`
},
{
  title:`Application Properties Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Application Properties Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Application properties play a crucial role in configuring and customizing software applications. They store key-value pairs that define application behavior, such as database connections, logging settings, and external API configurations. In Java-based applications, particularly with Spring Boot, the <code>application.properties</code> or <code>application.yml</code> files are used for these configurations.
  </p>

  <h3 style="color: #16a085;">Common Application Properties</h3>
  <p style="color: #34495e;">Some commonly used properties in Spring Boot applications include:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Server Configuration:</b> <code>server.port=8080</code> (Defines the application port)</li>
    <li><b>Database Configuration:</b> <code>spring.datasource.url=jdbc:mysql://localhost:3306/mydb</code></li>
    <li><b>Logging Level:</b> <code>logging.level.org.springframework=DEBUG</code></li>
    <li><b>File Upload Limits:</b> <code>spring.servlet.multipart.max-file-size=10MB</code></li>
    <li><b>External API Keys:</b> <code>api.key=your-api-key-here</code></li>
  </ul>

  <h3 style="color: #e67e22;">Using <code>application.properties</code> in Spring Boot</h3>
  <p style="color: #34495e;">Spring Boot automatically loads properties from the <code>application.properties</code> or <code>application.yml</code> file located in the <code>src/main/resources</code> directory.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      # Server configuration
      server.port=8081

      # Database configuration
      spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase
      spring.datasource.username=root
      spring.datasource.password=secret

      # Logging configuration
      logging.level.org.springframework=DEBUG
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Using <code>@Value</code> Annotation</h3>
  <p style="color: #34495e;">Spring Boot allows you to inject property values into Java classes using the <code>@Value</code> annotation.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;
      
      @Component
      public class ConfigExample {
          @Value("\${server.port}")
          private String serverPort;
          
          public String getServerPort() {
              return serverPort;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using <code>@ConfigurationProperties</code></h3>
  <p style="color: #34495e;">For handling multiple related properties, use the <code>@ConfigurationProperties</code> annotation.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.ConfigurationProperties;
      import org.springframework.stereotype.Component;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      public class AppProperties {
          private String name;
          private String version;
          
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
          
          public String getVersion() { return version; }
          public void setVersion(String version) { this.version = version; }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>application.yml</code> for better readability over <code>application.properties</code>.</li>
    <li>Store sensitive properties (e.g., passwords) in environment variables or secure vaults.</li>
    <li>Use profiles (e.g., <code>application-dev.properties</code>) to manage different environments.</li>
    <li>Keep property files organized and remove unused properties.</li>
    <li>Document critical properties to aid other developers.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Application properties are essential for configuring applications effectively. Spring Boot provides a flexible way to manage these properties through property files, annotations, and externalized configurations. Following best practices ensures maintainable and secure configuration management.
  </p>
</div>`
},
{
  title:`Spring Boot Properties`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Boot Properties</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot properties allow developers to configure various aspects of their applications using a simple key-value format. These properties are typically defined in <code>application.properties</code> or <code>application.yml</code> files and can be used to manage database connections, server settings, logging levels, and more.
  </p>

  <h3 style="color: #16a085;">Commonly Used Spring Boot Properties</h3>
  <p style="color: #34495e;">Here are some essential properties commonly used in Spring Boot applications:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Server Configuration:</b> <code>server.port=8080</code> (Defines the port for the application)</li>
    <li><b>Database Configuration:</b> <code>spring.datasource.url=jdbc:mysql://localhost:3306/mydb</code></li>
    <li><b>Logging Configuration:</b> <code>logging.level.org.springframework=DEBUG</code></li>
    <li><b>Spring Profiles:</b> <code>spring.profiles.active=dev</code></li>
    <li><b>Thymeleaf Configuration:</b> <code>spring.thymeleaf.cache=false</code></li>
  </ul>

  <h3 style="color: #e67e22;">Configuring <code>application.properties</code> in Spring Boot</h3>
  <p style="color: #34495e;">Spring Boot automatically loads properties from <code>application.properties</code> or <code>application.yml</code> files placed in the <code>src/main/resources</code> directory.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      # Server properties
      server.port=8081

      # Database properties
      spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase
      spring.datasource.username=root
      spring.datasource.password=secret

      # Logging properties
      logging.level.org.springframework=DEBUG
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Injecting Properties in Spring Boot</h3>
  <p style="color: #34495e;">Spring Boot provides several ways to access application properties in Java classes, such as using the <code>@Value</code> annotation.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;
      
      @Component
      public class ConfigExample {
          @Value("\${server.port}")
          private String serverPort;
          
          public String getServerPort() {
              return serverPort;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using <code>@ConfigurationProperties</code></h3>
  <p style="color: #34495e;">For handling multiple related properties, use <code>@ConfigurationProperties</code>.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.ConfigurationProperties;
      import org.springframework.stereotype.Component;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      public class AppProperties {
          private String name;
          private String version;
          
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
          
          public String getVersion() { return version; }
          public void setVersion(String version) { this.version = version; }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices for Spring Boot Properties</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>application.yml</code> for better readability over <code>application.properties</code>.</li>
    <li>Store sensitive information in environment variables or a secure vault.</li>
    <li>Use Spring profiles (e.g., <code>application-dev.properties</code>) to manage different environments.</li>
    <li>Organize properties logically and remove unused ones.</li>
    <li>Document critical properties for maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Spring Boot properties provide a flexible way to configure applications. Using <code>application.properties</code>, <code>application.yml</code>, and annotations like <code>@Value</code> and <code>@ConfigurationProperties</code>, developers can efficiently manage configurations. Following best practices ensures secure, maintainable, and efficient property management.
  </p>
</div>`
},
{
  title:`Common Properties`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Common Properties</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, properties allow developers to configure various aspects of their applications through key-value pairs. These properties are typically defined in <code>application.properties</code> or <code>application.yml</code> files and can manage server settings, database connections, logging, security, and more.
  </p>

  <h3 style="color: #16a085;">Commonly Used Spring Boot Properties</h3>
  <p style="color: #34495e;">Here are some frequently used properties in Spring Boot applications:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Server Configuration:</b> <code>server.port=8080</code> (Defines the application's running port).</li>
    <li><b>Context Path:</b> <code>server.servlet.context-path=/app</code> (Defines the base URL path).</li>
    <li><b>Database Configuration:</b> <code>spring.datasource.url=jdbc:mysql://localhost:3306/mydb</code></li>
    <li><b>Logging Level:</b> <code>logging.level.org.springframework=DEBUG</code></li>
    <li><b>Spring Profiles:</b> <code>spring.profiles.active=dev</code> (Defines active profile).</li>
    <li><b>Security Configuration:</b> <code>spring.security.user.name=admin</code>, <code>spring.security.user.password=secret</code></li>
  </ul>

  <h3 style="color: #e67e22;">Example: Configuring Common Properties</h3>
  <p style="color: #34495e;">Spring Boot loads properties from <code>application.properties</code> or <code>application.yml</code> automatically.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      # Server properties
      server.port=9090
      server.servlet.context-path=/myapp

      # Database properties
      spring.datasource.url=jdbc:postgresql://localhost:5432/mydatabase
      spring.datasource.username=postgres
      spring.datasource.password=secret
      
      # Logging properties
      logging.level.root=INFO
      logging.level.org.springframework.web=DEBUG
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Accessing Properties in Java</h3>
  <p style="color: #34495e;">Spring Boot allows accessing properties using <code>@Value</code> annotation.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;
      
      @Component
      public class AppConfig {
          @Value("\${server.port}")
          private String serverPort;
          
          public String getServerPort() {
              return serverPort;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using <code>@ConfigurationProperties</code></h3>
  <p style="color: #34495e;">For handling grouped properties, use <code>@ConfigurationProperties</code>.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.ConfigurationProperties;
      import org.springframework.stereotype.Component;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      public class AppProperties {
          private String name;
          private String version;
          
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
          
          public String getVersion() { return version; }
          public void setVersion(String version) { this.version = version; }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices for Common Properties</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>application.yml</code> for better readability over <code>application.properties</code>.</li>
    <li>Store sensitive information in environment variables or a secure vault.</li>
    <li>Use Spring profiles (e.g., <code>application-dev.properties</code>) to manage different environments.</li>
    <li>Organize properties logically and remove unused ones.</li>
    <li>Document critical properties for maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Understanding and utilizing common properties in Spring Boot is essential for configuring and managing applications efficiently. By leveraging <code>application.properties</code>, <code>application.yml</code>, and annotations like <code>@Value</code> and <code>@ConfigurationProperties</code>, developers can achieve flexible and maintainable configurations.
  </p>
</div>`
},
{
  title:`YAML vs Properties`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">YAML vs Properties in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot allows configuration using both <code>application.properties</code> and <code>application.yml</code>. These files define settings for the application, including server configurations, database connections, logging levels, and more. Understanding the differences between these two formats can help in choosing the best option for your project.
  </p>

  <h3 style="color: #16a085;">Properties File</h3>
  <p style="color: #34495e;">The properties file format uses key-value pairs for configuration.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      # Server properties
      server.port=8080
      server.servlet.context-path=/app
      
      # Database properties
      spring.datasource.url=jdbc:mysql://localhost:3306/mydb
      spring.datasource.username=root
      spring.datasource.password=secret
    </code>
  </pre>

  <h3 style="color: #9b59b6;">YAML File</h3>
  <p style="color: #34495e;">The YAML format provides a more structured way to define configuration properties.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      server:
        port: 8080
        servlet:
          context-path: /app
      
      spring:
        datasource:
          url: jdbc:mysql://localhost:3306/mydb
          username: root
          password: secret
    </code>
  </pre>

  <h3 style="color: #e67e22;">Key Differences</h3>
  <table style="width: 100%; border-collapse: collapse;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px; border: 1px solid #ddd;">Feature</th>
      <th style="padding: 10px; border: 1px solid #ddd;">Properties</th>
      <th style="padding: 10px; border: 1px solid #ddd;">YAML</th>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Format</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Key-Value pairs</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Hierarchical structure</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Readability</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Less readable for complex configurations</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Easier to read and maintain</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Multiline Values</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Requires escaping characters</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Supports multiline natively</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Array Support</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Not intuitive</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Easy to define lists</td>
    </tr>
  </table>

  <h3 style="color: #9b59b6;">When to Use Properties or YAML?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>application.properties</code> for simple key-value configurations.</li>
    <li>Use <code>application.yml</code> when dealing with structured configurations.</li>
    <li>YAML is preferred for large projects as it offers better readability.</li>
    <li>For environment-specific properties, both formats support Spring profiles.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Both YAML and properties files serve as configuration options in Spring Boot. YAML is more readable and structured, while properties files are simpler for smaller applications. Choosing the right format depends on project requirements and developer preference.
  </p>
</div>`
},
{
  title:`Spring Profiles`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Profiles</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Profiles provide a way to define different configurations for different environments (e.g., development, testing, production) within a Spring Boot application. This helps in maintaining environment-specific settings without changing the core application code.
  </p>

  <h3 style="color: #16a085;">Defining Profiles</h3>
  <p style="color: #34495e;">Spring Profiles can be defined using the <code>spring.profiles.active</code> property in <code>application.properties</code> or <code>application.yml</code>. Different profiles allow applications to load configurations dynamically based on the environment.</p>

  <h4 style="color: #e67e22;">Example: Using Properties File</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      # application.properties (default)
      spring.profiles.active=dev
      
      # application-dev.properties
      server.port=8081
      spring.datasource.url=jdbc:mysql://localhost:3306/devdb
      
      # application-prod.properties
      server.port=8082
      spring.datasource.url=jdbc:mysql://localhost:3306/proddb
    </code>
  </pre>

  <h4 style="color: #e67e22;">Example: Using YAML</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        profiles:
          active: dev
      
      ---
      spring:
        profiles: dev
      server:
        port: 8081
      datasource:
        url: jdbc:mysql://localhost:3306/devdb
      
      ---
      spring:
        profiles: prod
      server:
        port: 8082
      datasource:
        url: jdbc:mysql://localhost:3306/proddb
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Activating Profiles</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Profiles can be activated via command line: <code>-Dspring.profiles.active=prod</code></li>
    <li>Profiles can be set in environment variables: <code>SPRING_PROFILES_ACTIVE=prod</code></li>
    <li>Profiles can be specified in an application configuration file.</li>
  </ul>

  <h3 style="color: #e67e22;">Using @Profile Annotation</h3>
  <p style="color: #34495e;">The <code>@Profile</code> annotation can be used to conditionally load beans based on the active profile.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.context.annotation.Profile;
      
      @Configuration
      public class AppConfig {
        
          @Bean
          @Profile("dev")
          public DataSource devDataSource() {
              return new DataSource("jdbc:mysql://localhost:3306/devdb");
          }
          
          @Bean
          @Profile("prod")
          public DataSource prodDataSource() {
              return new DataSource("jdbc:mysql://localhost:3306/proddb");
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Advantages of Using Profiles</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Allows easy environment-specific configurations.</li>
    <li>Improves code maintainability.</li>
    <li>Enables automatic selection of configurations based on deployment environment.</li>
    <li>Supports different property files or YAML sections for each profile.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Spring Profiles offer a powerful way to manage application configurations across different environments. By leveraging profiles in properties files, YAML configurations, or the <code>@Profile</code> annotation, developers can easily switch between development, testing, and production configurations without modifying the core code.
  </p>
</div>`
},
{
  title:`Custom Properties`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Custom Properties in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot allows defining custom properties in configuration files to externalize application-specific settings. These properties can be accessed using the <code>@Value</code> annotation, <code>Environment</code> object, or by binding them to a configuration class.
  </p>

  <h3 style="color: #16a085;">Defining Custom Properties</h3>
  <p style="color: #34495e;">Custom properties can be added to the <code>application.properties</code> or <code>application.yml</code> file.</p>

  <h4 style="color: #e67e22;">Example: Using application.properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      app.name=My Spring Boot App
      app.version=1.0.0
      app.description=This is a sample Spring Boot application.
    </code>
  </pre>

  <h4 style="color: #e67e22;">Example: Using application.yml</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      app:
        name: My Spring Boot App
        version: 1.0.0
        description: This is a sample Spring Boot application.
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Accessing Custom Properties</h3>
  <h4 style="color: #e67e22;">Using @Value Annotation</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;
      
      @Component
      public class AppConfig {
          
          @Value("\${app.name}")
          private String appName;
          
          @Value("\${app.version}")
          private String appVersion;
          
          public String getAppDetails() {
              return appName + " - " + appVersion;
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Using @ConfigurationProperties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.ConfigurationProperties;
      import org.springframework.context.annotation.Configuration;
      
      @Configuration
      @ConfigurationProperties(prefix = "app")
      public class AppProperties {
          private String name;
          private String version;
          
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
          
          public String getVersion() { return version; }
          public void setVersion(String version) { this.version = version; }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using Environment Object</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.core.env.Environment;
      import org.springframework.stereotype.Component;
      
      @Component
      public class AppEnvConfig {
          private final Environment environment;
          
          public AppEnvConfig(Environment environment) {
              this.environment = environment;
          }
          
          public String getAppName() {
              return environment.getProperty("app.name");
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Advantages of Custom Properties</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Allows externalizing configuration settings.</li>
    <li>Improves maintainability and flexibility.</li>
    <li>Supports easy modification without changing the code.</li>
    <li>Works seamlessly with different environments.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Custom properties in Spring Boot provide a powerful way to configure applications dynamically. By leveraging properties files, YAML configurations, or binding properties to Java classes, developers can easily manage application settings across different environments.
  </p>
</div>`
},
{
  title:`Externalized Configuration`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Externalized Configuration in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot provides powerful support for externalized configuration, allowing developers to define application settings outside of the source code. This enables greater flexibility and easier management of different environments like development, testing, and production.
  </p>

  <h3 style="color: #16a085;">Sources of Externalized Configuration</h3>
  <p style="color: #34495e;">Spring Boot supports multiple sources for externalized configuration, including:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Properties files (application.properties, application.yml)</li>
    <li>Command-line arguments</li>
    <li>Environment variables</li>
    <li>System properties</li>
    <li>Configuration servers (e.g., Spring Cloud Config)</li>
    <li>JNDI attributes</li>
  </ul>

  <h3 style="color: #9b59b6;">Using Properties Files</h3>
  <p style="color: #34495e;">Application configuration is often stored in <code>application.properties</code> or <code>application.yml</code>:</p>

  <h4 style="color: #e67e22;">Example: application.properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      server.port=8081
      spring.datasource.url=jdbc:mysql://localhost:3306/mydb
      spring.datasource.username=root
      spring.datasource.password=secret
    </code>
  </pre>

  <h4 style="color: #e67e22;">Example: application.yml</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      server:
        port: 8081
      spring:
        datasource:
          url: jdbc:mysql://localhost:3306/mydb
          username: root
          password: secret
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using Command-Line Arguments</h3>
  <p style="color: #34495e;">Spring Boot allows overriding properties through command-line arguments:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-bash">
      java -jar myapp.jar --server.port=9090 --spring.datasource.username=admin
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Using Environment Variables</h3>
  <p style="color: #34495e;">Spring Boot reads environment variables using the <code>@Value</code> annotation or <code>Environment</code> object:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;
      
      @Component
      public class ConfigExample {
          
          @Value("\${SERVER_PORT:8080}")
          private String serverPort;
          
          public String getServerPort() {
              return serverPort;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using Spring Cloud Config</h3>
  <p style="color: #34495e;">Spring Cloud Config provides centralized externalized configuration for distributed applications:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      spring.cloud.config.uri=http://config-server:8888
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Benefits of Externalized Configuration</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Separates configuration from code</li>
    <li>Facilitates easy environment management</li>
    <li>Supports runtime modifications without restarting</li>
    <li>Improves maintainability and flexibility</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Externalized configuration is an essential feature of Spring Boot that enables better configurability and easier environment management. By leveraging properties files, command-line arguments, environment variables, and external configuration servers, applications become more flexible and maintainable.
  </p>
</div>`
},
{
  title:`Binding to POJOs`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Binding to POJOs in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot provides a powerful mechanism for binding externalized configuration properties to Plain Old Java Objects (POJOs). This allows for structured and type-safe access to application properties, making it easier to manage configurations.
  </p>

  <h3 style="color: #16a085;">Why Use POJO Binding?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Encapsulates configuration properties in a structured manner</li>
    <li>Eliminates the need for manual parsing of properties</li>
    <li>Provides type safety and validation</li>
    <li>Makes configuration management cleaner and more maintainable</li>
  </ul>

  <h3 style="color: #9b59b6;">Using <code>@ConfigurationProperties</code></h3>
  <p style="color: #34495e;">
    The <code>@ConfigurationProperties</code> annotation allows mapping properties from <code>application.properties</code> or <code>application.yml</code> to a Java POJO.
  </p>

  <h4 style="color: #e67e22;">Example: application.properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      app.name=MyApp
      app.version=1.0.0
      app.enabled=true
    </code>
  </pre>

  <h4 style="color: #e67e22;">Example: Binding to a POJO</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.ConfigurationProperties;
      import org.springframework.stereotype.Component;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      public class AppProperties {
          private String name;
          private String version;
          private boolean enabled;
          
          // Getters and Setters
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
          public String getVersion() { return version; }
          public void setVersion(String version) { this.version = version; }
          public boolean isEnabled() { return enabled; }
          public void setEnabled(boolean enabled) { this.enabled = enabled; }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Enabling Configuration Binding</h3>
  <p style="color: #34495e;">Ensure that the POJO is managed as a Spring bean by adding <code>@Component</code> or using <code>@EnableConfigurationProperties</code> in a configuration class.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.EnableConfigurationProperties;
      import org.springframework.context.annotation.Configuration;
      
      @Configuration
      @EnableConfigurationProperties(AppProperties.class)
      public class AppConfig {
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Validating Properties</h3>
  <p style="color: #34495e;">Spring Boot allows validation of properties using JSR-303 validation annotations like <code>@NotNull</code> and <code>@Min</code>:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.validation.constraints.Min;
      import javax.validation.constraints.NotNull;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      public class AppProperties {
          @NotNull
          private String name;
          
          @Min(1)
          private String version;
          
          private boolean enabled;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Binding to POJOs in Spring Boot simplifies configuration management by providing a structured and type-safe approach. Using <code>@ConfigurationProperties</code>, developers can cleanly manage application settings while leveraging validation and externalized configuration sources.
  </p>
</div>`
},
{
  title:`@Value Annotation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Value Annotation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@Value</code> annotation in Spring Boot is used to inject values into fields from property files, system properties, or even SpEL (Spring Expression Language). It is a simple and effective way to externalize configuration values in a Spring application.
  </p>

  <h3 style="color: #16a085;">Why Use @Value?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Injects values directly into fields</li>
    <li>Supports default values</li>
    <li>Works with system properties, environment variables, and property files</li>
    <li>Supports Spring Expression Language (SpEL) for dynamic values</li>
  </ul>

  <h3 style="color: #9b59b6;">Basic Usage of @Value</h3>
  <p style="color: #34495e;">
    The <code>@Value</code> annotation can be used to inject values from <code>application.properties</code> or <code>application.yml</code> into a Spring component.
  </p>

  <h4 style="color: #e67e22;">Example: application.properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      app.name=MyApp
      app.version=1.0.0
    </code>
  </pre>

  <h4 style="color: #e67e22;">Injecting Properties with @Value</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;
      
      @Component
      public class AppConfig {
          @Value("\${app.name}")
          private String appName;
          
          @Value("\${app.version}")
          private String appVersion;
          
          public String getAppName() {
              return appName;
          }
          
          public String getAppVersion() {
              return appVersion;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using Default Values</h3>
  <p style="color: #34495e;">If a property is missing, a default value can be specified:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Value("\${app.description:Default App Description}")
      private String appDescription;
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Using SpEL (Spring Expression Language)</h3>
  <p style="color: #34495e;">Spring Expression Language (SpEL) can be used to derive values dynamically:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Value("#{systemProperties['user.name']}")
      private String systemUser;
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Injecting Lists and Maps</h3>
  <p style="color: #34495e;">Lists and Maps can also be injected using <code>@Value</code>:</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Value("#{'\${app.supportedLanguages}'.split(',')}")
      private List<String> supportedLanguages;
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    The <code>@Value</code> annotation is a powerful tool for injecting externalized properties into Spring components. It supports default values, SpEL, system properties, and more, making it a flexible choice for configuration management.
  </p>
</div>`
},
{
  title:`Configuration Prefixes`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Configuration Prefixes in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, configuration properties are often grouped using prefixes to organize related settings and simplify property binding. This allows for better structuring and easier management of application properties.
  </p>

  <h3 style="color: #16a085;">Why Use Configuration Prefixes?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Organizes related configuration properties</li>
    <li>Enables easy binding to POJOs</li>
    <li>Improves readability and maintainability</li>
    <li>Supports hierarchical property structures</li>
  </ul>

  <h3 style="color: #9b59b6;">Defining Configuration Prefixes</h3>
  <p style="color: #34495e;">
    Configuration prefixes are used in property files such as <code>application.properties</code> or <code>application.yml</code>. Each prefix groups related properties together.
  </p>

  <h4 style="color: #e67e22;">Example: application.properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      app.name=MyApplication
      app.version=1.0.0
      app.description=Spring Boot App
    </code>
  </pre>

  <h4 style="color: #e67e22;">Example: application.yml</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      app:
        name: MyApplication
        version: 1.0.0
        description: Spring Boot App
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Binding Configuration Prefixes to POJOs</h3>
  <p style="color: #34495e;">Spring Boot allows binding these properties to a Java class using the <code>@ConfigurationProperties</code> annotation.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.ConfigurationProperties;
      import org.springframework.stereotype.Component;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      public class AppConfig {
          private String name;
          private String version;
          private String description;
          
          // Getters and setters
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
          
          public String getVersion() { return version; }
          public void setVersion(String version) { this.version = version; }
          
          public String getDescription() { return description; }
          public void setDescription(String description) { this.description = description; }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Validating Configuration Properties</h3>
  <p style="color: #34495e;">Spring Boot supports validation for configuration properties using <code>@Validated</code> and constraint annotations.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.validation.constraints.NotBlank;
      import jakarta.validation.constraints.NotNull;
      import org.springframework.validation.annotation.Validated;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      @Validated
      public class AppConfig {
          @NotBlank
          private String name;
          
          @NotNull
          private String version;
          
          private String description;
          
          // Getters and setters
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Configuration prefixes in Spring Boot allow for structured and manageable property configurations. They help in organizing related settings and make it easy to bind them to Java objects using <code>@ConfigurationProperties</code>. This enhances the maintainability and flexibility of application configurations.
  </p>
</div>`
},
{
  title:`Property Sources`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Property Sources in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, property sources define the locations from which configuration properties are loaded. These properties play a crucial role in externalizing application configurations, making applications more flexible and manageable across different environments.
  </p>

  <h3 style="color: #16a085;">Understanding Property Sources</h3>
  <p style="color: #34495e;">
    Spring Boot loads properties from multiple sources in a specific order, allowing developers to override configurations as needed. Property sources can include property files, environment variables, system properties, and command-line arguments.
  </p>

  <h3 style="color: #9b59b6;">Types of Property Sources</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>application.properties / application.yml:</b> Default configuration files loaded from <code>src/main/resources</code>.</li>
    <li><b>System Properties:</b> Java system properties passed using <code>-Dproperty=value</code>.</li>
    <li><b>Environment Variables:</b> Variables defined in the system environment.</li>
    <li><b>Command-Line Arguments:</b> Properties passed when starting the application using <code>--property=value</code>.</li>
    <li><b>PropertySource Annotations:</b> Custom properties loaded from specific locations using <code>@PropertySource</code>.</li>
    <li><b>Profiles:</b> Environment-specific configurations using <code>application-{profile}.properties</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">Order of Property Sources</h3>
  <p style="color: #34495e;">
    Spring Boot follows a predefined order when resolving properties. The general precedence (from highest to lowest) is:
  </p>
  <ol style="color: #2c3e50; padding-left: 20px;">
    <li>DevTools properties (if applicable)</li>
    <li>Command-line arguments</li>
    <li>Java system properties (<code>-Dproperty=value</code>)</li>
    <li>OS environment variables</li>
    <li><code>RandomValuePropertySource</code> (random values in configuration)</li>
    <li>Application properties from <code>application-{profile}.properties</code> or <code>application.yml</code></li>
    <li>Application properties from <code>@PropertySource</code> annotations</li>
    <li>Default properties set via <code>SpringApplication.setDefaultProperties()</code></li>
  </ol>

  <h3 style="color: #9b59b6;">Using @PropertySource to Load Custom Properties</h3>
  <p style="color: #34495e;">The <code>@PropertySource</code> annotation can be used to load properties from external files.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.context.annotation.PropertySource;
      
      @Configuration
      @PropertySource("classpath:custom.properties")
      public class CustomPropertyConfig {
          @Value("\${custom.property}")
          private String customProperty;
          
          public String getCustomProperty() {
              return customProperty;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Binding Property Sources to POJOs</h3>
  <p style="color: #34495e;">Property sources can be mapped directly to Java objects using <code>@ConfigurationProperties</code>.</p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.context.properties.ConfigurationProperties;
      import org.springframework.stereotype.Component;
      
      @Component
      @ConfigurationProperties(prefix = "app")
      public class AppConfig {
          private String name;
          private String version;
          
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
          
          public String getVersion() { return version; }
          public void setVersion(String version) { this.version = version; }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Property sources in Spring Boot allow for externalized and flexible application configurations. By leveraging multiple sources such as property files, system variables, and command-line arguments, developers can ensure their applications are adaptable and environment-friendly. Understanding how these property sources interact helps in maintaining scalable and maintainable applications.
  </p>
</div>`
},
{
  title:`Configuration Property Types`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Configuration Property Types in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    In JPA and Hibernate, configuration properties define how the persistence layer behaves.
    These properties control database connections, entity mapping, caching, and more.
  </p>

  <h3 style="color: #16a085;">Types of Configuration Properties</h3>
  <p style="color: #34495e;">
    The main types of configuration properties in JPA and Hibernate are:
  </p>
  <ul style="color: #34495e; padding-left: 20px;">
    <li><b>Database Connection Properties</b> – Define how Hibernate connects to the database.</li>
    <li><b>JPA Provider Properties</b> – Specify JPA provider behavior.</li>
    <li><b>Hibernate-Specific Properties</b> – Fine-tune Hibernate features.</li>
    <li><b>Caching and Performance Properties</b> – Manage caching and query optimizations.</li>
    <li><b>Transaction Management Properties</b> – Define how transactions are handled.</li>
  </ul>

  <h3 style="color: #9b59b6;">1. Database Connection Properties</h3>
  <p style="color: #34495e;">
    These properties define the **JDBC connection** used by Hibernate.
  </p>

  <h4 style="color: #e67e22;">Example: Database Configuration</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      spring.datasource.url=jdbc:mysql://localhost:3306/mydb
      spring.datasource.username=root
      spring.datasource.password=secret
      spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    </code>
  </pre>

  <p style="color: #34495e;">
    These properties define the **database URL**, **username**, **password**, and **JDBC driver**.
  </p>

  <h3 style="color: #16a085;">2. JPA Provider Properties</h3>
  <p style="color: #34495e;">
    JPA provider properties configure the **JPA implementation**, such as Hibernate.
  </p>

  <h4 style="color: #e67e22;">Example: JPA Provider Configuration</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
      spring.jpa.show-sql=true
      spring.jpa.hibernate.ddl-auto=update
    </code>
  </pre>

  <p style="color: #34495e;">
    - **Database Dialect**: Specifies the SQL dialect Hibernate should use.<br>
    - **Show SQL**: Enables query logging.<br>
    - **DDL Auto**: Controls schema generation (e.g., update, create, none).
  </p>

  <h3 style="color: #9b59b6;">3. Hibernate-Specific Properties</h3>
  <p style="color: #34495e;">
    Hibernate offers additional properties for fine-grained control.
  </p>

  <h4 style="color: #e67e22;">Example: Hibernate Configuration</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      hibernate.format_sql=true
      hibernate.jdbc.batch_size=50
      hibernate.order_inserts=true
      hibernate.order_updates=true
    </code>
  </pre>

  <p style="color: #34495e;">
    - **Format SQL**: Pretty-prints SQL queries.<br>
    - **Batch Size**: Controls batch processing for inserts/updates.<br>
    - **Order Inserts/Updates**: Optimizes bulk operations.
  </p>

  <h3 style="color: #16a085;">4. Caching and Performance Properties</h3>
  <p style="color: #34495e;">
    These properties enable **caching** and **query optimizations**.
  </p>

  <h4 style="color: #e67e22;">Example: Caching Configuration</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      hibernate.cache.use_second_level_cache=true
      hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
      hibernate.cache.use_query_cache=true
    </code>
  </pre>

  <p style="color: #34495e;">
    - **Second-Level Cache**: Enables entity caching.<br>
    - **Cache Provider**: Specifies the caching implementation.<br>
    - **Query Cache**: Enables caching of query results.
  </p>

  <h3 style="color: #9b59b6;">5. Transaction Management Properties</h3>
  <p style="color: #34495e;">
    These properties control how **transactions** are managed.
  </p>

  <h4 style="color: #e67e22;">Example: Transaction Configuration</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-properties">
      spring.transaction.default-timeout=30
      spring.transaction.rollback-on-commit-failure=true
    </code>
  </pre>

  <p style="color: #34495e;">
    - **Default Timeout**: Specifies transaction timeout in seconds.<br>
    - **Rollback on Failure**: Ensures failed transactions are rolled back.
  </p>

  <h3 style="color: #16a085;">Best Practices for Configuration</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **environment variables** instead of hardcoding credentials.</li>
    <li>Enable **query logging** only in development.</li>
    <li>Optimize **batch size** for better performance.</li>
    <li>Use **caching** to reduce database load.</li>
  </ul>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Configuring JPA and Hibernate properly ensures efficient database interactions.
    Using the right **property settings** enhances performance, security, and scalability.
  </p>
</div>
`
},
{
  title:`Profile-Specific Config`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Profile-Specific Configuration in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot allows you to define different configurations for different environments using 
    <b>profile-specific properties</b>. This feature helps manage configurations for <b>development</b>, <b>testing</b>, 
    <b>staging</b>, and <b>production</b> without modifying the codebase.
  </p>

  <h3 style="color: #16a085;">1. What is a Profile in Spring Boot?</h3>
  <p style="color: #34495e;">
    A <b>profile</b> in Spring Boot is a way to separate configurations based on different environments. 
    You can have separate property files or bean configurations for each profile.
  </p>

  <h3 style="color: #9b59b6;">2. Defining Profile-Specific Property Files</h3>
  <p style="color: #34495e;">
    Spring Boot allows creating <b>profile-specific property files</b> using the naming convention:
  </p>

  <ul style="color: #34495e; padding-left: 20px;">
    <li><b>application.properties</b> (default configuration)</li>
    <li><b>application-dev.properties</b> (for development)</li>
    <li><b>application-test.properties</b> (for testing)</li>
    <li><b>application-prod.properties</b> (for production)</li>
  </ul>

  <h4 style="color: #e67e22;">Example: Profile-Specific Property Files</h4>
  
  <p><b>application-dev.properties</b></p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      spring.datasource.url=jdbc:mysql://localhost:3306/devdb
      spring.datasource.username=devuser
      spring.datasource.password=devpass
      server.port=8081
    </code>
  </pre>

  <p><b>application-prod.properties</b></p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      spring.datasource.url=jdbc:mysql://prod-db:3306/proddb
      spring.datasource.username=produser
      spring.datasource.password=prodpass
      server.port=8080
    </code>
  </pre>

  <p style="color: #34495e;">
    Here, different database configurations and ports are used for <b>development</b> and <b>production</b>.
  </p>

  <h3 style="color: #16a085;">3. Activating a Profile</h3>
  <p style="color: #34495e;">
    You can activate a specific profile using:
  </p>
  
  <ul style="color: #34495e; padding-left: 20px;">
    <li><b>Environment Variable</b>: Set <code>SPRING_PROFILES_ACTIVE</code></li>
    <li><b>Command Line</b>: Use <code>--spring.profiles.active=dev</code></li>
    <li><b>Configuration File</b>: Set in <code>application.properties</code></li>
  </ul>

  <h4 style="color: #e67e22;">Example: Setting Profile in application.properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      spring.profiles.active=dev
    </code>
  </pre>

  <h4 style="color: #e67e22;">Example: Setting Profile in Command Line</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      java -jar myapp.jar --spring.profiles.active=prod
    </code>
  </pre>

  <h3 style="color: #9b59b6;">4. Using Profiles in Java Configuration</h3>
  <p style="color: #34495e;">
    You can use <b>@Profile</b> annotation to define beans for specific profiles.
  </p>

  <h4 style="color: #e67e22;">Example: Profile-Based Bean Configuration</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class DataSourceConfig {

          @Bean
          @Profile("dev")
          public DataSource devDataSource() {
              return new HikariDataSource(); // Dev DB setup
          }

          @Bean
          @Profile("prod")
          public DataSource prodDataSource() {
              return new HikariDataSource(); // Prod DB setup
          }
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    - The **devDataSource()** bean is created only when the <b>dev</b> profile is active.<br>
    - The **prodDataSource()** bean is used when the <b>prod</b> profile is active.
  </p>

  <h3 style="color: #16a085;">5. Best Practices for Profile-Specific Configurations</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **profile-specific properties** instead of manually changing configurations.</li>
    <li>Store **sensitive credentials** (e.g., database passwords) in **environment variables**.</li>
    <li>Ensure **default profiles** are set for cases when no profile is active.</li>
    <li>Use **@Profile annotation** in Java-based configurations.</li>
  </ul>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Profile-specific configurations allow developers to manage settings for different environments 
    efficiently. By using **application-{profile}.properties**, **@Profile annotations**, and 
    **environment variables**, Spring Boot applications can dynamically adapt to different 
    deployment scenarios.
  </p>
</div>
`
},
{
  title:`Profiles in application.yml`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Profiles in <code>application.yml</code></h2>
  <p style="font-size: 16px; color: #34495e;">
    Profiles in Spring Boot are a powerful feature that allows you to define different configurations for different environments, such as development, testing, and production. By using profiles, you can customize properties, beans, and behavior based on the active profile. The <code>application.yml</code> file is a common way to define these configurations in a structured and readable format. This article explores how to use profiles in <code>application.yml</code> to manage environment-specific settings in a Spring Boot application.
  </p>

  <h3 style="color: #16a085;">Why Use Profiles?</h3>
  <p style="color: #2c3e50;">
    Profiles offer several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Environment-Specific Configuration</strong>: Tailor settings for different environments without changing code.</li>
    <li><strong>Simplified Deployment</strong>: Easily switch configurations when deploying to different environments.</li>
    <li><strong>Improved Maintainability</strong>: Keep all configurations in one place, making it easier to manage and update.</li>
    <li><strong>Flexibility</strong>: Override default properties for specific environments or use cases.</li>
    <li><strong>Testing</strong>: Use different configurations for unit tests, integration tests, and end-to-end tests.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Profiles in <code>application.yml</code></h3>
  <p style="color: #2c3e50;">
    When working with profiles in <code>application.yml</code>, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Default Profile</strong>: Properties defined outside any profile block are considered default and apply to all profiles.</li>
    <li><strong>Profile-Specific Properties</strong>: Properties defined under a specific profile block override the default properties.</li>
    <li><strong>Activating Profiles</strong>: Profiles can be activated using environment variables, command-line arguments, or configuration files.</li>
    <li><strong>Profile Groups</strong>: Combine multiple profiles into a group for easier management.</li>
    <li><strong>YAML Structure</strong>: Use indentation and dashes to define profiles and properties in <code>application.yml</code>.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Profiles in <code>application.yml</code></h3>
  <p style="color: #2c3e50;">
    Below is an example of how to define and use profiles in a <code>application.yml</code> file.
  </p>

  <h4 style="color: #8e44ad;">1. Define Default Properties</h4>
  <p style="color: #2c3e50;">
    Define default properties that apply to all profiles.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      # Default properties
      app:
        name: MySpringBootApp
        version: 1.0.0

      server:
        port: 8080
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Define Profile-Specific Properties</h4>
  <p style="color: #2c3e50;">
    Define properties for specific profiles like <code>dev</code>, <code>test</code>, and <code>prod</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      # Development profile
      ---
      spring:
        profiles: dev

      app:
        environment: Development
      server:
        port: 8081

      # Testing profile
      ---
      spring:
        profiles: test

      app:
        environment: Testing
      server:
        port: 8082

      # Production profile
      ---
      spring:
        profiles: prod

      app:
        environment: Production
      server:
        port: 8080
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Activate Profiles</h4>
  <p style="color: #2c3e50;">
    Activate a profile using environment variables, command-line arguments, or configuration files.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-bash">
      # Using environment variable
      export SPRING_PROFILES_ACTIVE=dev

      # Using command-line argument
      java -jar myapp.jar --spring.profiles.active=test

      # In application.yml (for default profile)
      spring:
        profiles:
          active: prod
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Use Profile Groups</h4>
  <p style="color: #2c3e50;">
    Combine multiple profiles into a group for easier activation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        profiles:
          group:
            dev: dev,debug
            prod: prod,secure
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Profiles</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful profile names like <code>dev</code>, <code>test</code>, and <code>prod</code>.</li>
    <li>Keep default properties minimal and override them in profile-specific blocks.</li>
    <li>Avoid hardcoding sensitive information (e.g., passwords) in <code>application.yml</code>; use environment variables or secrets management tools.</li>
    <li>Use profile groups to simplify the activation of related profiles.</li>
    <li>Test your application with all active profiles to ensure compatibility.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Profiles in <code>application.yml</code> are a powerful way to manage environment-specific configurations in Spring Boot applications. By defining default properties and overriding them for specific profiles, you can easily customize your application for different environments. Whether you're developing, testing, or deploying to production, profiles provide the flexibility and maintainability needed to manage configurations effectively. By following best practices, you can ensure that your application is well-organized, secure, and ready for any environment.
  </p>
</div>`
},
{
  title:`Placeholder Resolution`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Placeholder Resolution in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot supports <b>placeholder resolution</b>, allowing developers to use variables in configuration files 
    and resolve them dynamically at runtime. Placeholders are commonly used in <b>application.properties</b> or 
    <b>application.yml</b> to improve maintainability and flexibility.
  </p>

  <h3 style="color: #16a085;">1. What is Placeholder Resolution?</h3>
  <p style="color: #34495e;">
    Placeholder resolution is a mechanism that allows values in configuration files to be dynamically replaced 
    using <b>$\{...}</b> syntax. These placeholders can reference:
  </p>
  <ul style="color: #34495e; padding-left: 20px;">
    <li><b>Other property values</b> within the same file</li>
    <li><b>Environment variables</b> set at runtime</li>
    <li><b>System properties</b> (e.g., JVM arguments)</li>
    <li><b>Default values</b> if the placeholder is not found</li>
  </ul>

  <h3 style="color: #9b59b6;">2. Using Placeholders in application.properties</h3>
  <p style="color: #34495e;">
    You can use placeholders to reference values inside your <b>application.properties</b> file.
  </p>

  <h4 style="color: #e67e22;">Example: Using Placeholders in application.properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      app.name=MySpringApp
      app.version=1.0.0
      app.fullname=$\{app.name} v$\{app.version}
    </code>
  </pre>

  <p style="color: #34495e;">
    The placeholder <b>$\{app.name}</b> resolves to <b>MySpringApp</b> and <b>$\{app.version}</b> resolves to <b>1.0.0</b>, 
    so <code>app.fullname</code> will become <b>MySpringApp v1.0.0</b>.
  </p>

  <h3 style="color: #16a085;">3. Placeholder Resolution in YAML Configuration</h3>
  <p style="color: #34495e;">
    In YAML configuration, placeholders work the same way.
  </p>

  <h4 style="color: #e67e22;">Example: Using Placeholders in application.yml</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      app:
        name: MySpringApp
        version: 1.0.0
        fullname: $\{app.name} v$\{app.version}
    </code>
  </pre>

  <h3 style="color: #9b59b6;">4. Using System Properties & Environment Variables</h3>
  <p style="color: #34495e;">
    You can also reference system properties or environment variables inside your configuration.
  </p>

  <h4 style="color: #e67e22;">Example: Resolving System Properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      server.port=$\{PORT:8080}
    </code>
  </pre>

  <p style="color: #34495e;">
    - If the <b>PORT</b> environment variable is set, it will be used.<br>
    - If <b>PORT</b> is not set, the default value <b>8080</b> will be used.
  </p>

  <h3 style="color: #16a085;">5. Using Placeholders in Java Code</h3>
  <p style="color: #34495e;">
    You can use the <b>@Value</b> annotation to inject placeholder values into Spring Beans.
  </p>

  <h4 style="color: #e67e22;">Example: Injecting Placeholders in a Spring Component</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Component
      public class AppConfig {
          @Value("$\{app.name}")
          private String appName;
      
          @Value("\${server.port:8080}")
          private int serverPort;

          public void printConfig() {
              System.out.println("App Name: " + appName);
              System.out.println("Server Port: " + serverPort);
          }
      }
    </code>
  </pre>

  <p style="color: #34495e;">
    - <b>@Value("\${app.name}")</b> injects the value from <code>application.properties</code>.<br>
    - <b>@Value("\${server.port:8080}")</b> uses <b>8080</b> as a default if no value is found.
  </p>

  <h3 style="color: #16a085;">6. Resolving Placeholders Programmatically</h3>
  <p style="color: #34495e;">
    The <b>Environment</b> object in Spring can be used to resolve placeholders programmatically.
  </p>

  <h4 style="color: #e67e22;">Example: Using Environment to Resolve Placeholders</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      public class ConfigController {
      
          @Autowired
          private Environment env;
      
          @GetMapping("/config")
          public String getConfig() {
              String appName = env.getProperty("app.name", "DefaultApp");
              return "App Name: " + appName;
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">7. Best Practices for Placeholder Resolution</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <b>\${property.name}</b> for referencing other properties.</li>
    <li>Provide default values using <b>\${property.name:defaultValue}</b>.</li>
    <li>Use <b>@Value</b> annotation for injecting properties in Spring Beans.</li>
    <li>Use <b>Environment</b> object for programmatic access to properties.</li>
    <li>Store sensitive data in **environment variables** instead of properties files.</li>
  </ul>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Placeholder resolution in Spring Boot provides a powerful way to manage application configurations dynamically. 
    Using **\${...} syntax**, **@Value annotations**, and **environment variables**, you can write flexible, maintainable, 
    and scalable applications.
  </p>
</div>
`
},
{
  title:`Property Encryption`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Property Encryption</h2>
  <p style="font-size: 16px; color: #34495e;">
    Property encryption is a crucial security measure used to protect sensitive data in configuration files such as <code>application.yml</code> or <code>application.properties</code>. Encrypting properties ensures that sensitive credentials, API keys, database passwords, and other confidential information remain secure and unreadable to unauthorized users. This article explores different methods to implement property encryption in a Spring Boot application.
  </p>

  <h3 style="color: #16a085;">Why Use Property Encryption?</h3>
  <p style="color: #2c3e50;">
    Encrypting properties offers several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Enhanced Security</strong>: Protects sensitive information from unauthorized access.</li>
    <li><strong>Compliance</strong>: Meets security standards like GDPR, HIPAA, and PCI-DSS.</li>
    <li><strong>Configuration Safety</strong>: Prevents exposure of credentials in version control systems.</li>
    <li><strong>Integration</strong>: Works with various encryption mechanisms and key management systems.</li>
    <li><strong>Flexibility</strong>: Allows decryption at runtime while keeping plaintext values hidden.</li>
  </ul>

  <h3 style="color: #e67e22;">Methods for Property Encryption</h3>
  <p style="color: #2c3e50;">
    There are multiple ways to encrypt properties in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Jasypt Encryption</strong>: A popular library for encrypting and decrypting configuration properties.</li>
    <li><strong>Spring Cloud Config</strong>: Provides secure storage and retrieval of encrypted values.</li>
    <li><strong>Environment Variables</strong>: Stores sensitive data externally to avoid hardcoding.</li>
    <li><strong>Vault Integration</strong>: Uses HashiCorp Vault for secure secrets management.</li>
  </ul>

  <h3 style="color: #2980b9;">Using Jasypt for Property Encryption</h3>
  <p style="color: #2c3e50;">
    Jasypt (Java Simplified Encryption) is a widely used encryption library in Spring Boot.
  </p>

  <h4 style="color: #8e44ad;">1. Add Jasypt Dependency</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;
          &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;
          &lt;version&gt;3.0.4&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Encrypt a Property</h4>
  <p style="color: #2c3e50;">
    Encrypt the sensitive value using the Jasypt command-line tool or online Jasypt encryption tools.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      java -cp jasypt.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI \
        input="mysecretpassword" password="encryptionKey" algorithm="PBEWITHHMACSHA512ANDAES_256"
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Store Encrypted Property in <code>application.yml</code></h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      spring:
        datasource:
          url: jdbc:mysql://localhost:3306/mydb
          username: admin
          password: ENC(encryptedValueHere)
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Set Encryption Password</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      export JASYPT_ENCRYPTOR_PASSWORD=encryptionKey
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Property Encryption</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Never store plaintext credentials in source code.</li>
    <li>Use strong encryption algorithms like AES-256.</li>
    <li>Manage encryption keys securely using a key management system.</li>
    <li>Regularly rotate encryption keys and credentials.</li>
    <li>Test property decryption to ensure compatibility with the application.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Property encryption is a critical security measure for protecting sensitive information in Spring Boot applications. By leveraging encryption tools like Jasypt, Spring Cloud Config, and Vault, developers can secure configuration properties and prevent unauthorized access. Following best practices ensures that encrypted data remains safe and accessible only to authorized applications and users.
  </p>
</div>
`
},
{
  title:`Spring Cloud Config`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Spring Cloud Config</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Cloud Config is a powerful tool for managing external configurations across multiple microservices in a distributed system. It provides a centralized configuration server that allows applications to dynamically retrieve and update configurations without the need for redeployment. This article explores the concepts, benefits, and implementation of Spring Cloud Config in a microservices architecture.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Cloud Config?</h3>
  <p style="color: #2c3e50;">Spring Cloud Config offers several advantages:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized Configuration</strong>: Store and manage configuration properties in one place.</li>
    <li><strong>Dynamic Updates</strong>: Modify configurations without restarting services.</li>
    <li><strong>Consistency</strong>: Ensure uniform settings across multiple microservices.</li>
    <li><strong>Security</strong>: Secure sensitive data using encrypted properties.</li>
    <li><strong>Version Control</strong>: Store configurations in Git or other repositories.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Components of Spring Cloud Config</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Config Server</strong>: The centralized server that stores and serves configurations.</li>
    <li><strong>Config Client</strong>: The application that retrieves configurations from the server.</li>
    <li><strong>Backend Storage</strong>: Configuration sources like Git, databases, or local files.</li>
    <li><strong>Refresh Mechanism</strong>: Allows applications to update configurations dynamically.</li>
  </ul>

  <h3 style="color: #2980b9;">Setting Up Spring Cloud Config</h3>
  <p style="color: #2c3e50;">Follow these steps to set up Spring Cloud Config.</p>

  <h4 style="color: #8e44ad;">1. Create a Config Server</h4>
  <p style="color: #2c3e50;">Start by creating a Spring Boot application with the Config Server dependency.</p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @EnableConfigServer
      @SpringBootApplication
      public class ConfigServerApplication {
          public static void main(String[] args) {
              SpringApplication.run(ConfigServerApplication.class, args);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Configure application.yml for the Server</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      server:
        port: 8888
      spring:
        cloud:
          config:
            server:
              git:
                uri: https://github.com/your-repo/config-repo
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Create a Config Client</h4>
  <p style="color: #2c3e50;">Your microservices need to fetch configurations from the Config Server.</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        application:
          name: my-service
        cloud:
          config:
            uri: http://localhost:8888
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Spring Cloud Config</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use Git for version-controlled configuration storage.</li>
    <li>Secure sensitive data using encryption.</li>
    <li>Enable auto-refresh for real-time updates.</li>
    <li>Use Spring Boot Actuator for monitoring configuration changes.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Config simplifies configuration management for distributed applications by providing a centralized, dynamic, and secure solution. By using best practices, teams can efficiently manage configurations across multiple microservices.
  </p>
</div>
`
},
{
  title:`Config Server`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Spring Cloud Config Server</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a microservices architecture, managing configuration centrally is crucial to ensure consistency, security, and ease of maintenance. Spring Cloud Config Server provides a centralized configuration management system that enables applications to fetch and update their configurations dynamically. This article explores how to set up and use Config Server effectively in a Spring Boot application.
  </p>

  <h3 style="color: #16a085;">Why Use Config Server?</h3>
  <p style="color: #2c3e50;">
    Config Server offers several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized Configuration Management</strong>: Store all configuration properties in one place.</li>
    <li><strong>Dynamic Configuration Updates</strong>: Change configurations without redeploying applications.</li>
    <li><strong>Version Control Integration</strong>: Use Git repositories to maintain configuration history.</li>
    <li><strong>Security</strong>: Keep sensitive data secure using encryption and environment variables.</li>
    <li><strong>Environment-Specific Configurations</strong>: Define separate settings for dev, test, and production environments.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up a Spring Cloud Config Server</h3>
  <p style="color: #2c3e50;">
    Follow these steps to create a Config Server using Spring Boot:
  </p>

  <h4 style="color: #8e44ad;">1. Add Dependencies</h4>
  <p style="color: #2c3e50;">
    Include the required dependencies in your <code>pom.xml</code> file.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Enable Config Server</h4>
  <p style="color: #2c3e50;">
    Annotate the main Spring Boot application class with <code>@EnableConfigServer</code>.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @SpringBootApplication
      @EnableConfigServer
      public class ConfigServerApplication {
        public static void main(String[] args) {
          SpringApplication.run(ConfigServerApplication.class, args);
        }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Configure <code>application.yml</code></h4>
  <p style="color: #2c3e50;">
    Set up the configuration file to define the repository where configuration files are stored.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      server:
        port: 8888
      spring:
        cloud:
          config:
            server:
              git:
                uri: https://github.com/your-repo/config-files
                default-label: main
    </code>
  </pre>

  <h3 style="color: #2980b9;">Accessing Configuration from a Client Application</h3>
  <p style="color: #2c3e50;">
    Client applications fetch configuration from the Config Server using the following URL pattern:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-bash">
      http://localhost:8888/{application}/{profile}/{label}
    </code>
  </pre>
  <p style="color: #2c3e50;">
    Example:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-bash">
      http://localhost:8888/myapp/dev/main
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Config Server</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use a version control system like Git to store configurations.</li>
    <li>Keep sensitive data out of the repository and use environment variables.</li>
    <li>Ensure the Config Server is highly available and replicated.</li>
    <li>Use Spring Cloud Bus to refresh configurations dynamically across services.</li>
    <li>Secure access to the Config Server using authentication mechanisms.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Config Server provides a powerful way to manage configuration centrally, ensuring consistency across microservices. With its integration with Git, ability to handle dynamic updates, and support for environment-specific settings, it is an essential tool for modern cloud-native applications. By following best practices, you can make your configuration management more robust and secure.
  </p>
</div>
`
},
{
  title:`Environment Variables`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Environment Variables in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Environment variables are a powerful way to configure Spring Boot applications dynamically. They allow you to externalize configuration settings, making your application more flexible and secure. Environment variables are particularly useful for managing sensitive information, such as API keys, database credentials, and other configuration values that may vary across different environments (e.g., development, testing, production). Spring Boot provides seamless support for environment variables, enabling you to use them in your application with minimal effort.
  </p>

  <h3 style="color: #16a085;">Why Use Environment Variables?</h3>
  <p style="color: #2c3e50;">
    Environment variables offer several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Security</strong>: Keep sensitive information like passwords and API keys out of your codebase.</li>
    <li><strong>Flexibility</strong>: Easily change configuration values without modifying the application code.</li>
    <li><strong>Environment-Specific Configuration</strong>: Use different values for different environments (e.g., dev, test, prod).</li>
    <li><strong>Portability</strong>: Simplify deployment across different platforms and environments.</li>
    <li><strong>Compliance</strong>: Meet security and compliance requirements by avoiding hardcoded secrets.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Environment Variables</h3>
  <p style="color: #2c3e50;">
    When working with environment variables in Spring Boot, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Accessing Environment Variables</strong>: Use the <code>@Value</code> annotation or the <code>Environment</code> object to access environment variables.</li>
    <li><strong>Naming Conventions</strong>: Environment variable names are typically uppercase with underscores (e.g., <code>DATABASE_URL</code>).</li>
    <li><strong>Default Values</strong>: Provide default values for environment variables to ensure your application runs even if the variable is not set.</li>
    <li><strong>Spring Boot's Property Sources</strong>: Spring Boot automatically maps environment variables to properties, allowing you to use them in <code>application.properties</code> or <code>application.yml</code>.</li>
    <li><strong>Profiles</strong>: Combine environment variables with Spring profiles for environment-specific configurations.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Environment Variables in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use environment variables in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Access Environment Variables in Code</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Value</code> annotation to inject environment variables into your application.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;

      @Component
      public class MyComponent {

          @Value("\${DATABASE_URL}")
          private String databaseUrl;

          @Value("\${API_KEY:default_api_key}") // Default value if not set
          private String apiKey;

          public void printConfig() {
              System.out.println("Database URL: " + databaseUrl);
              System.out.println("API Key: " + apiKey);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Use Environment Variables in <code>application.yml</code></h4>
  <p style="color: #2c3e50;">
    Reference environment variables in your <code>application.yml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      app:
        database:
          url: \${DATABASE_URL}
        api:
          key: \${API_KEY:default_api_key} # Default value if not set
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Set Environment Variables</h4>
  <p style="color: #2c3e50;">
    Set environment variables in your operating system or deployment environment.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-bash">
      # On Linux/macOS
      export DATABASE_URL=jdbc:mysql://localhost:3306/mydb
      export API_KEY=my_secret_key

      # On Windows
      set DATABASE_URL=jdbc:mysql://localhost:3306/mydb
      set API_KEY=my_secret_key
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Use Environment Variables with Profiles</h4>
  <p style="color: #2c3e50;">
    Combine environment variables with Spring profiles for environment-specific configurations.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      # application.yml
      spring:
        profiles: dev
      app:
        database:
          url: \${DEV_DATABASE_URL}

      ---
      spring:
        profiles: prod
      app:
        database:
          url: \${PROD_DATABASE_URL}
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Environment Variables</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use uppercase names with underscores for environment variables (e.g., <code>DATABASE_URL</code>).</li>
    <li>Provide default values for optional environment variables to avoid runtime errors.</li>
    <li>Avoid hardcoding sensitive information in your codebase; use environment variables instead.</li>
    <li>Use tools like <code>.env</code> files or secrets management services (e.g., AWS Secrets Manager) for managing environment variables in development and production.</li>
    <li>Document all required environment variables in your project's README or configuration guide.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Environment variables are a powerful and secure way to configure Spring Boot applications. By externalizing configuration settings, you can make your application more flexible, portable, and compliant with security best practices. Whether you're managing sensitive information or customizing behavior for different environments, environment variables provide a clean and efficient solution. By following best practices, you can ensure that your application is well-configured, secure, and ready for deployment in any environment.
  </p>
</div>`
},
{
  title:`Environment Variables`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Working with Multiple Property Files in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a Spring Boot application, managing configurations efficiently is crucial for scalability and maintainability. One effective way to achieve this is by using multiple property files. Spring Boot allows you to define multiple property files to separate configurations for different environments, modules, or external services. This article explores the benefits and best practices of using multiple property files in Spring Boot.
  </p>

  <h3 style="color: #16a085;">Why Use Multiple Property Files?</h3>
  <p style="color: #2c3e50;">
    Using multiple property files provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Modular Configuration</strong>: Organize configurations based on different modules or services.</li>
    <li><strong>Environment Separation</strong>: Maintain different property files for development, testing, and production environments.</li>
    <li><strong>Security</strong>: Store sensitive configurations in separate property files and load them securely.</li>
    <li><strong>Flexibility</strong>: Override properties dynamically based on profiles or external sources.</li>
  </ul>

  <h3 style="color: #e67e22;">Defining Multiple Property Files</h3>
  <p style="color: #2c3e50;">
    Spring Boot loads properties from <code>application.properties</code> or <code>application.yml</code> by default. However, you can define additional property files as needed.
  </p>
  
  <h4 style="color: #8e44ad;">1. Creating Environment-Specific Property Files</h4>
  <p style="color: #2c3e50;">
    You can define separate property files for different environments:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      # application-dev.properties
      app.name=MyApp (Development)
      server.port=8081

      # application-prod.properties
      app.name=MyApp (Production)
      server.port=8080
    </code>
  </pre>
  
  <h4 style="color: #8e44ad;">2. Loading Additional Property Files</h4>
  <p style="color: #2c3e50;">
    You can explicitly load additional property files using <code>@PropertySource</code> in a Spring Boot configuration class:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      @PropertySource("classpath:custom-config.properties")
      public class AppConfig {
          @Value("\${custom.property}")
          private String customProperty;
      }
    </code>
  </pre>
  
  <h4 style="color: #8e44ad;">3. Using Profile-Specific Property Files</h4>
  <p style="color: #2c3e50;">
    To activate a specific profile’s property file, set the profile in <code>application.properties</code> or via environment variables:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      spring.profiles.active=dev
    </code>
  </pre>
  
  <h3 style="color: #d35400;">Best Practices for Managing Multiple Property Files</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep environment-specific properties in separate files to avoid accidental overrides.</li>
    <li>Use <code>@PropertySource</code> to load custom configuration files when necessary.</li>
    <li>Leverage Spring Boot’s built-in profile support for managing multiple configurations.</li>
    <li>Use externalized configuration (e.g., environment variables) for sensitive data like passwords.</li>
    <li>Ensure consistency and documentation of property files for maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Using multiple property files in Spring Boot helps in managing configurations efficiently for different environments and modules. By separating concerns and leveraging profiles, developers can ensure flexibility, security, and better maintainability of their applications. Following best practices ensures smooth configuration management and hassle-free deployments.
  </p>
</div>
`
},
{
  title:`Multiple Property Files`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Working with Multiple Property Files in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a Spring Boot application, managing configurations efficiently is crucial for scalability and maintainability. One effective way to achieve this is by using multiple property files. Spring Boot allows you to define multiple property files to separate configurations for different environments, modules, or external services. This article explores the benefits and best practices of using multiple property files in Spring Boot.
  </p>

  <h3 style="color: #16a085;">Why Use Multiple Property Files?</h3>
  <p style="color: #2c3e50;">
    Using multiple property files provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Modular Configuration</strong>: Organize configurations based on different modules or services.</li>
    <li><strong>Environment Separation</strong>: Maintain different property files for development, testing, and production environments.</li>
    <li><strong>Security</strong>: Store sensitive configurations in separate property files and load them securely.</li>
    <li><strong>Flexibility</strong>: Override properties dynamically based on profiles or external sources.</li>
  </ul>

  <h3 style="color: #e67e22;">Defining Multiple Property Files</h3>
  <p style="color: #2c3e50;">
    Spring Boot loads properties from <code>application.properties</code> or <code>application.yml</code> by default. However, you can define additional property files as needed.
  </p>
  
  <h4 style="color: #8e44ad;">1. Creating Environment-Specific Property Files</h4>
  <p style="color: #2c3e50;">
    You can define separate property files for different environments:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      # application-dev.properties
      app.name=MyApp (Development)
      server.port=8081

      # application-prod.properties
      app.name=MyApp (Production)
      server.port=8080
    </code>
  </pre>
  
  <h4 style="color: #8e44ad;">2. Loading Additional Property Files</h4>
  <p style="color: #2c3e50;">
    You can explicitly load additional property files using <code>@PropertySource</code> in a Spring Boot configuration class:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      @PropertySource("classpath:custom-config.properties")
      public class AppConfig {
          @Value("\${custom.property}")
          private String customProperty;
      }
    </code>
  </pre>
  
  <h4 style="color: #8e44ad;">3. Using Profile-Specific Property Files</h4>
  <p style="color: #2c3e50;">
    To activate a specific profiles property file, set the profile in <code>application.properties</code> or via environment variables:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      spring.profiles.active=dev
    </code>
  </pre>
  
  <h3 style="color: #d35400;">Best Practices for Managing Multiple Property Files</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep environment-specific properties in separate files to avoid accidental overrides.</li>
    <li>Use <code>@PropertySource</code> to load custom configuration files when necessary.</li>
    <li>Leverage Spring Boots built-in profile support for managing multiple configurations.</li>
    <li>Use externalized configuration (e.g., environment variables) for sensitive data like passwords.</li>
    <li>Ensure consistency and documentation of property files for maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Using multiple property files in Spring Boot helps in managing configurations efficiently for different environments and modules.
     By separating concerns and leveraging profiles, developers can ensure flexibility, security, and better maintainability of their applications. Following best practices ensures smooth configuration management and hassle-free deployments.
  </p>
</div>`
},
{
  title:`Property Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Property Best Practices</h2>
  <p style="font-size: 16px; color: #34495e;">
    In software development, managing properties effectively is crucial for maintaining scalable and maintainable applications. Properties refer to configuration values such as database connection strings, API keys, and application settings. Following best practices ensures security, reliability, and ease of management.
  </p>

  <h3 style="color: #16a085;">1. Use External Configuration Files</h3>
  <p style="font-size: 16px; color: #34495e;">
    Instead of hardcoding property values within the source code, store them in external configuration files such as <code>application.properties</code> (Spring Boot) or <code>config.yaml</code>. This approach provides flexibility and keeps the source code clean.
  </p>

  <h4 style="color: #e67e22;">Example: Using a Properties File</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      database.url=jdbc:mysql://localhost:3306/mydb
      database.username=root
      database.password=securePass
    </code>
  </pre>

  <h3 style="color: #9b59b6;">2. Secure Sensitive Data</h3>
  <p style="font-size: 16px; color: #34495e;">
    Sensitive properties such as API keys and passwords should never be stored in plaintext. Use encryption, environment variables, or secure vaults like AWS Secrets Manager or HashiCorp Vault.
  </p>

  <h4 style="color: #e67e22;">Example: Storing Sensitive Data Securely</h4>
  <p style="color: #34495e;">
    Instead of hardcoding passwords in the properties file, use environment variables:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      database.password=\${DB_PASSWORD}
    </code>
  </pre>

  <h3 style="color: #2c3e50;">3. Organize Properties Logically</h3>
  <p style="font-size: 16px; color: #34495e;">
    Group related properties together to improve readability and maintainability. Use prefixes to categorize configurations properly.
  </p>

  <h4 style="color: #e67e22;">Example: Organized Properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      server.port=8080
      server.contextPath=/api
      
      database.url=jdbc:postgresql://localhost:5432/mydb
      database.username=admin
      database.password=\${DB_PASSWORD}
      
      api.key=ABCD1234XYZ
    </code>
  </pre>

  <h3 style="color: #9b59b6;">4. Use Profiles for Environment-Specific Configurations</h3>
  <p style="font-size: 16px; color: #34495e;">
    Different environments (development, testing, production) require different configurations. Use profiles to manage these variations.
  </p>

  <h4 style="color: #e67e22;">Example: Environment-Specific Properties</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      # application-dev.properties
      database.url=jdbc:mysql://localhost:3306/devdb

      # application-prod.properties
      database.url=jdbc:mysql://prod-db-server:3306/proddb
    </code>
  </pre>

  <h3 style="color: #2c3e50;">5. Validate and Monitor Property Values</h3>
  <p style="font-size: 16px; color: #34495e;">
    Always validate property values to prevent misconfigurations. Use monitoring tools to track changes and alerts in case of incorrect values.
  </p>

  <h3 style="color: #e67e22;">6. Document Property Usage</h3>
  <p style="color: #34495e;">
    Maintain proper documentation for properties, explaining their purpose, expected values, and usage. This helps new developers understand the configurations easily.
  </p>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    Following these best practices ensures that application properties are managed securely, efficiently, and in a scalable way. Proper organization, security, and documentation of properties lead to a more maintainable software system.
  </p>
</div>
`
},
{
  title:`@SpringBootApplication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding <code>@SpringBootApplication</code> in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@SpringBootApplication</code> annotation is a key component of Spring Boot applications. It serves as a combination of three core annotations—<code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, and <code>@ComponentScan</code>—making application setup and configuration simpler. This article explores its purpose, breakdown, and best practices in detail.
  </p>

  <h3 style="color: #16a085;">Why Use <code>@SpringBootApplication</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@SpringBootApplication</code> annotation simplifies Spring Boot application setup by:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reducing Boilerplate Code</strong>: Combines multiple annotations into one.</li>
    <li><strong>Enabling Auto-Configuration</strong>: Automatically configures beans based on dependencies.</li>
    <li><strong>Component Scanning</strong>: Scans and registers components in the application package.</li>
    <li><strong>Providing a Clean and Readable Setup</strong>: Encourages a convention-over-configuration approach.</li>
  </ul>

  <h3 style="color: #e67e22;">Breakdown of <code>@SpringBootApplication</code></h3>
  <p style="color: #2c3e50;">
    The <code>@SpringBootApplication</code> annotation is equivalent to using these three annotations separately:
  </p>
  
  <h4 style="color: #8e44ad;">1. <code>@Configuration</code></h4>
  <p style="color: #2c3e50;">
    Marks the class as a configuration class, allowing it to define bean methods.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class AppConfig {
          @Bean
          public MyService myService() {
              return new MyService();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. <code>@EnableAutoConfiguration</code></h4>
  <p style="color: #2c3e50;">
    Enables Spring Boot's auto-configuration feature, which automatically configures beans based on the dependencies in the classpath.
  </p>
  
  <h4 style="color: #8e44ad;">3. <code>@ComponentScan</code></h4>
  <p style="color: #2c3e50;">
    Scans the specified package and its sub-packages for Spring components such as controllers, services, and repositories.
  </p>
  
  <h3 style="color: #d35400;">Using <code>@SpringBootApplication</code></h3>
  <p style="color: #2c3e50;">
    In a typical Spring Boot application, the main class is annotated with <code>@SpringBootApplication</code>:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      
      @SpringBootApplication
      public class MyApplication {
          public static void main(String[] args) {
              SpringApplication.run(MyApplication.class, args);
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Keep the <code>@SpringBootApplication</code> annotation at the root package level to enable proper component scanning.</li>
    <li>Avoid placing business logic inside the main application class—use separate service and controller classes.</li>
    <li>Use <code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})</code> to disable specific auto-configurations.</li>
    <li>Enable debug logs using <code>spring.main.log-startup-info=true</code> in <code>application.properties</code> for better troubleshooting.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@SpringBootApplication</code> annotation simplifies the setup of Spring Boot applications by combining essential annotations into a single declaration. By understanding its components and best practices, developers can build clean, efficient, and scalable applications with ease.
  </p>
</div>
`
},
{
  title:`@RestController`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @RestController in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@RestController</code> annotation is a specialized version of <code>@Controller</code> used to create RESTful web services. It simplifies the process of building REST APIs by combining the functionalities of <code>@Controller</code> and <code>@ResponseBody</code>. This article explores the purpose, working mechanism, and best practices of using <code>@RestController</code> in Spring Boot.
  </p>

  <h3 style="color: #16a085;">What is @RestController?</h3>
  <p style="color: #2c3e50;">
    The <code>@RestController</code> annotation is a convenience annotation that marks a class as a RESTful controller. It eliminates the need to annotate each method with <code>@ResponseBody</code>, as it is applied at the class level and automatically converts returned objects into JSON or XML responses.
  </p>

  <h3 style="color: #e67e22;">How @RestController Works</h3>
  <p style="color: #2c3e50;">
    When a class is annotated with <code>@RestController</code>, Spring Boot registers it as a controller that handles HTTP requests. All the methods within this class return data directly instead of resolving to a view template. By default, Spring Boot uses Jackson to convert Java objects into JSON format.
  </p>

  <h3 style="color: #8e44ad;">Example of @RestController</h3>
  <p style="color: #2c3e50;">Here is a simple example demonstrating the usage of <code>@RestController</code>:</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      
      @RestController
      @RequestMapping("/api")
      public class HelloController {
        
          @GetMapping("/hello")
          public String sayHello() {
              return "Hello, Spring Boot!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Key Features of @RestController</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Combines @Controller and @ResponseBody</strong>: Simplifies REST API development.</li>
    <li><strong>JSON Response by Default</strong>: Automatically serializes Java objects into JSON.</li>
    <li><strong>Works with @RequestMapping and @GetMapping</strong>: Easily handles HTTP requests.</li>
    <li><strong>Supports Various Return Types</strong>: Can return primitive types, custom objects, or collections.</li>
  </ul>

  <h3 style="color: #8e44ad;">Handling Different HTTP Methods</h3>
  <p style="color: #2c3e50;">Spring Boot provides annotations to handle different HTTP request types:</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      @RequestMapping("/users")
      public class UserController {
          
          @GetMapping("/{id}")
          public String getUser(@PathVariable int id) {
              return "Fetching user with ID: " + id;
          }
          
          @PostMapping("/")
          public String createUser(@RequestBody User user) {
              return "User created: " + user.getName();
          }
          
          @PutMapping("/{id}")
          public String updateUser(@PathVariable int id, @RequestBody User user) {
              return "User " + id + " updated with name: " + user.getName();
          }
          
          @DeleteMapping("/{id}")
          public String deleteUser(@PathVariable int id) {
              return "User with ID " + id + " deleted.";
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #d35400;">Best Practices for Using @RestController</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@RestController</code> only for REST APIs; for traditional MVC, use <code>@Controller</code>.</li>
    <li>Structure APIs with meaningful endpoints and HTTP methods.</li>
    <li>Use <code>@RequestMapping</code> at the class level to define base URLs.</li>
    <li>Ensure proper exception handling using <code>@ExceptionHandler</code> or <code>@ControllerAdvice</code>.</li>
    <li>Utilize response entities (<code>ResponseEntity&lt;T&gt;</code>) for better control over response status codes.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@RestController</code> annotation simplifies the development of RESTful web services in Spring Boot. By combining the features of <code>@Controller</code> and <code>@ResponseBody</code>, it reduces boilerplate code and enhances productivity. Following best practices ensures maintainable and scalable APIs that adhere to RESTful principles.
  </p>
</div>`
},
{
  title:`@Controller`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding <code>@Controller</code> in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Controller</code> annotation is a fundamental part of the Model-View-Controller (MVC) pattern. It is used to define web controllers that handle HTTP requests and return views. Unlike <code>@RestController</code>, which returns JSON responses, <code>@Controller</code> is mainly used for rendering HTML pages using templates like Thymeleaf, JSP, or FreeMarker.
  </p>

  <h3 style="color: #16a085;">What is <code>@Controller</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@Controller</code> annotation marks a class as a Spring MVC controller. It works with view resolvers to return appropriate HTML responses to the client.
  </p>
  
  <h3 style="color: #e67e22;">Basic Usage of <code>@Controller</code></h3>
  <p style="color: #2c3e50;">
    A simple example of using <code>@Controller</code> to return an HTML view:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Controller
      public class HomeController {
          @GetMapping("/")
          public String home() {
              return "home"; // Returns home.html (Thymeleaf) or home.jsp
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Differences Between <code>@Controller</code> and <code>@RestController</code></h3>
  <table style="width:100%; border-collapse: collapse; text-align: left;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px; border: 1px solid #ddd;">@Controller</th>
      <th style="padding: 10px; border: 1px solid #ddd;">@RestController</th>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Used for handling web pages</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Used for RESTful web services</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Returns HTML views</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Returns JSON or XML responses</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Works with View Resolvers (Thymeleaf, JSP)</td>
      <td style="padding: 10px; border: 1px solid #ddd;">By default, returns response body</td>
    </tr>
  </table>

  <h3 style="color: #d35400;">Using <code>@Controller</code> with <code>Model</code></h3>
  <p style="color: #2c3e50;">
    You can pass data to views using the <code>Model</code> object:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Controller
      public class GreetingController {
          @GetMapping("/greeting")
          public String greeting(Model model) {
              model.addAttribute("message", "Welcome to Spring Boot!");
              return "greeting"; // Returns greeting.html
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Controller</code> annotation is essential for building traditional web applications in Spring Boot. It enables developers to handle web requests, integrate with view templates, and manage user interactions efficiently. When working with REST APIs, consider using <code>@RestController</code> instead for better JSON response handling.
  </p>
</div>`
},
{
  title:`@Service`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Service in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Service</code> annotation is a specialization of the <code>@Component</code> annotation. It is used to mark a class as a service layer component, indicating that it contains business logic. This annotation plays a vital role in the architecture of a Spring Boot application by managing service layer beans efficiently.
  </p>

  <h3 style="color: #16a085;">What is @Service?</h3>
  <p style="color: #2c3e50;">
    The <code>@Service</code> annotation is a stereotype annotation in Spring, used to indicate that a class is part of the service layer. It helps in defining business logic separately from the controller and repository layers, promoting a clean separation of concerns.
  </p>

  <h3 style="color: #e67e22;">Why Use @Service?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Encapsulation of Business Logic</strong>: Keeps business rules separate from other application layers.</li>
    <li><strong>Automatic Bean Detection</strong>: Allows Spring to detect and register service classes as beans.</li>
    <li><strong>Dependency Injection</strong>: Enables the use of <code>@Autowired</code> to inject dependencies into service classes.</li>
    <li><strong>Better Maintainability</strong>: Facilitates a clean separation between data access and presentation logic.</li>
  </ul>

  <h3 style="color: #d35400;">How to Use @Service?</h3>
  <p style="color: #2c3e50;">
    To define a service class in Spring Boot, simply annotate it with <code>@Service</code>.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class UserService {
          public String getUserDetails() {
              return "User details fetched successfully";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Injecting @Service in Other Components</h3>
  <p style="color: #2c3e50;">
    The <code>@Service</code> class can be injected into controllers or other services using <code>@Autowired</code>.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      public class UserController {
          private final UserService userService;
  
          @Autowired
          public UserController(UserService userService) {
              this.userService = userService;
          }
  
          @GetMapping("/user")
          public String getUser() {
              return userService.getUserDetails();
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #d35400;">Best Practices for Using @Service</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure business logic is placed inside service classes instead of controllers or repositories.</li>
    <li>Use dependency injection rather than creating new instances manually.</li>
    <li>Keep service classes focused on a single responsibility to maintain clarity.</li>
    <li>Leverage transactional management if dealing with database operations.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Service</code> annotation in Spring Boot is essential for structuring an application’s business logic effectively. By using it correctly, developers can ensure better maintainability, modularity, and testability of their applications.
  </p>
</div>
`
},
{
  title:`@Repository`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Repository in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Repository</code> annotation is a crucial part of the persistence layer. It is used to indicate that a class is responsible for data access and interacts with the database. Spring recognizes classes annotated with <code>@Repository</code> as DAO (Data Access Object) components and provides exception translation to handle database errors effectively.
  </p>

  <h3 style="color: #16a085;">Why Use @Repository?</h3>
  <p style="color: #2c3e50;">
    The <code>@Repository</code> annotation offers several advantages in Spring Boot applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Exception Translation</strong>: Converts database-specific exceptions into Spring’s <code>DataAccessException</code> hierarchy.</li>
    <li><strong>Data Access Layer Identification</strong>: Clearly defines classes that handle database operations.</li>
    <li><strong>Integration with Spring Data JPA</strong>: Works seamlessly with JPA repositories for CRUD operations.</li>
    <li><strong>Code Modularity</strong>: Separates business logic from database interactions for better maintainability.</li>
  </ul>

  <h3 style="color: #e67e22;">Using @Repository in Spring Boot</h3>
  <p style="color: #2c3e50;">
    To use <code>@Repository</code>, annotate a class that interacts with the database. Below is an example:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Repository;
      import org.springframework.data.jpa.repository.JpaRepository;

      @Repository
      public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
          Employee findByEmail(String email);
      }
    </code>
  </pre>
  
  <h3 style="color: #8e44ad;">Exception Handling with @Repository</h3>
  <p style="color: #2c3e50;">
    Spring automatically translates database-related exceptions into <code>DataAccessException</code> when using <code>@Repository</code>. For example:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class EmployeeService {
          @Autowired
          private EmployeeRepository employeeRepository;

          public Employee getEmployeeByEmail(String email) {
              try {
                  return employeeRepository.findByEmail(email);
              } catch (DataAccessException e) {
                  throw new RuntimeException("Error accessing database", e);
              }
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #d35400;">Best Practices for Using @Repository</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Repository</code> for DAO classes interacting with the database.</li>
    <li>Leverage Spring Data JPA to reduce boilerplate code for CRUD operations.</li>
    <li>Handle database exceptions effectively using Spring’s exception translation mechanism.</li>
    <li>Use custom query methods to optimize data retrieval.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Repository</code> annotation plays a vital role in separating the persistence layer in Spring Boot applications. It simplifies database interactions, provides exception translation, and enhances modularity. By following best practices, developers can build efficient and maintainable data access layers.
  </p>
</div>
`
},
{
  title:`@Component`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Component in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Component</code> annotation is a core part of the Spring Framework’s dependency injection mechanism. It is a generic stereotype annotation that marks a Java class as a Spring-managed bean, allowing the Spring container to detect and manage it automatically.
  </p>

  <h3 style="color: #16a085;">Why Use @Component?</h3>
  <p style="color: #2c3e50;">
    The <code>@Component</code> annotation provides several advantages in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automatic Bean Detection</strong>: Spring automatically detects and registers classes annotated with <code>@Component</code>.</li>
    <li><strong>Reusable and Maintainable Code</strong>: Reduces manual bean configuration in XML or Java-based configurations.</li>
    <li><strong>Supports Dependency Injection</strong>: Works seamlessly with Spring’s <code>@Autowired</code> to inject dependencies.</li>
    <li><strong>Foundation for Other Annotations</strong>: Annotations like <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> are specialized forms of <code>@Component</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">Using @Component in Spring Boot</h3>
  <p style="color: #2c3e50;">
    To use <code>@Component</code>, simply annotate a class that should be managed by Spring:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Component;

      @Component
      public class MyComponent {
          public void execute() {
              System.out.println("Executing MyComponent logic...");
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #8e44ad;">Injecting @Component into Other Beans</h3>
  <p style="color: #2c3e50;">
    A class annotated with <code>@Component</code> can be injected into other Spring-managed beans using <code>@Autowired</code>:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class MyService {
          private final MyComponent myComponent;

          @Autowired
          public MyService(MyComponent myComponent) {
              this.myComponent = myComponent;
          }

          public void performAction() {
              myComponent.execute();
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #d35400;">Best Practices for Using @Component</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Component</code> for generic utility classes that don’t fit under <code>@Service</code> or <code>@Repository</code>.</li>
    <li>Ensure package scanning includes the component to allow Spring to detect it.</li>
    <li>Prefer specialized annotations like <code>@Service</code> and <code>@Repository</code> for clarity and maintainability.</li>
    <li>Use dependency injection rather than manually instantiating <code>@Component</code> beans.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Component</code> annotation is a powerful feature in Spring Boot that enables automatic bean detection and dependency injection. It provides a simple way to manage application components while maintaining modularity and scalability. Following best practices ensures a clean and maintainable Spring application architecture.
  </p>
</div>
`
},
{
  title:`@Bean`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Bean in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Bean</code> annotation is used to define and configure Spring-managed beans manually. Unlike <code>@Component</code>, which relies on component scanning, <code>@Bean</code> is typically used inside a <code>@Configuration</code> class to create and customize beans programmatically. This approach is useful for integrating third-party libraries or when more control over bean creation is required.
  </p>

  <h3 style="color: #16a085;">Why Use @Bean?</h3>
  <p style="color: #2c3e50;">
    The <code>@Bean</code> annotation provides several advantages in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Explicit Bean Definition</strong>: Allows fine-grained control over bean creation and initialization.</li>
    <li><strong>Third-Party Integration</strong>: Useful for configuring beans that are not part of the application’s codebase.</li>
    <li><strong>Customization</strong>: Enables setting up bean dependencies manually with specific properties.</li>
    <li><strong>Lifecycle Management</strong>: Supports lifecycle callbacks like <code>initMethod</code> and <code>destroyMethod</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">Using @Bean in Spring Boot</h3>
  <p style="color: #2c3e50;">
    To use <code>@Bean</code>, define it inside a <code>@Configuration</code> class:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class AppConfig {

          @Bean
          public MyBean myBean() {
              return new MyBean();
          }
      }

      class MyBean {
          public void showMessage() {
              System.out.println("Hello from MyBean!");
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #8e44ad;">Injecting @Bean into Other Components</h3>
  <p style="color: #2c3e50;">
    Beans created using <code>@Bean</code> can be injected into other components using <code>@Autowired</code>:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class MyService {
          private final MyBean myBean;

          @Autowired
          public MyService(MyBean myBean) {
              this.myBean = myBean;
          }

          public void execute() {
              myBean.showMessage();
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #d35400;">Best Practices for Using @Bean</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Bean</code> when configuring third-party libraries or manually managing bean instantiation.</li>
    <li>Keep all <code>@Bean</code> definitions inside a dedicated <code>@Configuration</code> class.</li>
    <li>Leverage lifecycle methods (<code>initMethod</code> and <code>destroyMethod</code>) for proper resource management.</li>
    <li>Avoid unnecessary <code>@Bean</code> definitions for classes that can be handled with <code>@Component</code> scanning.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Bean</code> annotation is a powerful way to define Spring beans explicitly when more control over their creation and configuration is needed. It complements the component scanning approach and is particularly useful for integrating third-party dependencies. Following best practices ensures a clean and maintainable Spring application structure.
  </p>
</div>
`
},
{
  title:`@Configuration`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Configuration in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Configuration</code> annotation is used to define configuration classes that contain bean definitions. It is a key part of the Java-based configuration approach in Spring, replacing traditional XML-based configuration. Classes annotated with <code>@Configuration</code> are processed by the Spring container to register beans, manage dependencies, and set up the application context efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use @Configuration?</h3>
  <p style="color: #2c3e50;">
    The <code>@Configuration</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Java-Based Configuration</strong>: Eliminates the need for complex XML configuration files.</li>
    <li><strong>Improved Readability</strong>: Organizes configuration settings within a dedicated class.</li>
    <li><strong>Encapsulation</strong>: Groups related bean definitions in a structured way.</li>
    <li><strong>Explicit Bean Management</strong>: Allows manual bean creation and configuration.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @Configuration?</h3>
  <p style="color: #2c3e50;">
    To use <code>@Configuration</code>, create a class annotated with it and define beans using the <code>@Bean</code> annotation:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class AppConfig {

          @Bean
          public MyService myService() {
              return new MyService();
          }
      }

      class MyService {
          public void serve() {
              System.out.println("Service is running...");
          }
      }
    </code>
  </pre>
  
  <h3 style="color: #8e44ad;">Injecting Beans from @Configuration</h3>
  <p style="color: #2c3e50;">
    Beans defined in an <code>@Configuration</code> class can be injected into other components using <code>@Autowired</code>:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Component;

      @Component
      public class MyComponent {
          private final MyService myService;

          @Autowired
          public MyComponent(MyService myService) {
              this.myService = myService;
          }

          public void execute() {
              myService.serve();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using @Configuration with @ComponentScan</h3>
  <p style="color: #2c3e50;">
    The <code>@ComponentScan</code> annotation can be used with <code>@Configuration</code> to specify base packages for component scanning:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.ComponentScan;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      @ComponentScan(basePackages = "com.example.services")
      public class AppConfig {
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @Configuration</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@Configuration</code> to organize and manage bean definitions systematically.</li>
    <li>Define multiple configuration classes to separate concerns (e.g., database config, service config).</li>
    <li>Prefer Java-based configuration over XML for better maintainability.</li>
    <li>Use <code>@ComponentScan</code> wisely to avoid unnecessary component scanning.</li>
    <li>Ensure bean dependencies are correctly injected to avoid circular dependencies.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Configuration</code> annotation is a fundamental part of Spring Boot’s Java-based configuration, providing a clear and structured way to define beans and application settings. By leveraging <code>@Bean</code> along with <code>@Configuration</code>, developers can manage dependencies efficiently, ensuring a flexible and maintainable Spring Boot application.
  </p>
</div>
`
},
{
  title:`@ComponentScan`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @ComponentScan in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@ComponentScan</code> annotation is used to specify the base packages where Spring should scan for components, such as <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code>. By default, Spring Boot scans the package where the main application class is located and its sub-packages. However, <code>@ComponentScan</code> allows developers to customize the scanning path.
  </p>

  <h3 style="color: #16a085;">Why Use @ComponentScan?</h3>
  <p style="color: #2c3e50;">
    The <code>@ComponentScan</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Custom Package Scanning</strong>: Allows scanning specific packages outside the default package.</li>
    <li><strong>Modular Code Organization</strong>: Enables separating different application layers.</li>
    <li><strong>Improved Performance</strong>: Prevents unnecessary scanning of unused packages.</li>
    <li><strong>Flexible Configuration</strong>: Can be used with multiple packages for better component management.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @ComponentScan?</h3>
  <p style="color: #2c3e50;">
    To use <code>@ComponentScan</code>, annotate a configuration class (usually the main application class) with it and specify the packages to scan:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.context.annotation.ComponentScan;

      @SpringBootApplication
      @ComponentScan(basePackages = {"com.example.services", "com.example.repositories"})
      public class MyApplication {
          public static void main(String[] args) {
              SpringApplication.run(MyApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using @ComponentScan with Specific Classes</h3>
  <p style="color: #2c3e50;">
    Instead of specifying package names, you can reference specific component classes as well:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.ComponentScan;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      @ComponentScan(basePackageClasses = MyService.class)
      public class AppConfig {
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Filtering Components in @ComponentScan</h3>
  <p style="color: #2c3e50;">
    You can exclude specific classes or include only certain types of components using filters:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.ComponentScan;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.context.annotation.FilterType;

      @Configuration
      @ComponentScan(
          basePackages = "com.example",
          excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Deprecated.class)
      )
      public class AppConfig {
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @ComponentScan</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@ComponentScan</code> only when necessary, as Spring Boot already scans the main package by default.</li>
    <li>Organize components in structured packages to avoid unnecessary scanning.</li>
    <li>Use package-level scanning instead of scanning the entire application for better performance.</li>
    <li>Apply filters to include or exclude specific classes where needed.</li>
    <li>Ensure that custom package scanning does not conflict with the default component scanning behavior.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@ComponentScan</code> annotation plays a crucial role in managing Spring Boot applications by specifying which packages to scan for components. It helps in modularizing applications, improving performance, and maintaining clean, organized code. Proper use of <code>@ComponentScan</code> ensures efficient dependency injection and seamless component management.
  </p>
</div>
`
},
{
  title:`@Autowired`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Autowired in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Autowired</code> annotation is used for automatic dependency injection. It allows Spring to resolve and inject the required bean into a class without explicitly instantiating it. <code>@Autowired</code> simplifies the process of managing dependencies and promotes loose coupling in the application.
  </p>

  <h3 style="color: #16a085;">Why Use @Autowired?</h3>
  <p style="color: #2c3e50;">
    The <code>@Autowired</code> annotation provides several advantages in Spring applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automatic Dependency Injection</strong>: Eliminates the need for manual bean initialization.</li>
    <li><strong>Loose Coupling</strong>: Improves modularity by reducing direct dependencies between classes.</li>
    <li><strong>Readable and Maintainable Code</strong>: Reduces boilerplate code, making the application cleaner.</li>
    <li><strong>Supports Different Injection Types</strong>: Works with constructor, setter, and field-based injection.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @Autowired?</h3>
  <p style="color: #2c3e50;">
    The <code>@Autowired</code> annotation can be used in different ways, including field injection, constructor injection, and setter injection.
  </p>

  <h3 style="color: #8e44ad;">1. Field Injection (Direct Injection)</h3>
  <p style="color: #2c3e50;">
    The simplest way to use <code>@Autowired</code> is by directly injecting a dependency into a field.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          @Autowired
          private UserRepository userRepository;

          public void getUserDetails() {
              userRepository.findUser();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Constructor Injection (Recommended)</h3>
  <p style="color: #2c3e50;">
    Constructor injection is the preferred method because it makes dependencies immutable and easier to test.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          private final UserRepository userRepository;

          @Autowired
          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public void getUserDetails() {
              userRepository.findUser();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Setter Injection</h3>
  <p style="color: #2c3e50;">
    Setter injection is useful when dependencies are optional or can be changed at runtime.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          private UserRepository userRepository;

          @Autowired
          public void setUserRepository(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public void getUserDetails() {
              userRepository.findUser();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using @Autowired with Multiple Beans</h3>
  <p style="color: #2c3e50;">
    If there are multiple beans of the same type, you can specify which one to inject using <code>@Qualifier</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.beans.factory.annotation.Qualifier;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          private final UserRepository userRepository;

          @Autowired
          public UserService(@Qualifier("myUserRepository") UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public void getUserDetails() {
              userRepository.findUser();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @Autowired</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>constructor injection</strong> whenever possible for better testability and immutability.</li>
    <li>Use <strong>@Qualifier</strong> to resolve conflicts when multiple beans of the same type exist.</li>
    <li>Minimize field injection and prefer constructor-based dependency injection.</li>
    <li>Ensure that all required beans are properly annotated with <code>@Component</code>, <code>@Service</code>, or <code>@Repository</code>.</li>
    <li>Use setter injection for optional dependencies that can be modified dynamically.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Autowired</code> annotation is a powerful feature in Spring Boot for automatic dependency injection. By using it effectively, you can create modular, maintainable, and testable applications with minimal configuration. Understanding its different usage patterns helps in writing cleaner and more efficient code.
  </p>
</div>
`
},
{
  title:`@Value`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Value in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Value</code> annotation is used to inject values into fields from property files, environment variables, or system properties. This annotation is useful for configuring application settings dynamically without hardcoding values directly into the codebase.
  </p>

  <h3 style="color: #16a085;">Why Use @Value?</h3>
  <p style="color: #2c3e50;">
    The <code>@Value</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Externalized Configuration</strong>: Allows values to be managed outside the application code.</li>
    <li><strong>Flexibility</strong>: Supports property files, environment variables, and system properties.</li>
    <li><strong>Default Values</strong>: Provides a way to define fallback values.</li>
    <li><strong>SpEL Support</strong>: Enables Spring Expression Language (SpEL) for advanced expressions.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @Value?</h3>
  <p style="color: #2c3e50;">
    The <code>@Value</code> annotation can be used in different ways to inject values from various sources.
  </p>

  <h3 style="color: #8e44ad;">1. Injecting Values from application.properties</h3>
  <p style="color: #2c3e50;">
    The most common usage of <code>@Value</code> is to inject values from the <code>application.properties</code> or <code>application.yml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      app.name=MySpringApp
      app.version=1.0.0
    </code>
  </pre>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.stereotype.Component;

      @Component
      public class AppConfig {

          @Value("\${app.name}")
          private String appName;

          @Value("\${app.version}")
          private String appVersion;

          public void printConfig() {
              System.out.println("App Name: " + appName);
              System.out.println("App Version: " + appVersion);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Injecting Default Values</h3>
  <p style="color: #2c3e50;">
    If a property is missing, a default value can be specified.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Value("\${app.description:Default App Description}")
      private String appDescription;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Injecting Environment Variables</h3>
  <p style="color: #2c3e50;">
    The <code>@Value</code> annotation can also inject values from environment variables.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Value("\${HOME}")
      private String homeDirectory;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">4. Using SpEL (Spring Expression Language)</h3>
  <p style="color: #2c3e50;">
    <code>@Value</code> supports SpEL for more dynamic value injection.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Value("#{systemProperties['user.name']}")
      private String systemUser;
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @Value</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>externalized configuration</strong> to avoid hardcoding values.</li>
    <li>Define <strong>default values</strong> to handle missing properties.</li>
    <li>Use <strong>environment variables</strong> where necessary for dynamic configurations.</li>
    <li>Use <strong>SpEL</strong> for more complex expressions when required.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Value</code> annotation is a powerful feature in Spring Boot that simplifies property injection. By using it effectively, developers can create configurable and flexible applications with ease.
  </p>
</div>
`
},
{
  title:`@Qualifier`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Qualifier Annotation in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Framework, the <b>@Qualifier</b> annotation is used to resolve the ambiguity when multiple beans of the same type exist. It works in conjunction with <b>@Autowired</b> to specify exactly which bean should be injected when there are multiple candidates.
  </p>

  <h3 style="color: #16a085;">Why Do We Need @Qualifier?</h3>
  <p style="font-size: 16px; color: #34495e;">
    When using dependency injection, if multiple beans of the same type are present in the Spring context, the framework doesn’t know which bean to inject. The <b>@Qualifier</b> annotation helps in explicitly specifying which bean should be used to avoid <b>NoUniqueBeanDefinitionException</b>.
  </p>

  <h3 style="color: #9b59b6;">Using @Qualifier with @Autowired</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Qualifier</b> annotation is used along with <b>@Autowired</b> to define the specific bean to be injected.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.beans.factory.annotation.Qualifier;
      import org.springframework.stereotype.Component;

      @Component
      public class ServiceConsumer {
          private Service service;

          @Autowired
          public ServiceConsumer(@Qualifier("emailService") Service service) {
              this.service = service;
          }

          public void process() {
              service.execute();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Defining Multiple Beans</h3>
  <p style="font-size: 16px; color: #34495e;">
    Let’s define multiple beans implementing the same interface, and we’ll use <b>@Qualifier</b> to specify which one to inject.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Component;

      public interface Service {
          void execute();
      }

      @Component("emailService")
      public class EmailService implements Service {
          @Override
          public void execute() {
              System.out.println("Executing Email Service");
          }
      }

      @Component("smsService")
      public class SMSService implements Service {
          @Override
          public void execute() {
              System.out.println("Executing SMS Service");
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using @Qualifier in a Setter Method</h3>
  <p style="color: #34495e;">
    The <b>@Qualifier</b> annotation can also be used with setter methods to specify the exact bean to be injected.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.beans.factory.annotation.Qualifier;
      import org.springframework.stereotype.Component;

      @Component
      public class NotificationService {
          private Service service;

          @Autowired
          @Qualifier("smsService")
          public void setService(Service service) {
              this.service = service;
          }

          public void notifyUser() {
              service.execute();
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Using @Qualifier with List of Beans</h3>
  <p style="font-size: 16px; color: #34495e;">
    We can use <b>@Qualifier</b> with a list of beans to inject specific implementations.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.beans.factory.annotation.Qualifier;
      import org.springframework.stereotype.Component;

      import java.util.List;

      @Component
      public class BulkNotificationService {
          private List<Service> services;

          @Autowired
          public BulkNotificationService(@Qualifier("emailService") List<Service> services) {
              this.services = services;
          }

          public void notifyAllUsers() {
              services.forEach(Service::execute);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@Qualifier</b> annotation is a powerful tool in Spring for resolving bean injection conflicts. It ensures that the correct bean is injected when multiple beans of the same type exist. By using <b>@Qualifier</b> in constructors, setter methods, or lists, developers can effectively manage dependency injection in complex Spring applications.
  </p>
</div>
`
},
{
  title:`@Primary`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Primary Annotation in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, the <b>@Primary</b> annotation is used to resolve ambiguity when multiple beans of the same type exist in the application context. It allows Spring to automatically choose a primary bean to be injected when no specific bean name is mentioned.
  </p>

  <h3 style="color: #16a085;">Purpose of @Primary</h3>
  <p style="font-size: 16px; color: #34495e;">
    When multiple beans of the same type exist, Spring needs a way to determine which bean to inject. The <b>@Primary</b> annotation marks a particular bean as the preferred candidate, reducing the need to use the <b>@Qualifier</b> annotation explicitly.
  </p>

  <h4 style="color: #e67e22;">@Primary Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Primary;
      import org.springframework.stereotype.Component;
      
      interface PaymentService {
          void processPayment();
      }
      
      @Component
      @Primary // This bean will be the primary choice
      class CreditCardPayment implements PaymentService {
          public void processPayment() {
              System.out.println("Processing payment using Credit Card");
          }
      }
      
      @Component
      class PayPalPayment implements PaymentService {
          public void processPayment() {
              System.out.println("Processing payment using PayPal");
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Usage in Dependency Injection</h3>
  <p style="font-size: 16px; color: #34495e;">
    If multiple implementations of a bean exist, Spring injects the bean marked with <b>@Primary</b> automatically, unless another bean is explicitly specified using <b>@Qualifier</b>.
  </p>

  <h4 style="color: #e67e22;">Dependency Injection Example</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Component;
      
      @Component
      class PaymentProcessor {
          private final PaymentService paymentService;
          
          @Autowired
          public PaymentProcessor(PaymentService paymentService) {
              this.paymentService = paymentService;
          }
          
          public void process() {
              paymentService.processPayment();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">When to Use @Primary</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>When multiple beans of the same type exist, and one should be preferred by default.</li>
    <li>When you want to reduce the use of <b>@Qualifier</b> in multiple places.</li>
    <li>When you are working with autowiring and want Spring to resolve dependencies automatically.</li>
  </ul>

  <h3 style="color: #2c3e50;">@Primary vs @Qualifier</h3>
  <p style="font-size: 16px; color: #34495e;">
    While <b>@Primary</b> defines a default bean when multiple options exist, <b>@Qualifier</b> allows specifying a particular bean explicitly.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>@Primary:</b> Used for setting a default bean at a class level.</li>
    <li><b>@Qualifier:</b> Used for selecting a specific bean explicitly at the injection point.</li>
  </ul>

  <h3 style="color: #e67e22;">Example Combining @Primary and @Qualifier</h3>
  <p style="color: #34495e;">
    Even if a <b>@Primary</b> bean exists, you can still override it using <b>@Qualifier</b>.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Component
      class PaymentProcessor {
          private final PaymentService paymentService;
          
          @Autowired
          public PaymentProcessor(@Qualifier("payPalPayment") PaymentService paymentService) {
              this.paymentService = paymentService;
          }
          
          public void process() {
              paymentService.processPayment();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@Primary</b> annotation helps in resolving bean conflicts by setting a default bean when multiple beans of the same type exist. It works well for reducing the need for explicit bean names but can be overridden using <b>@Qualifier</b> when necessary.
  </p>
</div>`
},
{
  title:`@Lazy`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Lazy Annotation in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, the <b>@Lazy</b> annotation is used to control the initialization of beans. By default, Spring eagerly initializes beans at application startup. However, with <b>@Lazy</b>, we can defer the instantiation of a bean until it is actually needed, improving startup performance and resource efficiency.
  </p>

  <h3 style="color: #16a085;">What is @Lazy?</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Lazy</b> annotation is used to mark a bean so that it is not created at application startup but rather when it is first requested. This annotation can be applied at both the class and method levels.
  </p>

  <h4 style="color: #e67e22;">@Lazy at Class Level</h4>
  <p style="color: #34495e;">
    When applied at the class level, the entire bean will be lazily initialized.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Lazy;
      import org.springframework.stereotype.Component;

      @Component
      @Lazy
      public class LazyService {
          public LazyService() {
              System.out.println("LazyService Bean Initialized");
          }

          public void performTask() {
              System.out.println("Performing a task in LazyService");
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">@Lazy at Method Level</h4>
  <p style="color: #34495e;">
    When applied to a method inside a configuration class, it delays the initialization of the specific bean defined in that method.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.context.annotation.Lazy;

      @Configuration
      public class AppConfig {
          
          @Bean
          @Lazy
          public LazyService lazyService() {
              return new LazyService();
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">How @Lazy Works</h3>
  <p style="font-size: 16px; color: #34495e;">
    When a bean is marked with <b>@Lazy</b>, it is not instantiated during the application startup. Instead, it is created when requested for the first time. This behavior is particularly useful for optimizing application startup time.
  </p>

  <h3 style="color: #2c3e50;">@Lazy with @Autowired</h3>
  <p style="font-size: 16px; color: #34495e;">
    When using <b>@Autowired</b>, we can also use <b>@Lazy</b> to ensure that dependencies are injected lazily.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.context.annotation.Lazy;
      import org.springframework.stereotype.Component;

      @Component
      public class UserService {
          
          @Autowired
          @Lazy
          private LazyService lazyService;
          
          public void executeService() {
              lazyService.performTask();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Use Cases of @Lazy</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>To improve application startup time by deferring bean creation.</li>
    <li>To avoid unnecessary initialization of beans that might not be used immediately.</li>
    <li>To break cyclic dependencies between beans by delaying their instantiation.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@Lazy</b> annotation in Spring provides an efficient way to manage bean instantiation, helping to optimize application performance. By using <b>@Lazy</b> at the class, method, or field level, developers can defer the initialization of beans until they are required, reducing resource consumption and improving startup efficiency.
  </p>
</div>
`
},
{
  title:`@Scope`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Scope Annotation in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, the <b>@Scope</b> annotation is used to define the scope of a Spring bean. The scope determines the lifecycle and visibility of a bean within the Spring container. By default, Spring beans are <b>singleton</b>, meaning only one instance of the bean is created per Spring container.
  </p>

  <h3 style="color: #16a085;">Available Bean Scopes</h3>
  <p style="font-size: 16px; color: #34495e;">
    Spring provides several predefined scopes for beans:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Singleton (default):</b> A single instance of the bean is created per Spring container.</li>
    <li><b>Prototype:</b> A new instance is created every time the bean is requested.</li>
    <li><b>Request:</b> A new bean instance is created for each HTTP request (used in web applications).</li>
    <li><b>Session:</b> A single bean instance is created for each HTTP session.</li>
    <li><b>Application:</b> A single bean instance is created for the entire application.</li>
    <li><b>WebSocket:</b> A single bean instance is created for each WebSocket session.</li>
  </ul>

  <h3 style="color: #9b59b6;">Using @Scope Annotation</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Scope</b> annotation is used in conjunction with the <b>@Component</b> or <b>@Bean</b> annotation to specify the scope of a bean.
  </p>

  <h4 style="color: #e67e22;">Example: Singleton Scope (Default)</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Component;

      @Component
      public class SingletonBean {
          public SingletonBean() {
              System.out.println("SingletonBean instance created");
          }
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Example: Prototype Scope</h4>
  <p style="color: #34495e;">
    The prototype scope creates a new bean instance each time it is requested.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Scope;
      import org.springframework.stereotype.Component;

      @Component
      @Scope("prototype")
      public class PrototypeBean {
          public PrototypeBean() {
              System.out.println("PrototypeBean instance created");
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Differences Between Singleton and Prototype</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Singleton:</b> A single instance is maintained in the Spring container.</li>
    <li><b>Prototype:</b> A new instance is created each time it is requested.</li>
  </ul>

  <h3 style="color: #9b59b6;">Web Scopes (Request, Session, Application)</h3>
  <p style="color: #34495e;">
    For web applications, Spring provides additional scopes like <b>request</b> and <b>session</b>.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Scope;
      import org.springframework.stereotype.Component;

      @Component
      @Scope("request")
      public class RequestScopedBean {
          public RequestScopedBean() {
              System.out.println("RequestScopedBean instance created");
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@Scope</b> annotation is essential for defining the lifecycle of Spring beans. Understanding different scopes helps in designing scalable and efficient applications by managing bean instances appropriately.
  </p>
</div>
`
},
{
  title:`@RequestMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@RequestMapping in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@RequestMapping</b> annotation in Spring is used to map HTTP requests to handler methods in a controller class. It allows developers to define request paths, HTTP methods, headers, parameters, and more for handling web requests efficiently.
  </p>

  <h3 style="color: #16a085;">Basic Usage</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@RequestMapping</b> annotation can be applied at the class level and method level. At the class level, it specifies the base URL for all methods inside the controller, while at the method level, it defines specific endpoint mappings.
  </p>
  
  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class MyController {
          
          @RequestMapping("/hello")
          public String sayHello() {
              return "Hello, Spring!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Specifying HTTP Methods</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>method</b> attribute of <b>@RequestMapping</b> is used to specify the HTTP request type (GET, POST, PUT, DELETE, etc.).
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          
          @RequestMapping(value = "/get", method = RequestMethod.GET)
          public String getUser() {
              return "Fetching User";
          }
          
          @RequestMapping(value = "/create", method = RequestMethod.POST)
          public String createUser() {
              return "User Created";
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Using Path Variables</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@PathVariable</b> annotation is used to extract values from the URL and pass them as parameters to a handler method.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/products")
      public class ProductController {
          
          @RequestMapping("/{id}")
          public String getProduct(@PathVariable("id") int productId) {
              return "Product ID: " + productId;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using Request Parameters</h3>
  <p style="color: #34495e;">
    The <b>@RequestParam</b> annotation allows extracting query parameters from the URL.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/search")
      public class SearchController {
          
          @RequestMapping("/query")
          public String search(@RequestParam("keyword") String keyword) {
              return "Searching for: " + keyword;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Combining Multiple Attributes</h3>
  <p style="font-size: 16px; color: #34495e;">
    You can combine different attributes like <b>value</b>, <b>method</b>, <b>headers</b>, <b>params</b>, and <b>produces</b> in a single <b>@RequestMapping</b> annotation.
  </p>

  <h4 style="color: #e67e22;">Example:</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/orders")
      public class OrderController {
          
          @RequestMapping(value = "/status", method = RequestMethod.GET, produces = "application/json")
          public String getOrderStatus() {
              return "{\"status\": \"Processed\"}";
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@RequestMapping</b> annotation is a powerful tool in Spring for handling web requests. It allows defining routes, HTTP methods, path variables, query parameters, and response types efficiently, making it a cornerstone of Spring MVC development.
  </p>
</div>`
},
{
  title:`@GetMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@GetMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <b>@GetMapping</b> annotation is a specialized version of <b>@RequestMapping</b> that is used to handle HTTP GET requests. It is commonly used in RESTful web services to fetch resources from the server.
  </p>

  <h3 style="color: #16a085;">What is @GetMapping?</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@GetMapping</b> annotation is part of Spring Web MVC and is used to map HTTP GET requests to specific handler methods in a controller. It simplifies request mappings and improves code readability compared to using <b>@RequestMapping(method = RequestMethod.GET)</b>.
  </p>

  <h3 style="color: #e67e22;">Basic Usage of @GetMapping</h3>
  <p style="color: #34495e;">
    The following example demonstrates a basic usage of <b>@GetMapping</b>:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class MyController {
          
          @GetMapping("/hello")
          public String sayHello() {
              return "Hello, World!";
          }
      }
    </code>
  </pre>
  <p style="color: #34495e;">
    In this example, when a client makes a GET request to <code>/api/hello</code>, the method <code>sayHello()</code> is invoked, and it returns "Hello, World!" as the response.
  </p>

  <h3 style="color: #9b59b6;">Using Path Variables with @GetMapping</h3>
  <p style="color: #34495e;">
    You can use <b>@PathVariable</b> to handle dynamic URL parameters in a GET request.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.PathVariable;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          
          @GetMapping("/{id}")
          public String getUserById(@PathVariable("id") int userId) {
              return "User ID: " + userId;
          }
      }
    </code>
  </pre>
  <p style="color: #34495e;">
    A GET request to <code>/users/5</code> will return "User ID: 5" as the response.
  </p>

  <h3 style="color: #e67e22;">Using Request Parameters with @GetMapping</h3>
  <p style="color: #34495e;">
    The <b>@RequestParam</b> annotation is used to extract query parameters from the request URL.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestParam;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/search")
      public class SearchController {
          
          @GetMapping("/find")
          public String search(@RequestParam("query") String query) {
              return "Search results for: " + query;
          }
      }
    </code>
  </pre>
  <p style="color: #34495e;">
    A GET request to <code>/search/find?query=spring</code> will return "Search results for: spring" as the response.
  </p>

  <h3 style="color: #2c3e50;">Comparison: @GetMapping vs. @RequestMapping</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>@GetMapping</b> is a shortcut for <b>@RequestMapping(method = RequestMethod.GET)</b>.</li>
    <li><b>@RequestMapping</b> is more general and can handle multiple HTTP methods.</li>
    <li>Using <b>@GetMapping</b> makes the code more concise and readable when handling GET requests.</li>
  </ul>

  <h3 style="color: #e67e22;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@GetMapping</b> annotation in Spring Boot is a powerful tool for handling GET requests in RESTful APIs. It simplifies request mappings, supports path variables, query parameters, and improves code readability. By understanding how to use it effectively, developers can build clean and efficient web applications.
  </p>
</div>`
},
{
  title:`@PostMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@PostMapping Annotation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@PostMapping</b> annotation in Spring Boot is used to map HTTP <b>POST</b> requests onto specific handler methods in a controller. It simplifies the process of handling form submissions and API requests that send data to the server.
  </p>

  <h3 style="color: #16a085;">Understanding @PostMapping</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@PostMapping</b> annotation is a specialized version of <b>@RequestMapping</b> that is used for handling HTTP POST requests. It is commonly used in RESTful APIs where the client sends data to the server to create a new resource.
  </p>

  <h4 style="color: #e67e22;">Basic Usage of @PostMapping</h4>
  <p style="color: #34495e;">
    Below is an example demonstrating the use of <b>@PostMapping</b> to create a new user in a RESTful service:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;
      import org.springframework.http.HttpStatus;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          
          @PostMapping("/create")
          public ResponseEntity<String> createUser(@RequestBody User user) {
              // Logic to save user to the database
              return new ResponseEntity<>("User created successfully", HttpStatus.CREATED);
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Key Features of @PostMapping</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Handles HTTP POST requests:</b> Maps HTTP POST requests to a specific method.</li>
    <li><b>Used for creating resources:</b> Commonly used to create new records in databases.</li>
    <li><b>Works with @RequestBody:</b> Supports binding request body data to Java objects.</li>
    <li><b>Can return custom HTTP responses:</b> Allows specifying response status codes and messages.</li>
  </ul>

  <h3 style="color: #e67e22;">Using @PostMapping with @RequestBody</h3>
  <p style="color: #34495e;">
    The <b>@RequestBody</b> annotation is used with <b>@PostMapping</b> to automatically convert JSON data sent in the request body into a Java object.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @PostMapping("/add")
      public ResponseEntity<User> addUser(@RequestBody User user) {
          userService.save(user);
          return ResponseEntity.ok(user);
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">@PostMapping with @RequestParam</h3>
  <p style="color: #34495e;">
    The <b>@RequestParam</b> annotation can be used to retrieve form data submitted via a POST request.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @PostMapping("/register")
      public ResponseEntity<String> registerUser(@RequestParam String name, @RequestParam String email) {
          return ResponseEntity.ok("User registered: " + name + " (" + email + ")");
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Handling Form Submissions with @PostMapping</h3>
  <p style="color: #34495e;">
    When handling form data submissions in a Spring Boot web application, <b>@PostMapping</b> works well with <b>@ModelAttribute</b>.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @PostMapping("/submit")
      public String handleForm(@ModelAttribute User user) {
          return "User form submitted successfully!";
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@PostMapping</b> annotation is a powerful and convenient way to handle HTTP POST requests in Spring Boot. Whether you’re handling JSON requests with <b>@RequestBody</b>, processing form data with <b>@RequestParam</b> or <b>@ModelAttribute</b>, or creating new resources in a RESTful API, <b>@PostMapping</b> makes it easy to implement POST request handling in a clean and readable way.
  </p>
</div>
`
},
{
  title:`@PutMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@PutMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <b>@PutMapping</b> annotation is used to map HTTP <b>PUT</b> requests to specific handler methods in a REST controller. The PUT method is typically used for updating existing resources on the server. This annotation simplifies defining endpoints that accept PUT requests in a Spring Boot application.
  </p>

  <h3 style="color: #16a085;">Understanding @PutMapping</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@PutMapping</b> annotation is a specialized shortcut for <b>@RequestMapping</b> with the HTTP method set to <b>PUT</b>. It helps developers create RESTful APIs by specifying that the method should handle PUT requests for updating resources.
  </p>

  <h4 style="color: #e67e22;">Basic Usage</h4>
  <p style="color: #34495e;">
    Below is a simple example demonstrating how to use <b>@PutMapping</b> in a Spring Boot REST controller to update an existing resource:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;
      import java.util.HashMap;
      import java.util.Map;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          private Map&lt;Integer, String&gt; users = new HashMap&lt;&gt;();

          public UserController() {
              users.put(1, "John Doe");
              users.put(2, "Jane Doe");
          }

          @PutMapping("/{id}")
          public String updateUser(@PathVariable int id, @RequestBody String name) {
              if (users.containsKey(id)) {
                  users.put(id, name);
                  return "User updated successfully!";
              } else {
                  return "User not found!";
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Using @PutMapping with Request Parameters</h3>
  <p style="color: #34495e;">
    You can also use query parameters instead of a request body to update data. Here’s an example:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @PutMapping("/update")
      public String updateUserWithParams(@RequestParam int id, @RequestParam String name) {
          if (users.containsKey(id)) {
              users.put(id, name);
              return "User updated successfully!";
          } else {
              return "User not found!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Handling PUT Requests with DTOs</h3>
  <p style="color: #34495e;">
    A more structured approach to handling updates is by using Data Transfer Objects (DTOs). Here’s how you can do it:
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.web.bind.annotation.*;

      class UserDTO {
          private int id;
          private String name;

          // Getters and Setters
          public int getId() { return id; }
          public void setId(int id) { this.id = id; }
          public String getName() { return name; }
          public void setName(String name) { this.name = name; }
      }

      @PutMapping("/updateUser")
      public String updateUserWithDTO(@RequestBody UserDTO user) {
          if (users.containsKey(user.getId())) {
              users.put(user.getId(), user.getName());
              return "User updated successfully!";
          } else {
              return "User not found!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">@PutMapping vs @PostMapping</h3>
  <p style="color: #34495e;">
    Both <b>@PutMapping</b> and <b>@PostMapping</b> are used to send data to the server, but they serve different purposes:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>@PostMapping:</b> Used for creating new resources. Each request typically generates a new entity.</li>
    <li><b>@PutMapping:</b> Used for updating existing resources. The request must contain the complete data required for updating.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #34495e;">
    The <b>@PutMapping</b> annotation simplifies handling HTTP PUT requests in Spring Boot RESTful APIs. It is used to update existing resources using request bodies, request parameters, or DTOs. Understanding the difference between <b>@PutMapping</b> and <b>@PostMapping</b> ensures proper API design and better resource management in RESTful applications.
  </p>
</div>
`
},
{
  title:`@DeleteMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@DeleteMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <b>@DeleteMapping</b> is a specialized annotation used in Spring MVC controllers to handle HTTP DELETE requests. It is primarily used to delete resources from the server based on a specified identifier. This annotation simplifies RESTful API development by clearly defining delete operations.
  </p>

  <h3 style="color: #16a085;">Understanding @DeleteMapping</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@DeleteMapping</b> annotation is part of Spring’s RESTful framework and is used to map HTTP DELETE requests to specific handler methods in a controller. It helps in creating cleaner and more readable code by explicitly defining the delete operations.
  </p>

  <h4 style="color: #e67e22;">Basic Syntax</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @DeleteMapping("/users/{id}")
      public ResponseEntity<String> deleteUser(@PathVariable Long id) {
          userService.deleteUserById(id);
          return ResponseEntity.ok("User deleted successfully");
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Working with @DeleteMapping</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@DeleteMapping</b> annotation works similarly to other HTTP method mapping annotations like <b>@GetMapping</b> and <b>@PostMapping</b>. It is typically used in REST APIs to remove entities from the database.
  </p>

  <h4 style="color: #e67e22;">Example: Deleting a Resource</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/api/users")
      public class UserController {

          private final UserService userService;

          public UserController(UserService userService) {
              this.userService = userService;
          }

          @DeleteMapping("/{id}")
          public ResponseEntity<String> deleteUser(@PathVariable Long id) {
              boolean isDeleted = userService.deleteUserById(id);
              if (isDeleted) {
                  return ResponseEntity.ok("User deleted successfully");
              } else {
                  return ResponseEntity.status(404).body("User not found");
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Handling @DeleteMapping with Request Parameters</h3>
  <p style="font-size: 16px; color: #34495e;">
    You can also use <b>@RequestParam</b> instead of <b>@PathVariable</b> to pass the ID as a query parameter.
  </p>

  <h4 style="color: #e67e22;">Example Using @RequestParam</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @DeleteMapping("/delete")
      public ResponseEntity<String> deleteUserByRequestParam(@RequestParam Long id) {
          userService.deleteUserById(id);
          return ResponseEntity.ok("User deleted successfully");
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Key Points to Remember</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>@DeleteMapping</b> is used to map HTTP DELETE requests.</li>
    <li>It can be combined with <b>@PathVariable</b> or <b>@RequestParam</b> to pass the ID of the resource.</li>
    <li>It is commonly used in RESTful APIs to remove data from a database.</li>
    <li>It returns an appropriate HTTP response code such as <code>200 OK</code> or <code>404 Not Found</code>.</li>
    <li>Ensure that proper error handling is implemented for cases where the resource does not exist.</li>
  </ul>

  <h3 style="color: #9b59b6;">Conclusion</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@DeleteMapping</b> annotation is a crucial part of REST API development in Spring Boot. It allows for seamless deletion of resources using HTTP DELETE requests while maintaining clean and organized code. Proper handling of non-existent resources and response statuses ensures a robust API.
  </p>
</div>`
},
{
title:`@PatchMapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @PatchMapping in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@PatchMapping</code> annotation is used to handle HTTP PATCH requests. It is typically used for making partial updates to a resource, allowing clients to send only the fields that need modification instead of the entire entity.
  </p>

  <h3 style="color: #16a085;">Why Use @PatchMapping?</h3>
  <p style="color: #2c3e50;">
    The <code>@PatchMapping</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Partial Updates</strong>: Enables updating specific fields without modifying the entire resource.</li>
    <li><strong>Efficiency</strong>: Reduces data transfer by only sending changed fields.</li>
    <li><strong>RESTful Compliance</strong>: Aligns with HTTP methods semantics.</li>
    <li><strong>Flexibility</strong>: Works well with JSON Merge Patch and JSON Patch formats.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @PatchMapping?</h3>
  <p style="color: #2c3e50;">
    The <code>@PatchMapping</code> annotation is used in Spring Boot controllers to handle PATCH requests. It can be applied to update fields selectively.
  </p>

  <h3 style="color: #8e44ad;">1. Basic Example of @PatchMapping</h3>
  <p style="color: #2c3e50;">
    Consider a scenario where we have a user entity, and we want to update only some of its fields.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      @RequestMapping("/users")
      public class UserController {

          @Autowired
          private UserService userService;

          @PatchMapping("/{id}")
          public ResponseEntity&lt;User&gt; updateUser(@PathVariable Long id, @RequestBody Map&lt;String, Object&gt; updates) {
              User updatedUser = userService.updateUserFields(id, updates);
              return ResponseEntity.ok(updatedUser);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Handling Partial Updates in Service Layer</h3>
  <p style="color: #2c3e50;">
    The service layer should handle updating only the specified fields without overwriting the entire entity.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      public User updateUserFields(Long id, Map&lt;String, Object&gt; updates) {
          User user = userRepository.findById(id).orElseThrow(() -> new ResourceNotFoundException("User not found"));
          updates.forEach((key, value) -> {
              Field field = ReflectionUtils.findField(User.class, key);
              if (field != null) {
                  field.setAccessible(true);
                  ReflectionUtils.setField(field, user, value);
              }
          });
          return userRepository.save(user);
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Using @PatchMapping with JSON Merge Patch</h3>
  <p style="color: #2c3e50;">
    JSON Merge Patch allows clients to send only the fields they want to update. The server merges the changes into the existing entity.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @PatchMapping("/{id}")
      public ResponseEntity&lt;User&gt; patchUser(@PathVariable Long id, @RequestBody JsonMergePatch patch) {
          User updatedUser = userService.applyPatch(id, patch);
          return ResponseEntity.ok(updatedUser);
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @PatchMapping</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure validation of incoming data to prevent invalid updates.</li>
    <li>Use JSON Merge Patch or JSON Patch for structured updates.</li>
    <li>Handle exceptions gracefully for missing or incorrect fields.</li>
    <li>Use field reflection carefully to maintain security.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@PatchMapping</code> annotation in Spring Boot provides an efficient way to handle partial updates of resources. By leveraging JSON Patch and JSON Merge Patch, developers can create flexible and RESTful APIs that minimize data transfer while maintaining data integrity.
  </p>
</div>
`
},
{
  title:`@RequestParam`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @RequestParam in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@RequestParam</code> annotation is used to extract query parameters from HTTP requests. This annotation is particularly useful in REST APIs to handle user inputs via URL parameters efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use @RequestParam?</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestParam</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Simple Extraction</strong>: Easily retrieves values from query parameters.</li>
    <li><strong>Flexibility</strong>: Supports default values and required/optional parameters.</li>
    <li><strong>Type Conversion</strong>: Automatically converts string parameters into required data types.</li>
    <li><strong>Multiple Parameters</strong>: Handles multiple request parameters seamlessly.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @RequestParam?</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestParam</code> annotation is used in Spring Boot controller methods to bind query parameters from a URL.
  </p>

  <h3 style="color: #8e44ad;">1. Basic Usage</h3>
  <p style="color: #2c3e50;">
    A simple example of using <code>@RequestParam</code> in a controller method.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestParam;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      public class GreetingController {

          @GetMapping("/greet")
          public String greet(@RequestParam String name) {
              return "Hello, " + name + "!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Using Default Values</h3>
  <p style="color: #2c3e50;">
    If a query parameter is missing, a default value can be specified.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @GetMapping("/greet")
      public String greet(@RequestParam(defaultValue = "Guest") String name) {
          return "Hello, " + name + "!";
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Making Parameters Optional</h3>
  <p style="color: #2c3e50;">
    You can make a query parameter optional by setting <code>required = false</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @GetMapping("/greet")
      public String greet(@RequestParam(required = false) String name) {
          return name != null ? "Hello, " + name + "!" : "Hello, Guest!";
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">4. Handling Multiple Parameters</h3>
  <p style="color: #2c3e50;">
    You can use multiple <code>@RequestParam</code> annotations in a method to handle multiple query parameters.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @GetMapping("/user")
      public String getUser(@RequestParam String firstName, @RequestParam String lastName) {
          return "User: " + firstName + " " + lastName;
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @RequestParam</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>default values</strong> to handle missing parameters gracefully.</li>
    <li>Make parameters <strong>optional</strong> if they are not always required.</li>
    <li>Ensure proper <strong>type conversion</strong> for expected data types.</li>
    <li>Use multiple <code>@RequestParam</code> annotations to handle multiple inputs efficiently.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestParam</code> annotation simplifies handling query parameters in Spring Boot applications. By using it effectively, developers can create clean, flexible, and efficient REST APIs.
  </p>
</div>
`
},

{
  title:`@PathVariable`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @PathVariable in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@PathVariable</code> annotation is used to extract values from the URI path of an HTTP request and bind them to method parameters. This annotation is useful for handling RESTful endpoints where values are passed dynamically through the URL.
  </p>

  <h3 style="color: #16a085;">Why Use @PathVariable?</h3>
  <p style="color: #2c3e50;">
    The <code>@PathVariable</code> annotation offers several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Dynamic URL Mapping</strong>: Extracts values directly from the URL path.</li>
    <li><strong>Improved Readability</strong>: Makes RESTful APIs more intuitive and structured.</li>
    <li><strong>Type Conversion</strong>: Automatically converts path variables to the appropriate data type.</li>
    <li><strong>Flexible Parameter Handling</strong>: Allows single or multiple path variables.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @PathVariable?</h3>
  <p style="color: #2c3e50;">
    The <code>@PathVariable</code> annotation is commonly used in Spring Boot controllers to extract parameters from the URL.
  </p>

  <h3 style="color: #8e44ad;">1. Basic Usage</h3>
  <p style="color: #2c3e50;">
    You can use <code>@PathVariable</code> to capture values from the URL and use them in controller methods.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.stereotype.Controller;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @GetMapping("/{id}")
          public String getUserById(@PathVariable("id") int userId) {
              return "User ID: " + userId;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Multiple @PathVariable Parameters</h3>
  <p style="color: #2c3e50;">
    You can use multiple <code>@PathVariable</code> annotations to capture multiple values from the URL.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @GetMapping("/{category}/{id}")
      public String getItem(@PathVariable String category, @PathVariable int id) {
          return "Category: " + category + ", Item ID: " + id;
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Optional @PathVariable Parameters</h3>
  <p style="color: #2c3e50;">
    You can make a path variable optional by providing a default value.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @GetMapping({"/{id}", ""})
      public String getUser(@PathVariable(required = false) Integer id) {
          return id != null ? "User ID: " + id : "No ID provided";
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @PathVariable</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>descriptive path variables</strong> to enhance API readability.</li>
    <li>Ensure <strong>type conversion</strong> is handled properly to avoid runtime errors.</li>
    <li>Make use of <strong>optional parameters</strong> where needed for flexibility.</li>
    <li>Keep URLs <strong>RESTful</strong> by using nouns and logical endpoints.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@PathVariable</code> annotation in Spring Boot is a powerful way to extract values from the URL. By using it effectively, developers can create clean, structured, and flexible RESTful APIs.
  </p>
</div>
`
},
{
  title:`@RequestBody`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @RequestBody in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@RequestBody</code> annotation is used to map the HTTP request body to a Java object. It is particularly useful when handling incoming JSON or XML data in RESTful APIs.
  </p>

  <h3 style="color: #16a085;">Why Use @RequestBody?</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestBody</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automatic Conversion</strong>: Converts JSON/XML payloads to Java objects.</li>
    <li><strong>Ease of Use</strong>: Reduces the need for manual parsing.</li>
    <li><strong>Integration with Validation</strong>: Supports bean validation annotations.</li>
    <li><strong>Improved Readability</strong>: Simplifies the controller method signatures.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @RequestBody?</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestBody</code> annotation is commonly used in controller methods to process JSON payloads.
  </p>

  <h3 style="color: #8e44ad;">1. Basic Usage</h3>
  <p style="color: #2c3e50;">
    Here's a simple example of using <code>@RequestBody</code> in a Spring Boot REST controller.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/api")
      public class UserController {
          @PostMapping("/users")
          public String createUser(@RequestBody User user) {
              return "User " + user.getName() + " created successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Using @RequestBody with Validation</h3>
  <p style="color: #2c3e50;">
    The <code>@Valid</code> annotation can be used along with <code>@RequestBody</code> to validate incoming requests.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.Valid;
      import org.springframework.validation.annotation.Validated;

      @RestController
      @RequestMapping("/api")
      @Validated
      public class UserController {
          @PostMapping("/users")
          public String createUser(@Valid @RequestBody User user) {
              return "User " + user.getName() + " created successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Handling Errors Gracefully</h3>
  <p style="color: #2c3e50;">
    If the incoming JSON is malformed or invalid, Spring Boot can handle exceptions using <code>@ExceptionHandler</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @ControllerAdvice
      public class GlobalExceptionHandler {
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public ResponseEntity<String> handleValidationExceptions(MethodArgumentNotValidException ex) {
              return new ResponseEntity<>("Invalid input data", HttpStatus.BAD_REQUEST);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @RequestBody</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>DTO (Data Transfer Objects)</strong> to encapsulate request data.</li>
    <li>Enable <strong>validation</strong> to ensure data integrity.</li>
    <li>Handle <strong>exceptions</strong> to provide meaningful error responses.</li>
    <li>Use <strong>logging</strong> to track incoming request payloads for debugging.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@RequestBody</code> annotation simplifies the process of handling HTTP request bodies in Spring Boot applications. By using it effectively, developers can build robust and flexible REST APIs.
  </p>
</div>
`
},
{
  title:`@ResponseBody`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @ResponseBody in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@ResponseBody</code> annotation is used to indicate that the return value of a method should be serialized directly into the HTTP response body instead of being resolved as a view name. This annotation is typically used in RESTful web services to send JSON or XML responses.
  </p>

  <h3 style="color: #16a085;">Why Use @ResponseBody?</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseBody</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Direct Response</strong>: Returns the actual data rather than a view name.</li>
    <li><strong>REST API Support</strong>: Essential for building RESTful web services.</li>
    <li><strong>Automatic Serialization</strong>: Converts Java objects into JSON or XML responses.</li>
    <li><strong>Flexible Data Handling</strong>: Can be used with various return types like strings, objects, and collections.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @ResponseBody?</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseBody</code> annotation can be used in different ways within a Spring Boot controller.
  </p>

  <h3 style="color: #8e44ad;">1. Returning a Simple String</h3>
  <p style="color: #2c3e50;">
    A basic example of using <code>@ResponseBody</code> to return a simple string response.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.ResponseBody;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class HelloController {

          @GetMapping("/hello")
          @ResponseBody
          public String sayHello() {
              return "Hello, World!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Returning a JSON Response</h3>
  <p style="color: #2c3e50;">
    When returning an object, Spring Boot automatically converts it to JSON if Jackson is available in the classpath.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.ResponseBody;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class UserController {

          @GetMapping("/user")
          @ResponseBody
          public User getUser() {
              return new User("John Doe", 30);
          }
      }

      class User {
          private String name;
          private int age;

          public User(String name, int age) {
              this.name = name;
              this.age = age;
          }

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @ResponseBody</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@RestController</code> instead of <code>@Controller</code> + <code>@ResponseBody</code> for REST APIs.</li>
    <li>Ensure that the Jackson library is included for JSON serialization.</li>
    <li>Use proper exception handling to return meaningful error messages.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseBody</code> annotation is a powerful feature in Spring Boot that simplifies API development by automatically serializing Java objects into JSON responses. It is an essential tool for building modern RESTful applications.
  </p>
</div>
`
},
{
  title:`@ResponseStatus`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @ResponseStatus in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@ResponseStatus</code> annotation is used to specify the HTTP status code that should be returned from a controller method. This annotation is particularly useful when handling exceptions and customizing responses in a REST API.
  </p>

  <h3 style="color: #16a085;">Why Use @ResponseStatus?</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseStatus</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Custom HTTP Responses</strong>: Allows setting specific HTTP status codes for different controller methods.</li>
    <li><strong>Better Exception Handling</strong>: Enables defining meaningful HTTP status codes in exception handling.</li>
    <li><strong>Improved API Readability</strong>: Makes it clear what HTTP status a method returns without needing explicit <code>ResponseEntity</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @ResponseStatus?</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseStatus</code> annotation can be applied to controller methods and exception handler methods.
  </p>

  <h3 style="color: #8e44ad;">1. Using @ResponseStatus in a Controller Method</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseStatus</code> annotation can be used to define the HTTP status for a method.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class MyController {

          @GetMapping("/success")
          @ResponseStatus(HttpStatus.OK)
          public String successResponse() {
              return "Request was successful!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Using @ResponseStatus in Exception Handling</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseStatus</code> annotation can be used in custom exception classes to define HTTP status codes.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.annotation.ResponseStatus;

      @ResponseStatus(HttpStatus.NOT_FOUND)
      public class ResourceNotFoundException extends RuntimeException {
          public ResourceNotFoundException(String message) {
              super(message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @ResponseStatus</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>meaningful HTTP status codes</strong> to indicate the result of API calls.</li>
    <li>Use <strong>custom exceptions</strong> with <code>@ResponseStatus</code> for better error handling.</li>
    <li>Combine with <code>@ExceptionHandler</code> for a centralized exception-handling mechanism.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@ResponseStatus</code> annotation is a useful tool for defining HTTP status codes in Spring Boot applications. By using it effectively, developers can improve API consistency and enhance error handling.
  </p>
</div>
`
},
{
  title:`@CrossOrigin`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @CrossOrigin in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@CrossOrigin</code> annotation in Spring Boot is used to handle Cross-Origin Resource Sharing (CORS) issues. It allows web applications running on different domains to access resources from a Spring Boot backend.
  </p>

  <h3 style="color: #16a085;">Why Use @CrossOrigin?</h3>
  <p style="color: #2c3e50;">
    When building REST APIs, browsers enforce the same-origin policy, restricting requests from different origins. The <code>@CrossOrigin</code> annotation helps overcome this restriction.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Enables cross-origin requests</strong>: Allows frontend applications to access backend APIs.</li>
    <li><strong>Configurable</strong>: Can specify allowed origins, methods, and headers.</li>
    <li><strong>Supports global and method-level configuration</strong>: Can be applied at the class or method level.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @CrossOrigin?</h3>
  <p style="color: #2c3e50;">
    The <code>@CrossOrigin</code> annotation can be used at both the controller and method levels.
  </p>

  <h3 style="color: #8e44ad;">1. Applying @CrossOrigin at the Class Level</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.CrossOrigin;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      @CrossOrigin(origins = "http://example.com")
      public class ApiController {
          
          @GetMapping("/data")
          public String getData() {
              return "Cross-origin request successful!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Applying @CrossOrigin at the Method Level</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      @RequestMapping("/api")
      public class ApiController {
          
          @CrossOrigin(origins = "http://anotherdomain.com")
          @GetMapping("/info")
          public String getInfo() {
              return "Specific CORS configuration applied.";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Configuring Global CORS in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Instead of using <code>@CrossOrigin</code> on controllers, you can configure global CORS in a Spring Boot application.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.web.servlet.config.annotation.CorsRegistry;
      import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

      @Configuration
      public class CorsConfig {
          
          @Bean
          public WebMvcConfigurer corsConfigurer() {
              return new WebMvcConfigurer() {
                  @Override
                  public void addCorsMappings(CorsRegistry registry) {
                      registry.addMapping("/**").allowedOrigins("http://myfrontend.com");
                  }
              };
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @CrossOrigin</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Specify <strong>allowed origins</strong> to restrict access.</li>
    <li>Define <strong>allowed HTTP methods</strong> explicitly for security.</li>
    <li>Use <strong>global CORS configuration</strong> when needed for uniformity.</li>
    <li>Avoid using <strong>wildcard (*)</strong> origins in production for security reasons.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@CrossOrigin</code> annotation is an essential feature in Spring Boot to manage CORS policies and enable secure cross-origin requests. By configuring it properly, developers can ensure seamless communication between frontend and backend services.</p>
</div>
`
},
{
  title:`@ExceptionHandler`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @ExceptionHandler in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@ExceptionHandler</code> annotation is used to handle exceptions thrown by controller methods. It provides a centralized way to manage exceptions and return meaningful responses to clients.
  </p>

  <h3 style="color: #16a085;">Why Use @ExceptionHandler?</h3>
  <p style="color: #2c3e50;">
    The <code>@ExceptionHandler</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized Exception Handling</strong>: Allows handling exceptions in one place instead of multiple try-catch blocks.</li>
    <li><strong>Custom Error Responses</strong>: Returns user-friendly error messages.</li>
    <li><strong>Improved Code Readability</strong>: Reduces clutter in controller methods.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @ExceptionHandler?</h3>
  <p style="color: #2c3e50;">
    The <code>@ExceptionHandler</code> annotation can be used to define custom error handling logic for specific exception types.
  </p>

  <h3 style="color: #8e44ad;">1. Basic Example</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates handling a specific exception in a controller.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestControllerAdvice;

      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(IllegalArgumentException.class)
          @ResponseStatus(HttpStatus.BAD_REQUEST)
          public String handleIllegalArgumentException(IllegalArgumentException ex) {
              return "Error: " + ex.getMessage();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Handling Multiple Exceptions</h3>
  <p style="color: #2c3e50;">
    You can handle multiple exception types in a single method using an array.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @ExceptionHandler({NullPointerException.class, NumberFormatException.class})
      @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
      public String handleMultipleExceptions(Exception ex) {
          return "Unexpected error: " + ex.getMessage();
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Returning Custom Response Objects</h3>
  <p style="color: #2c3e50;">
    Instead of returning plain text messages, you can return custom error response objects.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      public class ErrorResponse {
          private String message;
          private int status;

          public ErrorResponse(String message, int status) {
              this.message = message;
              this.status = status;
          }

          // Getters and setters
      }

      @ExceptionHandler(RuntimeException.class)
      @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
      public ErrorResponse handleRuntimeException(RuntimeException ex) {
          return new ErrorResponse(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR.value());
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @ExceptionHandler</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>global exception handling</strong> with <code>@RestControllerAdvice</code> for better maintainability.</li>
    <li>Return <strong>meaningful error messages</strong> to clients.</li>
    <li>Log exceptions properly for debugging.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@ExceptionHandler</code> annotation is a powerful tool in Spring Boot for handling exceptions efficiently. By implementing proper exception handling strategies, developers can improve the user experience and application stability.
  </p>
</div>
`
},
{
  title:`@RestControllerAdvice`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @RestControllerAdvice in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@RestControllerAdvice</code> annotation in Spring Boot is a specialized version of <code>@ControllerAdvice</code> designed specifically for RESTful web services. It is used to handle global exceptions and apply cross-cutting concerns across multiple controllers in a centralized manner.
  </p>

  <h3 style="color: #16a085;">Why Use @RestControllerAdvice?</h3>
  <p style="color: #2c3e50;">
    The <code>@RestControllerAdvice</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized Exception Handling</strong>: Allows managing exceptions in one place instead of handling them in each controller separately.</li>
    <li><strong>Code Reusability</strong>: Reduces redundancy by applying error handling across multiple controllers.</li>
    <li><strong>Improved Readability</strong>: Makes the codebase cleaner by separating concerns.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @RestControllerAdvice?</h3>
  <p style="color: #2c3e50;">
    The <code>@RestControllerAdvice</code> annotation is typically used with <code>@ExceptionHandler</code> to catch and handle exceptions globally.
  </p>

  <h3 style="color: #8e44ad;">1. Basic Exception Handling</h3>
  <p style="color: #2c3e50;">
    A simple example of using <code>@RestControllerAdvice</code> to handle exceptions globally.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.RestControllerAdvice;
      import org.springframework.web.bind.annotation.ResponseStatus;

      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(IllegalArgumentException.class)
          @ResponseStatus(HttpStatus.BAD_REQUEST)
          public String handleIllegalArgumentException(IllegalArgumentException ex) {
              return "Error: " + ex.getMessage();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Handling Multiple Exceptions</h3>
  <p style="color: #2c3e50;">
    You can define multiple exception handlers in a single class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(NullPointerException.class)
          @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
          public String handleNullPointerException(NullPointerException ex) {
              return "Null value encountered!";
          }

          @ExceptionHandler(ArithmeticException.class)
          @ResponseStatus(HttpStatus.BAD_REQUEST)
          public String handleArithmeticException(ArithmeticException ex) {
              return "Math error: " + ex.getMessage();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Custom Error Response</h3>
  <p style="color: #2c3e50;">
    Instead of returning plain strings, you can create a structured error response.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      public class ErrorResponse {
          private String message;
          private int statusCode;

          public ErrorResponse(String message, int statusCode) {
              this.message = message;
              this.statusCode = statusCode;
          }

          public String getMessage() { return message; }
          public int getStatusCode() { return statusCode; }
      }
    </code>
  </pre>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ExceptionHandler(Exception.class)
          @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
          public ErrorResponse handleGenericException(Exception ex) {
              return new ErrorResponse(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR.value());
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @RestControllerAdvice</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>specific exception handlers</strong> before a generic handler.</li>
    <li>Return <strong>custom error responses</strong> instead of plain strings.</li>
    <li>Combine with <code>@ResponseStatus</code> for meaningful HTTP responses.</li>
    <li>Keep exception handlers <strong>organized</strong> to improve maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@RestControllerAdvice</code> annotation provides a powerful way to centralize exception handling in a Spring Boot REST API. By leveraging this feature, you can make your application more robust, maintainable, and user-friendly.
  </p>
</div>
`
},
{
  title:`@Transactional`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Transactional in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@Transactional</code> annotation in Spring is used to manage transactions declaratively. It ensures that a sequence of database operations is executed within a transaction context, providing ACID (Atomicity, Consistency, Isolation, Durability) properties.
  </p>

  <h3 style="color: #16a085;">Why Use @Transactional?</h3>
  <p style="color: #2c3e50;">
    The <code>@Transactional</code> annotation offers several benefits in Spring applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automatic Transaction Management</strong>: Eliminates manual transaction handling.</li>
    <li><strong>Rollback Support</strong>: Ensures consistency by rolling back on exceptions.</li>
    <li><strong>Declarative Approach</strong>: Simplifies transaction handling without boilerplate code.</li>
    <li><strong>Isolation and Propagation Control</strong>: Allows fine-grained control over transaction behavior.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @Transactional?</h3>
  <p style="color: #2c3e50;">
    The <code>@Transactional</code> annotation can be applied at the class or method level.
  </p>

  <h3 style="color: #8e44ad;">1. Applying @Transactional at Method Level</h3>
  <p style="color: #2c3e50;">
    The most common usage is to apply <code>@Transactional</code> on service methods that involve database operations.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class UserService {

          private final UserRepository userRepository;

          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          @Transactional
          public void registerUser(User user) {
              userRepository.save(user);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Applying @Transactional at Class Level</h3>
  <p style="color: #2c3e50;">
    If <code>@Transactional</code> is applied at the class level, all methods within the class will be transactional by default.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      @Transactional
      public class AccountService {
          
          private final AccountRepository accountRepository;
          
          public AccountService(AccountRepository accountRepository) {
              this.accountRepository = accountRepository;
          }
          
          public void updateAccountBalance(Long accountId, Double amount) {
              Account account = accountRepository.findById(accountId).orElseThrow();
              account.setBalance(account.getBalance() + amount);
              accountRepository.save(account);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Transaction Propagation and Isolation Levels</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Propagation</strong>: Defines how transactions relate to each other (e.g., REQUIRED, REQUIRES_NEW).</li>
    <li><strong>Isolation</strong>: Controls concurrency behavior (e.g., READ_COMMITTED, SERIALIZABLE).</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Transactional</code> annotation simplifies transaction management in Spring, ensuring data integrity and consistency. By using it effectively, developers can manage transactions declaratively with minimal effort.
  </p>
</div>
`
},
{
  title:`@EnableScheduling`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @EnableScheduling in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@EnableScheduling</code> annotation in Spring Boot is used to enable support for scheduled tasks. It allows developers to execute tasks at fixed intervals, specific times, or dynamically based on cron expressions.
  </p>

  <h3 style="color: #16a085;">Why Use @EnableScheduling?</h3>
  <p style="color: #2c3e50;">
    The <code>@EnableScheduling</code> annotation provides several benefits in a Spring Boot application:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automated Task Execution</strong>: Runs scheduled tasks without manual intervention.</li>
    <li><strong>Flexible Scheduling</strong>: Supports fixed rates, delays, and cron expressions.</li>
    <li><strong>Concurrency Control</strong>: Can be configured to prevent overlapping executions.</li>
    <li><strong>Improved Efficiency</strong>: Helps automate background tasks efficiently.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @EnableScheduling?</h3>
  <p style="color: #2c3e50;">
    The <code>@EnableScheduling</code> annotation is typically placed on a configuration class to activate scheduling support.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.scheduling.annotation.EnableScheduling;

      @Configuration
      @EnableScheduling
      public class SchedulerConfig {
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Scheduling a Task</h3>
  <p style="color: #2c3e50;">
    The <code>@Scheduled</code> annotation is used to define scheduled tasks.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.scheduling.annotation.Scheduled;
      import org.springframework.stereotype.Component;

      @Component
      public class ScheduledTask {

          @Scheduled(fixedRate = 5000) // Runs every 5 seconds
          public void executeTask() {
              System.out.println("Executing scheduled task at: " + new java.util.Date());
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using Cron Expressions</h3>
  <p style="color: #2c3e50;">
    You can use cron expressions for more precise scheduling.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Scheduled(cron = "0 0/1 * * * ?") // Runs every minute
      public void cronTask() {
          System.out.println("Executing cron task at: " + new java.util.Date());
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for @EnableScheduling</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>fixedRate</strong> or <strong>cron expressions</strong> wisely to avoid overlapping tasks.</li>
    <li>Ensure tasks do not consume excessive resources.</li>
    <li>Use <strong>asynchronous scheduling</strong> if tasks take a long time to execute.</li>
    <li>Enable logging to monitor scheduled tasks execution.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@EnableScheduling</code> annotation is a powerful feature in Spring Boot that facilitates automated task execution. By combining it with <code>@Scheduled</code>, developers can efficiently manage periodic tasks in their applications.
  </p>
</div>
`
},
{
  title:`@Scheduled`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Scheduled in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Scheduled</code> annotation is used to schedule tasks to run at fixed intervals, with a delay, or at specific times using cron expressions. It enables developers to automate repetitive tasks efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use @Scheduled?</h3>
  <p style="color: #2c3e50;">
    The <code>@Scheduled</code> annotation provides several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automated Task Execution</strong>: Eliminates the need for manual triggers.</li>
    <li><strong>Fixed-Rate Execution</strong>: Runs tasks at a regular interval.</li>
    <li><strong>Fixed-Delay Execution</strong>: Ensures a delay between executions.</li>
    <li><strong>Cron Expression Support</strong>: Allows scheduling with advanced patterns.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @Scheduled?</h3>
  <p style="color: #2c3e50;">
    To use <code>@Scheduled</code>, you need to enable scheduling in your Spring Boot application.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.scheduling.annotation.EnableScheduling;
      import org.springframework.scheduling.annotation.Scheduled;
      import org.springframework.stereotype.Component;

      @Component
      @EnableScheduling
      public class ScheduledTasks {

          @Scheduled(fixedRate = 5000)
          public void runAtFixedRate() {
              System.out.println("Task running at fixed rate of 5 seconds");
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Different Scheduling Strategies</h3>

  <h4 style="color: #8e44ad;">1. Fixed Rate Execution</h4>
  <p style="color: #2c3e50;">Runs the method at a fixed interval, regardless of execution time.</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Scheduled(fixedRate = 10000) // Executes every 10 seconds
      public void fixedRateTask() {
          System.out.println("Fixed rate task executed");
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Fixed Delay Execution</h4>
  <p style="color: #2c3e50;">Ensures a delay between the completion of one execution and the start of the next.</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Scheduled(fixedDelay = 7000) // Executes 7 seconds after last execution completion
      public void fixedDelayTask() {
          System.out.println("Fixed delay task executed");
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Using Cron Expressions</h4>
  <p style="color: #2c3e50;">Allows precise scheduling of tasks based on a cron pattern.</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Scheduled(cron = "0 0/5 * * * ?") // Runs every 5 minutes
      public void cronTask() {
          System.out.println("Cron-based scheduled task executed");
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @Scheduled</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>fixed delay</strong> if tasks take variable execution time.</li>
    <li>Prefer <strong>cron expressions</strong> for complex scheduling needs.</li>
    <li>Ensure the method is <strong>public</strong> and resides in a Spring-managed bean.</li>
    <li>Use <strong>asynchronous execution</strong> when necessary to avoid blocking.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Scheduled</code> annotation simplifies task scheduling in Spring Boot applications. By leveraging fixed rates, delays, or cron expressions, developers can automate repetitive processes efficiently.
  </p>
</div>
`
},
{
  title:`@EnableAsync`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @EnableAsync in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@EnableAsync</code> annotation in Spring Boot is used to enable asynchronous processing in an application. It allows methods to run in a separate thread without blocking the main execution flow, improving performance for tasks like I/O operations, database transactions, or background processing.
  </p>

  <h3 style="color: #16a085;">Why Use @EnableAsync?</h3>
  <p style="color: #2c3e50;">
    The <code>@EnableAsync</code> annotation provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improved Performance</strong>: Executes tasks in parallel without blocking the main thread.</li>
    <li><strong>Better Scalability</strong>: Allows applications to handle more requests simultaneously.</li>
    <li><strong>Non-Blocking Execution</strong>: Useful for I/O-intensive operations like API calls, database queries, and file processing.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @EnableAsync?</h3>
  <p style="color: #2c3e50;">
    To use <code>@EnableAsync</code>, follow these steps:
  </p>

  <h3 style="color: #8e44ad;">1. Enable Async Processing</h3>
  <p style="color: #2c3e50;">
    Add <code>@EnableAsync</code> to your Spring Boot configuration class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.scheduling.annotation.EnableAsync;

      @Configuration
      @EnableAsync
      public class AsyncConfig {
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Define an Asynchronous Method</h3>
  <p style="color: #2c3e50;">
    Use <code>@Async</code> to mark a method as asynchronous.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;

      @Service
      public class AsyncService {

          @Async
          public void asyncMethod() {
              System.out.println("Executing async method: " + Thread.currentThread().getName());
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Call the Asynchronous Method</h3>
  <p style="color: #2c3e50;">
    The method will run in a separate thread when called from another Spring-managed bean.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class AsyncController {

          @Autowired
          private AsyncService asyncService;

          @GetMapping("/execute")
          public String executeAsync() {
              asyncService.asyncMethod();
              return "Async method called!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @EnableAsync</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure that async methods are called from another Spring-managed bean.</li>
    <li>Use a custom executor if needed for better thread pool management.</li>
    <li>Handle exceptions properly as they may not be caught in the main thread.</li>
    <li>Avoid using <code>@Async</code> in the same class where the method is called.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@EnableAsync</code> annotation is a powerful feature in Spring Boot that allows for non-blocking method execution. When used correctly, it can greatly improve application performance and responsiveness.
  </p>
</div>
`
},
{
  title:`@Async`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Async in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Async</code> annotation is used to execute methods asynchronously. It enables the execution of time-consuming tasks in a separate thread, improving application performance and responsiveness.
  </p>

  <h3 style="color: #16a085;">Why Use @Async?</h3>
  <p style="color: #2c3e50;">
    The <code>@Async</code> annotation provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improves Performance</strong>: Runs tasks in the background without blocking the main thread.</li>
    <li><strong>Enhances Scalability</strong>: Handles multiple requests efficiently.</li>
    <li><strong>Better User Experience</strong>: Prevents UI or API delays for users.</li>
    <li><strong>Reduces Processing Time</strong>: Parallel execution speeds up operations.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @Async?</h3>
  <p style="color: #2c3e50;">
    The <code>@Async</code> annotation works with <code>@EnableAsync</code> to enable asynchronous execution in Spring Boot.
  </p>

  <h3 style="color: #8e44ad;">1. Enable Asynchronous Execution</h3>
  <p style="color: #2c3e50;">
    Add <code>@EnableAsync</code> to a configuration class to enable async processing.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.scheduling.annotation.EnableAsync;

      @Configuration
      @EnableAsync
      public class AsyncConfig {
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Using @Async in a Service</h3>
  <p style="color: #2c3e50;">
    Apply <code>@Async</code> to a method to execute it asynchronously.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;

      @Service
      public class AsyncService {

          @Async
          public void asyncMethod() {
              System.out.println("Executing task in: " + Thread.currentThread().getName());
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Returning a Future</h3>
  <p style="color: #2c3e50;">
    You can return a <code>CompletableFuture</code> to handle the result asynchronously.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import java.util.concurrent.CompletableFuture;
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;

      @Service
      public class AsyncService {

          @Async
          public CompletableFuture<String> asyncMethodWithReturn() {
              return CompletableFuture.completedFuture("Async Task Completed");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @Async</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure <strong>@EnableAsync</strong> is present to enable async execution.</li>
    <li>Use <strong>thread pools</strong> for better control over concurrent tasks.</li>
    <li>Handle <strong>exceptions</strong> properly in async methods to prevent silent failures.</li>
    <li>Use <strong>CompletableFuture</strong> for better control over async results.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Async</code> annotation is a powerful feature in Spring Boot that allows asynchronous execution of methods, enhancing performance and responsiveness. By using it effectively, developers can optimize resource usage and improve application efficiency.
  </p>
</div>
`
},
{
  title:`@Cacheable`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @Cacheable in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@Cacheable</code> annotation is used to enable caching for method results. It helps improve application performance by storing frequently accessed data in memory, reducing redundant method calls and database queries.
  </p>

  <h3 style="color: #16a085;">Why Use @Cacheable?</h3>
  <p style="color: #2c3e50;">
    The <code>@Cacheable</code> annotation provides several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Performance Improvement</strong>: Reduces redundant method executions and database hits.</li>
    <li><strong>Faster Response Time</strong>: Retrieves cached results instead of recomputing them.</li>
    <li><strong>Optimized Resource Usage</strong>: Lowers CPU and memory overhead by avoiding duplicate computations.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @Cacheable?</h3>
  <p style="color: #2c3e50;">
    To use <code>@Cacheable</code>, first enable caching in your Spring Boot application by adding the <code>@EnableCaching</code> annotation to the main class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cache.annotation.EnableCaching;

      @SpringBootApplication
      @EnableCaching
      public class CacheApplication {
          public static void main(String[] args) {
              SpringApplication.run(CacheApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Example of @Cacheable Usage</h3>
  <p style="color: #2c3e50;">
    The <code>@Cacheable</code> annotation can be applied to a method to store its results in the cache.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {

          @Cacheable("products")
          public Product getProductById(Long id) {
              // Simulate a slow database query
              try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); }
              return new Product(id, "Sample Product");
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Customizing Cache Behavior</h3>
  <p style="color: #2c3e50;">
    The <code>@Cacheable</code> annotation provides attributes to customize caching behavior.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Cacheable(value = "products", key = "#id", condition = "#id > 10")
      public Product getProductById(Long id) {
          return new Product(id, "Sample Product");
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @Cacheable</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@EnableCaching</strong> to activate caching.</li>
    <li>Ensure proper cache eviction policies to avoid stale data.</li>
    <li>Customize caching keys to prevent unwanted cache collisions.</li>
    <li>Monitor cache usage to optimize performance.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Cacheable</code> annotation is a powerful tool in Spring Boot that enhances application performance by storing method results in cache. By implementing caching efficiently, applications can improve response times and reduce database load significantly.
  </p>
</div>
`
},
{
  title:`@CachePut`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding @CachePut in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>@CachePut</code> annotation is used to update or refresh the cache with the latest method execution results. Unlike <code>@Cacheable</code>, which only caches results if they are not already in the cache, <code>@CachePut</code> always executes the method and updates the cache with the new value.
  </p>

  <h3 style="color: #16a085;">Why Use @CachePut?</h3>
  <p style="color: #2c3e50;">
    The <code>@CachePut</code> annotation provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensures Fresh Data</strong>: Updates the cache every time the method is called.</li>
    <li><strong>Improves Performance</strong>: Reduces redundant database updates.</li>
    <li><strong>Works Alongside @Cacheable</strong>: Helps maintain up-to-date cache while still leveraging caching benefits.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use @CachePut?</h3>
  <p style="color: #2c3e50;">
    To use <code>@CachePut</code>, ensure that caching is enabled in your Spring Boot application by adding <code>@EnableCaching</code> to the main class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cache.annotation.EnableCaching;

      @SpringBootApplication
      @EnableCaching
      public class CacheApplication {
          public static void main(String[] args) {
              SpringApplication.run(CacheApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Example of @CachePut Usage</h3>
  <p style="color: #2c3e50;">
    The <code>@CachePut</code> annotation is used to update the cache when a method is executed.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cache.annotation.CachePut;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {

          @CachePut(value = "products", key = "#product.id")
          public Product updateProduct(Product product) {
              // Simulate updating product in the database
              return product;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Customizing Cache Behavior</h3>
  <p style="color: #2c3e50;">
    The <code>@CachePut</code> annotation supports attributes to customize its behavior.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @CachePut(value = "products", key = "#product.id", condition = "#product.price > 100")
      public Product updateProduct(Product product) {
          return product;
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @CachePut</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@EnableCaching</strong> to activate caching.</li>
    <li>Ensure cache keys are unique to avoid unintended updates.</li>
    <li>Combine with <code>@Cacheable</code> for better cache management.</li>
    <li>Monitor cache performance to optimize resource usage.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@CachePut</code> annotation in Spring Boot is an essential tool for updating cached data while maintaining performance. It ensures that your application always has the latest data in the cache, reducing unnecessary database calls and improving response times.
  </p>
</div>
`
},
{
  title:`@CacheEvict`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to <code>@CacheEvict</code> in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching is a powerful technique to improve the performance of applications by storing frequently accessed data in memory. However, cached data can become stale when the underlying data changes. Spring Boot provides the <code>@CacheEvict</code> annotation to address this issue by allowing you to remove entries from the cache when they are no longer valid. This ensures that your application always serves up-to-date data while still benefiting from the performance advantages of caching.
  </p>

  <h3 style="color: #16a085;">Why Use <code>@CacheEvict</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@CacheEvict</code> annotation is essential for maintaining cache consistency and ensuring that your application serves accurate data. Key reasons to use it include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Cache Consistency</strong>: Ensures that outdated or invalid data is removed from the cache.</li>
    <li><strong>Performance Optimization</strong>: Prevents stale data from being served, improving the reliability of your application.</li>
    <li><strong>Flexibility</strong>: Allows you to evict specific entries or clear an entire cache.</li>
    <li><strong>Integration with Spring Cache</strong>: Works seamlessly with Spring's caching abstraction.</li>
    <li><strong>Improved User Experience</strong>: Ensures users always see the most up-to-date information.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of <code>@CacheEvict</code></h3>
  <p style="color: #2c3e50;">
    When working with <code>@CacheEvict</code>, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Cache Name</strong>: Specifies the cache from which entries should be evicted.</li>
    <li><strong>Key</strong>: Identifies the specific entry to evict. If not provided, all entries in the cache are evicted.</li>
    <li><strong>Condition</strong>: Allows you to evict entries based on a condition.</li>
    <li><strong>Before Invocation</strong>: Determines whether the eviction occurs before or after the method execution.</li>
    <li><strong>All Entries</strong>: Clears the entire cache when set to <code>true</code>.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using <code>@CacheEvict</code> in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use <code>@CacheEvict</code> in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Enable Caching</h4>
  <p style="color: #2c3e50;">
    Enable caching in your Spring Boot application using the <code>@EnableCaching</code> annotation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.EnableCaching;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      @EnableCaching
      public class CacheConfig {
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Define a Service with Caching</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Cacheable</code> annotation to cache method results and <code>@CacheEvict</code> to evict cache entries.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.CacheEvict;
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          @Cacheable("users")
          public User getUserById(Long id) {
              // Simulate fetching user from database
              System.out.println("Fetching user from database: " + id);
              return new User(id, "John Doe", "john.doe@example.com");
          }

          @CacheEvict(value = "users", key = "#id")
          public void updateUser(Long id, String name, String email) {
              // Simulate updating user in database
              System.out.println("Updating user: " + id);
          }

          @CacheEvict(value = "users", allEntries = true)
          public void clearAllUsersCache() {
              System.out.println("Clearing all users cache");
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Service in a Controller</h4>
  <p style="color: #2c3e50;">
    Use the service methods in a controller to demonstrate caching and cache eviction.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/users")
      public class UserController {

          @Autowired
          private UserService userService;

          @GetMapping("/{id}")
          public User getUserById(@PathVariable Long id) {
              return userService.getUserById(id);
          }

          @PutMapping("/{id}")
          public void updateUser(@PathVariable Long id, @RequestParam String name, @RequestParam String email) {
              userService.updateUser(id, name, email);
          }

          @DeleteMapping("/cache")
          public void clearCache() {
              userService.clearAllUsersCache();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using <code>@CacheEvict</code></h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@CacheEvict</code> in methods that modify data to ensure cache consistency.</li>
    <li>Specify the cache name and key to evict specific entries.</li>
    <li>Use <code>allEntries = true</code> to clear the entire cache when necessary.</li>
    <li>Combine <code>@CacheEvict</code> with <code>@Cacheable</code> to manage cache updates effectively.</li>
    <li>Test your caching logic to ensure that evictions occur as expected.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@CacheEvict</code> annotation is a powerful tool for maintaining cache consistency in Spring Boot applications. By evicting stale or invalid data from the cache, you can ensure that your application always serves accurate and up-to-date information. Whether you're evicting specific entries or clearing an entire cache, <code>@CacheEvict</code> provides the flexibility and control needed to manage caching effectively. By following best practices, you can optimize performance and improve the reliability of your application.
  </p>
</div>`
},
{
   title:`@EnableCaching`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@EnableCaching in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching is an essential technique for optimizing application performance by storing frequently accessed data in memory. Spring Boot provides built-in support for caching through the <b>@EnableCaching</b> annotation, which allows easy integration of various caching mechanisms into your application.
  </p>

  <h3 style="color: #16a085;">What is @EnableCaching?</h3>
  <p style="color: #2c3e50;">
    The <b>@EnableCaching</b> annotation is used to enable Spring’s annotation-driven caching mechanism. By applying this annotation to a configuration class, Spring Boot automatically detects cache-related annotations such as <b>@Cacheable</b>, <b>@CachePut</b>, and <b>@CacheEvict</b> to manage caching operations seamlessly.
  </p>

  <h4 style="color: #e67e22;">Basic Usage</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.EnableCaching;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      @EnableCaching
      public class CacheConfig {
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">How @EnableCaching Works</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>It scans for cache-related annotations in the application.</li>
    <li>Automatically configures a cache manager to store cached data.</li>
    <li>Supports various cache providers such as EhCache, Caffeine, Redis, and Hazelcast.</li>
    <li>Works seamlessly with Spring Boot’s caching abstraction.</li>
  </ul>

  <h3 style="color: #e67e22;">Using Caching in a Service</h3>
  <p style="color: #2c3e50;">
    Here’s an example of how caching can be enabled in a Spring Boot service class.
  </p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {

          @Cacheable("products")
          public Product getProductById(Long id) {
              System.out.println("Fetching product from database: " + id);
              return new Product(id, "Sample Product", 99.99);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Evicting Cached Data</h3>
  <p style="color: #2c3e50;">
    Cached data may become stale. Use <b>@CacheEvict</b> to remove old entries from the cache.
  </p>

  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cache.annotation.CacheEvict;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {

          @CacheEvict(value = "products", key = "#id")
          public void updateProduct(Long id, String name, double price) {
              System.out.println("Updating product: " + id);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <b>@EnableCaching</b> in the main configuration class.</li>
    <li>Select an appropriate cache provider based on your needs.</li>
    <li>Combine <b>@Cacheable</b> with <b>@CacheEvict</b> to maintain cache consistency.</li>
    <li>Test caching logic to ensure efficiency and correctness.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <b>@EnableCaching</b> annotation is a powerful feature in Spring Boot that simplifies cache management and boosts application performance. By leveraging caching techniques, you can reduce database queries, improve response times, and enhance scalability.
  </p>
</div>
`
  },
  {
    title:`@Entity`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Entity in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <b>@Entity</b> annotation is a key component of the Java Persistence API (JPA). It is used to mark a class as a persistent entity, meaning that instances of this class can be stored in a database. This annotation is typically applied to model classes that map to database tables.
  </p>

  <h3 style="color: #16a085;">Understanding @Entity</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Entity</b> annotation is used to define a class as a JPA entity, making it eligible for persistence operations using an ORM (Object-Relational Mapping) framework like Hibernate. It enables seamless interaction between Java objects and relational database tables.
  </p>

  <h4 style="color: #e67e22;">Basic Syntax</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          private Long id;
          private String name;
          private String email;
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Working with @Entity</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Entity</b> annotation works in conjunction with other JPA annotations such as <b>@Table</b>, <b>@Id</b>, and <b>@Column</b> to provide more control over how entities are mapped to database tables.
  </p>

  <h4 style="color: #e67e22;">Example: Defining an Entity with Additional Annotations</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(nullable = false)
          private String name;

          @Column(unique = true, nullable = false)
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Using @Entity with Spring Data JPA</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Entity</b> annotation is often used with Spring Data JPA repositories to perform CRUD operations without writing complex queries.
  </p>

  <h4 style="color: #e67e22;">Example: Creating a Repository</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;

      public interface UserRepository extends JpaRepository<User, Long> {
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Key Points to Remember</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>@Entity</b> is used to define a JPA entity class.</li>
    <li>It must be accompanied by an <b>@Id</b> field to specify the primary key.</li>
    <li>It can be used with <b>@Table</b>, <b>@Column</b>, and <b>@GeneratedValue</b> for better control over entity mapping.</li>
    <li>It enables seamless integration with Spring Data JPA for database operations.</li>
  </ul>

  <h3 style="color: #9b59b6;">Conclusion</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Entity</b> annotation is a fundamental part of JPA and Hibernate in Spring Boot applications. It simplifies the process of mapping Java objects to database tables, making data persistence more manageable. When combined with Spring Data JPA, it enables developers to efficiently perform CRUD operations with minimal boilerplate code.
  </p>
</div>
`
  },
  {
    title:`@Table`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Table Annotation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <b>@Table</b> annotation is part of the Java Persistence API (JPA) and is used to specify the name and properties of the database table that a JPA entity maps to. It provides customization options such as defining the table name, schema, and unique constraints, making it a powerful tool for managing database interactions efficiently.
  </p>

  <h3 style="color: #16a085;">Understanding @Table</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Table</b> annotation is placed above an entity class and is used to define how the entity should be mapped to a database table. If omitted, the table name defaults to the entity class name.
  </p>

  <h4 style="color: #e67e22;">Basic Syntax</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Using @Table for Customization</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Table</b> annotation allows additional configurations, such as setting schema, unique constraints, and indexes.
  </p>

  <h4 style="color: #e67e22;">Example: Customizing Table Name, Schema, and Constraints</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @Table(
          name = "customers",
          schema = "public",
          uniqueConstraints = {@UniqueConstraint(columnNames = {"email"})}
      )
      public class Customer {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;
          private String email;
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Defining Indexes with @Table</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Table</b> annotation also allows defining indexes to improve query performance.
  </p>

  <h4 style="color: #e67e22;">Example Using Indexes</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Entity
      @Table(
          name = "orders",
          indexes = {@Index(name = "idx_customer_id", columnList = "customer_id")}
      )
      public class Order {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(name = "customer_id")
          private Long customerId;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Key Points to Remember</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>@Table</b> is used to define database table properties in JPA.</li>
    <li>It allows specifying the table name, schema, constraints, and indexes.</li>
    <li>Omitting <b>@Table</b> causes the table name to default to the entity class name.</li>
    <li>Indexes and unique constraints improve database performance and integrity.</li>
  </ul>

  <h3 style="color: #9b59b6;">Conclusion</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Table</b> annotation in Spring Boot provides a way to customize database table mapping in JPA. By defining table names, schemas, constraints, and indexes, developers can optimize data management and performance in their applications. Proper usage of <b>@Table</b> ensures well-structured and efficient database interaction.
  </p>
</div>
`
  },
  {
    title:`@Id`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">@Id Annotation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot and JPA (Java Persistence API), the <b>@Id</b> annotation is used to specify the primary key of an entity. It is an essential part of defining entity relationships in a relational database and ensures that each record has a unique identifier.
  </p>

  <h3 style="color: #16a085;">Understanding @Id</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Id</b> annotation is part of the <code>javax.persistence</code> package and is used in combination with <b>@Entity</b> to mark a field as the primary key. This allows JPA to uniquely identify each record in the database table.
  </p>

  <h4 style="color: #e67e22;">Basic Usage</h4>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.Entity;
      import javax.persistence.Id;

      @Entity
      public class User {
          @Id
          private Long id;
          private String name;
          private String email;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #9b59b6;">Generating Primary Keys</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Id</b> annotation can be used with different strategies to generate primary key values automatically.
  </p>

  <h4 style="color: #e67e22;">Using @GeneratedValue</h4>
  <p style="font-size: 16px; color: #34495e;">
    To automatically generate unique IDs, you can use the <b>@GeneratedValue</b> annotation along with <b>@Id</b>.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import javax.persistence.*;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #e67e22;">Different Generation Strategies</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>GenerationType.IDENTITY</b>: Uses the database’s auto-increment feature.</li>
    <li><b>GenerationType.SEQUENCE</b>: Uses a database sequence to generate values.</li>
    <li><b>GenerationType.TABLE</b>: Uses a separate table to store ID values.</li>
    <li><b>GenerationType.AUTO</b>: Lets JPA decide the strategy based on the database.</li>
  </ul>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always define an <b>@Id</b> field in every JPA entity.</li>
    <li>Use <b>@GeneratedValue</b> for automatic primary key generation.</li>
    <li>Choose the appropriate <b>GenerationType</b> based on database requirements.</li>
    <li>Ensure that the primary key field is unique and indexed for better performance.</li>
  </ul>

  <h3 style="color: #9b59b6;">Conclusion</h3>
  <p style="font-size: 16px; color: #34495e;">
    The <b>@Id</b> annotation is a fundamental part of defining entities in Spring Boot with JPA. It ensures each record has a unique identifier, enabling efficient data retrieval and management. Combining it with <b>@GeneratedValue</b> provides flexibility in managing primary keys, making it easier to handle database records efficiently.
  </p>
</div>
`
  },
  {
    title:`@GeneratedValue`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@GeneratedValue</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot and JPA (Java Persistence API), the <code>@GeneratedValue</code> annotation is used to automatically generate
        primary key values for entity objects. It ensures uniqueness and avoids manual ID management.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@GeneratedValue</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Used with <code>@Id</code> to mark a field as the primary key.</li>
        <li>Supports different strategies for key generation: <code>IDENTITY</code>, <code>SEQUENCE</code>, <code>TABLE</code>, and <code>AUTO</code>.</li>
        <li>Ensures unique primary keys across entity instances.</li>
        <li>Works with relational databases through JPA providers like Hibernate.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Generation Strategies</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li><code>GenerationType.IDENTITY</code>: Relies on the database’s identity column (e.g., auto-increment).</li>
        <li><code>GenerationType.SEQUENCE</code>: Uses a database sequence object for generating unique values.</li>
        <li><code>GenerationType.TABLE</code>: Maintains a separate table for key generation (less common).</li>
        <li><code>GenerationType.AUTO</code>: Allows JPA to choose the best strategy based on the database.</li>
    </ul>
    
    <h3 style="color: #9b59b6;">Example: Using <code>@GeneratedValue</code> in an Entity</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            
            @Entity
            public class User {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                private String name;
                private String email;
                
                // Getters and Setters
                public Long getId() { return id; }
                public void setId(Long id) { this.id = id; }
                public String getName() { return name; }
                public void setName(String name) { this.name = name; }
                public String getEmail() { return email; }
                public void setEmail(String email) { this.email = email; }
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Using <code>GenerationType.SEQUENCE</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            
            @Entity
            public class Product {
                @Id
                @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "product_seq")
                @SequenceGenerator(name = "product_seq", sequenceName = "product_sequence", allocationSize = 1)
                private Long id;
                
                private String name;
                private double price;
                
                // Getters and Setters
                public Long getId() { return id; }
                public void setId(Long id) { this.id = id; }
                public String getName() { return name; }
                public void setName(String name) { this.name = name; }
                public double getPrice() { return price; }
                public void setPrice(double price) { this.price = price; }
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Choosing the Right Strategy</h3>
    <p style="color: #34495e;">
        The choice of <code>@GeneratedValue</code> strategy depends on the database being used:
    </p>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>For MySQL and PostgreSQL, <code>IDENTITY</code> is commonly used.</li>
        <li>For Oracle, <code>SEQUENCE</code> is preferred.</li>
        <li><code>AUTO</code> is a flexible choice but may lead to unexpected behaviors.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@GeneratedValue</code> annotation is crucial for managing primary keys in JPA entities efficiently. By selecting the appropriate generation strategy,
        developers can ensure smooth database operations and scalability in their Spring Boot applications.
    </p>
</div>
`
  },
  {
    title:`@Column`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to <code>@Column</code> in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@Column</code> annotation in JPA (Java Persistence API) is used to specify the mapping between a field in an entity class and a column in a database table. It allows you to customize the column's properties, such as its name, length, nullable constraint, and unique constraint. By using <code>@Column</code>, you can define how your entity fields are persisted in the database, ensuring that the database schema aligns with your application's requirements.
  </p>

  <h3 style="color: #16a085;">Why Use <code>@Column</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@Column</code> annotation is essential for fine-tuning the database schema and ensuring that your entity fields are mapped correctly. Key reasons to use it include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Custom Column Names</strong>: Map entity fields to database columns with different names.</li>
    <li><strong>Data Integrity</strong>: Enforce constraints like <code>nullable</code>, <code>unique</code>, and <code>length</code> to ensure data consistency.</li>
    <li><strong>Schema Control</strong>: Define the database schema directly in your entity classes.</li>
    <li><strong>Flexibility</strong>: Customize how fields are persisted without modifying the database manually.</li>
    <li><strong>Improved Readability</strong>: Make the mapping between entities and database columns explicit and clear.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of <code>@Column</code></h3>
  <p style="color: #2c3e50;">
    When working with the <code>@Column</code> annotation, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Column Name</strong>: Specifies the name of the database column.</li>
    <li><strong>Nullable</strong>: Determines whether the column can store <code>NULL</code> values.</li>
    <li><strong>Unique</strong>: Ensures that all values in the column are unique.</li>
    <li><strong>Length</strong>: Defines the maximum length of the column (for string fields).</li>
    <li><strong>Precision and Scale</strong>: Specifies the precision and scale for numeric columns.</li>
    <li><strong>Insertable and Updatable</strong>: Controls whether the column is included in <code>INSERT</code> and <code>UPDATE</code> statements.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using <code>@Column</code> in an Entity</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use the <code>@Column</code> annotation in a JPA entity.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity with <code>@Column</code></h4>
  <p style="color: #2c3e50;">
    Use the <code>@Column</code> annotation to customize the mapping of entity fields to database columns.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Column;
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {

          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @Column(name = "user_name", nullable = false, length = 50)
          private String name;

          @Column(unique = true, nullable = false)
          private String email;

          @Column(precision = 10, scale = 2)
          private Double salary;

          @Column(insertable = false, updatable = false)
          private String readOnlyField;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Explanation of <code>@Column</code> Attributes</h4>
  <p style="color: #2c3e50;">
    The <code>@Column</code> annotation in the example above uses the following attributes:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>name</strong>: Maps the <code>name</code> field to the <code>user_name</code> column in the database.</li>
    <li><strong>nullable</strong>: Ensures that the <code>name</code> and <code>email</code> fields cannot be <code>NULL</code>.</li>
    <li><strong>length</strong>: Limits the <code>name</code> field to 50 characters.</li>
    <li><strong>unique</strong>: Ensures that the <code>email</code> field contains unique values.</li>
    <li><strong>precision and scale</strong>: Defines the <code>salary</code> field as a numeric column with 10 digits, 2 of which are decimal places.</li>
    <li><strong>insertable and updatable</strong>: Makes the <code>readOnlyField</code> read-only by excluding it from <code>INSERT</code> and <code>UPDATE</code> statements.</li>
  </ul>

  <h4 style="color: #8e44ad;">3. Generate the Database Schema</h4>
  <p style="color: #2c3e50;">
    When you run the application, JPA will generate the database schema based on the entity definition. For example, the <code>User</code> entity might generate the following table:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-sql">
      CREATE TABLE User (
          id BIGINT PRIMARY KEY AUTO_INCREMENT,
          user_name VARCHAR(50) NOT NULL,
          email VARCHAR(255) NOT NULL UNIQUE,
          salary DECIMAL(10, 2),
          readOnlyField VARCHAR(255)
      );
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using <code>@Column</code></h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful column names that align with your database naming conventions.</li>
    <li>Enforce <code>nullable</code> and <code>unique</code> constraints to ensure data integrity.</li>
    <li>Set appropriate <code>length</code>, <code>precision</code>, and <code>scale</code> values to optimize storage and performance.</li>
    <li>Use <code>insertable</code> and <code>updatable</code> to control which fields can be modified.</li>
    <li>Document your entity mappings to make the schema clear for other developers.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Column</code> annotation is a powerful tool for defining how entity fields are mapped to database columns in JPA. By customizing column properties like name, length, nullable constraints, and more, you can ensure that your database schema aligns with your application's requirements. Whether you're building a new application or maintaining an existing one, using <code>@Column</code> effectively will help you create a robust and maintainable data access layer.
  </p>
</div>`
  },
  {
    title:`@OneToOne`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to <code>@OneToOne</code> in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@OneToOne</code> annotation in JPA (Java Persistence API) is used to define a one-to-one relationship between two entities. This means that one instance of an entity is associated with exactly one instance of another entity. For example, a <code>User</code> entity might have a one-to-one relationship with a <code>Profile</code> entity, where each user has exactly one profile. The <code>@OneToOne</code> annotation simplifies the management of such relationships and ensures that the database schema reflects the association correctly.
  </p>

  <h3 style="color: #16a085;">Why Use <code>@OneToOne</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@OneToOne</code> annotation is essential for modeling relationships where one entity is uniquely associated with another. Key reasons to use it include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures that the relationship between entities is maintained correctly in the database.</li>
    <li><strong>Simplified Management</strong>: Automatically handles the creation, updating, and deletion of related entities.</li>
    <li><strong>Flexibility</strong>: Supports both unidirectional and bidirectional relationships.</li>
    <li><strong>Improved Readability</strong>: Makes the relationship between entities explicit and easy to understand.</li>
    <li><strong>Efficient Queries</strong>: Allows you to fetch related entities efficiently using JPA queries.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of <code>@OneToOne</code></h3>
  <p style="color: #2c3e50;">
    When working with the <code>@OneToOne</code> annotation, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Unidirectional vs. Bidirectional</strong>: A unidirectional relationship is defined in only one entity, while a bidirectional relationship is defined in both entities.</li>
    <li><strong>Owner of the Relationship</strong>: In a bidirectional relationship, one entity is the owner (defined using <code>@JoinColumn</code>), and the other is the inverse side (defined using <code>mappedBy</code>).</li>
    <li><strong>Fetch Type</strong>: Determines whether the related entity is fetched eagerly (immediately) or lazily (on-demand).</li>
    <li><strong>Cascade Type</strong>: Specifies how operations (e.g., persist, merge, remove) are cascaded to the related entity.</li>
    <li><strong>Optional</strong>: Indicates whether the relationship is optional (can be <code>NULL</code>) or mandatory.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using <code>@OneToOne</code> in JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use the <code>@OneToOne</code> annotation in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define Entities with a Unidirectional Relationship</h4>
  <p style="color: #2c3e50;">
    Create two entities with a unidirectional one-to-one relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
          @JoinColumn(name = "profile_id", referencedColumnName = "id")
          private Profile profile;

          // Getters and Setters
      }

      @Entity
      public class Profile {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String bio;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Define Entities with a Bidirectional Relationship</h4>
  <p style="color: #2c3e50;">
    Create two entities with a bidirectional one-to-one relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
          private Profile profile;

          // Getters and Setters
      }

      @Entity
      public class Profile {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String bio;

          @OneToOne
          @JoinColumn(name = "user_id", referencedColumnName = "id")
          private User user;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Entities in a Service</h4>
  <p style="color: #2c3e50;">
    Use the entities in a service to demonstrate the one-to-one relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          @Autowired
          private UserRepository userRepository;

          public User createUserWithProfile(String name, String bio) {
              User user = new User();
              user.setName(name);

              Profile profile = new Profile();
              profile.setBio(bio);
              profile.setUser(user); // Set the user in the profile

              user.setProfile(profile); // Set the profile in the user
              return userRepository.save(user);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using <code>@OneToOne</code></h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@JoinColumn</code> to specify the foreign key column in the owner entity.</li>
    <li>Use <code>mappedBy</code> in the inverse side of a bidirectional relationship.</li>
    <li>Choose the appropriate <code>FetchType</code> (e.g., <code>LAZY</code> for performance optimization).</li>
    <li>Use <code>CascadeType</code> to manage the lifecycle of related entities.</li>
    <li>Ensure that the relationship is consistent by setting both sides of a bidirectional relationship.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@OneToOne</code> annotation is a powerful tool for modeling one-to-one relationships in JPA. Whether you're working with unidirectional or bidirectional relationships, <code>@OneToOne</code> simplifies the management of entity associations and ensures that your database schema reflects the relationships accurately. By following best practices, you can create efficient, maintainable, and consistent data models for your Spring Boot applications.
  </p>
</div>`
  },
  {
    title:`@OneToMany`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to <code>@OneToMany</code> in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@OneToMany</code> annotation in JPA (Java Persistence API) is used to define a one-to-many relationship between two entities. This means that one instance of an entity is associated with multiple instances of another entity. For example, a <code>Department</code> entity might have a one-to-many relationship with an <code>Employee</code> entity, where one department can have many employees. The <code>@OneToMany</code> annotation simplifies the management of such relationships and ensures that the database schema reflects the association correctly.
  </p>

  <h3 style="color: #16a085;">Why Use <code>@OneToMany</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@OneToMany</code> annotation is essential for modeling relationships where one entity is associated with multiple instances of another entity. Key reasons to use it include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures that the relationship between entities is maintained correctly in the database.</li>
    <li><strong>Simplified Management</strong>: Automatically handles the creation, updating, and deletion of related entities.</li>
    <li><strong>Flexibility</strong>: Supports both unidirectional and bidirectional relationships.</li>
    <li><strong>Improved Readability</strong>: Makes the relationship between entities explicit and easy to understand.</li>
    <li><strong>Efficient Queries</strong>: Allows you to fetch related entities efficiently using JPA queries.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of <code>@OneToMany</code></h3>
  <p style="color: #2c3e50;">
    When working with the <code>@OneToMany</code> annotation, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Unidirectional vs. Bidirectional</strong>: A unidirectional relationship is defined in only one entity, while a bidirectional relationship is defined in both entities.</li>
    <li><strong>Owner of the Relationship</strong>: In a bidirectional relationship, the "many" side is typically the owner (defined using <code>@ManyToOne</code>), and the "one" side is the inverse side (defined using <code>mappedBy</code>).</li>
    <li><strong>Fetch Type</strong>: Determines whether the related entities are fetched eagerly (immediately) or lazily (on-demand).</li>
    <li><strong>Cascade Type</strong>: Specifies how operations (e.g., persist, merge, remove) are cascaded to the related entities.</li>
    <li><strong>Orphan Removal</strong>: Automatically removes orphaned entities (entities that are no longer referenced).</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using <code>@OneToMany</code> in JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use the <code>@OneToMany</code> annotation in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define Entities with a Unidirectional Relationship</h4>
  <p style="color: #2c3e50;">
    Create two entities with a unidirectional one-to-many relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;
      import java.util.List;

      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
          @JoinColumn(name = "department_id") // Foreign key in the Employee table
          private List&lt;Employee&gt; employees;

          // Getters and Setters
      }

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Define Entities with a Bidirectional Relationship</h4>
  <p style="color: #2c3e50;">
    Create two entities with a bidirectional one-to-many relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;
      import java.util.List;

      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
          private List&lt;Employee&gt; employees;

          // Getters and Setters
      }

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Entities in a Service</h4>
  <p style="color: #2c3e50;">
    Use the entities in a service to demonstrate the one-to-many relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class DepartmentService {

          @Autowired
          private DepartmentRepository departmentRepository;

          public Department createDepartmentWithEmployees(String name, List&lt;String&gt; employeeNames) {
              Department department = new Department();
              department.setName(name);

              for (String empName : employeeNames) {
                  Employee employee = new Employee();
                  employee.setName(empName);
                  employee.setDepartment(department); // Set the department in the employee
                  department.getEmployees().add(employee); // Add the employee to the department
              }

              return departmentRepository.save(department);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using <code>@OneToMany</code></h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>mappedBy</code> in the "one" side of a bidirectional relationship to avoid duplicate foreign keys.</li>
    <li>Choose the appropriate <code>FetchType</code> (e.g., <code>LAZY</code> for performance optimization).</li>
    <li>Use <code>CascadeType</code> to manage the lifecycle of related entities.</li>
    <li>Enable <code>orphanRemoval</code> to automatically remove orphaned entities.</li>
    <li>Ensure that the relationship is consistent by setting both sides of a bidirectional relationship.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@OneToMany</code> annotation is a powerful tool for modeling one-to-many relationships in JPA. Whether you're working with unidirectional or bidirectional relationships, <code>@OneToMany</code> simplifies the management of entity associations and ensures that your database schema reflects the relationships accurately. By following best practices, you can create efficient, maintainable, and consistent data models for your Spring Boot applications.
  </p>
</div>`
  },
  {
    title:`@ManyToOne`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to <code>@ManyToOne</code> in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@ManyToOne</code> annotation in JPA (Java Persistence API) is used to define a many-to-one relationship between two entities. This means that multiple instances of one entity can be associated with a single instance of another entity. For example, multiple <code>Employee</code> entities might be associated with a single <code>Department</code> entity, where many employees belong to one department. The <code>@ManyToOne</code> annotation simplifies the management of such relationships and ensures that the database schema reflects the association correctly.
  </p>

  <h3 style="color: #16a085;">Why Use <code>@ManyToOne</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@ManyToOne</code> annotation is essential for modeling relationships where multiple instances of one entity are associated with a single instance of another entity. Key reasons to use it include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures that the relationship between entities is maintained correctly in the database.</li>
    <li><strong>Simplified Management</strong>: Automatically handles the creation, updating, and deletion of related entities.</li>
    <li><strong>Flexibility</strong>: Supports both unidirectional and bidirectional relationships.</li>
    <li><strong>Improved Readability</strong>: Makes the relationship between entities explicit and easy to understand.</li>
    <li><strong>Efficient Queries</strong>: Allows you to fetch related entities efficiently using JPA queries.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of <code>@ManyToOne</code></h3>
  <p style="color: #2c3e50;">
    When working with the <code>@ManyToOne</code> annotation, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Unidirectional vs. Bidirectional</strong>: A unidirectional relationship is defined in only one entity, while a bidirectional relationship is defined in both entities.</li>
    <li><strong>Owner of the Relationship</strong>: In a bidirectional relationship, the "many" side is typically the owner (defined using <code>@ManyToOne</code>), and the "one" side is the inverse side (defined using <code>mappedBy</code>).</li>
    <li><strong>Fetch Type</strong>: Determines whether the related entity is fetched eagerly (immediately) or lazily (on-demand).</li>
    <li><strong>Cascade Type</strong>: Specifies how operations (e.g., persist, merge, remove) are cascaded to the related entity.</li>
    <li><strong>Join Column</strong>: Specifies the foreign key column in the database.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using <code>@ManyToOne</code> in JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use the <code>@ManyToOne</code> annotation in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define Entities with a Unidirectional Relationship</h4>
  <p style="color: #2c3e50;">
    Create two entities with a unidirectional many-to-one relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;

          // Getters and Setters
      }

      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Define Entities with a Bidirectional Relationship</h4>
  <p style="color: #2c3e50;">
    Create two entities with a bidirectional many-to-one relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.*;
      import java.util.List;

      @Entity
      public class Employee {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @ManyToOne
          @JoinColumn(name = "department_id")
          private Department department;

          // Getters and Setters
      }

      @Entity
      public class Department {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;

          @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
          private List&lt;Employee&gt; employees;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Entities in a Service</h4>
  <p style="color: #2c3e50;">
    Use the entities in a service to demonstrate the many-to-one relationship.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class DepartmentService {

          @Autowired
          private DepartmentRepository departmentRepository;

          public Department createDepartmentWithEmployees(String name, List&lt;String&gt; employeeNames) {
              Department department = new Department();
              department.setName(name);

              for (String empName : employeeNames) {
                  Employee employee = new Employee();
                  employee.setName(empName);
                  employee.setDepartment(department); // Set the department in the employee
                  department.getEmployees().add(employee); // Add the employee to the department
              }

              return departmentRepository.save(department);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using <code>@ManyToOne</code></h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@JoinColumn</code> to specify the foreign key column in the database.</li>
    <li>Choose the appropriate <code>FetchType</code> (e.g., <code>LAZY</code> for performance optimization).</li>
    <li>Use <code>CascadeType</code> to manage the lifecycle of related entities.</li>
    <li>Ensure that the relationship is consistent by setting both sides of a bidirectional relationship.</li>
    <li>Use <code>mappedBy</code> in the "one" side of a bidirectional relationship to avoid duplicate foreign keys.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@ManyToOne</code> annotation is a powerful tool for modeling many-to-one relationships in JPA. Whether you're working with unidirectional or bidirectional relationships, <code>@ManyToOne</code> simplifies the management of entity associations and ensures that your database schema reflects the relationships accurately. By following best practices, you can create efficient, maintainable, and consistent data models for your Spring Boot applications.
  </p>
</div>`
  },
  {
    title:`@ManyToMany`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@ManyToMany</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot and JPA (Java Persistence API), the <code>@ManyToMany</code> annotation is used to establish a many-to-many relationship
        between two entities. It helps manage complex associations efficiently in relational databases.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@ManyToMany</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Defines a many-to-many association between two entities.</li>
        <li>Requires a join table to store the relationship.</li>
        <li>Can be unidirectional or bidirectional.</li>
        <li>Uses <code>@JoinTable</code> to define the join table details.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Unidirectional <code>@ManyToMany</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            import java.util.Set;
            
            @Entity
            public class Student {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                private String name;
                
                @ManyToMany
                @JoinTable(
                    name = "student_course",
                    joinColumns = @JoinColumn(name = "student_id"),
                    inverseJoinColumns = @JoinColumn(name = "course_id")
                )
                private Set<Course> courses;
                
                // Getters and Setters
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Bidirectional <code>@ManyToMany</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            import java.util.Set;
            
            @Entity
            public class Course {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                private String title;
                
                @ManyToMany(mappedBy = "courses")
                private Set<Student> students;
                
                // Getters and Setters
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Choosing Between Unidirectional and Bidirectional</h3>
    <p style="color: #34495e;">
        The choice depends on the use case:
    </p>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Use unidirectional when only one side needs to access the relationship.</li>
        <li>Use bidirectional when both entities should reference each other.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@ManyToMany</code> annotation simplifies handling many-to-many relationships in JPA.
        Properly defining the join table and choosing the right directionality ensures a well-structured database design.
    </p>
</div>
`
  },
  {
    title:`@JoinColumn`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@JoinColumn</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot and JPA (Java Persistence API), the <code>@JoinColumn</code> annotation is used to specify the foreign key column 
        for a relationship between two entities. It defines how the association is mapped in the database.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@JoinColumn</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Used to specify the foreign key column in a relationship.</li>
        <li>Can be applied in <code>@OneToOne</code> and <code>@ManyToOne</code> associations.</li>
        <li>Allows customization of the column name and constraints.</li>
        <li>Defaults to using the field name with an <code>_id</code> suffix if not explicitly specified.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Using <code>@JoinColumn</code> in a <code>@ManyToOne</code> Relationship</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            
            @Entity
            public class Employee {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                private String name;
                
                @ManyToOne
                @JoinColumn(name = "department_id", nullable = false)
                private Department department;
                
                // Getters and Setters
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Using <code>@JoinColumn</code> in a <code>@OneToOne</code> Relationship</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            
            @Entity
            public class User {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                private String username;
                
                @OneToOne
                @JoinColumn(name = "profile_id", unique = true)
                private UserProfile profile;
                
                // Getters and Setters
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Customizing <code>@JoinColumn</code></h3>
    <p style="color: #34495e;">
        The <code>@JoinColumn</code> annotation provides additional options:
    </p>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li><code>name</code>: Specifies the exact column name.</li>
        <li><code>nullable</code>: Defines whether the foreign key column can be null.</li>
        <li><code>unique</code>: Ensures the foreign key is unique (used in <code>@OneToOne</code>).</li>
        <li><code>referencedColumnName</code>: Specifies the column in the target entity to reference.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@JoinColumn</code> annotation is essential for defining foreign key relationships in JPA.
        Proper usage ensures a well-structured and efficient database design in Spring Boot applications.
    </p>
</div>
`
  },
  {
    title:`@JoinTable`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@JoinTable</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot and JPA (Java Persistence API), the <code>@JoinTable</code> annotation is used to define a join table for many-to-many relationships.
        It specifies how two entities are linked in a relational database by defining the table that holds the relationship data.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@JoinTable</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Used in <code>@ManyToMany</code> relationships.</li>
        <li>Defines a join table to map the relationship.</li>
        <li>Specifies join columns for both associated entities.</li>
        <li>Allows customization of table name, foreign keys, and constraints.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Using <code>@JoinTable</code> in a <code>@ManyToMany</code> Relationship</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            import java.util.Set;
            
            @Entity
            public class Student {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                private String name;
                
                @ManyToMany
                @JoinTable(
                    name = "student_course",
                    joinColumns = @JoinColumn(name = "student_id"),
                    inverseJoinColumns = @JoinColumn(name = "course_id")
                )
                private Set<Course> courses;
                
                // Getters and Setters
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Defining a Custom Join Table</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import javax.persistence.*;
            import java.util.Set;
            
            @Entity
            public class Course {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                private String title;
                
                @ManyToMany(mappedBy = "courses")
                private Set<Student> students;
                
                // Getters and Setters
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Customizing <code>@JoinTable</code></h3>
    <p style="color: #34495e;">
        The <code>@JoinTable</code> annotation provides additional options:
    </p>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li><code>name</code>: Specifies the exact join table name.</li>
        <li><code>joinColumns</code>: Defines the foreign key column of the owning entity.</li>
        <li><code>inverseJoinColumns</code>: Defines the foreign key column of the target entity.</li>
        <li>Allows defining unique constraints and indexes if necessary.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@JoinTable</code> annotation is essential for managing many-to-many relationships in JPA.
        Properly structuring the join table ensures data integrity and efficient querying in Spring Boot applications.
    </p>
</div>
`
  },
  {
    title:`@EnableJpaRepositories`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@EnableJpaRepositories</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, the <code>@EnableJpaRepositories</code> annotation is used to enable JPA repository support.
        It allows Spring to scan for repository interfaces and create their implementations automatically.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@EnableJpaRepositories</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Automatically scans and registers JPA repositories.</li>
        <li>Typically used in Spring Boot applications but can be explicitly defined in configurations.</li>
        <li>Customizes the base package for repository scanning.</li>
        <li>Works in conjunction with Spring Data JPA to simplify database interactions.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Using <code>@EnableJpaRepositories</code> in a Configuration Class</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.context.annotation.Configuration;
            import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
            
            @Configuration
            @EnableJpaRepositories(basePackages = "com.example.repository")
            public class JpaConfig {
                // Additional JPA-related configurations (if needed)
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Spring Boot Auto-Configuration</h3>
    <p style="color: #34495e;">
        In most Spring Boot applications, explicit usage of <code>@EnableJpaRepositories</code> is not required
        because Spring Boot auto-configures repositories based on classpath scanning.
    </p>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.data.jpa.repository.JpaRepository;
            import org.springframework.stereotype.Repository;
            
            @Repository
            public interface UserRepository extends JpaRepository<User, Long> {
                // Custom query methods can be defined here
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Customizing <code>@EnableJpaRepositories</code></h3>
    <p style="color: #34495e;">
        The annotation provides additional options:
    </p>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li><code>basePackages</code>: Defines the packages to scan for repositories.</li>
        <li><code>repositoryFactoryBeanClass</code>: Specifies a custom factory for repository beans.</li>
        <li><code>entityManagerFactoryRef</code>: Refers to a specific entity manager factory.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@EnableJpaRepositories</code> annotation plays a crucial role in managing JPA repositories.
        While Spring Boot auto-configures it, manual configuration can be useful for customization and multi-database setups.
    </p>
</div>
`
  },
  {
    title:`@Modifying`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@Modifying</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot and Spring Data JPA, the <code>@Modifying</code> annotation is used to annotate update, delete,
        or insert queries within a repository interface. It works alongside <code>@Query</code> to modify database records
        in a transactional way.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@Modifying</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Used with <code>@Query</code> to perform update, delete, or insert operations.</li>
        <li>Indicates that a query modifies data rather than selecting it.</li>
        <li>Requires a transaction context when modifying records.</li>
        <li>Must be used with <code>@Transactional</code> if required.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Updating Records Using <code>@Modifying</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.data.jpa.repository.Modifying;
            import org.springframework.data.jpa.repository.Query;
            import org.springframework.data.repository.CrudRepository;
            import org.springframework.transaction.annotation.Transactional;
            
            public interface UserRepository extends CrudRepository<User, Long> {
                
                @Modifying
                @Transactional
                @Query("UPDATE User u SET u.status = 'ACTIVE' WHERE u.id = :id")
                int activateUser(Long id);
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Deleting Records Using <code>@Modifying</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.data.jpa.repository.Modifying;
            import org.springframework.data.jpa.repository.Query;
            import org.springframework.data.repository.CrudRepository;
            import org.springframework.transaction.annotation.Transactional;
            
            public interface UserRepository extends CrudRepository<User, Long> {
                
                @Modifying
                @Transactional
                @Query("DELETE FROM User u WHERE u.status = 'INACTIVE'")
                int deleteInactiveUsers();
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>@Modifying</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Always use <code>@Transactional</code> to ensure consistency when modifying data.</li>
        <li>Return an integer to get the number of affected rows.</li>
        <li>Ensure the query correctly targets the intended records to prevent unwanted modifications.</li>
        <li>Use parameterized queries to avoid SQL injection risks.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@Modifying</code> annotation is essential for executing update, delete, and insert queries in Spring Boot applications.
        Proper usage ensures safe and efficient data modifications within a transactional context.
    </p>
</div>
`
  },
  {
    title:`@Query`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to <code>@Query</code> in Spring Data JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>@Query</code> annotation in Spring Data JPA is a powerful feature that allows you to define custom queries directly in your repository interfaces. Instead of relying on method names to generate queries, you can write JPQL (Java Persistence Query Language) or native SQL queries to fetch or manipulate data. This provides greater flexibility and control over the queries executed by your application, especially for complex use cases that cannot be easily expressed using derived query methods.
  </p>

  <h3 style="color: #16a085;">Why Use <code>@Query</code>?</h3>
  <p style="color: #2c3e50;">
    The <code>@Query</code> annotation is essential for scenarios where you need more control over the queries executed by your application. Key reasons to use it include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Complex Queries</strong>: Write custom queries for complex use cases that cannot be handled by derived query methods.</li>
    <li><strong>Performance Optimization</strong>: Optimize queries for better performance by fine-tuning the SQL or JPQL.</li>
    <li><strong>Flexibility</strong>: Use both JPQL and native SQL queries depending on your requirements.</li>
    <li><strong>Readability</strong>: Make queries explicit and easier to understand compared to long method names.</li>
    <li><strong>Advanced Features</strong>: Leverage advanced SQL features like joins, subqueries, and aggregations.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of <code>@Query</code></h3>
  <p style="color: #2c3e50;">
    When working with the <code>@Query</code> annotation, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>JPQL vs. Native Queries</strong>: JPQL is database-agnostic and works with entities, while native queries are written in SQL and are database-specific.</li>
    <li><strong>Parameters</strong>: Use named parameters (<code>:param</code>) or positional parameters (<code>?1</code>) to pass values to the query.</li>
    <li><strong>Modifying Queries</strong>: Use <code>@Modifying</code> for queries that update or delete data.</li>
    <li><strong>Pagination</strong>: Combine <code>@Query</code> with <code>Pageable</code> for paginated results.</li>
    <li><strong>Result Mapping</strong>: Map query results to custom DTOs or entities.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using <code>@Query</code> in Spring Data JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use the <code>@Query</code> annotation in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define a Repository with JPQL Queries</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Query</code> annotation to define custom JPQL queries in a repository.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.JpaRepository;
      import org.springframework.data.jpa.repository.Query;
      import org.springframework.data.repository.query.Param;

      import java.util.List;

      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

          @Query("SELECT u FROM User u WHERE u.email = :email")
          User findByEmail(@Param("email") String email);

          @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
          List&lt;User&gt; findByNameContaining(@Param("name") String name);

          @Query("SELECT u FROM User u ORDER BY u.name")
          List&lt;User&gt; findAllUsersSortedByName();
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Define a Repository with Native Queries</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Query</code> annotation with <code>nativeQuery = true</code> to define native SQL queries.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
      User findUserByEmailNative(@Param("email") String email);

      @Query(value = "SELECT * FROM users WHERE name LIKE %:name%", nativeQuery = true)
      List&lt;User&gt; findUsersByNameNative(@Param("name") String name);
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use Modifying Queries</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Modifying</code> annotation for queries that update or delete data.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.Modifying;
      import org.springframework.transaction.annotation.Transactional;

      @Modifying
      @Transactional
      @Query("UPDATE User u SET u.name = :name WHERE u.id = :id")
      int updateUserName(@Param("id") Long id, @Param("name") String name);

      @Modifying
      @Transactional
      @Query("DELETE FROM User u WHERE u.email = :email")
      int deleteByEmail(@Param("email") String email);
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Use Pagination with <code>@Query</code></h4>
  <p style="color: #2c3e50;">
    Combine <code>@Query</code> with <code>Pageable</code> for paginated results.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.domain.Page;
      import org.springframework.data.domain.Pageable;

      @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
      Page&lt;User&gt; findUsersByName(@Param("name") String name, Pageable pageable);
    </code>
  </pre>

  <h4 style="color: #8e44ad;">5. Map Query Results to DTOs</h4>
  <p style="color: #2c3e50;">
    Use <code>@Query</code> to map query results to custom DTOs.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.data.jpa.repository.Query;

      public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
          @Query("SELECT new com.example.UserDTO(u.id, u.name, u.email) FROM User u WHERE u.id = :id")
          UserDTO findUserDTOById(@Param("id") Long id);
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using <code>@Query</code></h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prefer JPQL over native queries for database independence.</li>
    <li>Use named parameters (<code>:param</code>) for better readability and maintainability.</li>
    <li>Use <code>@Modifying</code> and <code>@Transactional</code> for update and delete queries.</li>
    <li>Test your queries thoroughly to ensure they work as expected.</li>
    <li>Use pagination for large datasets to improve performance.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Query</code> annotation is a powerful tool for defining custom queries in Spring Data JPA. Whether you're working with JPQL or native SQL, <code>@Query</code> provides the flexibility and control needed to handle complex use cases. By following best practices, you can write efficient, maintainable, and performant queries that meet the needs of your application. Whether you're fetching data, updating records, or mapping results to DTOs, <code>@Query</code> is an essential feature for building robust data access layers.
  </p>
</div>`
  },
  {
       title:`@RestTemplate`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>RestTemplate</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, <code>RestTemplate</code> is a synchronous HTTP client used to make RESTful web service calls.
        It provides various methods to interact with external APIs and handle HTTP requests and responses efficiently.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>RestTemplate</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Supports HTTP methods like GET, POST, PUT, DELETE, and PATCH.</li>
        <li>Provides convenience methods for making API calls.</li>
        <li>Can be customized with interceptors, error handlers, and message converters.</li>
        <li>Being deprecated in favor of <code>WebClient</code> in Spring WebFlux for reactive applications.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Using <code>RestTemplate</code> to Make a GET Request</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.stereotype.Service;
            import org.springframework.web.client.RestTemplate;
            
            @Service
            public class ApiService {
                private final RestTemplate restTemplate = new RestTemplate();
                
                public String getApiResponse() {
                    return restTemplate.getForObject("https://api.example.com/data", String.class);
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Making a POST Request with <code>RestTemplate</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.http.ResponseEntity;
            import org.springframework.stereotype.Service;
            import org.springframework.web.client.RestTemplate;
            
            @Service
            public class ApiService {
                private final RestTemplate restTemplate = new RestTemplate();
                
                public ResponseEntity<String> createResource(Object request) {
                    return restTemplate.postForEntity("https://api.example.com/resource", request, String.class);
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>RestTemplate</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Use a single <code>RestTemplate</code> bean instead of creating new instances.</li>
        <li>Configure a custom error handler to manage API errors gracefully.</li>
        <li>Use <code>exchange()</code> for more control over request and response handling.</li>
        <li>Consider migrating to <code>WebClient</code> for non-blocking, reactive applications.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>RestTemplate</code> class provides a simple way to make synchronous REST API calls in Spring Boot applications.
        While still widely used, it is recommended to migrate to <code>WebClient</code> for modern, reactive applications.
    </p>
</div>
    `
    },
    {
      title:`@FeignClient`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@FeignClient</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, <code>@FeignClient</code> is an annotation used to simplify HTTP requests to external APIs.
        It is part of Spring Cloud OpenFeign and provides a declarative way to call RESTful services,
        reducing the need for boilerplate code compared to <code>RestTemplate</code>.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@FeignClient</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Enables declarative REST client functionality in Spring Boot applications.</li>
        <li>Automatically integrates with Spring Boot for service discovery and load balancing.</li>
        <li>Supports request customization using annotations like <code>@GetMapping</code>, <code>@PostMapping</code>, etc.</li>
        <li>Can be configured with interceptors, error handling, and logging.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Declaring a Feign Client</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.cloud.openfeign.FeignClient;
            import org.springframework.web.bind.annotation.GetMapping;
            import org.springframework.web.bind.annotation.PathVariable;
            
            @FeignClient(name = "user-service", url = "https://api.example.com")
            public interface UserClient {
                
                @GetMapping("/users/{id}")
                User getUserById(@PathVariable("id") Long id);
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Using Feign Client in a Service</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.stereotype.Service;
            
            @Service
            public class UserService {
                private final UserClient userClient;
                
                public UserService(UserClient userClient) {
                    this.userClient = userClient;
                }
                
                public User fetchUser(Long id) {
                    return userClient.getUserById(id);
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>@FeignClient</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Enable Feign by adding <code>@EnableFeignClients</code> in the main Spring Boot application class.</li>
        <li>Use <code>fallback</code> mechanisms to handle failures gracefully.</li>
        <li>Configure Feign logging for better debugging and monitoring.</li>
        <li>Leverage request interceptors to add headers or authentication details.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@FeignClient</code> annotation provides a powerful, declarative way to communicate with external APIs
        in Spring Boot applications. It enhances readability, maintainability, and integration with service discovery mechanisms.
    </p>
</div>
`
    },
    {
      title:`@EnableFeignClients`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@EnableFeignClients</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, <code>@EnableFeignClients</code> is an annotation used to enable Feign, a declarative HTTP client
        for making RESTful API calls. It simplifies external service communication by providing an interface-based
        approach to defining API clients.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@EnableFeignClients</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Scans for Feign clients annotated with <code>@FeignClient</code>.</li>
        <li>Enables declarative REST client functionality in Spring Boot applications.</li>
        <li>Works seamlessly with Spring Boot's service discovery and load balancing mechanisms.</li>
        <li>Integrates with Spring Cloud for distributed applications.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Enabling Feign Clients</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.boot.SpringApplication;
            import org.springframework.boot.autoconfigure.SpringBootApplication;
            import org.springframework.cloud.openfeign.EnableFeignClients;
            
            @SpringBootApplication
            @EnableFeignClients
            public class Application {
                public static void main(String[] args) {
                    SpringApplication.run(Application.class, args);
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Defining a Feign Client</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.cloud.openfeign.FeignClient;
            import org.springframework.web.bind.annotation.GetMapping;
            import org.springframework.web.bind.annotation.PathVariable;
            
            @FeignClient(name = "user-service", url = "https://api.example.com")
            public interface UserClient {
                
                @GetMapping("/users/{id}")
                User getUserById(@PathVariable("id") Long id);
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>@EnableFeignClients</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Place <code>@EnableFeignClients</code> in the main application class or a configuration class.</li>
        <li>Use <code>fallback</code> mechanisms to handle failures gracefully.</li>
        <li>Configure Feign logging for better debugging and monitoring.</li>
        <li>Leverage request interceptors to add headers or authentication details.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@EnableFeignClients</code> annotation is crucial for activating Feign in Spring Boot applications.
        It allows for a more readable and maintainable way to make HTTP requests while integrating seamlessly with
        Spring Cloud's features.
    </p>
</div>
`
    },
    {
      title:`@EnableEurekaClient`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@EnableEurekaClient</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, <code>@EnableEurekaClient</code> is an annotation used to register a service with
        a Eureka Server for service discovery. It enables Spring Boot applications to act as Eureka clients,
        allowing them to dynamically discover and communicate with other services within a microservices architecture.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@EnableEurekaClient</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Registers the service with a Eureka Server.</li>
        <li>Enables automatic service discovery for inter-service communication.</li>
        <li>Works in conjunction with Spring Cloud and Netflix Eureka.</li>
        <li>Provides high availability and load balancing when used with Ribbon.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Enabling Eureka Client</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.boot.SpringApplication;
            import org.springframework.boot.autoconfigure.SpringBootApplication;
            import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
            
            @SpringBootApplication
            @EnableEurekaClient
            public class Application {
                public static void main(String[] args) {
                    SpringApplication.run(Application.class, args);
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Configuring Eureka Client in <code>application.yml</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-yaml">
            eureka:
              client:
                service-url:
                  defaultZone: http://localhost:8761/eureka/
              instance:
                prefer-ip-address: true
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>@EnableEurekaClient</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Ensure that the Eureka Server is running before registering services.</li>
        <li>Use <code>prefer-ip-address</code> to avoid hostname resolution issues.</li>
        <li>Monitor service registrations and health status in the Eureka dashboard.</li>
        <li>Use <code>spring.application.name</code> to uniquely identify services.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@EnableEurekaClient</code> annotation is essential for enabling service discovery in Spring Boot
        applications. It allows microservices to register with a Eureka Server and discover other services dynamically,
        improving scalability and flexibility within a distributed system.
    </p>
</div>
`
    },
    {
      title:`@EnableCircuitBreaker`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@EnableCircuitBreaker</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, <code>@EnableCircuitBreaker</code> is an annotation used to enable the Circuit Breaker pattern.
        It is part of Spring Cloud Netflix Hystrix and helps build resilient applications by preventing cascading failures
        in microservices. Circuit breakers monitor service calls and, if failures exceed a threshold, they stop calling
        the failing service temporarily.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@EnableCircuitBreaker</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Monitors service calls and prevents failures from propagating.</li>
        <li>Automatically falls back to alternative responses when failures occur.</li>
        <li>Improves application resilience and fault tolerance.</li>
        <li>Works in conjunction with Hystrix for better service stability.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Enabling Circuit Breaker</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.boot.SpringApplication;
            import org.springframework.boot.autoconfigure.SpringBootApplication;
            import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
            
            @SpringBootApplication
            @EnableCircuitBreaker
            public class Application {
                public static void main(String[] args) {
                    SpringApplication.run(Application.class, args);
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #9b59b6;">Example: Using Hystrix for Circuit Breaking</h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
            import org.springframework.stereotype.Service;
            
            @Service
            public class UserService {
                
                @HystrixCommand(fallbackMethod = "fallbackGetUser")
                public String getUser() {
                    // Simulate a failing service
                    throw new RuntimeException("Service Unavailable");
                }
                
                public String fallbackGetUser() {
                    return "Fallback User";
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>@EnableCircuitBreaker</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Always define a fallback method to handle failures gracefully.</li>
        <li>Use timeouts and retry mechanisms for better service stability.</li>
        <li>Monitor circuit breaker metrics using dashboards like Hystrix Dashboard.</li>
        <li>Adjust circuit breaker thresholds based on application behavior.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@EnableCircuitBreaker</code> annotation plays a crucial role in ensuring resilience in
        Spring Boot microservices. It helps in preventing system-wide failures by isolating faulty services
        and providing fallback mechanisms for enhanced reliability.
    </p>
</div>
`
    },
    {
      title:`@Retryable`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@Retryable</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, <code>@Retryable</code> is an annotation provided by Spring Retry that allows methods
        to be automatically retried upon failure. It is useful for handling transient errors such as network issues,
        database connection failures, and temporary service outages.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@Retryable</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Automatically retries failed method executions.</li>
        <li>Allows configuring the number of retry attempts and delay between retries.</li>
        <li>Works with specific exception types to trigger retries.</li>
        <li>Can be combined with <code>@Recover</code> to handle failures after all retries are exhausted.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Using <code>@Retryable</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.retry.annotation.Retryable;
            import org.springframework.retry.annotation.Recover;
            import org.springframework.stereotype.Service;
            import java.io.IOException;
            
            @Service
            public class RetryService {
                
                @Retryable(value = IOException.class, maxAttempts = 3, backoff = @Backoff(delay = 2000))
                public String fetchData() throws IOException {
                    System.out.println("Attempting to fetch data...");
                    throw new IOException("Temporary issue, retrying...");
                }
                
                @Recover
                public String recover(IOException e) {
                    return "Fallback response after retries failed";
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>@Retryable</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Use <code>@Retryable</code> only for transient failures, not permanent errors.</li>
        <li>Define meaningful <code>maxAttempts</code> and <code>backoff</code> values to avoid overwhelming services.</li>
        <li>Implement <code>@Recover</code> to handle failures gracefully after all retries are exhausted.</li>
        <li>Log retry attempts to monitor and troubleshoot issues effectively.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@Retryable</code> annotation is a powerful feature for making Spring Boot applications
        more resilient. It helps in handling temporary failures gracefully by retrying operations automatically,
        reducing downtime and improving system reliability.
    </p>
</div>
`
    },
    {
      title:`@Recover`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
    <h2 style="color: #2c3e50;">Understanding <code>@Recover</code> in Spring Boot</h2>
    <p style="font-size: 16px; color: #34495e;">
        In Spring Boot, <code>@Recover</code> is an annotation used in conjunction with <code>@Retryable</code>
        to define a fallback method when all retry attempts have been exhausted. It provides a graceful
        recovery mechanism, ensuring the system remains stable even after repeated failures.
    </p>
    
    <h3 style="color: #16a085;">Key Aspects of <code>@Recover</code>:</h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Defines a fallback method when retries fail.</li>
        <li>Must have the same return type as the <code>@Retryable</code> method.</li>
        <li>The first parameter must be the exception type it recovers from.</li>
        <li>Ensures graceful degradation by returning an alternative response.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Example: Using <code>@Recover</code></h3>
    <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
        <code codeHighlight class="language-java">
            import org.springframework.retry.annotation.Retryable;
            import org.springframework.retry.annotation.Recover;
            import org.springframework.stereotype.Service;
            import java.io.IOException;
            
            @Service
            public class RetryService {
                
                @Retryable(value = IOException.class, maxAttempts = 3, backoff = @Backoff(delay = 2000))
                public String fetchData() throws IOException {
                    System.out.println("Attempting to fetch data...");
                    throw new IOException("Temporary issue, retrying...");
                }
                
                @Recover
                public String recover(IOException e) {
                    return "Fallback response after retries failed";
                }
            }
        </code>
    </pre>
    
    <h3 style="color: #2c3e50;">Best Practices for <code>@Recover</code></h3>
    <ul style="color: #2c3e50; padding-left: 20px;">
        <li>Ensure the fallback method has the same return type as the <code>@Retryable</code> method.</li>
        <li>Use meaningful log messages to indicate when a recovery method is invoked.</li>
        <li>Define multiple <code>@Recover</code> methods for different exception types if needed.</li>
        <li>Ensure fallback responses are useful and informative for downstream processes.</li>
    </ul>
    
    <h3 style="color: #e67e22;">Conclusion</h3>
    <p style="color: #2c3e50;">
        The <code>@Recover</code> annotation is a powerful tool for handling failures gracefully in Spring Boot.
        It works alongside <code>@Retryable</code> to provide a reliable fallback mechanism, ensuring application
        stability and resilience against transient errors.
    </p>
</div>
`
    },
    {
      title:`Security Fundamentals`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Security Fundamentals</h2>
  <p style="font-size: 16px; color: #34495e;">
    Security is a critical aspect of any system, ensuring protection against threats, vulnerabilities, and unauthorized access. Security fundamentals cover various aspects, including authentication, authorization, encryption, network security, and best practices for maintaining a secure environment.
  </p>

  <h3 style="color: #16a085;">Why is Security Important?</h3>
  <p style="color: #2c3e50;">
    Security is essential to protect sensitive data, maintain privacy, and prevent malicious attacks. Key benefits include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Protection</strong>: Prevents unauthorized access to confidential information.</li>
    <li><strong>System Integrity</strong>: Ensures that systems function as intended without tampering.</li>
    <li><strong>Compliance</strong>: Meets legal and industry security standards.</li>
    <li><strong>Risk Mitigation</strong>: Reduces vulnerabilities and minimizes potential damage from attacks.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Security Principles</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Confidentiality</strong>: Ensuring data is only accessible to authorized individuals.</li>
    <li><strong>Integrity</strong>: Preventing unauthorized modification or corruption of data.</li>
    <li><strong>Availability</strong>: Ensuring that data and services are available when needed.</li>
    <li><strong>Authentication</strong>: Verifying user identities before granting access.</li>
    <li><strong>Authorization</strong>: Defining and enforcing access control policies.</li>
  </ul>

  <h3 style="color: #8e44ad;">Common Security Threats</h3>
  <p style="color: #2c3e50;">
    Understanding potential threats is crucial for implementing effective security measures. Common security threats include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Phishing Attacks</strong>: Deceptive attempts to steal sensitive information.</li>
    <li><strong>Malware</strong>: Software designed to damage or disrupt systems.</li>
    <li><strong>Man-in-the-Middle Attacks</strong>: Intercepting and altering communication between two parties.</li>
    <li><strong>Denial of Service (DoS)</strong>: Overloading systems to make them unavailable.</li>
    <li><strong>SQL Injection</strong>: Exploiting database vulnerabilities to manipulate data.</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices for Security</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use Strong Passwords</strong>: Enforce complex passwords and multi-factor authentication.</li>
    <li><strong>Keep Software Updated</strong>: Regularly patch vulnerabilities and update systems.</li>
    <li><strong>Encrypt Sensitive Data</strong>: Use strong encryption to protect data at rest and in transit.</li>
    <li><strong>Implement Firewalls</strong>: Restrict unauthorized access with network firewalls.</li>
    <li><strong>Security Audits</strong>: Regularly assess and improve security measures.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Security fundamentals are crucial for protecting data, ensuring system integrity, and mitigating risks. By following best practices, organizations can create a secure environment, preventing cyber threats and unauthorized access.
  </p>
</div>
`
},
{
  title:`Authentication & Authorization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Authentication & Authorization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Authentication and Authorization are two fundamental concepts in security that ensure only the right users can access a system and perform allowed actions.
  </p>

  <h3 style="color: #16a085;">What is Authentication?</h3>
  <p style="color: #2c3e50;">
    Authentication is the process of verifying the identity of a user or system. It ensures that users are who they claim to be.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Username & Password</strong>: The most common method where users enter their credentials.</li>
    <li><strong>Multi-Factor Authentication (MFA)</strong>: Adds an extra layer of security with OTPs or biometrics.</li>
    <li><strong>Biometric Authentication</strong>: Uses fingerprints, facial recognition, or iris scans.</li>
    <li><strong>Token-Based Authentication</strong>: Uses JWT, OAuth, or API keys.</li>
  </ul>

  <h3 style="color: #e67e22;">What is Authorization?</h3>
  <p style="color: #2c3e50;">
    Authorization determines the level of access a user has after authentication. It controls what actions a user can perform within a system.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Role-Based Access Control (RBAC)</strong>: Assigns permissions based on roles like Admin, User, or Guest.</li>
    <li><strong>Attribute-Based Access Control (ABAC)</strong>: Uses attributes like user location or device type.</li>
    <li><strong>Policy-Based Access Control</strong>: Uses security policies to grant or deny access.</li>
  </ul>

  <h3 style="color: #8e44ad;">Key Differences Between Authentication & Authorization</h3>
  <table style="width: 100%; border-collapse: collapse; color: #2c3e50;">
    <tr style="background: #16a085; color: #fff;">
      <th style="padding: 10px; border: 1px solid #ddd;">Authentication</th>
      <th style="padding: 10px; border: 1px solid #ddd;">Authorization</th>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Verifies identity</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Determines permissions</td>
    </tr>
    <tr style="background: #ecf0f1;">
      <td style="padding: 10px; border: 1px solid #ddd;">Usually done via passwords, biometrics, or tokens</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Managed through roles, policies, or rules</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Comes first in the security process</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Happens after authentication</td>
    </tr>
  </table>

  <h3 style="color: #d35400;">Best Practices for Secure Authentication & Authorization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>Multi-Factor Authentication (MFA)</strong> for added security.</li>
    <li>Store passwords securely using <strong>hashing</strong> (e.g., bcrypt, Argon2).</li>
    <li>Implement <strong>OAuth 2.0 or OpenID Connect</strong> for modern authentication.</li>
    <li>Follow the <strong>Principle of Least Privilege (PoLP)</strong> to restrict access.</li>
    <li>Regularly <strong>audit and monitor access logs</strong> to detect anomalies.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Authentication and Authorization work together to secure applications. Authentication ensures the right users gain access, while authorization controls their permissions. Implementing strong security measures helps protect sensitive data and prevent unauthorized access.
  </p>
</div>
`
    },
{
  title:`Security Configuration`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Security Configuration in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Security configuration is a critical aspect of any application to ensure data protection, user authentication, and controlled access to resources. In Spring Boot, security is commonly managed using <code>Spring Security</code>, which provides powerful features to configure authentication and authorization.
  </p>

  <h3 style="color: #16a085;">Why Security Configuration Matters?</h3>
  <p style="color: #2c3e50;">
    Configuring security properly in an application offers the following benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Protection</strong>: Prevents unauthorized access to sensitive data.</li>
    <li><strong>User Authentication</strong>: Ensures only valid users can access the system.</li>
    <li><strong>Role-Based Access Control</strong>: Grants different permissions to different users.</li>
    <li><strong>Threat Mitigation</strong>: Reduces the risk of security threats like SQL injection and XSS.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Configure Security in Spring Boot?</h3>
  <p style="color: #2c3e50;">
    To configure security in a Spring Boot application, you need to create a security configuration class using <code>@Configuration</code> and extend <code>SecurityFilterChain</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.web.SecurityFilterChain;

      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .authorizeHttpRequests(auth -> auth
                      .requestMatchers("/admin/**").hasRole("ADMIN")
                      .requestMatchers("/user/**").hasRole("USER")
                      .anyRequest().authenticated()
                  )
                  .formLogin()
                  .and()
                  .logout();
              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Adding User Authentication</h3>
  <p style="color: #2c3e50;">
    Define users with roles using <code>InMemoryUserDetailsManager</code> for simple authentication.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.core.userdetails.UserDetails;
      import org.springframework.security.core.userdetails.UserDetailsService;
      import org.springframework.security.provisioning.InMemoryUserDetailsManager;

      @Bean
      public UserDetailsService userDetailsService() {
          UserDetails user = User.withDefaultPasswordEncoder()
                  .username("user")
                  .password("password")
                  .roles("USER")
                  .build();

          UserDetails admin = User.withDefaultPasswordEncoder()
                  .username("admin")
                  .password("admin")
                  .roles("ADMIN")
                  .build();

          return new InMemoryUserDetailsManager(user, admin);
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Security Configuration</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always use <strong>strong password encryption</strong> (e.g., Bcrypt instead of plain text passwords).</li>
    <li>Restrict access using <strong>role-based authentication</strong>.</li>
    <li>Enable <strong>HTTPS</strong> to secure data transmission.</li>
    <li>Use <strong>JWT tokens</strong> or OAuth for API authentication.</li>
    <li>Regularly <strong>update security dependencies</strong> to prevent vulnerabilities.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Configuring security in a Spring Boot application is essential to protect sensitive data and restrict unauthorized access. By leveraging Spring Security, developers can implement robust authentication and authorization mechanisms to ensure a safe and secure application environment.
  </p>
</div>
`
    },
    {
      title:`UserDetailsService & Encoding`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding UserDetailsService & Encoding in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Security, <code>UserDetailsService</code> is an interface that loads user-specific data, primarily used for authentication. Password encoding is essential to store passwords securely instead of plain text. These two components work together to enhance security in authentication mechanisms.
  </p>

  <h3 style="color: #16a085;">What is UserDetailsService?</h3>
  <p style="color: #2c3e50;">
    <code>UserDetailsService</code> is a core Spring Security interface responsible for retrieving user-related data from various sources like databases, in-memory stores, or external identity providers.
  </p>

  <h3 style="color: #e67e22;">Implementing UserDetailsService</h3>
  <p style="color: #2c3e50;">
    To implement custom authentication, we need to create a class that implements <code>UserDetailsService</code> and overrides the <code>loadUserByUsername</code> method.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.core.userdetails.UserDetails;
      import org.springframework.security.core.userdetails.UserDetailsService;
      import org.springframework.security.core.userdetails.UsernameNotFoundException;
      import org.springframework.stereotype.Service;
      import java.util.ArrayList;

      @Service
      public class CustomUserDetailsService implements UserDetailsService {
          @Override
          public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
              if ("admin".equals(username)) {
                  return new User("admin", "{noop}password", new ArrayList<>());
              } else {
                  throw new UsernameNotFoundException("User not found!");
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Understanding Password Encoding</h3>
  <p style="color: #2c3e50;">
    Storing passwords as plain text is highly insecure. Spring Security provides password encoding mechanisms like <code>BCryptPasswordEncoder</code> to securely hash passwords before saving them in a database.
  </p>

  <h3 style="color: #d35400;">Using BCryptPasswordEncoder</h3>
  <p style="color: #2c3e50;">
    The <code>BCryptPasswordEncoder</code> generates a secure hash of the password that includes a unique salt to protect against brute-force attacks.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
      import org.springframework.security.crypto.password.PasswordEncoder;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class SecurityConfig {
          @Bean
          public PasswordEncoder passwordEncoder() {
              return new BCryptPasswordEncoder();
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Storing Encoded Passwords</h3>
  <p style="color: #2c3e50;">
    When saving user credentials in the database, we must encode the password using the <code>BCryptPasswordEncoder</code> before storing it.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

      public class PasswordHashingExample {
          public static void main(String[] args) {
              BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
              String rawPassword = "mypassword";
              String encodedPassword = encoder.encode(rawPassword);

              System.out.println("Encoded Password: " + encodedPassword);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Comparing Encoded Passwords</h3>
  <p style="color: #2c3e50;">
    To validate passwords during authentication, we use the <code>matches()</code> method of the <code>BCryptPasswordEncoder</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      public class PasswordVerificationExample {
          public static void main(String[] args) {
              BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
              String encodedPassword = encoder.encode("mypassword");

              boolean isMatch = encoder.matches("mypassword", encodedPassword);
              System.out.println("Password Match: " + isMatch);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Integrating UserDetailsService and Password Encoding</h3>
  <p style="color: #2c3e50;">
    In a real-world application, we integrate <code>UserDetailsService</code> with password encoding in the authentication process.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.core.userdetails.UserDetails;
      import org.springframework.security.core.userdetails.UserDetailsService;
      import org.springframework.security.core.userdetails.UsernameNotFoundException;
      import org.springframework.security.crypto.password.PasswordEncoder;
      import org.springframework.stereotype.Service;
      import java.util.ArrayList;

      @Service
      public class CustomUserDetailsService implements UserDetailsService {

          @Autowired
          private PasswordEncoder passwordEncoder;

          @Override
          public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
              if ("admin".equals(username)) {
                  return new User("admin", passwordEncoder.encode("password"), new ArrayList<>());
              } else {
                  throw new UsernameNotFoundException("User not found!");
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always use <strong>BCryptPasswordEncoder</strong> for password hashing.</li>
    <li>Do not store passwords in plain text; always encode them.</li>
    <li>Use a secure random salt to prevent rainbow table attacks.</li>
    <li>Ensure <code>UserDetailsService</code> fetches users securely from a trusted database.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    <code>UserDetailsService</code> and password encoding are fundamental in Spring Security for managing authentication securely. By implementing a custom <code>UserDetailsService</code> and encoding passwords with <code>BCryptPasswordEncoder</code>, we can ensure robust authentication mechanisms for modern applications.
  </p>
</div>
`
},
{
  title:`Security Filters & Context`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Security Filters & Context in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Security filters and context play a crucial role in handling authentication and authorization in Spring Security. Filters intercept requests, while the security context holds authentication details throughout the session.
  </p>

  <h3 style="color: #16a085;">What are Security Filters?</h3>
  <p style="color: #2c3e50;">
    Security filters are part of the Spring Security filter chain, responsible for processing authentication and authorization logic before requests reach the application.
  </p>

  <h3 style="color: #e67e22;">Common Security Filters</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>UsernamePasswordAuthenticationFilter</strong> - Handles form-based authentication.</li>
    <li><strong>BasicAuthenticationFilter</strong> - Supports HTTP Basic authentication.</li>
    <li><strong>JwtAuthenticationFilter</strong> - Manages JWT-based authentication.</li>
    <li><strong>SecurityContextPersistenceFilter</strong> - Maintains security context across multiple requests.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing a Custom Security Filter</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import jakarta.servlet.FilterChain;
      import jakarta.servlet.ServletException;
      import jakarta.servlet.http.HttpServletRequest;
      import jakarta.servlet.http.HttpServletResponse;
      import org.springframework.web.filter.OncePerRequestFilter;
      import java.io.IOException;

      public class CustomSecurityFilter extends OncePerRequestFilter {
          @Override
          protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                         FilterChain filterChain) throws ServletException, IOException {
              System.out.println("Custom Security Filter Executed");
              filterChain.doFilter(request, response);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Understanding Security Context</h3>
  <p style="color: #2c3e50;">
    The <code>SecurityContext</code> stores authentication details across user sessions. It is managed by <code>SecurityContextHolder</code> in Spring Security.
  </p>

  <h3 style="color: #e67e22;">Retrieving Authentication from Security Context</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.core.Authentication;
      import org.springframework.security.core.context.SecurityContextHolder;

      public class SecurityContextExample {
          public static void main(String[] args) {
              Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
              System.out.println("Authenticated User: " + authentication.getName());
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>JWT</strong> or <strong>OAuth2</strong> instead of session-based authentication for scalability.</li>
    <li>Ensure <strong>SecurityContext</strong> is properly cleared after logout to prevent session hijacking.</li>
    <li>Use <strong>custom security filters</strong> for advanced authentication requirements.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Security filters process authentication and authorization, while the security context maintains authentication details. Understanding these concepts is vital for implementing secure applications in Spring Security.
  </p>
</div>
`
},
{
  title:`RBAC`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding RBAC (Role-Based Access Control) in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Role-Based Access Control (RBAC) is a security model that restricts system access based on assigned roles. In Spring Security, RBAC ensures that users can only access resources that match their roles, making it a crucial component of application security.
  </p>

  <h3 style="color: #16a085;">What is RBAC?</h3>
  <p style="color: #2c3e50;">
    RBAC is a method for managing user permissions by assigning roles. Instead of granting individual permissions, users are assigned roles, and roles contain the required permissions.
  </p>

  <h3 style="color: #e67e22;">Configuring RBAC in Spring Security</h3>
  <p style="color: #2c3e50;">
    To implement RBAC, we define roles and restrict access using Spring Security configurations.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.core.userdetails.UserDetails;
      import org.springframework.security.core.userdetails.UserDetailsService;
      import org.springframework.security.provisioning.InMemoryUserDetailsManager;
      import org.springframework.security.web.SecurityFilterChain;

      @Configuration
      @EnableWebSecurity
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http.authorizeHttpRequests(auth -> auth
                      .requestMatchers("/admin/**").hasRole("ADMIN")
                      .requestMatchers("/user/**").hasRole("USER")
                      .anyRequest().authenticated())
                  .formLogin()
                  .and()
                  .logout();
              return http.build();
          }

          @Bean
          public UserDetailsService userDetailsService() {
              UserDetails admin = User.withDefaultPasswordEncoder()
                      .username("admin")
                      .password("password")
                      .roles("ADMIN")
                      .build();

              UserDetails user = User.withDefaultPasswordEncoder()
                      .username("user")
                      .password("password")
                      .roles("USER")
                      .build();

              return new InMemoryUserDetailsManager(admin, user);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Assigning Roles and Permissions</h3>
  <p style="color: #2c3e50;">
    Roles are assigned to users, and access is restricted based on these roles. The <code>hasRole()</code> method ensures that only users with the correct role can access certain endpoints.
  </p>

  <h3 style="color: #d35400;">Role-Based Method Security</h3>
  <p style="color: #2c3e50;">
    Spring Security allows method-level security using annotations like <code>@PreAuthorize</code> and <code>@Secured</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.access.prepost.PreAuthorize;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class RoleBasedController {
          
          @GetMapping("/admin")
          @PreAuthorize("hasRole('ADMIN')")
          public String adminAccess() {
              return "Admin Access Granted";
          }
          
          @GetMapping("/user")
          @PreAuthorize("hasRole('USER')")
          public String userAccess() {
              return "User Access Granted";
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Best Practices for RBAC</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Follow the principle of <strong>least privilege</strong>, granting only necessary permissions.</li>
    <li>Use role hierarchies to simplify permission management.</li>
    <li>Regularly review and update role assignments.</li>
    <li>Store user roles securely in a database and integrate with <code>UserDetailsService</code>.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    RBAC in Spring Security is a powerful approach to managing user permissions efficiently. By implementing roles and securing endpoints with <code>hasRole()</code> and <code>@PreAuthorize</code>, we can ensure that users access only what they are authorized for, enhancing overall application security.
  </p>
</div>
`
},
{
  title:`Method-Level Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Method-Level Security in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Method-Level Security in Spring Security allows us to apply access control at the method level using annotations such as <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@Secured</code>, and <code>@RolesAllowed</code>. This ensures that users can only access specific methods based on their roles or permissions.
  </p>

  <h3 style="color: #16a085;">Enabling Method Security</h3>
  <p style="color: #2c3e50;">
    To enable method-level security, annotate the configuration class with <code>@EnableMethodSecurity</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

      @Configuration
      @EnableMethodSecurity
      public class SecurityConfig {
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using @PreAuthorize</h3>
  <p style="color: #2c3e50;">
    The <code>@PreAuthorize</code> annotation is used to evaluate expressions before the method execution. For example, restricting access to users with the role <code>ROLE_ADMIN</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.access.prepost.PreAuthorize;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          
          @PreAuthorize("hasRole('ROLE_ADMIN')")
          public void deleteProduct(Long productId) {
              System.out.println("Product deleted: " + productId);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using @PostAuthorize</h3>
  <p style="color: #2c3e50;">
    The <code>@PostAuthorize</code> annotation allows security checks after the method execution. It is useful when we need to verify the returned object before providing access.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.access.prepost.PostAuthorize;
      import org.springframework.stereotype.Service;

      @Service
      public class OrderService {
          
          @PostAuthorize("returnObject.owner == authentication.name")
          public Order getOrderDetails(Long orderId) {
              return new Order(orderId, "john_doe");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Using @Secured</h3>
  <p style="color: #2c3e50;">
    The <code>@Secured</code> annotation restricts method access based on roles. Unlike <code>@PreAuthorize</code>, it does not support SpEL expressions.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.access.annotation.Secured;
      import org.springframework.stereotype.Service;

      @Service
      public class AccountService {
          
          @Secured("ROLE_USER")
          public void viewAccountDetails() {
              System.out.println("Viewing account details");
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Using @RolesAllowed</h3>
  <p style="color: #2c3e50;">
    Similar to <code>@Secured</code>, the <code>@RolesAllowed</code> annotation specifies role-based access control but is part of Java EE.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import jakarta.annotation.security.RolesAllowed;
      import org.springframework.stereotype.Service;

      @Service
      public class CustomerService {
          
          @RolesAllowed({"ROLE_ADMIN", "ROLE_MANAGER"})
          public void manageCustomers() {
              System.out.println("Managing customers");
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <code>@PreAuthorize</code> and <code>@PostAuthorize</code> for flexible security expressions.</li>
    <li>Restrict access to sensitive methods using role-based annotations.</li>
    <li>Keep security configurations centralized to simplify management.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Method-Level Security enhances application security by enforcing access control at the service layer. Using <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@Secured</code>, and <code>@RolesAllowed</code>, we can ensure that users have appropriate permissions before executing critical operations.
  </p>
</div>`
},
{
  title:`JWT Authentication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding JWT Authentication in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    JSON Web Token (JWT) is a widely used method for securing authentication and authorization in modern web applications. It enables stateless authentication by using a digitally signed token to represent user identity and claims.
  </p>

  <h3 style="color: #16a085;">What is JWT?</h3>
  <p style="color: #2c3e50;">
    JWT is a compact, URL-safe token format used to securely transmit information between parties as a JSON object. It consists of three parts: Header, Payload, and Signature.
  </p>

  <h3 style="color: #e67e22;">Structure of JWT</h3>
  <p style="color: #2c3e50;">A JWT token is typically structured as follows:</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
      .eyJzdWIiOiJ1c2VyIiwiaWF0IjoxNjM0MDk0NTYwLCJleHAiOjE2MzQxMDgxNjB9
      .HMACSHA256_signature
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Implementing JWT Authentication in Spring Security</h3>
  <p style="color: #2c3e50;">
    Below is a step-by-step implementation of JWT authentication in a Spring Boot application.
  </p>

  <h3 style="color: #d35400;">1. Adding Dependencies</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
          &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
          &lt;version&gt;0.11.2&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #16a085;">2. Creating JWT Utility Class</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import io.jsonwebtoken.*;
      import io.jsonwebtoken.security.Keys;
      import java.util.Date;
      import javax.crypto.SecretKey;

      public class JwtUtil {
          private static final SecretKey SECRET_KEY = Keys.secretKeyFor(SignatureAlgorithm.HS256);
          private static final long EXPIRATION_TIME = 86400000; // 1 day

          public static String generateToken(String username) {
              return Jwts.builder()
                  .setSubject(username)
                  .setIssuedAt(new Date())
                  .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                  .signWith(SECRET_KEY)
                  .compact();
          }

          public static String extractUsername(String token) {
              return Jwts.parserBuilder().setSigningKey(SECRET_KEY).build()
                  .parseClaimsJws(token).getBody().getSubject();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">3. Implementing JWT Filter</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.servlet.FilterChain;
      import javax.servlet.ServletException;
      import javax.servlet.http.HttpServletRequest;
      import javax.servlet.http.HttpServletResponse;
      import org.springframework.security.core.context.SecurityContextHolder;
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.web.authentication.UsernamePasswordAuthenticationToken;
      import org.springframework.web.filter.OncePerRequestFilter;

      public class JwtAuthenticationFilter extends OncePerRequestFilter {
          @Override
          protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                         FilterChain filterChain) throws ServletException, IOException {
              String authorizationHeader = request.getHeader("Authorization");
              if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
                  String token = authorizationHeader.substring(7);
                  String username = JwtUtil.extractUsername(token);

                  if (username != null) {
                      UsernamePasswordAuthenticationToken authToken =
                          new UsernamePasswordAuthenticationToken(new User(username, "", new ArrayList<>()),
                          null, new ArrayList<>());
                      SecurityContextHolder.getContext().setAuthentication(authToken);
                  }
              }
              filterChain.doFilter(request, response);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">4. Configuring Spring Security</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.config.http.SessionCreationPolicy;
      import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

      @Configuration
      @EnableWebSecurity
      public class SecurityConfig {
          protected void configure(HttpSecurity http) throws Exception {
              http.csrf().disable()
                  .authorizeRequests()
                  .antMatchers("/api/login").permitAll()
                  .anyRequest().authenticated()
                  .and()
                  .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                  .and()
                  .addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JWT authentication provides a secure and stateless way to handle user authentication in Spring Security. By using a token-based approach, we eliminate the need for server-side session management, making it ideal for distributed applications and microservices.
  </p>
</div>
`
},
{
   title:`OAuth2 & OpenID Connect`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding OAuth2 & OpenID Connect in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    OAuth2 and OpenID Connect (OIDC) are authentication and authorization protocols used in modern applications to secure access to resources. Spring Security provides built-in support for integrating these protocols efficiently.
  </p>

  <h3 style="color: #16a085;">What is OAuth2?</h3>
  <p style="color: #2c3e50;">
    OAuth2 (Open Authorization) is an authorization framework that enables third-party applications to access user resources without exposing credentials. It uses Access Tokens to authorize API requests.
  </p>

  <h3 style="color: #e67e22;">What is OpenID Connect?</h3>
  <p style="color: #2c3e50;">
    OpenID Connect (OIDC) is an authentication protocol built on top of OAuth2. It allows users to authenticate with an identity provider (IdP) and obtain identity tokens (ID Token) along with access tokens.
  </p>

  <h3 style="color: #8e44ad;">Setting Up OAuth2 in Spring Security</h3>
  <p style="color: #2c3e50;">
    To integrate OAuth2 in a Spring Boot application, we need to configure OAuth2 client properties and enable security filters.
  </p>

  <h3 style="color: #d35400;">OAuth2 Configuration</h3>
  <p style="color: #2c3e50;">
    Define OAuth2 properties in the <code>application.yml</code> file to specify the authentication provider.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      spring:
        security:
          oauth2:
            client:
              registration:
                google:
                  client-id: your-client-id
                  client-secret: your-client-secret
                  scope: openid, profile, email
    </code>
  </pre>

  <h3 style="color: #16a085;">OAuth2 Security Configuration</h3>
  <p style="color: #2c3e50;">
    Enable OAuth2 login in Spring Security by creating a security configuration class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

      @Configuration
      @EnableWebSecurity
      public class SecurityConfig extends WebSecurityConfigurerAdapter {
          @Override
          protected void configure(HttpSecurity http) throws Exception {
              http
                  .authorizeRequests()
                      .antMatchers("/").permitAll()
                      .anyRequest().authenticated()
                  .and()
                  .oauth2Login();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Extracting User Information</h3>
  <p style="color: #2c3e50;">
    After successful authentication, we can extract user details from the OAuth2 user object.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.oauth2.core.user.OAuth2User;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RestController;
      import java.security.Principal;

      @RestController
      public class UserController {
          @GetMapping("/user")
          public Principal getUser(Principal principal) {
              return principal;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>OAuth2</strong> for secure API authorization.</li>
    <li>Enable <strong>OpenID Connect</strong> for identity authentication.</li>
    <li>Store OAuth2 tokens securely and avoid exposing them in URLs.</li>
    <li>Use secure scopes and permissions when configuring OAuth2 clients.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    OAuth2 and OpenID Connect provide a secure way to authenticate users and authorize API access. Spring Security makes integration easy with built-in OAuth2 login and identity token management. By leveraging these protocols, we can ensure seamless and secure authentication in modern applications.
  </p>
</div>
`
},
{
  title:`OAuth2 Authorization Server`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding OAuth2 Authorization Server in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    OAuth2 Authorization Server is a component that issues access tokens for client applications to securely access protected resources. In Spring Security, it provides authentication and authorization mechanisms following OAuth2 specifications.
  </p>

  <h3 style="color: #16a085;">What is an OAuth2 Authorization Server?</h3>
  <p style="color: #2c3e50;">
    The OAuth2 Authorization Server is responsible for issuing, validating, and managing access tokens. It provides endpoints such as token issuance, introspection, and revocation.
  </p>

  <h3 style="color: #e67e22;">Setting Up OAuth2 Authorization Server</h3>
  <p style="color: #2c3e50;">
    To create an OAuth2 Authorization Server in Spring Security, we use the <code>spring-authorization-server</code> dependency and configure its components.
  </p>

  <h3 style="color: #8e44ad;">Adding Dependencies</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-oauth2-authorization-server&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #d35400;">Creating the Authorization Server Configuration</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfigurer;
      import org.springframework.security.web.SecurityFilterChain;
      import static org.springframework.security.config.Customizer.withDefaults;
      
      @Configuration
      @EnableWebSecurity
      public class AuthorizationServerConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = 
                  new OAuth2AuthorizationServerConfigurer();
              http.apply(authorizationServerConfigurer);
              return http.formLogin(withDefaults()).build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Defining Registered Clients</h3>
  <p style="color: #2c3e50;">
    OAuth2 requires registered clients that will be authorized to request tokens.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.oauth2.server.authorization.client.RegisteredClient;
      import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository;
      import org.springframework.security.oauth2.server.authorization.client.InMemoryRegisteredClientRepository;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import java.util.UUID;
      
      @Configuration
      public class ClientConfig {
          @Bean
          public RegisteredClientRepository registeredClientRepository() {
              RegisteredClient client = RegisteredClient.withId(UUID.randomUUID().toString())
                      .clientId("client-id")
                      .clientSecret("{noop}client-secret")
                      .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                      .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                      .build();
              return new InMemoryRegisteredClientRepository(client);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use secure password encoding for client secrets.</li>
    <li>Enable HTTPS to secure communication between clients and the authorization server.</li>
    <li>Configure token expiration policies and revocation mechanisms.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Setting up an OAuth2 Authorization Server in Spring Security allows secure authentication and authorization for client applications. By correctly configuring the authorization server and its clients, we can ensure secure and efficient token-based authentication.
  </p>
</div>
`
},
{
  title:`OAuth2 Resource Server`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding OAuth2 Resource Server in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    In an OAuth2-based authentication system, the **Resource Server** is responsible for securing APIs and validating access tokens issued by the **Authorization Server**. Spring Security provides built-in support for implementing an OAuth2 **Resource Server**, allowing applications to verify JWT (JSON Web Tokens) or opaque tokens before granting access to protected resources.
  </p>

  <h3 style="color: #16a085;">What is an OAuth2 Resource Server?</h3>
  <p style="color: #2c3e50;">
    The **OAuth2 Resource Server** is an application that hosts protected resources (APIs) and verifies access tokens before providing access. It works in conjunction with an **OAuth2 Authorization Server** to ensure only authorized clients can access the resources.
  </p>

  <h3 style="color: #e67e22;">Configuring an OAuth2 Resource Server in Spring Security</h3>
  <p style="color: #2c3e50;">
    To set up an **OAuth2 Resource Server**, we need to configure Spring Security to validate JWT tokens.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.http.SessionCreationPolicy;
      import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
      import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
      import org.springframework.security.web.SecurityFilterChain;

      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .authorizeHttpRequests(auth -> auth
                      .requestMatchers("/public/**").permitAll()
                      .anyRequest().authenticated()
                  )
                  .oauth2ResourceServer(oauth2 -> oauth2
                      .jwt(jwtConfigurer -> jwtConfigurer.jwtAuthenticationConverter(jwtAuthenticationConverter()))
                  )
                  .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
              return http.build();
          }

          @Bean
          public JwtAuthenticationConverter jwtAuthenticationConverter() {
              JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
              grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");
              grantedAuthoritiesConverter.setAuthoritiesClaimName("roles");

              JwtAuthenticationConverter authenticationConverter = new JwtAuthenticationConverter();
              authenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
              return authenticationConverter;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Adding Dependencies for OAuth2 Resource Server</h3>
  <p style="color: #2c3e50;">
    To use Spring Security's OAuth2 Resource Server, add the following dependency in your **pom.xml** file:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
      </dependency>
    </code>
  </pre>

  <h3 style="color: #d35400;">Configuring JWT Token Validation</h3>
  <p style="color: #2c3e50;">
    The **OAuth2 Resource Server** needs to validate access tokens. Configure the token issuer in **application.properties**:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      spring.security.oauth2.resourceserver.jwt.issuer-uri=https://your-auth-server.com
    </code>
  </pre>

  <h3 style="color: #16a085;">Protecting API Endpoints</h3>
  <p style="color: #2c3e50;">
    We can now secure REST API endpoints using role-based access control (RBAC) with JWT claims.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      import org.springframework.security.access.prepost.PreAuthorize;

      @RestController
      @RequestMapping("/api")
      public class ResourceController {
          
          @GetMapping("/public")
          public String publicEndpoint() {
              return "This is a public endpoint";
          }

          @GetMapping("/user")
          @PreAuthorize("hasRole('USER')")
          public String userEndpoint() {
              return "This is a protected USER endpoint";
          }

          @GetMapping("/admin")
          @PreAuthorize("hasRole('ADMIN')")
          public String adminEndpoint() {
              return "This is a protected ADMIN endpoint";
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **JWT tokens** for better performance and stateless authentication.</li>
    <li>Secure API endpoints using **role-based access control (RBAC)**.</li>
    <li>Validate tokens using the **OAuth2 Authorization Server**.</li>
    <li>Configure CORS settings properly to prevent security vulnerabilities.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The **OAuth2 Resource Server** is a crucial component in securing APIs in a microservices or distributed system. By integrating Spring Security's OAuth2 Resource Server, we can ensure secure access control and token validation for API endpoints.
  </p>
</div>
`
},
{
  title:`Session Management & CSRF`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Session Management & CSRF in Spring Security</h2>
  
  <p style="font-size: 16px; color: #34495e;">
    In modern web applications, security is critical. Two key aspects of securing applications are **Session Management** and **Cross-Site Request Forgery (CSRF) Protection**. Spring Security provides built-in mechanisms to manage sessions and prevent CSRF attacks effectively.
  </p>
  
  <h3 style="color: #16a085;">Session Management in Spring Security</h3>
  <p style="color: #2c3e50;">
    Session management is essential to control user authentication and prevent session-related vulnerabilities such as **Session Fixation** and **Session Hijacking**.
  </p>

  <h3 style="color: #e67e22;">Configuring Session Management</h3>
  <p style="color: #2c3e50;">
    In Spring Security, we can configure session management using the sessionManagement() method inside the security filter chain.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.web.SecurityFilterChain;
      import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
      
      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .sessionManagement(session -> session
                      .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) // Default session policy
                      .maximumSessions(1) // Allows only one session per user
                      .expiredUrl("/session-expired") // Redirects to this URL when session expires
                  );
              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Session Management Policies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>ALWAYS</strong>: Always create a session.</li>
    <li><strong>IF_REQUIRED</strong>: Create a session only if needed (default).</li>
    <li><strong>NEVER</strong>: Do not create a session but use one if it exists.</li>
    <li><strong>STATELESS</strong>: Never use sessions (useful for JWT-based authentication).</li>
  </ul>

  <h3 style="color: #d35400;">Understanding CSRF (Cross-Site Request Forgery)</h3>
  <p style="color: #2c3e50;">
    CSRF is an attack that forces authenticated users to perform unwanted actions on a web application. Spring Security enables CSRF protection by default to prevent such attacks.
  </p>

  <h3 style="color: #16a085;">Enabling CSRF Protection</h3>
  <p style="color: #2c3e50;">
    CSRF protection works by generating a unique token for each request and validating it. This ensures that requests are coming from a legitimate source.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
      
      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .csrf(csrf -> csrf
                      .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) // Store CSRF token in a cookie
                  );
              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Disabling CSRF Protection (For APIs)</h3>
  <p style="color: #2c3e50;">
    For stateless REST APIs using JWT, we can disable CSRF protection since APIs do not rely on sessions.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      http
          .csrf(csrf -> csrf.disable());
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **stateless** sessions for APIs to improve security.</li>
    <li>Limit the number of concurrent sessions per user to prevent session hijacking.</li>
    <li>Always enable **CSRF protection** for web applications handling sensitive data.</li>
    <li>Use **secure cookies** to store CSRF tokens.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Proper session management and CSRF protection are crucial for securing modern applications. By implementing these best practices, we can prevent unauthorized access and mitigate security risks effectively.
  </p>
</div>
`
},
{
  title:`CORS Handling`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding CORS Handling in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cross-Origin Resource Sharing (CORS) is a security feature that controls how web applications in different domains interact. By default, browsers restrict cross-origin requests for security reasons. Spring Security provides mechanisms to handle CORS effectively.
  </p>

  <h3 style="color: #16a085;">What is CORS?</h3>
  <p style="color: #2c3e50;">
    CORS is a browser security policy that prevents unauthorized requests from different origins. If an application running on <code>http://localhost:3000</code> tries to access an API on <code>http://localhost:8080</code>, the browser will block the request unless the API explicitly allows it.
  </p>

  <h3 style="color: #e67e22;">Enabling CORS in Spring Security</h3>
  <p style="color: #2c3e50;">
    Spring Security provides flexible ways to configure CORS using global or method-level settings.
  </p>

  <h3 style="color: #8e44ad;">1. Global CORS Configuration</h3>
  <p style="color: #2c3e50;">
    A global configuration applies to all controllers.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.web.servlet.config.annotation.CorsRegistry;
      import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

      @Configuration
      public class CorsConfig {
          @Bean
          public WebMvcConfigurer corsConfigurer() {
              return new WebMvcConfigurer() {
                  @Override
                  public void addCorsMappings(CorsRegistry registry) {
                      registry.addMapping("/**")
                              .allowedOrigins("http://localhost:3000")
                              .allowedMethods("GET", "POST", "PUT", "DELETE")
                              .allowedHeaders("Authorization", "Content-Type");
                  }
              };
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">2. Configuring CORS in Spring Security</h3>
  <p style="color: #2c3e50;">
    If you use Spring Security, you must explicitly allow CORS in the security filter chain.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.web.SecurityFilterChain;

      @EnableWebSecurity
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http.cors().and().csrf().disable()
                  .authorizeHttpRequests(authorize -> authorize.anyRequest().authenticated());
              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">3. Enabling CORS in a Controller</h3>
  <p style="color: #2c3e50;">
    You can enable CORS on specific controllers or endpoints.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.CrossOrigin;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class TestController {
          @CrossOrigin(origins = "http://localhost:3000")
          @GetMapping("/data")
          public String getData() {
              return "CORS Enabled";
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Restrict allowed origins instead of using <code>*</code> to prevent security risks.</li>
    <li>Use secure HTTP methods and limit allowed headers.</li>
    <li>Enable CORS on the security layer if using Spring Security.</li>
    <li>Log CORS issues for debugging purposes.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    CORS handling is essential for allowing secure cross-origin requests in web applications. By properly configuring CORS in Spring Boot and Spring Security, we can enable controlled access while maintaining security.
  </p>
</div>`
},
{
  title:`Database Authentication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Database Authentication in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Database authentication is a common approach in Spring Security where user credentials are stored in a relational database instead of in-memory authentication. It ensures centralized user management and scalability.
  </p>

  <h3 style="color: #16a085;">Setting Up Database Authentication</h3>
  <p style="color: #2c3e50;">
    In Spring Security, we can authenticate users using a database by configuring **JDBC Authentication** or implementing a custom **UserDetailsService**.
  </p>

  <h3 style="color: #e67e22;">Creating the User Table</h3>
  <p style="color: #2c3e50;">
    We need to create a database table to store user credentials.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-sql">
      CREATE TABLE users (
          id INT PRIMARY KEY AUTO_INCREMENT,
          username VARCHAR(50) UNIQUE NOT NULL,
          password VARCHAR(255) NOT NULL,
          role VARCHAR(50) NOT NULL,
          enabled BOOLEAN DEFAULT TRUE
      );
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring JDBC Authentication</h3>
  <p style="color: #2c3e50;">
    Spring Security provides built-in JDBC authentication using a **DataSource**.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.sql.DataSource;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
      import org.springframework.security.crypto.password.PasswordEncoder;
      
      @Configuration
      @EnableWebSecurity
      public class SecurityConfig {
          private final DataSource dataSource;
          
          public SecurityConfig(DataSource dataSource) {
              this.dataSource = dataSource;
          }

          protected void configure(AuthenticationManagerBuilder auth) throws Exception {
              auth.jdbcAuthentication()
                  .dataSource(dataSource)
                  .usersByUsernameQuery("SELECT username, password, enabled FROM users WHERE username=?")
                  .authoritiesByUsernameQuery("SELECT username, role FROM users WHERE username=?")
                  .passwordEncoder(passwordEncoder());
          }
          
          @Bean
          public PasswordEncoder passwordEncoder() {
              return new BCryptPasswordEncoder();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Using Custom UserDetailsService</h3>
  <p style="color: #2c3e50;">
    Instead of using JDBC authentication, we can implement a **custom UserDetailsService** for more flexibility.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.core.userdetails.UserDetails;
      import org.springframework.security.core.userdetails.UserDetailsService;
      import org.springframework.security.core.userdetails.UsernameNotFoundException;
      import org.springframework.stereotype.Service;
      import java.util.ArrayList;
      
      @Service
      public class CustomUserDetailsService implements UserDetailsService {
          @Override
          public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
              if ("admin".equals(username)) {
                  return new User("admin", "{bcrypt}$2a$10$xyz", new ArrayList<>());
              } else {
                  throw new UsernameNotFoundException("User not found!");
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">Storing and Validating Passwords</h3>
  <p style="color: #2c3e50;">
    To ensure security, we must encode passwords before storing them in the database.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

      public class PasswordEncoderExample {
          public static void main(String[] args) {
              BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
              String rawPassword = "mypassword";
              String encodedPassword = encoder.encode(rawPassword);

              System.out.println("Encoded Password: " + encodedPassword);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always use **BCryptPasswordEncoder** for password storage.</li>
    <li>Use a strong hashing algorithm with a secure salt.</li>
    <li>Ensure the database is properly secured against SQL injection.</li>
    <li>Use **Prepared Statements** when querying user credentials.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Database authentication in Spring Security provides a scalable and secure way to manage user authentication. Whether using **JDBC Authentication** or a **custom UserDetailsService**, proper password encoding and best security practices are essential.
  </p>
</div>`
},
{
  title:`Form & Basic Authentication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Form & Basic Authentication in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Authentication is a fundamental part of web security, ensuring that only legitimate users access protected resources. Spring Security supports multiple authentication mechanisms, with <strong>Form Authentication</strong> and <strong>Basic Authentication</strong> being the most commonly used.
  </p>

  <h3 style="color: #16a085;">What is Basic Authentication?</h3>
  <p style="color: #2c3e50;">
    Basic Authentication is a simple authentication mechanism where the client sends a request with a username and password encoded in the HTTP <code>Authorization</code> header using Base64 encoding.
  </p>

  <h3 style="color: #e67e22;">Configuring Basic Authentication in Spring Security</h3>
  <p style="color: #2c3e50;">
    In Spring Boot, we can configure Basic Authentication using the security configuration class:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.web.SecurityFilterChain;

      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
                  .httpBasic();
              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">What is Form Authentication?</h3>
  <p style="color: #2c3e50;">
    Form Authentication is a user-friendly authentication method where users enter their credentials into a login form instead of using HTTP headers.
  </p>

  <h3 style="color: #d35400;">Configuring Form Authentication in Spring Security</h3>
  <p style="color: #2c3e50;">
    To enable form-based login, modify the security configuration as follows:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.web.SecurityFilterChain;

      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
                  .formLogin();
              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Differences Between Basic and Form Authentication</h3>
  <table border="1" style="border-collapse: collapse; width: 100%; text-align: left;">
    <tr style="background-color: #f4f4f4;">
      <th style="padding: 8px;">Feature</th>
      <th style="padding: 8px;">Basic Authentication</th>
      <th style="padding: 8px;">Form Authentication</th>
    </tr>
    <tr>
      <td style="padding: 8px;">Authentication Method</td>
      <td style="padding: 8px;">HTTP Headers</td>
      <td style="padding: 8px;">Login Form</td>
    </tr>
    <tr>
      <td style="padding: 8px;">Security Level</td>
      <td style="padding: 8px;">Less Secure (credentials sent in every request)</td>
      <td style="padding: 8px;">More Secure (session-based authentication)</td>
    </tr>
    <tr>
      <td style="padding: 8px;">User Experience</td>
      <td style="padding: 8px;">Less Friendly</td>
      <td style="padding: 8px;">More User-Friendly</td>
    </tr>
  </table>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always use HTTPS to prevent credential interception.</li>
    <li>For API authentication, prefer OAuth2 or JWT over Basic Authentication.</li>
    <li>Use session management and CSRF protection in Form Authentication.</li>
    <li>Encourage password hashing and encoding using <code>BCryptPasswordEncoder</code>.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Form Authentication and Basic Authentication serve different use cases. While Basic Authentication is simple and useful for APIs, Form Authentication provides a better user experience for web applications. Choosing the right authentication mechanism depends on security requirements and usability needs.
  </p>
</div>
`
},
{
  title:`LDAP Authentication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to LDAP Authentication in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    LDAP (Lightweight Directory Access Protocol) is a widely used protocol for accessing and managing directory information services, such as user authentication and authorization. In Spring Boot, LDAP authentication allows you to integrate your application with an LDAP server (e.g., Active Directory, OpenLDAP) to authenticate users and manage their roles. This article explores how to configure and implement LDAP authentication in a Spring Boot application.
  </p>

  <h3 style="color: #16a085;">Why Use LDAP Authentication?</h3>
  <p style="color: #2c3e50;">
    LDAP authentication offers several benefits for enterprise applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized User Management</strong>: Manage users and roles in a centralized directory service.</li>
    <li><strong>Security</strong>: Leverage LDAP's secure authentication mechanisms.</li>
    <li><strong>Scalability</strong>: Handle large numbers of users and roles efficiently.</li>
    <li><strong>Integration</strong>: Seamlessly integrate with existing LDAP-based systems like Active Directory.</li>
    <li><strong>Standardization</strong>: Use a standardized protocol for directory services.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of LDAP Authentication</h3>
  <p style="color: #2c3e50;">
    When working with LDAP authentication in Spring Boot, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>LDAP Server</strong>: The directory server that stores user and role information (e.g., Active Directory, OpenLDAP).</li>
    <li><strong>Bind Authentication</strong>: Authenticating a user by binding to the LDAP server with their credentials.</li>
    <li><strong>User DN (Distinguished Name)</strong>: The unique identifier for a user in the LDAP directory.</li>
    <li><strong>Base DN</strong>: The root of the LDAP directory tree where user searches begin.</li>
    <li><strong>Group/Role Mapping</strong>: Mapping LDAP groups to application roles for authorization.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing LDAP Authentication in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to configure and implement LDAP authentication in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Add Dependencies</h4>
  <p style="color: #2c3e50;">
    Add the necessary dependencies for LDAP and Spring Security in your <code>pom.xml</code> or <code>build.gradle</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;!-- For Maven --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-data-ldap&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Configure LDAP in <code>application.yml</code></h4>
  <p style="color: #2c3e50;">
    Configure the LDAP server connection details in the <code>application.yml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        ldap:
          urls: ldap://localhost:389
          base: dc=example,dc=com
          username: cn=admin,dc=example,dc=com
          password: adminpassword
      security:
        user:
          name: user
          password: password
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Configure Spring Security for LDAP</h4>
  <p style="color: #2c3e50;">
    Configure Spring Security to use LDAP for authentication and authorization.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
      import org.springframework.security.crypto.password.PasswordEncoder;

      @Configuration
      @EnableWebSecurity
      public class SecurityConfig extends WebSecurityConfigurerAdapter {

          @Override
          protected void configure(HttpSecurity http) throws Exception {
              http
                  .authorizeRequests()
                      .anyRequest().fullyAuthenticated()
                      .and()
                  .formLogin();
          }

          @Override
          protected void configure(AuthenticationManagerBuilder auth) throws Exception {
              auth
                  .ldapAuthentication()
                      .userDnPatterns("uid={0},ou=people")
                      .groupSearchBase("ou=groups")
                      .contextSource()
                          .url("ldap://localhost:389/dc=example,dc=com")
                          .and()
                      .passwordCompare()
                          .passwordEncoder(new BCryptPasswordEncoder())
                          .passwordAttribute("userPassword");
          }

          @Bean
          public PasswordEncoder passwordEncoder() {
              return new BCryptPasswordEncoder();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Test LDAP Authentication</h4>
  <p style="color: #2c3e50;">
    Run your application and test LDAP authentication by logging in with valid LDAP credentials.
  </p>

  <h3 style="color: #d35400;">Best Practices for LDAP Authentication</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use secure LDAP (LDAPS) to encrypt communication with the LDAP server.</li>
    <li>Store LDAP connection details (e.g., URLs, credentials) securely using environment variables or secrets management tools.</li>
    <li>Map LDAP groups to application roles for fine-grained authorization.</li>
    <li>Test your LDAP configuration thoroughly to ensure compatibility with your directory server.</li>
    <li>Use a password encoder to securely store and compare passwords.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    LDAP authentication is a powerful way to integrate your Spring Boot application with an LDAP directory service for centralized user management and secure authentication. By configuring Spring Security to use LDAP, you can leverage existing user directories like Active Directory or OpenLDAP, reducing the need for custom user management solutions. Whether you're building enterprise applications or integrating with existing systems, LDAP authentication provides a scalable and secure approach to user authentication and authorization.
  </p>
</div>`
},
{
  title:`Two-Factor Authentication`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Two-Factor Authentication (2FA) in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Two-Factor Authentication (2FA) enhances security by requiring users to verify their identity using two different factors: something they know (password) and something they have (OTP, email, or app-based authentication).
  </p>

  <h3 style="color: #16a085;">How 2FA Works</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>User enters their username and password.</li>
    <li>If credentials are correct, the system prompts for a second authentication factor.</li>
    <li>User provides a one-time password (OTP) from an email, SMS, or authentication app.</li>
    <li>If the OTP is valid, access is granted.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up 2FA with Spring Security</h3>
  <p style="color: #2c3e50;">
    Implementing 2FA requires integrating an OTP generator, such as Google Authenticator, or sending OTPs via email/SMS.
  </p>

  <h3 style="color: #d35400;">1. User Entity with OTP</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.persistence.*;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String username;
          private String password;
          private String otpSecret; // For TOTP-based authentication
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Generating and Validating OTP</h3>
  <p style="color: #2c3e50;">
    Use the <code>Time-based One-Time Password (TOTP)</code> algorithm for generating secure OTPs.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import com.eatthepath.otp.TimeBasedOneTimePasswordGenerator;
      import java.security.Key;
      import javax.crypto.KeyGenerator;
      import java.time.Instant;

      public class OTPService {
          private final TimeBasedOneTimePasswordGenerator totpGenerator = new TimeBasedOneTimePasswordGenerator();
          private final Key key;

          public OTPService() throws Exception {
              KeyGenerator keyGenerator = KeyGenerator.getInstance("HmacSHA1");
              this.key = keyGenerator.generateKey();
          }

          public int generateOTP() {
              return totpGenerator.generateOneTimePassword(key, Instant.now());
          }
      }
    </code>
  </pre>

  <h3 style="color: #16a085;">3. Validating OTP in Authentication</h3>
  <p style="color: #2c3e50;">
    Validate the OTP before granting access to the application.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      public boolean validateOTP(int providedOTP, int generatedOTP) {
          return providedOTP == generatedOTP;
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">4. Integrating 2FA with Spring Security</h3>
  <p style="color: #2c3e50;">
    Modify the authentication process to include OTP validation.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class CustomAuthenticationProvider implements AuthenticationProvider {
          @Autowired
          private OTPService otpService;

          @Override
          public Authentication authenticate(Authentication authentication) throws AuthenticationException {
              String username = authentication.getName();
              String password = authentication.getCredentials().toString();
              int providedOTP = (int) authentication.getDetails();
              int generatedOTP = otpService.generateOTP();

              if (validateOTP(providedOTP, generatedOTP)) {
                  return new UsernamePasswordAuthenticationToken(username, password, new ArrayList<>());
              } else {
                  throw new BadCredentialsException("Invalid OTP");
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>TOTP</strong> for enhanced security instead of SMS-based OTPs.</li>
    <li>Enable 2FA for critical user actions like password changes and financial transactions.</li>
    <li>Store OTP secrets securely and do not expose them in logs.</li>
    <li>Use third-party libraries like Google Authenticator for easier integration.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Two-Factor Authentication (2FA) adds an extra layer of security to protect user accounts. By integrating OTP-based authentication with Spring Security, we can ensure a more secure authentication mechanism.
  </p>
</div>
`
},
{
  title:`Security for Microservices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Security for Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Microservices architecture involves breaking down an application into smaller, independent services that communicate over a network. While this approach offers benefits like scalability, flexibility, and faster development cycles, it also introduces unique security challenges. Securing microservices requires a comprehensive strategy that addresses authentication, authorization, data protection, and communication security. This article explores best practices and tools for implementing security in a microservices architecture using Spring Boot and related technologies.
  </p>

  <h3 style="color: #16a085;">Why is Security Important for Microservices?</h3>
  <p style="color: #2c3e50;">
    Security is critical for microservices due to the following reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Distributed Nature</strong>: Microservices communicate over a network, making them vulnerable to attacks like eavesdropping and man-in-the-middle attacks.</li>
    <li><strong>Increased Attack Surface</strong>: Each microservice exposes its own API, increasing the number of potential entry points for attackers.</li>
    <li><strong>Data Sensitivity</strong>: Microservices often handle sensitive data, requiring robust protection mechanisms.</li>
    <li><strong>Compliance</strong>: Many industries have strict regulatory requirements for data security and privacy.</li>
    <li><strong>Service-to-Service Communication</strong>: Ensuring secure communication between microservices is essential to prevent unauthorized access.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Microservices Security</h3>
  <p style="color: #2c3e50;">
    When securing microservices, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Authentication</strong>: Verifying the identity of users or services accessing the system.</li>
    <li><strong>Authorization</strong>: Ensuring that authenticated users or services have the necessary permissions to access resources.</li>
    <li><strong>Encryption</strong>: Protecting data in transit and at rest using encryption techniques.</li>
    <li><strong>API Gateway</strong>: A centralized entry point for managing and securing API requests.</li>
    <li><strong>Service-to-Service Security</strong>: Securing communication between microservices using mutual TLS (mTLS) or tokens.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Security for Microservices</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement security in a microservices architecture using Spring Boot and Spring Cloud.
  </p>

  <h4 style="color: #8e44ad;">1. Secure APIs with Spring Security</h4>
  <p style="color: #2c3e50;">
    Use Spring Security to secure the APIs exposed by your microservices.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
      import org.springframework.security.crypto.password.PasswordEncoder;

      @Configuration
      @EnableWebSecurity
      public class SecurityConfig extends WebSecurityConfigurerAdapter {

          @Override
          protected void configure(HttpSecurity http) throws Exception {
              http
                  .authorizeRequests()
                      .antMatchers("/public/**").permitAll()
                      .anyRequest().authenticated()
                      .and()
                  .oauth2ResourceServer()
                      .jwt();
          }

          @Bean
          public PasswordEncoder passwordEncoder() {
              return new BCryptPasswordEncoder();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Use OAuth2 and JWT for Authentication</h4>
  <p style="color: #2c3e50;">
    Implement OAuth2 and JWT (JSON Web Tokens) for secure authentication and authorization.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.security.oauth2.jwt.JwtDecoder;
      import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;

      @Bean
      public JwtDecoder jwtDecoder() {
          return NimbusJwtDecoder.withJwkSetUri("https://your-auth-server/.well-known/jwks.json").build();
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Secure Service-to-Service Communication</h4>
  <p style="color: #2c3e50;">
    Use mutual TLS (mTLS) or OAuth2 tokens to secure communication between microservices.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      # Example configuration for mTLS in application.yml
      server:
        ssl:
          enabled: true
          key-store: classpath:keystore.jks
          key-store-password: changeit
          key-password: changeit
          trust-store: classpath:truststore.jks
          trust-store-password: changeit
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Use an API Gateway</h4>
  <p style="color: #2c3e50;">
    Implement an API gateway to centralize security, rate limiting, and request routing.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.cloud.gateway.route.RouteLocator;
      import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class GatewayConfig {

          @Bean
          public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
              return builder.routes()
                  .route("user_service", r -> r.path("/users/**")
                      .uri("http://localhost:8081"))
                  .route("order_service", r -> r.path("/orders/**")
                      .uri("http://localhost:8082"))
                  .build();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">5. Monitor and Log Security Events</h4>
  <p style="color: #2c3e50;">
    Implement logging and monitoring to detect and respond to security incidents.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.web.SecurityFilterChain;
      import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

      @Bean
      public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
          http
              .addFilterBefore(new LoggingFilter(), UsernamePasswordAuthenticationFilter.class)
              .authorizeRequests()
              .anyRequest().authenticated();
          return http.build();
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Microservices Security</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use OAuth2 and JWT for secure authentication and authorization.</li>
    <li>Encrypt data in transit using HTTPS and mutual TLS (mTLS).</li>
    <li>Implement an API gateway to centralize security and routing.</li>
    <li>Use role-based access control (RBAC) to enforce fine-grained permissions.</li>
    <li>Monitor and log security events to detect and respond to threats.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Securing microservices is a critical aspect of building modern, distributed applications. By implementing robust authentication, authorization, encryption, and monitoring mechanisms, you can protect your microservices from threats and ensure compliance with security standards. Whether you're using Spring Security, OAuth2, or an API gateway, following best practices will help you create a secure and resilient microservices architecture.
  </p>
</div>`
},
{
  title:`API Gateway Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding API Gateway Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    API Gateway acts as a central entry point for managing and securing API requests in a microservices architecture. It handles authentication, authorization, rate limiting, request validation, and monitoring, ensuring secure API communication.
  </p>

  <h3 style="color: #16a085;">Key Security Features in API Gateway</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Authentication & Authorization</li>
    <li>Rate Limiting & Throttling</li>
    <li>Secure Data Transmission (HTTPS, TLS)</li>
    <li>Request Validation & Filtering</li>
    <li>Logging & Monitoring</li>
    <li>Threat Protection (DDoS, SQL Injection, XSS)</li>
  </ul>

  <h3 style="color: #e67e22;">Implementing Authentication & Authorization</h3>
  <p style="color: #2c3e50;">
    API Gateways integrate authentication mechanisms such as JWT, OAuth2, and API keys to ensure secure access. Role-based access control (RBAC) and attribute-based access control (ABAC) enforce fine-grained authorization.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .authorizeHttpRequests(auth -> auth
                      .requestMatchers("/admin/**").hasRole("ADMIN")
                      .requestMatchers("/user/**").authenticated()
                  )
                  .oauth2Login()
                  .and()
                  .jwt();
              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Rate Limiting & Throttling</h3>
  <p style="color: #2c3e50;">
    To prevent API abuse, API gateways implement rate limiting strategies such as token bucket, leaky bucket, and sliding window counters.
  </p>
  
  <h3 style="color: #d35400;">Enforcing HTTPS & Secure Data Transmission</h3>
  <p style="color: #2c3e50;">
    APIs should only be accessible over HTTPS to encrypt data transmission and prevent eavesdropping and man-in-the-middle attacks.
  </p>
  
  <h3 style="color: #e67e22;">Logging, Monitoring & Threat Detection</h3>
  <p style="color: #2c3e50;">
    API Gateway logs request details, errors, and security incidents, helping teams monitor API traffic and detect potential threats.
  </p>

  <h3 style="color: #2c3e50;">Best Practices for API Gateway Security</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use strong authentication (JWT, OAuth2, API keys)</li>
    <li>Implement rate limiting and throttling</li>
    <li>Encrypt sensitive data in transit (TLS, HTTPS)</li>
    <li>Validate and sanitize all API requests</li>
    <li>Enable logging, monitoring, and anomaly detection</li>
  </ul>
  
  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    API Gateway security is critical for protecting APIs and microservices from unauthorized access, attacks, and performance degradation. By implementing strong authentication, rate limiting, and encryption, organizations can secure their API ecosystem effectively.
  </p>
</div>
`
},
{
  title:`Testing & Debugging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing & Debugging in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Ensuring security configurations function correctly is crucial for any application. Spring Security provides various tools for testing and debugging authentication, authorization, and security filters effectively.
  </p>

  <h3 style="color: #16a085;">Unit Testing Security Components</h3>
  <p style="color: #2c3e50;">
    Unit testing helps verify individual security components such as authentication, authorization, and security filters.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
      import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
      import org.springframework.security.test.context.support.WithMockUser;
      import org.springframework.test.web.servlet.MockMvc;

      @WebMvcTest
      public class SecurityTest {
          @Autowired
          private MockMvc mockMvc;

          @Test
          @WithMockUser(username = "admin", roles = {"ADMIN"})
          public void testAdminAccess() throws Exception {
              mockMvc.perform(get("/admin"))
                      .andExpect(status().isOk());
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Integration Testing Security Configurations</h3>
  <p style="color: #2c3e50;">
    Integration testing validates security mechanisms across multiple layers, ensuring secure authentication and authorization workflows.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.junit.jupiter.api.Test;
      import org.springframework.boot.test.context.SpringBootTest;
      import org.springframework.boot.test.web.client.TestRestTemplate;
      import org.springframework.boot.web.server.LocalServerPort;
      import static org.assertj.core.api.Assertions.assertThat;

      @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
      public class IntegrationTest {
          @LocalServerPort
          private int port;

          private TestRestTemplate restTemplate = new TestRestTemplate();

          @Test
          public void testUnauthorizedAccess() {
              String url = "http://localhost:" + port + "/secure-endpoint";
              String response = restTemplate.getForObject(url, String.class);
              assertThat(response).contains("Forbidden");
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Debugging Security Issues</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Enable **debug logs** in Spring Security: <code>logging.level.org.springframework.security=DEBUG</code></li>
    <li>Use **Spring Security’s event listeners** to track authentication failures and access denials.</li>
    <li>Leverage **Spring Security Test** utilities to simulate various user roles.</li>
    <li>Use **Postman** or **cURL** to manually test authentication endpoints.</li>
  </ul>

  <h3 style="color: #d35400;">Common Security Testing Tools</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>OWASP ZAP</strong> - For security vulnerability scanning.</li>
    <li><strong>JUnit & MockMvc</strong> - For unit and integration testing.</li>
    <li><strong>Burp Suite</strong> - For penetration testing.</li>
    <li><strong>Spring Security Test</strong> - For security-focused tests.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Testing and debugging Spring Security configurations is essential to prevent vulnerabilities. By using unit and integration tests, enabling debug logs, and leveraging security tools, we can ensure a robust security implementation in our applications.
  </p>
</div>
`
},
{
  title:`Spring Boot Actuator`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Spring Boot Actuator</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot Actuator is a powerful feature that provides production-ready capabilities to monitor and manage your Spring Boot application. It exposes a set of built-in endpoints that allow you to gather insights into the application's health, metrics, environment, and more. Actuator is particularly useful for DevOps teams, as it simplifies the process of monitoring, troubleshooting, and managing applications in production environments.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Boot Actuator?</h3>
  <p style="color: #2c3e50;">
    Spring Boot Actuator offers several benefits for managing and monitoring applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Production-Ready Monitoring</strong>: Provides built-in endpoints for health checks, metrics, and more.</li>
    <li><strong>Customizable</strong>: Allows you to extend and customize endpoints to suit your needs.</li>
    <li><strong>Integration</strong>: Integrates seamlessly with monitoring tools like Prometheus, Grafana, and Micrometer.</li>
    <li><strong>Insightful Metrics</strong>: Tracks application performance, memory usage, garbage collection, and other key metrics.</li>
    <li><strong>Security</strong>: Supports securing actuator endpoints to prevent unauthorized access.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Spring Boot Actuator</h3>
  <p style="color: #2c3e50;">
    When working with Spring Boot Actuator, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Endpoints</strong>: Built-in endpoints like <code>/actuator/health</code>, <code>/actuator/metrics</code>, and <code>/actuator/env</code> provide insights into the application.</li>
    <li><strong>Health Indicators</strong>: Checks the health of the application and its dependencies (e.g., database, disk space).</li>
    <li><strong>Metrics</strong>: Tracks application performance and resource usage using Micrometer.</li>
    <li><strong>Custom Endpoints</strong>: Allows you to create custom actuator endpoints for specific use cases.</li>
    <li><strong>Security</strong>: Secures actuator endpoints using Spring Security.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Spring Boot Actuator</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to configure and use Spring Boot Actuator in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Add Actuator Dependency</h4>
  <p style="color: #2c3e50;">
    Add the Spring Boot Actuator dependency to your <code>pom.xml</code> or <code>build.gradle</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;!-- For Maven --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Configure Actuator Endpoints</h4>
  <p style="color: #2c3e50;">
    Configure which actuator endpoints are enabled and exposed in the <code>application.yml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      management:
        endpoints:
          web:
            exposure:
              include: "*" # Expose all endpoints
        endpoint:
          health:
            show-details: always
          metrics:
            enabled: true
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Access Actuator Endpoints</h4>
  <p style="color: #2c3e50;">
    Access the actuator endpoints to monitor and manage your application.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-bash">
      # Health check
      curl http://localhost:8080/actuator/health

      # Metrics
      curl http://localhost:8080/actuator/metrics

      # Environment details
      curl http://localhost:8080/actuator/env
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Custom Health Indicators</h4>
  <p style="color: #2c3e50;">
    Create custom health indicators to monitor specific components of your application.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.boot.actuate.health.Health;
      import org.springframework.boot.actuate.health.HealthIndicator;
      import org.springframework.stereotype.Component;

      @Component
      public class CustomHealthIndicator implements HealthIndicator {

          @Override
          public Health health() {
              // Custom logic to check health
              boolean isHealthy = checkHealth();
              if (isHealthy) {
                  return Health.up().build();
              } else {
                  return Health.down().withDetail("Error", "Service is down").build();
              }
          }

          private boolean checkHealth() {
              // Implement health check logic
              return true;
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">5. Secure Actuator Endpoints</h4>
  <p style="color: #2c3e50;">
    Secure actuator endpoints using Spring Security.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

      @Configuration
      @EnableWebSecurity
      public class SecurityConfig extends WebSecurityConfigurerAdapter {

          @Override
          protected void configure(HttpSecurity http) throws Exception {
              http
                  .authorizeRequests()
                      .antMatchers("/actuator/**").hasRole("ADMIN")
                      .anyRequest().permitAll()
                      .and()
                  .httpBasic();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Spring Boot Actuator</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Expose only necessary endpoints to minimize security risks.</li>
    <li>Secure actuator endpoints using Spring Security or network-level restrictions.</li>
    <li>Use custom health indicators to monitor application-specific components.</li>
    <li>Integrate with monitoring tools like Prometheus and Grafana for advanced metrics visualization.</li>
    <li>Regularly review and update actuator configurations to align with production needs.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Boot Actuator is an essential tool for monitoring and managing Spring Boot applications in production environments. By leveraging built-in endpoints, custom health indicators, and integration with monitoring tools, you can gain valuable insights into your application's performance and health. Whether you're troubleshooting issues, optimizing performance, or ensuring uptime, Spring Boot Actuator provides the features and flexibility needed to keep your application running smoothly.
  </p>
</div>`
},
{
  title:`Spring Cloud Config`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Spring Cloud Config</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Cloud Config is a powerful tool in the Spring ecosystem that provides externalized, centralized configuration management for distributed applications. It allows applications to retrieve configurations from a central server, making it easier to manage environment-specific settings across multiple services.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Cloud Config?</h3>
  <p style="color: #2c3e50;">
    The benefits of using Spring Cloud Config include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized Configuration</strong>: Manage all application configurations in one place.</li>
    <li><strong>Dynamic Updates</strong>: Reload configuration changes without restarting applications.</li>
    <li><strong>Environment-Specific Properties</strong>: Easily manage configurations for dev, test, and production environments.</li>
    <li><strong>Security and Version Control</strong>: Store configurations securely in Git repositories with version history.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up Spring Cloud Config Server</h3>
  <p style="color: #2c3e50;">
    To create a Spring Cloud Config Server, add the necessary dependencies and enable the Config Server using <code>@EnableConfigServer</code> annotation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cloud.config.server.EnableConfigServer;

      @SpringBootApplication
      @EnableConfigServer
      public class ConfigServerApplication {
          public static void main(String[] args) {
              SpringApplication.run(ConfigServerApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring the Server</h3>
  <p style="color: #2c3e50;">
    In the <code>application.yml</code> file, specify the Git repository that holds the configuration files.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      server:
        port: 8888
      spring:
        cloud:
          config:
            server:
              git:
                uri: https://github.com/your-repo/config-files
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Setting Up a Config Client</h3>
  <p style="color: #2c3e50;">
    To enable a Spring Boot application as a Config Client, add dependencies and specify the Config Server URL.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      spring:
        application:
          name: my-app
        cloud:
          config:
            uri: http://localhost:8888
    </code>
  </pre>

  <h3 style="color: #d35400;">Fetching Configurations from Server</h3>
  <p style="color: #2c3e50;">
    The client application will fetch configurations from the Config Server dynamically.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      @RefreshScope
      public class ConfigClientController {
          @Value("\${config.property:Default Value}")
          private String configProperty;

          @GetMapping("/config")
          public String getConfigProperty() {
              return configProperty;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Config simplifies configuration management for distributed applications by centralizing properties and enabling dynamic updates. It enhances maintainability, security, and scalability, making it an essential tool for cloud-native microservices architectures.
  </p>
</div>
`
},
{
  title:`Eureka (Service Discovery)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Eureka (Service Discovery)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Eureka is a service discovery tool from Netflix, widely used in Spring Cloud to enable dynamic service registration and lookup. It helps microservices locate each other dynamically without hardcoding service locations, improving scalability and fault tolerance.
  </p>

  <h3 style="color: #16a085;">Why Use Eureka?</h3>
  <p style="color: #2c3e50;">
    Eureka provides multiple advantages for microservices-based architectures:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Dynamic Service Registration</strong>: Microservices register and deregister dynamically.</li>
    <li><strong>Load Balancing</strong>: Clients can retrieve service instances for better load distribution.</li>
    <li><strong>High Availability</strong>: Eureka Server can run in a cluster to ensure resilience.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up Eureka Server</h3>
  <p style="color: #2c3e50;">
    To create a Eureka Server, add the necessary dependencies and use the <code>@EnableEurekaServer</code> annotation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

      @SpringBootApplication
      @EnableEurekaServer
      public class EurekaServerApplication {
          public static void main(String[] args) {
              SpringApplication.run(EurekaServerApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring Eureka Server</h3>
  <p style="color: #2c3e50;">
    Add the following properties to <code>application.yml</code> or <code>application.properties</code> to configure the Eureka server.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      server:
        port: 8761
      eureka:
        instance:
          hostname: localhost
        client:
          register-with-eureka: false
          fetch-registry: false
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Registering a Microservice with Eureka</h3>
  <p style="color: #2c3e50;">
    A microservice can register with Eureka by adding the necessary dependencies and using <code>@EnableEurekaClient</code>.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

      @SpringBootApplication
      @EnableDiscoveryClient
      public class ServiceApplication {
          public static void main(String[] args) {
              SpringApplication.run(ServiceApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Eureka</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Run Eureka Server in cluster mode for high availability.</li>
    <li>Use instance metadata for service-specific configurations.</li>
    <li>Enable service health checks to remove unhealthy instances.</li>
    <li>Configure client timeouts and retry mechanisms for resilience.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Eureka simplifies service discovery in a microservices architecture, allowing dynamic scaling and resilience. By integrating Eureka effectively, applications gain better fault tolerance, load balancing, and streamlined communication between services.
  </p>
</div>
`
},
{
  title:`Load Balancer`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Spring Cloud LoadBalancer</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Cloud LoadBalancer is a client-side load-balancing library that helps distribute traffic among multiple instances of a service. It replaces Netflix Ribbon in Spring Cloud and provides an efficient way to balance service requests without relying on external load balancers.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Cloud LoadBalancer?</h3>
  <p style="color: #2c3e50;">
    Spring Cloud LoadBalancer offers several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Client-Side Load Balancing</strong>: Distributes requests across multiple instances of a microservice.</li>
    <li><strong>Ribbon Replacement</strong>: A lightweight alternative to Netflix Ribbon.</li>
    <li><strong>Integration with Service Discovery</strong>: Works seamlessly with Eureka, Consul, and other service registries.</li>
    <li><strong>Customization</strong>: Supports custom load-balancing rules and configurations.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up Spring Cloud LoadBalancer</h3>
  <p style="color: #2c3e50;">
    To use Spring Cloud LoadBalancer, add the necessary dependency in your <code>pom.xml</code> file:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-loadbalancer</artifactId>
      </dependency>
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using Spring Cloud LoadBalancer</h3>
  <p style="color: #2c3e50;">
    Inject a <code>RestTemplate</code> bean with load-balancing enabled:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cloud.client.loadbalancer.LoadBalanced;
      import org.springframework.context.annotation.Bean;
      import org.springframework.web.client.RestTemplate;

      @SpringBootApplication
      public class LoadBalancerApplication {
          public static void main(String[] args) {
              SpringApplication.run(LoadBalancerApplication.class, args);
          }

          @Bean
          @LoadBalanced
          public RestTemplate restTemplate() {
              return new RestTemplate();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Load Balancing in Feign Clients</h3>
  <p style="color: #2c3e50;">
    You can also enable load balancing with Feign clients:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cloud.openfeign.FeignClient;
      import org.springframework.web.bind.annotation.GetMapping;

      @FeignClient(name = "my-service")
      public interface MyServiceClient {
          @GetMapping("/data")
          String getData();
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Customizing Load Balancing Strategy</h3>
  <p style="color: #2c3e50;">
    Spring Cloud LoadBalancer allows customization using a <code>ServiceInstanceListSupplier</code>:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cloud.client.ServiceInstance;
      import org.springframework.cloud.client.loadbalancer.ServiceInstanceListSupplier;
      import reactor.core.publisher.Flux;
      import java.util.List;
      import java.util.Random;

      public class CustomLoadBalancer extends ServiceInstanceListSupplier {
          private final List<ServiceInstance> instances;

          public CustomLoadBalancer(List<ServiceInstance> instances) {
              this.instances = instances;
          }

          @Override
          public Flux<List<ServiceInstance>> get() {
              return Flux.just(instances);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Spring Cloud LoadBalancer</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure proper service discovery integration (Eureka, Consul, etc.).</li>
    <li>Use <strong>@LoadBalanced</strong> annotation for client-side load balancing.</li>
    <li>Monitor and fine-tune the load-balancing strategy based on traffic patterns.</li>
    <li>Implement resilience patterns like circuit breakers for better fault tolerance.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud LoadBalancer is a lightweight and efficient client-side load-balancing solution that replaces Ribbon in Spring Cloud. By integrating it with RestTemplate, Feign clients, and custom load-balancing strategies, developers can efficiently distribute traffic across microservice instances, ensuring optimal performance and resilience.
  </p>
</div>
`
},
{
  title:`Spring Cloud Gateway`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Spring Cloud Gateway</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Cloud Gateway is a powerful and flexible API gateway built on top of the Spring ecosystem. It is designed to provide a simple yet effective way to route requests to the appropriate microservices, apply cross-cutting concerns like security, rate limiting, and logging, and manage traffic in a microservices architecture. As a central entry point for all client requests, Spring Cloud Gateway plays a critical role in ensuring scalability, security, and reliability in distributed systems.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Cloud Gateway?</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Gateway offers several benefits for managing microservices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized Routing</strong>: Acts as a single entry point for routing requests to multiple microservices.</li>
    <li><strong>Cross-Cutting Concerns</strong>: Handles security, rate limiting, logging, and other concerns in a centralized manner.</li>
    <li><strong>Dynamic Routing</strong>: Supports dynamic routing based on conditions like headers, paths, or query parameters.</li>
    <li><strong>Scalability</strong>: Enables horizontal scaling of microservices by distributing traffic efficiently.</li>
    <li><strong>Integration</strong>: Works seamlessly with other Spring Cloud components like Eureka, Config, and Circuit Breaker.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Spring Cloud Gateway</h3>
  <p style="color: #2c3e50;">
    When working with Spring Cloud Gateway, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Routes</strong>: Define how requests are routed to backend services based on conditions like path, method, or headers.</li>
    <li><strong>Predicates</strong>: Conditions that determine whether a route should be applied to a request.</li>
    <li><strong>Filters</strong>: Modify requests or responses before or after routing (e.g., adding headers, logging, rate limiting).</li>
    <li><strong>Load Balancing</strong>: Integrates with Spring Cloud LoadBalancer to distribute traffic across multiple instances of a service.</li>
    <li><strong>Circuit Breaker</strong>: Provides fault tolerance by integrating with Spring Cloud Circuit Breaker.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Spring Cloud Gateway</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to configure and use Spring Cloud Gateway in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Add Spring Cloud Gateway Dependency</h4>
  <p style="color: #2c3e50;">
    Add the Spring Cloud Gateway dependency to your <code>pom.xml</code> or <code>build.gradle</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-xml">
      &lt;!-- For Maven --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Configure Routes in <code>application.yml</code></h4>
  <p style="color: #2c3e50;">
    Define routes and predicates in the <code>application.yml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        cloud:
          gateway:
            routes:
              - id: user_service
                uri: http://localhost:8081
                predicates:
                  - Path=/users/**
              - id: order_service
                uri: http://localhost:8082
                predicates:
                  - Path=/orders/**
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Add Filters to Routes</h4>
  <p style="color: #2c3e50;">
    Use filters to modify requests or responses.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        cloud:
          gateway:
            routes:
              - id: user_service
                uri: http://localhost:8081
                predicates:
                  - Path=/users/**
                filters:
                  - AddRequestHeader=X-Request-Id, 12345
                  - RewritePath=/users/(?&lt;segment&gt;.*), /$\{segment}
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Enable Load Balancing</h4>
  <p style="color: #2c3e50;">
    Integrate with Spring Cloud LoadBalancer to distribute traffic across multiple instances of a service.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        cloud:
          gateway:
            routes:
              - id: user_service
                uri: lb://user-service
                predicates:
                  - Path=/users/**
    </code>
  </pre>

  <h4 style="color: #8e44ad;">5. Enable Circuit Breaker</h4>
  <p style="color: #2c3e50;">
    Use Spring Cloud Circuit Breaker to handle failures gracefully.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-yaml">
      spring:
        cloud:
          gateway:
            routes:
              - id: user_service
                uri: lb://user-service
                predicates:
                  - Path=/users/**
                filters:
                  - CircuitBreaker=myCircuitBreaker
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Spring Cloud Gateway</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful route IDs and predicates for better readability and maintainability.</li>
    <li>Secure the gateway using Spring Security to prevent unauthorized access.</li>
    <li>Monitor gateway performance and logs to detect and resolve issues quickly.</li>
    <li>Use load balancing and circuit breakers to improve fault tolerance and scalability.</li>
    <li>Test routes and filters thoroughly to ensure they behave as expected.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Gateway is a powerful tool for managing and routing traffic in a microservices architecture. By centralizing routing, security, and cross-cutting concerns, it simplifies the development and operation of distributed systems. Whether you're building a new microservices application or migrating an existing one, Spring Cloud Gateway provides the flexibility and features needed to ensure scalability, reliability, and security.
  </p>
</div>
`
},
{
   title:`OpenFeign`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding OpenFeign in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    OpenFeign is a declarative web service client in Spring Boot that simplifies API communication between microservices. It eliminates the need for manually writing REST client code and enhances readability and maintainability.
  </p>

  <h3 style="color: #16a085;">Why Use OpenFeign?</h3>
  <p style="color: #2c3e50;">
    OpenFeign provides several benefits for microservices-based applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Declarative REST Client</strong>: No need to write complex HTTP client code.</li>
    <li><strong>Built-in Load Balancing</strong>: Integrates with Spring Cloud LoadBalancer for distributing requests.</li>
    <li><strong>Automatic Request Serialization</strong>: Converts Java objects to JSON automatically.</li>
    <li><strong>Resilience</strong>: Works well with Circuit Breakers like Resilience4J for fault tolerance.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up OpenFeign</h3>
  <p style="color: #2c3e50;">
    To use OpenFeign, add the required dependencies in your <code>pom.xml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Enabling OpenFeign in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Enable OpenFeign by adding the <code>@EnableFeignClients</code> annotation in your main Spring Boot application class.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.cloud.openfeign.EnableFeignClients;

      @SpringBootApplication
      @EnableFeignClients
      public class OpenFeignApplication {
          public static void main(String[] args) {
              SpringApplication.run(OpenFeignApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Defining a Feign Client</h3>
  <p style="color: #2c3e50;">
    Create an interface and annotate it with <code>@FeignClient</code> to declare a REST client.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cloud.openfeign.FeignClient;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.PathVariable;

      @FeignClient(name = "user-service", url = "http://localhost:8081")
      public interface UserClient {
          
          @GetMapping("/users/{id}")
          User getUserById(@PathVariable("id") Long id);
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using the Feign Client</h3>
  <p style="color: #2c3e50;">
    Inject the Feign client into a service class and call its methods.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {

          private final UserClient userClient;

          public UserService(UserClient userClient) {
              this.userClient = userClient;
          }

          public User fetchUser(Long id) {
              return userClient.getUserById(id);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Adding Resilience with Circuit Breakers</h3>
  <p style="color: #2c3e50;">
    Integrate OpenFeign with Resilience4J to handle failures gracefully.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cloud.openfeign.FallbackFactory;
      import org.springframework.stereotype.Component;

      @Component
      public class UserClientFallbackFactory implements FallbackFactory&lt;UserClient&gt; {
          @Override
          public UserClient create(Throwable cause) {
              return id -> new User(id, "Fallback User");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using OpenFeign</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Enable <strong>logging</strong> to debug API calls.</li>
    <li>Use <strong>Resilience4J</strong> for fault tolerance.</li>
    <li>Integrate with <strong>Spring Cloud LoadBalancer</strong> for distributed requests.</li>
    <li>Configure timeouts to prevent long request delays.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    OpenFeign simplifies REST client interactions in Spring Boot applications by offering a declarative API call approach. With built-in load balancing, resilience, and seamless integration with Spring Cloud, OpenFeign enhances microservices communication while improving performance and maintainability.
  </p>
</div>
`
},
{
   title:`Resilience4j (Circuit Breaker)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Resilience4j Circuit Breaker in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Resilience4j is a lightweight fault tolerance library designed for Java applications, particularly microservices. The <strong>Circuit Breaker</strong> module in Resilience4j helps prevent service failures from cascading by stopping excessive requests to failing services and allowing recovery time.
  </p>

  <h3 style="color: #16a085;">Why Use Resilience4j Circuit Breaker?</h3>
  <p style="color: #2c3e50;">
    The Circuit Breaker pattern provides several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Prevents System Overload</strong>: Stops repeated calls to a failing service, reducing resource usage.</li>
    <li><strong>Improves Fault Tolerance</strong>: Allows services to recover instead of continuously failing.</li>
    <li><strong>Enhances System Stability</strong>: Avoids cascading failures in distributed architectures.</li>
    <li><strong>Automatic Recovery</strong>: Gradually allows traffic once the failing service is restored.</li>
  </ul>

  <h3 style="color: #e67e22;">Adding Resilience4j to a Spring Boot Project</h3>
  <p style="color: #2c3e50;">
    To use Resilience4j, add the required dependencies in your <code>pom.xml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;
          &lt;artifactId&gt;resilience4j-spring-boot2&lt;/artifactId&gt;
          &lt;version&gt;1.7.1&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Enabling Circuit Breaker in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Use the <code>@CircuitBreaker</code> annotation to wrap methods that may experience failures.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
      import org.springframework.stereotype.Service;
      import java.util.Random;

      @Service
      public class ExternalService {

          @CircuitBreaker(name = "externalService", fallbackMethod = "fallbackResponse")
          public String getData() {
              if (new Random().nextBoolean()) {
                  throw new RuntimeException("Service failure!");
              }
              return "Successful Response";
          }

          public String fallbackResponse(Exception e) {
              return "Fallback Response: Service is temporarily unavailable.";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring Circuit Breaker Properties</h3>
  <p style="color: #2c3e50;">
    You can configure circuit breaker properties in <code>application.yml</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      resilience4j:
        circuitbreaker:
          instances:
            externalService:
              failureRateThreshold: 50
              waitDurationInOpenState: 5000ms
              permittedNumberOfCallsInHalfOpenState: 3
              slidingWindowSize: 10
              minimumNumberOfCalls: 5
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Circuit Breaker States</h3>
  <p style="color: #2c3e50;">
    A Circuit Breaker operates in three states:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Closed</strong>: Normal state; requests flow freely.</li>
    <li><strong>Open</strong>: Failure threshold exceeded; blocks requests for a cooldown period.</li>
    <li><strong>Half-Open</strong>: Allows limited test requests; if successful, switches back to Closed.</li>
  </ul>

  <h3 style="color: #d35400;">Combining Circuit Breaker with Retry</h3>
  <p style="color: #2c3e50;">
    Resilience4j allows integrating Circuit Breaker with Retry for better fault tolerance.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import io.github.resilience4j.retry.annotation.Retry;
      import org.springframework.stereotype.Service;

      @Service
      public class RetryService {

          @Retry(name = "retryService", fallbackMethod = "retryFallback")
          public String fetchData() {
              throw new RuntimeException("Temporary Failure");
          }

          public String retryFallback(Exception e) {
              return "Fallback after retries: Service not available.";
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Monitoring Circuit Breaker Metrics</h3>
  <p style="color: #2c3e50;">
    Resilience4j provides actuator endpoints to monitor circuit breakers.
  </p>
  <p style="color: #2c3e50;">
    Enable Actuator in <code>application.yml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      management:
        endpoints:
          web:
            exposure:
              include: resilience4j.circuitbreakers
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Access the metrics at: <code>http://localhost:8080/actuator/resilience4j/circuitbreakers</code>
  </p>

  <h3 style="color: #d35400;">Best Practices for Using Resilience4j</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Fine-tune circuit breaker thresholds based on system needs.</li>
    <li>Integrate with <strong>Retry</strong> to handle temporary failures.</li>
    <li>Use <strong>Actuator</strong> to monitor circuit breaker performance.</li>
    <li>Test failure scenarios to validate resilience strategies.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Resilience4j Circuit Breaker is a crucial tool for building resilient microservices. It prevents cascading failures, ensures better system stability, and improves application fault tolerance. By combining Circuit Breaker with Retry, Rate Limiting, and Actuator monitoring, Spring Boot applications can handle failures efficiently.
  </p>
</div>
`
},
{
   title:`Sleuth & Zipkin (Tracing)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Sleuth & Zipkin for Distributed Tracing in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In microservices architectures, it is challenging to trace requests as they travel across multiple services. <strong>Spring Cloud Sleuth</strong> and <strong>Zipkin</strong> help with distributed tracing by tagging requests with unique identifiers, allowing developers to monitor and debug service calls efficiently.
  </p>

  <h3 style="color: #16a085;">What is Spring Cloud Sleuth?</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Sleuth automatically generates tracing information for requests passing through microservices. It adds:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Trace ID</strong>: A unique identifier for each request.</li>
    <li><strong>Span ID</strong>: A segment within a trace, representing a specific operation.</li>
    <li><strong>Parent-Child Relationships</strong>: Helps track service interactions.</li>
  </ul>

  <h3 style="color: #16a085;">What is Zipkin?</h3>
  <p style="color: #2c3e50;">
    Zipkin is a distributed tracing system that collects timing data, visualizes request paths, and helps identify bottlenecks in microservices.
  </p>

  <h3 style="color: #e67e22;">Adding Sleuth & Zipkin to a Spring Boot Application</h3>
  <p style="color: #2c3e50;">
    To enable tracing, add the following dependencies in <code>pom.xml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
      &lt;/dependency&gt;
      
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring Zipkin in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Configure Zipkin properties in <code>application.yml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      spring:
        zipkin:
          base-url: http://localhost:9411
        sleuth:
          sampler:
            probability: 1.0
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The <code>probability</code> value (1.0) ensures all requests are traced. Reduce it for production environments.
  </p>

  <h3 style="color: #8e44ad;">Running Zipkin</h3>
  <p style="color: #2c3e50;">
    You can run Zipkin using Docker:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      docker run -d -p 9411:9411 openzipkin/zipkin
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Once running, access Zipkin UI at: <a href="http://localhost:9411" target="_blank">http://localhost:9411</a>
  </p>

  <h3 style="color: #8e44ad;">Using Sleuth for Tracing in a REST Controller</h3>
  <p style="color: #2c3e50;">
    Example of a REST API that logs tracing information:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.slf4j.Logger;
      import org.slf4j.LoggerFactory;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class TracingController {

          private static final Logger logger = LoggerFactory.getLogger(TracingController.class);

          @GetMapping("/trace")
          public String traceRequest() {
              logger.info("Tracing request received.");
              return "Tracing request completed.";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Tracing Requests Across Multiple Microservices</h3>
  <p style="color: #2c3e50;">
    When calling another microservice, Sleuth automatically propagates trace and span IDs.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      import org.springframework.web.client.RestTemplate;

      @RestController
      @RequestMapping("/service1")
      public class Service1Controller {

          @Autowired
          private RestTemplate restTemplate;

          @GetMapping("/callService2")
          public String callService2() {
              return restTemplate.getForObject("http://localhost:8081/service2/trace", String.class);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Viewing Tracing Data in Zipkin</h3>
  <p style="color: #2c3e50;">
    After making API calls, open Zipkin (<a href="http://localhost:9411" target="_blank">http://localhost:9411</a>) and:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Search for traces using the Trace ID.</li>
    <li>View the end-to-end latency of service calls.</li>
    <li>Identify slow microservices or failures.</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices for Using Sleuth & Zipkin</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use Sleuth with Zipkin for real-time monitoring of request flows.</li>
    <li>Reduce <code>sampling probability</code> in production to avoid performance overhead.</li>
    <li>Use logging frameworks (e.g., ELK stack) to complement tracing.</li>
    <li>Integrate with monitoring tools like Prometheus for deeper insights.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Sleuth and Zipkin provide essential tracing capabilities for microservices. They help developers diagnose performance issues, track request flows, and improve overall system reliability. Implementing distributed tracing enhances observability, making debugging and performance optimization easier.
  </p>
</div>
`
},
{
   title:`Spring Cloud Bus`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Spring Cloud Bus for Distributed Configuration Updates</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a microservices architecture, managing configuration updates across multiple services can be challenging. <strong>Spring Cloud Bus</strong> helps synchronize configuration changes across distributed systems using a lightweight message broker such as <strong>RabbitMQ</strong> or <strong>Kafka</strong>. This eliminates the need to restart services manually after updating configurations.
  </p>

  <h3 style="color: #16a085;">What is Spring Cloud Bus?</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Bus links microservices using a distributed messaging system to broadcast configuration updates and events dynamically. It is primarily used with <strong>Spring Cloud Config</strong> to notify all running instances when configuration changes occur.
  </p>

  <h3 style="color: #16a085;">Key Features of Spring Cloud Bus</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Propagates configuration changes across multiple services.</li>
    <li>Uses messaging systems like RabbitMQ or Kafka.</li>
    <li>Reduces downtime by eliminating manual service restarts.</li>
    <li>Enhances scalability in dynamic cloud environments.</li>
  </ul>

  <h3 style="color: #e67e22;">Adding Spring Cloud Bus to a Spring Boot Application</h3>
  <p style="color: #2c3e50;">
    To enable Spring Cloud Bus, add the following dependencies in <code>pom.xml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
      &lt;/dependency&gt;
      
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The above dependencies configure Spring Cloud Bus with <strong>RabbitMQ</strong>. If you are using <strong>Kafka</strong>, replace <code>spring-cloud-starter-bus-amqp</code> with <code>spring-cloud-starter-bus-kafka</code>.
  </p>

  <h3 style="color: #8e44ad;">Configuring Spring Cloud Bus</h3>
  <p style="color: #2c3e50;">
    Add the following properties in <code>application.yml</code> to configure RabbitMQ:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      spring:
        cloud:
          config:
            server:
              git:
                uri: https://github.com/your-repo/config-repo
        rabbitmq:
          host: localhost
          port: 5672
          username: guest
          password: guest
        bus:
          enabled: true
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Ensure RabbitMQ is running locally, or use a cloud-based RabbitMQ service.
  </p>

  <h3 style="color: #8e44ad;">Running RabbitMQ</h3>
  <p style="color: #2c3e50;">
    You can run RabbitMQ using Docker:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Access RabbitMQ Management UI at: <a href="http://localhost:15672" target="_blank">http://localhost:15672</a> (Default credentials: <code>guest/guest</code>)
  </p>

  <h3 style="color: #8e44ad;">Triggering Configuration Updates</h3>
  <p style="color: #2c3e50;">
    To refresh configurations dynamically across microservices, make a POST request:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      curl -X POST http://localhost:8080/actuator/bus-refresh
    </code>
  </pre>

  <p style="color: #2c3e50;">
    This command triggers Spring Cloud Bus to propagate the configuration changes across all connected services.
  </p>

  <h3 style="color: #8e44ad;">Using Spring Cloud Bus with Multiple Services</h3>
  <p style="color: #2c3e50;">
    To ensure all microservices update their configurations dynamically, enable <code>@RefreshScope</code> in your service:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Value;
      import org.springframework.cloud.context.config.annotation.RefreshScope;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RefreshScope
      @RequestMapping("/config")
      public class ConfigController {

          @Value("\${message}")
          private String message;

          @GetMapping("/message")
          public String getMessage() {
              return "Config Message: " + message;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Benefits of Using Spring Cloud Bus</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automatic Configuration Updates:</strong> No need to restart services.</li>
    <li><strong>Scalability:</strong> Works efficiently in large-scale distributed environments.</li>
    <li><strong>Messaging System Support:</strong> Works with RabbitMQ and Kafka.</li>
    <li><strong>Enhanced Event Broadcasting:</strong> Useful for real-time updates across services.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Bus simplifies configuration management in microservices by dynamically propagating changes using message brokers like RabbitMQ or Kafka. It enhances scalability, reduces downtime, and improves operational efficiency. By integrating Spring Cloud Bus with Spring Cloud Config, you can achieve a highly flexible and resilient cloud-native architecture.
  </p>
</div>
`
},
{
   title:`Spring Security & OAuth2`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Security & OAuth2: Securing Your Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    In modern web applications, securing APIs and user authentication is a critical requirement. <strong>Spring Security</strong> is the most widely used authentication and authorization framework in the Spring ecosystem, while <strong>OAuth2</strong> is a powerful protocol for secure delegated access. Together, they help protect microservices by enabling authentication, authorization, and token-based security.
  </p>

  <h3 style="color: #16a085;">What is Spring Security?</h3>
  <p style="color: #2c3e50;">
    Spring Security is a robust framework that provides authentication, authorization, and protection against security vulnerabilities such as CSRF, session fixation, and more. It integrates seamlessly with Spring Boot and supports various authentication mechanisms, including OAuth2.
  </p>

  <h3 style="color: #16a085;">What is OAuth2?</h3>
  <p style="color: #2c3e50;">
    <strong>OAuth2</strong> (Open Authorization) is an industry-standard protocol for secure API access. It allows users to grant limited access to their resources without exposing credentials. OAuth2 works by issuing <strong>access tokens</strong>, which are used to authenticate and authorize API requests.
  </p>

  <h3 style="color: #e67e22;">Key Components of OAuth2</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Resource Owner:</strong> The user who owns the data.</li>
    <li><strong>Client:</strong> The application requesting access.</li>
    <li><strong>Authorization Server:</strong> Issues access tokens.</li>
    <li><strong>Resource Server:</strong> Hosts the protected resources.</li>
  </ul>

  <h3 style="color: #8e44ad;">Adding Spring Security and OAuth2 to a Spring Boot Application</h3>
  <p style="color: #2c3e50;">
    To enable OAuth2 authentication in a Spring Boot application, add the following dependencies in <code>pom.xml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
      &lt;/dependency&gt;
      
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring OAuth2 Resource Server</h3>
  <p style="color: #2c3e50;">
    In <code>application.yml</code>, configure the resource server to validate access tokens issued by an authorization server (such as Keycloak, Okta, or Auth0):
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      spring:
        security:
          oauth2:
            resourceserver:
              jwt:
                issuer-uri: https://your-auth-server.com
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Securing REST APIs with OAuth2</h3>
  <p style="color: #2c3e50;">
    To protect REST endpoints, create a security configuration class:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.web.SecurityFilterChain;

      @EnableWebSecurity
      public class SecurityConfig {

          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              http
                  .authorizeHttpRequests(auth -> auth
                      .requestMatchers("/public/**").permitAll()
                      .anyRequest().authenticated()
                  )
                  .oauth2ResourceServer(oauth2 -> oauth2.jwt());

              return http.build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Testing OAuth2 Authentication</h3>
  <p style="color: #2c3e50;">
    Use a valid OAuth2 access token to access protected resources:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      curl -H "Authorization: Bearer YOUR_ACCESS_TOKEN" http://localhost:8080/api/secure-data
    </code>
  </pre>

  <h3 style="color: #d35400;">Benefits of Using Spring Security & OAuth2</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Centralized Authentication:</strong> Manages authentication across microservices.</li>
    <li><strong>Token-Based Security:</strong> Avoids exposing user credentials.</li>
    <li><strong>Role-Based Access Control:</strong> Defines access levels for users.</li>
    <li><strong>Integration with Identity Providers:</strong> Supports Okta, Keycloak, Auth0, etc.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Security and OAuth2 provide a robust and scalable approach to securing microservices. By integrating OAuth2, developers can implement authentication and authorization using token-based security. This ensures that APIs remain protected and only authorized users can access sensitive data.
  </p>
</div>
`
},

{
  title:`Kafka/RabbitMQ (Event-Driven)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Kafka vs. RabbitMQ: Understanding Event-Driven Architecture</h2>
  <p style="font-size: 16px; color: #34495e;">
    In modern microservices-based applications, <strong>event-driven architecture</strong> is widely used to enable asynchronous communication between services. <strong>Kafka</strong> and <strong>RabbitMQ</strong> are two popular message brokers that facilitate real-time data streaming and event-driven processing.
  </p>

  <h3 style="color: #16a085;">What is Event-Driven Architecture?</h3>
  <p style="color: #2c3e50;">
    Event-driven architecture (EDA) is a design pattern where services communicate through events rather than direct API calls. When an event occurs, it is published to an event broker, which distributes it to interested subscribers.
  </p>

  <h3 style="color: #e67e22;">Why Use Kafka or RabbitMQ?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Asynchronous Communication:</strong> Services operate independently without waiting for responses.</li>
    <li><strong>Scalability:</strong> Handles a large number of messages efficiently.</li>
    <li><strong>Reliability:</strong> Ensures message durability and fault tolerance.</li>
    <li><strong>Decoupled Services:</strong> Microservices remain loosely coupled, improving flexibility.</li>
  </ul>

  <h3 style="color: #8e44ad;">Apache Kafka Overview</h3>
  <p style="color: #2c3e50;">
    <strong>Kafka</strong> is a distributed event-streaming platform designed for high throughput and fault tolerance. It is widely used for real-time analytics, log aggregation, and stream processing.
  </p>

  <h4 style="color: #2980b9;">Key Features of Kafka:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Distributed and horizontally scalable.</li>
    <li>Uses a publish-subscribe model.</li>
    <li>Supports message retention and replay.</li>
    <li>Works well with real-time data processing frameworks.</li>
  </ul>

  <h3 style="color: #8e44ad;">RabbitMQ Overview</h3>
  <p style="color: #2c3e50;">
    <strong>RabbitMQ</strong> is a lightweight message broker based on the AMQP protocol, commonly used for transactional messaging and task queues.
  </p>

  <h4 style="color: #2980b9;">Key Features of RabbitMQ:</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Supports multiple messaging patterns (pub-sub, request-reply, work queues).</li>
    <li>Ensures message delivery with acknowledgments and retries.</li>
    <li>Lightweight and easy to configure.</li>
    <li>Well-suited for short-lived messages and transactional systems.</li>
  </ul>

  <h3 style="color: #8e44ad;">Setting Up Kafka in a Spring Boot Application</h3>
  <p style="color: #2c3e50;">
    Add the following dependencies in <code>pom.xml</code> to integrate Kafka with Spring Boot:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
          &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #2980b9;">Kafka Producer</h4>
  <p style="color: #2c3e50;">
    A Kafka producer sends messages to a topic.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.kafka.core.KafkaTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class KafkaProducer {

          private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;

          public KafkaProducer(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
              this.kafkaTemplate = kafkaTemplate;
          }

          public void sendMessage(String topic, String message) {
              kafkaTemplate.send(topic, message);
          }
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">Kafka Consumer</h4>
  <p style="color: #2c3e50;">
    A Kafka consumer listens for messages from a topic.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.apache.kafka.clients.consumer.ConsumerRecord;
      import org.springframework.kafka.annotation.KafkaListener;
      import org.springframework.stereotype.Service;

      @Service
      public class KafkaConsumer {

          @KafkaListener(topics = "myTopic", groupId = "group_id")
          public void consume(ConsumerRecord&lt;String, String&gt; record) {
              System.out.println("Received message: " + record.value());
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Setting Up RabbitMQ in a Spring Boot Application</h3>
  <p style="color: #2c3e50;">
    Add the following dependencies in <code>pom.xml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h4 style="color: #2980b9;">RabbitMQ Producer</h4>
  <p style="color: #2c3e50;">
    A RabbitMQ producer sends messages to a queue.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.rabbit.core.RabbitTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class RabbitMQProducer {

          private final RabbitTemplate rabbitTemplate;

          public RabbitMQProducer(RabbitTemplate rabbitTemplate) {
              this.rabbitTemplate = rabbitTemplate;
          }

          public void sendMessage(String queue, String message) {
              rabbitTemplate.convertAndSend(queue, message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Choosing Between Kafka and RabbitMQ</h3>
  <table border="1" style="width: 100%; border-collapse: collapse; text-align: left;">
    <tr style="background: #2c3e50; color: white;">
      <th style="padding: 10px;">Feature</th>
      <th style="padding: 10px;">Kafka</th>
      <th style="padding: 10px;">RabbitMQ</th>
    </tr>
    <tr>
      <td style="padding: 10px;">Best For</td>
      <td style="padding: 10px;">High-volume event streaming</td>
      <td style="padding: 10px;">Transactional messaging</td>
    </tr>
    <tr>
      <td style="padding: 10px;">Persistence</td>
      <td style="padding: 10px;">Message retention</td>
      <td style="padding: 10px;">Messages deleted after consumption</td>
    </tr>
  </table>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Kafka and RabbitMQ are powerful tools for event-driven systems. Kafka is best suited for large-scale data processing, while RabbitMQ excels at real-time messaging and transactional systems.
  </p>
</div>
`
},
{
  title:`Microservices Data Management`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Microservices Data Management: Strategies and Best Practices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Microservices architecture enables scalable and flexible application development by breaking down a monolithic system into smaller, independent services. However, managing data across multiple microservices presents challenges in consistency, integrity, and performance. This article explores effective strategies for handling data in microservices environments.
  </p>

  <h3 style="color: #16a085;">Challenges in Microservices Data Management</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Consistency:</strong> Ensuring consistency across distributed databases.</li>
    <li><strong>Scalability:</strong> Managing growing data volumes efficiently.</li>
    <li><strong>Data Integrity:</strong> Avoiding duplicate or conflicting data.</li>
    <li><strong>Querying Across Services:</strong> Handling cross-service data retrieval.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Strategies for Data Management in Microservices</h3>

  <h4 style="color: #2980b9;">1. Database Per Microservice</h4>
  <p style="color: #2c3e50;">
    Each microservice has its own dedicated database, ensuring loose coupling and independent scalability.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Improves service autonomy.</li>
    <li>Prevents direct database access between microservices.</li>
    <li>Enables technology flexibility (SQL, NoSQL, etc.).</li>
  </ul>

  <h4 style="color: #2980b9;">2. API-Based Communication</h4>
  <p style="color: #2c3e50;">
    Instead of sharing databases, microservices should expose APIs for data exchange.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      @RequestMapping("/orders")
      public class OrderController {
          @GetMapping("/{id}")
          public Order getOrder(@PathVariable Long id) {
              return orderService.getOrderById(id);
          }
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">3. Event-Driven Architecture</h4>
  <p style="color: #2c3e50;">
    Services communicate asynchronously using messaging systems like Kafka or RabbitMQ.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class OrderEventPublisher {
          @Autowired
          private KafkaTemplate&lt;String, String&gt; kafkaTemplate;

          public void publishOrderCreatedEvent(String order) {
              kafkaTemplate.send("order-topic", order);
          }
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">4. Saga Pattern for Distributed Transactions</h4>
  <p style="color: #2c3e50;">
    The Saga pattern ensures data consistency across microservices without using distributed transactions.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Orchestrator-based Saga: A centralized service coordinates transactions.</li>
    <li>Choreography-based Saga: Each service listens for events and acts accordingly.</li>
  </ul>

  <h4 style="color: #2980b9;">5. CQRS (Command Query Responsibility Segregation)</h4>
  <p style="color: #2c3e50;">
    Separates read and write operations for better performance and scalability.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      public class OrderService {
          public void createOrder(Order order) { /* Write operation */ }
          public Order getOrder(Long id) { /* Read operation */ return orderRepository.findById(id).get(); }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Choosing the Right Database for Microservices</h3>
  <table border="1" style="width: 100%; border-collapse: collapse; text-align: left;">
    <tr style="background: #2c3e50; color: white;">
      <th style="padding: 10px;">Database Type</th>
      <th style="padding: 10px;">Best For</th>
    </tr>
    <tr>
      <td style="padding: 10px;">SQL (MySQL, PostgreSQL)</td>
      <td style="padding: 10px;">Structured data and transactions</td>
    </tr>
    <tr>
      <td style="padding: 10px;">NoSQL (MongoDB, Cassandra)</td>
      <td style="padding: 10px;">High availability and flexible schema</td>
    </tr>
    <tr>
      <td style="padding: 10px;">Event Store (Kafka, EventStoreDB)</td>
      <td style="padding: 10px;">Event-driven data persistence</td>
    </tr>
  </table>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Effective data management in microservices requires choosing the right strategies and tools. By implementing techniques like database per service, event-driven architecture, and CQRS, organizations can build scalable, reliable, and high-performance microservices applications.
  </p>
</div>
`
},
{
  title:`Docker & Kubernetes`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Docker & Kubernetes: Containerization and Orchestration</h2>
  <p style="font-size: 16px; color: #34495e;">
    In modern software development, containerization has become a crucial approach for deploying applications efficiently. <strong>Docker</strong> is a powerful containerization platform that simplifies application packaging, while <strong>Kubernetes</strong> is an orchestration tool that manages and scales containers automatically. Together, they provide a robust solution for deploying, managing, and scaling applications.
  </p>

  <h3 style="color: #16a085;">What is Docker?</h3>
  <p style="color: #2c3e50;">
    Docker is a platform that enables developers to create, deploy, and run applications in isolated environments called containers. These containers package everything needed to run an application, including the code, dependencies, and runtime environment.
  </p>

  <h4 style="color: #2980b9;">Key Features of Docker</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Lightweight and fast compared to traditional virtual machines.</li>
    <li>Ensures consistency across multiple environments (development, testing, production).</li>
    <li>Enables easy deployment with Docker images and containers.</li>
    <li>Supports microservices architecture by isolating services.</li>
  </ul>

  <h4 style="color: #2980b9;">Basic Docker Commands</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      # Check Docker installation
      docker --version 

      # Pull an official Nginx image
      docker pull nginx 

      # Run a container from the Nginx image
      docker run -d -p 8080:80 nginx 

      # List running containers
      docker ps 

      # Stop a running container
      docker stop container_id 
    </code>
  </pre>

  <h3 style="color: #e67e22;">What is Kubernetes?</h3>
  <p style="color: #2c3e50;">
    Kubernetes (K8s) is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It is widely used for running microservices in cloud-native applications.
  </p>

  <h4 style="color: #2980b9;">Key Features of Kubernetes</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automated Deployment</strong>: Manages the deployment and rollback of applications.</li>
    <li><strong>Scaling</strong>: Automatically scales applications up or down based on demand.</li>
    <li><strong>Self-Healing</strong>: Detects and replaces failed containers automatically.</li>
    <li><strong>Service Discovery</strong>: Allows communication between microservices without hardcoded IPs.</li>
  </ul>

  <h4 style="color: #2980b9;">Basic Kubernetes Components</h4>
  <table border="1" style="width: 100%; border-collapse: collapse; text-align: left;">
    <tr style="background: #2c3e50; color: white;">
      <th style="padding: 10px;">Component</th>
      <th style="padding: 10px;">Function</th>
    </tr>
    <tr>
      <td style="padding: 10px;">Pod</td>
      <td style="padding: 10px;">The smallest deployable unit in Kubernetes, containing one or more containers.</td>
    </tr>
    <tr>
      <td style="padding: 10px;">Service</td>
      <td style="padding: 10px;">Defines networking rules for accessing pods.</td>
    </tr>
    <tr>
      <td style="padding: 10px;">Deployment</td>
      <td style="padding: 10px;">Manages application replicas and updates.</td>
    </tr>
    <tr>
      <td style="padding: 10px;">ConfigMap & Secret</td>
      <td style="padding: 10px;">Stores environment variables and sensitive data.</td>
    </tr>
  </table>

  <h4 style="color: #2980b9;">Basic Kubernetes Commands</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-bash">
      # Check Kubernetes installation
      kubectl version --client 

      # Get running pods
      kubectl get pods 

      # Apply a deployment configuration
      kubectl apply -f deployment.yaml 

      # Expose a deployment as a service
      kubectl expose deployment my-app --type=LoadBalancer --port=80 

      # Scale a deployment
      kubectl scale deployment my-app --replicas=3 

      # Delete a deployment
      kubectl delete deployment my-app 
    </code>
  </pre>

  <h3 style="color: #d35400;">Docker vs Kubernetes: When to Use What?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use Docker</strong> for containerizing applications and running them locally or on a single server.</li>
    <li><strong>Use Kubernetes</strong> when managing multiple containers across distributed environments.</li>
    <li>Docker simplifies development, while Kubernetes automates scaling and orchestration.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Docker and Kubernetes are essential tools in modern application development. While Docker makes it easy to package and deploy applications, Kubernetes ensures efficient management and scaling of containerized workloads. Together, they enable the development of highly scalable, cloud-native applications.
  </p>
</div>
`
},
{
  title:`API Gateway & Rate Limiting`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">API Gateway & Rate Limiting: Enhancing API Management</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a microservices architecture, an <strong>API Gateway</strong> acts as a single entry point that routes requests to various services. It enhances security, load balancing, and monitoring. <strong>Rate Limiting</strong> is a technique used to control the number of API requests a client can make within a specific time frame, preventing abuse and ensuring fair resource usage.
  </p>

  <h3 style="color: #16a085;">What is an API Gateway?</h3>
  <p style="color: #2c3e50;">
    An API Gateway is a server that sits between clients and backend services, managing requests, authentication, logging, and caching. It simplifies API consumption and protects internal microservices.
  </p>

  <h4 style="color: #2980b9;">Key Features of API Gateway</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Routing</strong>: Directs client requests to appropriate microservices.</li>
    <li><strong>Authentication & Authorization</strong>: Ensures only authorized clients can access APIs.</li>
    <li><strong>Load Balancing</strong>: Distributes traffic across multiple instances of microservices.</li>
    <li><strong>Monitoring & Logging</strong>: Tracks API usage and detects anomalies.</li>
    <li><strong>Caching</strong>: Improves performance by storing frequently accessed responses.</li>
  </ul>

  <h4 style="color: #2980b9;">Popular API Gateway Solutions</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Spring Cloud Gateway</strong> - A lightweight, Java-based API Gateway.</li>
    <li><strong>Netflix Zuul</strong> - A routing library developed by Netflix.</li>
    <li><strong>NGINX API Gateway</strong> - A high-performance reverse proxy solution.</li>
    <li><strong>Apigee & Kong</strong> - Enterprise-grade API management platforms.</li>
  </ul>

  <h4 style="color: #2980b9;">Spring Cloud Gateway Example</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cloud.gateway.route.RouteLocator;
      import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class ApiGatewayConfig {

          @Bean
          public RouteLocator gatewayRoutes(RouteLocatorBuilder builder) {
              return builder.routes()
                  .route("user-service", r -> r.path("/users/**")
                      .uri("http://localhost:8081"))
                  .route("order-service", r -> r.path("/orders/**")
                      .uri("http://localhost:8082"))
                  .build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">What is Rate Limiting?</h3>
  <p style="color: #2c3e50;">
    Rate Limiting restricts the number of API requests a client can make within a certain time period. It prevents API abuse, protects backend systems from overload, and ensures fair resource distribution.
  </p>

  <h4 style="color: #2980b9;">Types of Rate Limiting</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Fixed Window</strong>: Limits requests based on fixed time intervals.</li>
    <li><strong>Sliding Window</strong>: More flexible approach, allowing requests within overlapping windows.</li>
    <li><strong>Token Bucket</strong>: Clients must have tokens to make requests; tokens are replenished at a set rate.</li>
    <li><strong>Leaky Bucket</strong>: Similar to token bucket but processes requests at a constant rate.</li>
  </ul>

  <h4 style="color: #2980b9;">Implementing Rate Limiting in Spring Cloud Gateway</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import reactor.core.publisher.Mono;

      @Configuration
      public class RateLimitingConfig {

          @Bean
          public KeyResolver userKeyResolver() {
              return exchange -> Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());
          }
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">Configuring Rate Limiting in application.yml</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      spring:
        cloud:
          gateway:
            routes:
              - id: rate_limit_route
                uri: http://localhost:8080
                predicates:
                  - Path=/api/**
                filters:
                  - name: RequestRateLimiter
                    args:
                      redis-rate-limiter.replenishRate: 5
                      redis-rate-limiter.burstCapacity: 10
                      key-resolver: "#{@userKeyResolver}"
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for API Gateway & Rate Limiting</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>authentication and authorization</strong> to secure APIs.</li>
    <li>Implement <strong>caching</strong> to reduce repeated API calls.</li>
    <li>Monitor API performance and set appropriate <strong>timeouts</strong>.</li>
    <li>Use a combination of <strong>rate limiting and throttling</strong> to prevent misuse.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    An API Gateway provides a centralized mechanism for managing requests, ensuring security, and optimizing performance. Rate Limiting enhances API reliability by preventing excessive usage. Together, they help build scalable and secure microservices-based architectures.
  </p>
</div>
`
},
{
  title:`Logging & Monitoring`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Logging & Monitoring in Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a microservices architecture, <strong>Logging</strong> and <strong>Monitoring</strong> are crucial for tracking application health, identifying issues, and ensuring smooth operations. Logging helps capture application events, while monitoring provides real-time insights into system performance.
  </p>

  <h3 style="color: #16a085;">Why Logging & Monitoring Are Important?</h3>
  <p style="color: #2c3e50;">
    Managing logs and monitoring microservices ensures system reliability and quick issue resolution. Key benefits include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Debugging & Troubleshooting</strong>: Helps identify and resolve errors.</li>
    <li><strong>Performance Optimization</strong>: Tracks system health and resource utilization.</li>
    <li><strong>Security Auditing</strong>: Monitors unauthorized access and anomalies.</li>
    <li><strong>Compliance & Reporting</strong>: Ensures compliance with regulations like GDPR.</li>
  </ul>

  <h3 style="color: #e67e22;">Logging in Microservices</h3>
  <p style="color: #2c3e50;">
    Logging is used to capture application events such as errors, warnings, and system activities. In microservices, centralized logging is preferred to aggregate logs from multiple services.
  </p>

  <h4 style="color: #2980b9;">Best Practices for Logging</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>structured logging</strong> (JSON format) for better readability.</li>
    <li>Implement <strong>correlation IDs</strong> to track requests across services.</li>
    <li>Use <strong>log levels</strong> (DEBUG, INFO, WARN, ERROR) appropriately.</li>
    <li>Store logs in <strong>centralized systems</strong> like ELK (Elasticsearch, Logstash, Kibana).</li>
  </ul>

  <h4 style="color: #2980b9;">Logging with Spring Boot</h4>
  <p style="color: #2c3e50;">
    Spring Boot provides built-in logging using <strong>SLF4J</strong> and <strong>Logback</strong>. Below is an example:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.slf4j.Logger;
      import org.slf4j.LoggerFactory;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/api")
      public class LoggingController {

          private static final Logger logger = LoggerFactory.getLogger(LoggingController.class);

          @GetMapping("/log-example")
          public String logExample() {
              logger.info("Info Level Log");
              logger.warn("Warning Level Log");
              logger.error("Error Level Log");
              return "Logging Example";
          }
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">Centralized Logging with ELK Stack</h4>
  <p style="color: #2c3e50;">
    The ELK stack (Elasticsearch, Logstash, Kibana) is a popular centralized logging solution:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Elasticsearch</strong>: Stores logs in a searchable format.</li>
    <li><strong>Logstash</strong>: Processes and transforms logs before storing them.</li>
    <li><strong>Kibana</strong>: Visualizes logs in dashboards.</li>
  </ul>

  <h3 style="color: #8e44ad;">Monitoring in Microservices</h3>
  <p style="color: #2c3e50;">
    Monitoring tracks the health and performance of microservices in real-time, helping teams respond to issues quickly.
  </p>

  <h4 style="color: #2980b9;">Key Monitoring Metrics</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Latency</strong>: Measures response time for requests.</li>
    <li><strong>Throughput</strong>: Tracks the number of requests processed.</li>
    <li><strong>Error Rate</strong>: Logs the percentage of failed requests.</li>
    <li><strong>CPU & Memory Usage</strong>: Monitors resource consumption.</li>
  </ul>

  <h4 style="color: #2980b9;">Monitoring with Spring Boot Actuator</h4>
  <p style="color: #2c3e50;">
    Spring Boot Actuator provides built-in endpoints to monitor microservices. Add the dependency in <code>pom.xml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Enable monitoring endpoints in <code>application.yml</code>:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      management:
        endpoints:
          web:
            exposure:
              include: "health,metrics,info"
    </code>
  </pre>

  <h4 style="color: #2980b9;">Distributed Tracing with Sleuth & Zipkin</h4>
  <p style="color: #2c3e50;">
    Spring Cloud Sleuth and Zipkin help trace requests across microservices. Add Sleuth dependency:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Logging & Monitoring</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use structured logs (JSON format) for better parsing.</li>
    <li>Centralize logs using ELK, Fluentd, or Loki.</li>
    <li>Implement log rotation and retention policies.</li>
    <li>Monitor CPU, memory, and request latency.</li>
    <li>Use distributed tracing to debug microservices interactions.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Logging and Monitoring are essential for maintaining microservices stability. By using tools like <strong>ELK, Spring Boot Actuator, and Zipkin</strong>, teams can gain deep insights into system performance, detect issues early, and ensure seamless operations.
  </p>
</div>
`
},
{
  title:`Testing Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing Strategies in Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a microservices architecture, <strong>testing</strong> is critical to ensuring the reliability, performance, and security of individual services and their interactions. Since microservices are distributed systems, traditional monolithic testing approaches do not work effectively. Instead, a layered testing strategy is needed.
  </p>

  <h3 style="color: #16a085;">Why is Testing Important in Microservices?</h3>
  <p style="color: #2c3e50;">
    Testing microservices ensures that individual components work correctly and that the entire system functions as expected. The key benefits of a robust testing strategy include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensuring Functionality</strong>: Verifies that services behave as expected.</li>
    <li><strong>Detecting Integration Issues</strong>: Ensures seamless communication between services.</li>
    <li><strong>Maintaining Performance</strong>: Checks if the system performs well under load.</li>
    <li><strong>Improving Security</strong>: Identifies vulnerabilities and protects against threats.</li>
  </ul>

  <h3 style="color: #e67e22;">Testing Pyramid for Microservices</h3>
  <p style="color: #2c3e50;">
    Microservices testing follows a layered approach, often represented as a pyramid:
  </p>

  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Unit Testing</strong>: Tests individual methods and functions.</li>
    <li><strong>Component Testing</strong>: Validates microservice behavior independently.</li>
    <li><strong>Integration Testing</strong>: Ensures microservices communicate properly.</li>
    <li><strong>Contract Testing</strong>: Ensures API contracts between services remain unchanged.</li>
    <li><strong>End-to-End (E2E) Testing</strong>: Tests the entire system from the user's perspective.</li>
  </ul>

  <h3 style="color: #2980b9;">1. Unit Testing</h3>
  <p style="color: #2c3e50;">
    Unit tests focus on testing individual components in isolation. They are fast and form the foundation of microservices testing.
  </p>

  <h4 style="color: #2980b9;">Example: JUnit & Mockito</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import static org.junit.jupiter.api.Assertions.*;
      import org.junit.jupiter.api.Test;
      import org.mockito.Mockito;

      class CalculatorServiceTest {

          private CalculatorService service = new CalculatorService();

          @Test
          void testAddition() {
              int result = service.add(5, 3);
              assertEquals(8, result);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">2. Component Testing</h3>
  <p style="color: #2c3e50;">
    Component testing ensures a single microservice functions as expected, independent of other services.
  </p>

  <h4 style="color: #2980b9;">Example: Spring Boot Test</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @SpringBootTest
      class OrderServiceTest {
      
          @Autowired
          private OrderService orderService;
      
          @Test
          void testOrderCreation() {
              Order order = orderService.createOrder("Product123", 2);
              assertNotNull(order);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">3. Integration Testing</h3>
  <p style="color: #2c3e50;">
    Integration tests ensure microservices can communicate correctly using APIs, databases, or messaging queues.
  </p>

  <h4 style="color: #2980b9;">Example: Testing REST API with RestTemplate</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
      class ProductServiceIntegrationTest {

          @Autowired
          private TestRestTemplate restTemplate;

          @Test
          void testGetProduct() {
              ResponseEntity<Product> response = restTemplate.getForEntity("/api/products/1", Product.class);
              assertEquals(HttpStatus.OK, response.getStatusCode());
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">4. Contract Testing</h3>
  <p style="color: #2c3e50;">
    Contract tests ensure that microservices APIs maintain expected behavior when changes occur.
  </p>

  <h4 style="color: #2980b9;">Example: Using Pact for Contract Testing</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @PactTestFor(providerName = "OrderService")
      public class OrderServiceContractTest {
      
          @Pact(provider = "OrderService", consumer = "PaymentService")
          public RequestResponsePact createPact(PactDslWithProvider builder) {
              return builder
                  .given("Order exists")
                  .uponReceiving("Request to fetch order")
                  .path("/api/orders/1")
                  .willRespondWith()
                  .status(200)
                  .toPact();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">5. End-to-End (E2E) Testing</h3>
  <p style="color: #2c3e50;">
    E2E tests validate the complete system flow from the user's perspective, ensuring that multiple microservices work together.
  </p>

  <h4 style="color: #2980b9;">Example: Selenium for UI Testing</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.openqa.selenium.WebDriver;
      import org.openqa.selenium.chrome.ChromeDriver;
      import org.junit.jupiter.api.Test;

      class E2ETest {

          @Test
          void testLoginPage() {
              WebDriver driver = new ChromeDriver();
              driver.get("http://localhost:8080/login");
              assertEquals("Login Page", driver.getTitle());
              driver.quit();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Microservices Testing</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Follow the testing pyramid (more unit tests, fewer E2E tests).</li>
    <li>Use contract testing to avoid integration issues.</li>
    <li>Mock dependencies to speed up tests.</li>
    <li>Automate regression tests to catch breaking changes.</li>
    <li>Monitor test coverage and fix flaky tests.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    A comprehensive <strong>Testing Strategy</strong> ensures that microservices remain reliable and scalable. By combining unit, integration, contract, and end-to-end testing, teams can build resilient applications with confidence.
  </p>
</div>
`
},
{
  title:`DevOps & CI/CD`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">DevOps & CI/CD: Automating Software Delivery</h2>
  <p style="font-size: 16px; color: #34495e;">
    In modern software development, <strong>DevOps</strong> and <strong>Continuous Integration/Continuous Deployment (CI/CD)</strong> play a crucial role in automating workflows, improving collaboration, and ensuring faster, reliable software delivery.
  </p>

  <h3 style="color: #16a085;">What is DevOps?</h3>
  <p style="color: #2c3e50;">
    DevOps is a cultural and technical movement that promotes collaboration between development (Dev) and operations (Ops) teams to improve software quality and speed up the delivery process.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Faster Releases:</strong> Automates build, test, and deployment pipelines.</li>
    <li><strong>Improved Collaboration:</strong> Breaks down silos between Dev and Ops teams.</li>
    <li><strong>Reliability & Stability:</strong> Reduces deployment failures and downtime.</li>
    <li><strong>Scalability:</strong> Ensures that applications can handle increased load efficiently.</li>
  </ul>

  <h3 style="color: #e67e22;">What is CI/CD?</h3>
  <p style="color: #2c3e50;">
    CI/CD is a set of automated processes that help integrate code changes, test them, and deploy software to production efficiently.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Continuous Integration (CI):</strong> Developers frequently merge code into a shared repository where automated builds and tests are run.</li>
    <li><strong>Continuous Deployment (CD):</strong> Successfully tested code is automatically deployed to production.</li>
    <li><strong>Continuous Delivery:</strong> Ensures that new changes are always in a deployable state, but manual approval may be required before deployment.</li>
  </ul>

  <h3 style="color: #2980b9;">CI/CD Pipeline Stages</h3>
  <p style="color: #2c3e50;">
    A typical CI/CD pipeline consists of multiple stages to automate software delivery.
  </p>

  <h4 style="color: #2980b9;">1. Source Code Management</h4>
  <p style="color: #2c3e50;">
    Developers push code to a version control system like GitHub, GitLab, or Bitbucket.
  </p>

  <h4 style="color: #2980b9;">2. Build</h4>
  <p style="color: #2c3e50;">
    The CI/CD system compiles the source code into executable artifacts.
  </p>

  <h4 style="color: #2980b9;">3. Testing</h4>
  <p style="color: #2c3e50;">
    Automated tests (unit, integration, and functional) validate the changes.
  </p>

  <h4 style="color: #2980b9;">4. Deployment</h4>
  <p style="color: #2c3e50;">
    Once the tests pass, the new version is deployed to production or a staging environment.
  </p>

  <h4 style="color: #2980b9;">5. Monitoring</h4>
  <p style="color: #2c3e50;">
    Logs and metrics are collected to track application performance and detect issues.
  </p>

  <h3 style="color: #16a085;">Popular CI/CD Tools</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Jenkins:</strong> Open-source automation server for building, testing, and deploying applications.</li>
    <li><strong>GitHub Actions:</strong> CI/CD workflows integrated with GitHub repositories.</li>
    <li><strong>GitLab CI/CD:</strong> Built-in CI/CD pipelines for GitLab projects.</li>
    <li><strong>CircleCI:</strong> Cloud-based CI/CD service for rapid software delivery.</li>
    <li><strong>Travis CI:</strong> Popular for testing open-source projects.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: CI/CD Pipeline with GitHub Actions</h3>
  <p style="color: #2c3e50;">
    Below is an example of a simple CI/CD pipeline using GitHub Actions:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-yaml">
      name: CI/CD Pipeline
      
      on:
        push:
          branches:
            - main
          
      jobs:
        build:
          runs-on: ubuntu-latest
          
          steps:
            - name: Checkout Code
              uses: actions/checkout@v2

            - name: Set up JDK 11
              uses: actions/setup-java@v2
              with:
                java-version: '11'
                distribution: 'adopt'

            - name: Build Project
              run: mvn clean install

            - name: Run Tests
              run: mvn test

            - name: Deploy
              run: echo "Deploying to production..."
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for DevOps & CI/CD</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>Infrastructure as Code (IaC)</strong> to automate server provisioning.</li>
    <li>Implement <strong>automated security scans</strong> in CI/CD pipelines.</li>
    <li>Ensure <strong>rollback mechanisms</strong> in case of deployment failures.</li>
    <li>Adopt <strong>blue-green deployments</strong> to minimize downtime.</li>
    <li>Monitor application performance using <strong>Prometheus, Grafana, or ELK Stack</strong>.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    DevOps and CI/CD accelerate software delivery, improve code quality, and enhance system reliability. By automating build, test, and deployment workflows, teams can achieve <strong>faster and safer releases</strong>, ensuring continuous improvement in software development.
  </p>
</div>
`
},
{
  title:`Scaling & Performance`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Scaling & Performance: Optimizing Applications for Growth</h2>
  <p style="font-size: 16px; color: #34495e;">
    As applications grow, they need to handle increased traffic, data, and computational demands. <strong>Scaling</strong> and <strong>performance optimization</strong> are critical to ensuring that applications remain fast, reliable, and efficient under heavy loads.
  </p>

  <h3 style="color: #16a085;">What is Scaling?</h3>
  <p style="color: #2c3e50;">
    Scaling is the ability to increase the capacity of an application to handle more users and requests efficiently.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Vertical Scaling (Scaling Up):</strong> Increasing the power (CPU, RAM) of a single server.</li>
    <li><strong>Horizontal Scaling (Scaling Out):</strong> Adding more servers to distribute the load.</li>
    <li><strong>Auto-Scaling:</strong> Dynamically adjusting resources based on demand.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Performance Metrics</h3>
  <p style="color: #2c3e50;">
    Monitoring the right performance metrics helps in optimizing an application.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Response Time:</strong> Time taken for a request to be processed.</li>
    <li><strong>Throughput:</strong> Number of requests processed per second.</li>
    <li><strong>Latency:</strong> Delay before a response is sent to the user.</li>
    <li><strong>Error Rate:</strong> Percentage of failed requests.</li>
    <li><strong>CPU & Memory Usage:</strong> System resource consumption.</li>
  </ul>

  <h3 style="color: #2980b9;">Scaling Strategies</h3>
  
  <h4 style="color: #2980b9;">1. Load Balancing</h4>
  <p style="color: #2c3e50;">
    Distributes incoming traffic across multiple servers to improve availability and reliability.
  </p>
  
  <h4 style="color: #2980b9;">2. Caching</h4>
  <p style="color: #2c3e50;">
    Stores frequently accessed data in memory to reduce database queries.
  </p>

  <h4 style="color: #2980b9;">3. Database Optimization</h4>
  <p style="color: #2c3e50;">
    Techniques like indexing, partitioning, and replication improve database performance.
  </p>

  <h4 style="color: #2980b9;">4. Microservices Architecture</h4>
  <p style="color: #2c3e50;">
    Breaking down applications into smaller, independent services for better scalability.
  </p>

  <h3 style="color: #16a085;">Performance Optimization Techniques</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Optimize Queries:</strong> Use indexes and avoid unnecessary joins.</li>
    <li><strong>Implement Asynchronous Processing:</strong> Use queues for background tasks.</li>
    <li><strong>Use Content Delivery Networks (CDN):</strong> Serve static assets from edge servers.</li>
    <li><strong>Reduce Network Latency:</strong> Use HTTP/2 and compression techniques.</li>
    <li><strong>Profile and Benchmark:</strong> Identify slow-performing code with tools like JProfiler.</li>
  </ul>

  <h3 style="color: #e67e22;">Example: Using Redis for Caching</h3>
  <p style="color: #2c3e50;">
    Below is an example of integrating Redis caching in a Spring Boot application:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          @Cacheable(value = "products", key = "#id")
          public Product getProductById(Long id) {
              return new Product(id, "Sample Product");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Scaling & Performance</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>Auto-Scaling</strong> to handle dynamic traffic loads.</li>
    <li>Implement <strong>distributed caching</strong> for reducing response times.</li>
    <li>Optimize <strong>database queries</strong> to avoid performance bottlenecks.</li>
    <li>Monitor performance using <strong>Prometheus, Grafana, or New Relic</strong>.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Scaling and performance optimization ensure applications remain fast, efficient, and reliable as they grow. By implementing the right strategies, businesses can provide a seamless user experience while maintaining system stability.
  </p>
</div>
`
},
{
  title:`DI Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Dependency Injection (DI) Basics in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    <strong>Dependency Injection (DI)</strong> is a fundamental concept in Spring Boot that allows objects to be injected into other objects, promoting loose coupling and making applications more modular, testable, and maintainable.
  </p>

  <h3 style="color: #16a085;">What is Dependency Injection?</h3>
  <p style="color: #2c3e50;">
    Dependency Injection is a design pattern that allows an object to receive its dependencies from an external source rather than creating them itself. It helps separate object creation from object usage.
  </p>

  <h3 style="color: #e67e22;">Types of Dependency Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Constructor Injection:</strong> Dependencies are injected via a class constructor.</li>
    <li><strong>Setter Injection:</strong> Dependencies are set via public setter methods.</li>
    <li><strong>Field Injection:</strong> Dependencies are injected directly into fields using <code>@Autowired</code>.</li>
  </ul>

  <h3 style="color: #2980b9;">Constructor Injection Example</h3>
  <p style="color: #2c3e50;">
    Constructor-based injection is recommended for mandatory dependencies.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          private final Repository repository;

          public ProductService(Repository repository) {
              this.repository = repository;
          }

          public void fetchProducts() {
              repository.getAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Setter Injection Example</h3>
  <p style="color: #2c3e50;">
    Setter-based injection is useful when dependencies are optional.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          private Repository repository;

          @Autowired
          public void setRepository(Repository repository) {
              this.repository = repository;
          }

          public void fetchProducts() {
              repository.getAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Field Injection Example</h3>
  <p style="color: #2c3e50;">
    Field injection is the simplest but not recommended for complex applications.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.beans.factory.annotation.Autowired;

      @Service
      public class ProductService {
          @Autowired
          private Repository repository;

          public void fetchProducts() {
              repository.getAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Benefits of Dependency Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Improves <strong>testability</strong> by allowing mock dependencies.</li>
    <li>Enhances <strong>modularity</strong> and <strong>code reuse</strong>.</li>
    <li>Promotes <strong>loose coupling</strong> between components.</li>
    <li>Simplifies <strong>object creation</strong> and management.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Dependency Injection is a core concept in Spring Boot that makes applications more flexible and maintainable. By using DI effectively, developers can write cleaner, modular, and testable code.
  </p>
</div>
`
},
{
  title:`Types of DI (Constructor, Setter, Field)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Types of Dependency Injection (Constructor, Setter, Field) in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    <strong>Dependency Injection (DI)</strong> is a design pattern that helps in injecting dependencies into a class rather than creating them within the class. Spring Boot supports three types of DI: <strong>Constructor Injection</strong>, <strong>Setter Injection</strong>, and <strong>Field Injection</strong>.
  </p>

  <h3 style="color: #16a085;">1. Constructor Injection</h3>
  <p style="color: #2c3e50;">
    In Constructor Injection, dependencies are injected through the class constructor. It is the most recommended approach as it ensures <strong>mandatory dependencies</strong> are always available.
  </p>

  <h4 style="color: #2980b9;">Example of Constructor Injection</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          private final ProductRepository repository;

          // Constructor Injection
          public ProductService(ProductRepository repository) {
              this.repository = repository;
          }

          public void fetchProducts() {
              repository.getAll();
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    <strong>Advantages of Constructor Injection:</strong>
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensures all required dependencies are available.</li>
    <li>Supports immutability by making dependencies <code>final</code>.</li>
    <li>Recommended for complex applications.</li>
  </ul>

  <h3 style="color: #e67e22;">2. Setter Injection</h3>
  <p style="color: #2c3e50;">
    In Setter Injection, dependencies are injected through a setter method. It is useful when dependencies are <strong>optional</strong> or need to be changed dynamically.
  </p>

  <h4 style="color: #2980b9;">Example of Setter Injection</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.beans.factory.annotation.Autowired;

      @Service
      public class ProductService {
          private ProductRepository repository;

          // Setter Injection
          @Autowired
          public void setRepository(ProductRepository repository) {
              this.repository = repository;
          }

          public void fetchProducts() {
              repository.getAll();
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    <strong>Advantages of Setter Injection:</strong>
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Allows optional dependencies.</li>
    <li>Provides flexibility to modify dependencies dynamically.</li>
    <li>Useful for testing when replacing beans.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Field Injection</h3>
  <p style="color: #2c3e50;">
    In Field Injection, dependencies are injected directly into fields using the <code>@Autowired</code> annotation. It is the simplest method but not recommended for large applications.
  </p>

  <h4 style="color: #2980b9;">Example of Field Injection</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.beans.factory.annotation.Autowired;

      @Service
      public class ProductService {
          // Field Injection
          @Autowired
          private ProductRepository repository;

          public void fetchProducts() {
              repository.getAll();
          }
      }
    </code>
  </pre>
  <p style="color: #2c3e50;">
    <strong>Disadvantages of Field Injection:</strong>
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Makes unit testing difficult.</li>
    <li>Violates the principle of dependency visibility.</li>
    <li>Not recommended for production-level applications.</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices for Dependency Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prefer <strong>Constructor Injection</strong> for mandatory dependencies.</li>
    <li>Use <strong>Setter Injection</strong> for optional dependencies.</li>
    <li>Avoid <strong>Field Injection</strong> due to its limitations in testing and maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Understanding the different types of Dependency Injection in Spring Boot helps in designing flexible and maintainable applications. Constructor Injection is the most preferred approach, while Setter Injection is useful in specific cases. Field Injection should be avoided for better testability and maintainability.
  </p>
</div>
`
},
{
  title:`Inversion of Control (IoC)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Inversion of Control (IoC) in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    <strong>Inversion of Control (IoC)</strong> is a fundamental principle of software design that shifts control of object creation and dependency management from the application code to a framework or container. In Spring Boot, the IoC container takes care of managing the lifecycle and dependencies of beans, making applications more modular and easier to maintain.
  </p>

  <h3 style="color: #16a085;">Why Use Inversion of Control (IoC)?</h3>
  <p style="color: #2c3e50;">
    The IoC principle provides several key advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Loose Coupling:</strong> Components interact through interfaces, reducing direct dependencies.</li>
    <li><strong>Code Reusability:</strong> Promotes modular and reusable components.</li>
    <li><strong>Easy Testing:</strong> Dependencies can be easily mocked for unit testing.</li>
    <li><strong>Automatic Dependency Management:</strong> Spring handles object creation and injection.</li>
  </ul>

  <h3 style="color: #e67e22;">How IoC Works in Spring Boot?</h3>
  <p style="color: #2c3e50;">
    Spring Boot implements IoC using the <strong>Spring IoC Container</strong>, which manages the lifecycle of beans (Spring components). The container instantiates, configures, and injects dependencies into beans automatically.
  </p>

  <h3 style="color: #8e44ad;">Example: IoC in Action</h3>
  <p style="color: #2c3e50;">
    Let’s see how Spring Boot manages dependencies using IoC.
  </p>

  <h4 style="color: #2980b9;">Step 1: Define a Service</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          public String getProduct() {
              return "Laptop";
          }
      }
    </code>
  </pre>

  <h4 style="color: #2980b9;">Step 2: Inject the Service into a Controller</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/products")
      public class ProductController {
          private final ProductService productService;

          // Constructor Injection (IoC in action)
          public ProductController(ProductService productService) {
              this.productService = productService;
          }

          @GetMapping
          public String getProduct() {
              return productService.getProduct();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Spring IoC Container</h3>
  <p style="color: #2c3e50;">
    The <strong>Spring IoC Container</strong> is responsible for managing Spring beans. It ensures that objects are created and injected where needed. The IoC Container uses:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>ApplicationContext:</strong> The main Spring container that manages the lifecycle of beans.</li>
    <li><strong>BeanFactory:</strong> A lightweight container primarily used for simple dependency injection.</li>
  </ul>

  <h3 style="color: #d35400;">Types of Dependency Injection in IoC</h3>
  <p style="color: #2c3e50;">
    Spring IoC provides different ways to inject dependencies:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Constructor Injection:</strong> Recommended approach that ensures immutability.</li>
    <li><strong>Setter Injection:</strong> Used for optional dependencies.</li>
    <li><strong>Field Injection:</strong> Not recommended as it makes testing harder.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Inversion of Control (IoC) is a core principle in Spring Boot that enhances modularity, flexibility, and testability. By letting the IoC Container manage dependencies, developers can focus on business logic while Spring handles object creation and lifecycle management efficiently.
  </p>
</div>
`
},
{
  title:`Spring DI Annotations (@Autowired, @Inject)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Spring DI Annotations (@Autowired, @Inject)</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, <strong>Dependency Injection (DI)</strong> is a design pattern that manages dependencies between objects. Spring provides powerful annotations such as <code>@Autowired</code> and <code>@Inject</code> to automatically inject dependencies into Spring beans, making applications modular, testable, and maintainable.
  </p>

  <h3 style="color: #16a085;">Why Use Dependency Injection (DI)?</h3>
  <p style="color: #2c3e50;">
    Spring DI provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Loose Coupling:</strong> Components are injected rather than manually instantiated.</li>
    <li><strong>Code Reusability:</strong> Promotes modular design.</li>
    <li><strong>Easy Testing:</strong> Dependencies can be easily mocked.</li>
    <li><strong>Automatic Object Management:</strong> Spring manages object creation and lifecycle.</li>
  </ul>

  <h3 style="color: #e67e22;">What is @Autowired?</h3>
  <p style="color: #2c3e50;">
    The <code>@Autowired</code> annotation in Spring Boot automatically injects dependencies into Spring-managed beans. It eliminates the need for explicit object creation using the <code>new</code> keyword.
  </p>

  <h4 style="color: #2980b9;">Example: Using @Autowired</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          public String getProduct() {
              return "Laptop";
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Injecting <code>ProductService</code> into a controller:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      import org.springframework.beans.factory.annotation.Autowired;

      @RestController
      @RequestMapping("/products")
      public class ProductController {

          @Autowired
          private ProductService productService;

          @GetMapping
          public String getProduct() {
              return productService.getProduct();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">What is @Inject?</h3>
  <p style="color: #2c3e50;">
    The <code>@Inject</code> annotation is part of the Java Dependency Injection (JSR-330) standard. It works similarly to <code>@Autowired</code> but is not Spring-specific. Spring supports <code>@Inject</code> as an alternative to <code>@Autowired</code>.
  </p>

  <h4 style="color: #2980b9;">Example: Using @Inject</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.inject.Inject;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;

      @RestController
      @RequestMapping("/products")
      public class ProductController {

          @Inject
          private ProductService productService;

          @GetMapping
          public String getProduct() {
              return productService.getProduct();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Key Differences Between @Autowired and @Inject</h3>
  <table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd; font-size: 16px; color: #2c3e50;">
    <tr style="background: #f8f9fa;">
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">Feature</th>
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">@Autowired</th>
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">@Inject</th>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Package</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Spring-specific (org.springframework.beans.factory.annotation)</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Java standard (javax.inject)</td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Primary Usage</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Spring applications</td>
      <td style="border: 1px solid #ddd; padding: 10px;">General Java DI</td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Required Spring Dependency</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Yes</td>
      <td style="border: 1px solid #ddd; padding: 10px;">No</td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Supports @Primary</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Yes</td>
      <td style="border: 1px solid #ddd; padding: 10px;">No</td>
    </tr>
  </table>

  <h3 style="color: #8e44ad;">Best Practices for Using @Autowired and @Inject</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Prefer Constructor Injection</strong>: Ensures immutability and testability.</li>
    <li><strong>Avoid Field Injection</strong>: Makes unit testing difficult.</li>
    <li><strong>Use @Autowired for Spring Apps</strong>: It provides additional Spring features.</li>
    <li><strong>Use @Inject for Standard Java DI</strong>: Useful for non-Spring projects.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring DI annotations like <code>@Autowired</code> and <code>@Inject</code> simplify dependency injection, making applications more modular and testable. While both annotations serve the same purpose, <code>@Autowired</code> is Spring-specific, whereas <code>@Inject</code> is part of the Java standard. Choosing the right approach depends on your project’s requirements.
  </p>
</div>
`
},
{
  title:`Bean Configuration (XML, Java-based, Annotations)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Bean Configuration (XML, Java-based, Annotations)</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, <strong>Bean Configuration</strong> is a crucial concept that defines how beans (Spring-managed objects) are created, initialized, and managed. There are three main ways to configure beans in Spring:
  </p>

  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>XML Configuration</strong> – Traditional method using XML files.</li>
    <li><strong>Java-based Configuration</strong> – Uses Java classes with <code>@Configuration</code> and <code>@Bean</code> annotations.</li>
    <li><strong>Annotation-based Configuration</strong> – Uses annotations like <code>@Component</code>, <code>@Service</code>, and <code>@Repository</code>.</li>
  </ul>

  <h3 style="color: #e67e22;">1. XML-based Bean Configuration</h3>
  <p style="color: #2c3e50;">
    In XML-based configuration, beans are defined inside an XML file (typically <code>applicationContext.xml</code>). This method was widely used in older Spring versions.
  </p>

  <h4 style="color: #2980b9;">Example: Defining a Bean in XML</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

          &lt;bean id="productService" class="com.example.ProductService"&gt;
              &lt;property name="productName" value="Laptop"/&gt;
          &lt;/bean&gt;

      &lt;/beans&gt;
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The bean is retrieved in Java code using:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
      ProductService productService = (ProductService) context.getBean("productService");
    </code>
  </pre>

  <h3 style="color: #16a085;">2. Java-based Bean Configuration</h3>
  <p style="color: #2c3e50;">
    Java-based configuration eliminates the need for XML files. It uses <code>@Configuration</code> and <code>@Bean</code> annotations to define beans.
  </p>

  <h4 style="color: #2980b9;">Example: Defining a Bean in Java</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class AppConfig {

          @Bean
          public ProductService productService() {
              return new ProductService("Laptop");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The bean is retrieved using:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
      ProductService productService = context.getBean(ProductService.class);
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Annotation-based Bean Configuration</h3>
  <p style="color: #2c3e50;">
    Annotation-based configuration uses Spring annotations like <code>@Component</code>, <code>@Service</code>, and <code>@Repository</code> to mark classes as Spring beans.
  </p>

  <h4 style="color: #2980b9;">Example: Using @Component Annotation</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Component;

      @Component
      public class ProductService {
          private String productName = "Laptop";

          public String getProduct() {
              return productName;
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In the Spring configuration class, we use <code>@ComponentScan</code> to enable annotation-based scanning:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.ComponentScan;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      @ComponentScan(basePackages = "com.example")
      public class AppConfig {
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The bean is retrieved in Java code using:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
      ProductService productService = context.getBean(ProductService.class);
    </code>
  </pre>

  <h3 style="color: #d35400;">Comparison of Bean Configuration Approaches</h3>
  <table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd; font-size: 16px; color: #2c3e50;">
    <tr style="background: #f8f9fa;">
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">Approach</th>
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">Pros</th>
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">Cons</th>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">XML Configuration</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Separation of configuration from code, supports legacy applications.</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Verbose, harder to maintain.</td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Java-based Configuration</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Type-safe, refactor-friendly, and readable.</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Configuration class must be explicitly defined.</td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Annotation-based Configuration</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Less code, easy to use.</td>
      <td style="border: 1px solid #ddd; padding: 10px;">May lead to hidden dependencies.</td>
    </tr>
  </table>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring provides multiple ways to configure beans: XML, Java-based, and Annotation-based approaches. While XML is useful for legacy projects, Java-based and annotation-based configurations are preferred for modern Spring Boot applications.
  </p>
</div>
`
},
{
  title:`Bean Scopes (Singleton, Prototype)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Bean Scopes (Singleton, Prototype, and More)</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, <strong>Bean Scope</strong> defines the lifecycle and visibility of a bean. It determines how many instances of a bean will be created and how they will be shared within the application context.
  </p>

  <p style="color: #2c3e50;">
    Spring provides the following bean scopes:
  </p>

  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Singleton</strong> – Only one instance per Spring container.</li>
    <li><strong>Prototype</strong> – A new instance is created each time the bean is requested.</li>
    <li><strong>Request</strong> – A new instance per HTTP request (for web applications).</li>
    <li><strong>Session</strong> – A new instance per HTTP session.</li>
    <li><strong>Application</strong> – A new instance per servlet context.</li>
  </ul>

  <h3 style="color: #e67e22;">1. Singleton Scope (Default)</h3>
  <p style="color: #2c3e50;">
    The <strong>singleton</strong> scope ensures that only <strong>one instance</strong> of the bean exists in the Spring container. Any request for the bean will return the same shared instance.
  </p>

  <h4 style="color: #2980b9;">Example: Singleton Scope</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Scope;
      import org.springframework.stereotype.Component;

      @Component
      @Scope("singleton")
      public class SingletonBean {
          public SingletonBean() {
              System.out.println("Singleton Bean Created");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    If we retrieve this bean multiple times, the same instance is returned.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
      SingletonBean bean1 = context.getBean(SingletonBean.class);
      SingletonBean bean2 = context.getBean(SingletonBean.class);

      System.out.println(bean1 == bean2); // Output: true (Same instance)
    </code>
  </pre>

  <h3 style="color: #16a085;">2. Prototype Scope</h3>
  <p style="color: #2c3e50;">
    The <strong>prototype</strong> scope ensures that a <strong>new instance</strong> of the bean is created each time it is requested from the container.
  </p>

  <h4 style="color: #2980b9;">Example: Prototype Scope</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Scope;
      import org.springframework.stereotype.Component;

      @Component
      @Scope("prototype")
      public class PrototypeBean {
          public PrototypeBean() {
              System.out.println("Prototype Bean Created");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    When we retrieve this bean multiple times, a new instance is created each time.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
      PrototypeBean bean1 = context.getBean(PrototypeBean.class);
      PrototypeBean bean2 = context.getBean(PrototypeBean.class);

      System.out.println(bean1 == bean2); // Output: false (Different instances)
    </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Request Scope (For Web Applications)</h3>
  <p style="color: #2c3e50;">
    The <strong>request</strong> scope creates a new bean instance for each HTTP request. It is used in web applications where beans need to be request-specific.
  </p>

  <h4 style="color: #2980b9;">Example: Request Scope</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Scope;
      import org.springframework.stereotype.Component;
      import org.springframework.web.context.annotation.RequestScope;

      @Component
      @RequestScope
      public class RequestBean {
          public RequestBean() {
              System.out.println("Request Bean Created");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    A new instance is created for each HTTP request.
  </p>

  <h3 style="color: #d35400;">4. Session Scope</h3>
  <p style="color: #2c3e50;">
    The <strong>session</strong> scope creates a new bean instance for each HTTP session. The same instance is shared within the session.
  </p>

  <h4 style="color: #2980b9;">Example: Session Scope</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Component;
      import org.springframework.web.context.annotation.SessionScope;

      @Component
      @SessionScope
      public class SessionBean {
          public SessionBean() {
              System.out.println("Session Bean Created");
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Comparison of Bean Scopes</h3>
  <table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd; font-size: 16px; color: #2c3e50;">
    <tr style="background: #f8f9fa;">
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">Scope</th>
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">Description</th>
      <th style="border: 1px solid #ddd; padding: 10px; text-align: left;">Instance per...</th>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Singleton</td>
      <td style="border: 1px solid #ddd; padding: 10px;">One instance per Spring container.</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Application</td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Prototype</td>
      <td style="border: 1px solid #ddd; padding: 10px;">New instance every time requested.</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Each request</td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 10px;">Request</td>
      <td style="border: 1px solid #ddd; padding: 10px;">New instance per HTTP request.</td>
      <td style="border: 1px solid #ddd; padding: 10px;">Each HTTP request</td>
    </tr>
  </table>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring provides multiple bean scopes for different use cases. Singleton is the default and widely used, while prototype is useful for non-shared beans. Request, session, and application scopes are designed for web applications.
  </p>
</div>
`
},
{
  title:`DI and Loose Coupling`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Dependency Injection (DI) and Loose Coupling</h2>
  <p style="font-size: 16px; color: #34495e;">
    In software development, <strong>Dependency Injection (DI)</strong> is a design pattern that promotes <em>loose coupling</em> between components by injecting dependencies rather than creating them manually. This improves maintainability, scalability, and testability.
  </p>

  <h3 style="color: #16a085;">What is Dependency Injection?</h3>
  <p style="color: #2c3e50;">
    Dependency Injection is a technique where one object supplies the dependencies of another object. Instead of creating dependencies manually using the <code>new</code> keyword, DI enables dependencies to be injected from an external source, such as a framework or configuration.
  </p>

  <h3 style="color: #e67e22;">Types of Dependency Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Constructor Injection</strong>: Dependencies are passed through the constructor.</li>
    <li><strong>Setter Injection</strong>: Dependencies are provided via setter methods.</li>
    <li><strong>Field Injection</strong>: Dependencies are assigned directly to fields (less recommended due to testability issues).</li>
  </ul>

  <h3 style="color: #8e44ad;">Example of Constructor Injection in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.beans.factory.annotation.Autowired;

      @Service
      public class OrderService {
          private final PaymentService paymentService;

          @Autowired
          public OrderService(PaymentService paymentService) {
              this.paymentService = paymentService;
          }

          public void processOrder() {
              paymentService.processPayment();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">What is Loose Coupling?</h3>
  <p style="color: #2c3e50;">
    Loose coupling refers to reducing dependencies between classes to improve modularity and flexibility. When components are loosely coupled, changes in one class have minimal impact on others, making the system easier to maintain and extend.
  </p>

  <h3 style="color: #d35400;">Benefits of DI and Loose Coupling</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improved Testability</strong>: Easily mock dependencies for unit testing.</li>
    <li><strong>Code Reusability</strong>: Components can be reused in different contexts.</li>
    <li><strong>Scalability</strong>: Makes it easier to extend and modify applications.</li>
    <li><strong>Maintainability</strong>: Reduces code duplication and improves readability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Dependency Injection and Loose Coupling are essential concepts in modern software development. By leveraging DI, developers can build flexible, scalable, and maintainable applications. Frameworks like Spring Boot make DI implementation seamless, ensuring efficient dependency management.
  </p>
</div>
`
},
{
  title:`DI in Spring Framework`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Dependency Injection (DI) in Spring Framework</h2>
  <p style="font-size: 16px; color: #34495e;">
    Dependency Injection (DI) is a core feature of the Spring Framework that helps manage object dependencies efficiently. It allows developers to build loosely coupled and easily testable applications by injecting dependencies at runtime rather than hardcoding them.
  </p>

  <h3 style="color: #16a085;">What is Dependency Injection?</h3>
  <p style="color: #2c3e50;">
    Dependency Injection is a design pattern that enables objects to receive their dependencies from an external source rather than creating them internally. In the Spring Framework, DI is achieved through Spring’s Inversion of Control (IoC) container.
  </p>

  <h3 style="color: #e67e22;">Types of Dependency Injection in Spring</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Constructor Injection</strong>: Dependencies are injected through a class constructor.</li>
    <li><strong>Setter Injection</strong>: Dependencies are injected via setter methods.</li>
    <li><strong>Field Injection</strong>: Dependencies are directly injected into fields using annotations.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example of Constructor Injection in Spring</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.beans.factory.annotation.Autowired;

      @Service
      public class UserService {
          private final UserRepository userRepository;

          @Autowired
          public UserService(UserRepository userRepository) {
              this.userRepository = userRepository;
          }

          public User getUserById(Long id) {
              return userRepository.findById(id).orElse(null);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using Setter Injection in Spring</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          private ProductRepository productRepository;

          @Autowired
          public void setProductRepository(ProductRepository productRepository) {
              this.productRepository = productRepository;
          }

          public Product getProductById(Long id) {
              return productRepository.findById(id).orElse(null);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Benefits of DI in Spring</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Loose Coupling</strong>: Makes components independent and easier to manage.</li>
    <li><strong>Improved Testability</strong>: Allows easy mocking of dependencies in unit tests.</li>
    <li><strong>Better Maintainability</strong>: Reduces dependency management complexity.</li>
    <li><strong>Flexible Configuration</strong>: Supports XML, Java-based, and annotation-based configurations.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Dependency Injection is a powerful feature of the Spring Framework that simplifies dependency management and enhances application flexibility. By leveraging DI, developers can create scalable, maintainable, and testable applications with minimal effort.
  </p>
</div>
`
},
{
  title:`Autowiring Modes (ByType, ByName)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Autowiring Modes (ByType, ByName) in Spring Framework</h2>
  <p style="font-size: 16px; color: #34495e;">
    Autowiring in Spring Framework is a feature that allows Spring to automatically resolve and inject dependencies into beans. Spring provides different modes of autowiring to facilitate dependency injection and reduce explicit configuration.
  </p>

  <h3 style="color: #16a085;">What is Autowiring?</h3>
  <p style="color: #2c3e50;">
    Autowiring allows Spring to automatically inject dependencies into beans without explicit bean definitions. It helps in reducing the boilerplate code required for dependency injection.
  </p>

  <h3 style="color: #e67e22;">Types of Autowiring Modes in Spring</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>ByType</strong>: Injects dependencies based on the type of the bean.</li>
    <li><strong>ByName</strong>: Injects dependencies based on the name of the bean.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example of Autowiring ByType</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class UserService {
          private UserRepository userRepository;

          @Autowired
          public void setUserRepository(UserRepository userRepository) {
              this.userRepository = userRepository;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Example of Autowiring ByName</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          @Autowired
          private ProductRepository productRepository;
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Choosing the Right Autowiring Mode</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>ByType</strong> is useful when there is only one bean of a particular type.</li>
    <li><strong>ByName</strong> is useful when multiple beans of the same type exist, and we want to inject a specific one by its name.</li>
    <li>Both modes help reduce XML or Java configuration complexity.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Autowiring in Spring simplifies dependency injection by automatically resolving dependencies using different modes. Choosing the right mode depends on the project requirements and the structure of bean definitions.
  </p>
</div>
`
},
{
  title:`DI with Qualifiers (@Qualifier)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding DI with Qualifiers (@Qualifier) in Spring Framework</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Framework, dependency injection (DI) helps in managing dependencies between objects. When multiple beans of the same type exist, the <code>@Qualifier</code> annotation is used to specify which bean should be injected, ensuring precise control over dependency resolution.
  </p>

  <h3 style="color: #16a085;">Why Use @Qualifier?</h3>
  <p style="color: #2c3e50;">
    The <code>@Qualifier</code> annotation is necessary when multiple beans of the same type are available in the application context. It helps avoid ambiguity by explicitly defining which bean should be injected.
  </p>

  <h3 style="color: #e67e22;">Using @Qualifier with Autowired</h3>
  <p style="color: #2c3e50;">
    The <code>@Qualifier</code> annotation works alongside <code>@Autowired</code> to resolve dependencies by bean name.
  </p>

  <h3 style="color: #8e44ad;">Example of @Qualifier Usage</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.beans.factory.annotation.Qualifier;
      import org.springframework.stereotype.Service;

      @Service
      public class PaymentService {

          private PaymentProcessor paymentProcessor;

          @Autowired
          public PaymentService(@Qualifier("creditCardProcessor") PaymentProcessor paymentProcessor) {
              this.paymentProcessor = paymentProcessor;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Defining Multiple Beans and Using @Qualifier</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class AppConfig {
          @Bean(name = "creditCardProcessor")
          public PaymentProcessor creditCardProcessor() {
              return new CreditCardProcessor();
          }

          @Bean(name = "paypalProcessor")
          public PaymentProcessor paypalProcessor() {
              return new PayPalProcessor();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using @Qualifier</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Always use <code>@Qualifier</code> when multiple beans of the same type exist to avoid ambiguity.</li>
    <li>Ensure that the specified bean name matches exactly with the one defined in the configuration.</li>
    <li>Use meaningful bean names to enhance code readability and maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>@Qualifier</code> annotation in Spring helps in precisely selecting the correct bean when multiple candidates are available. It enhances the flexibility and maintainability of dependency injection in Spring applications.
  </p>
</div>
`
},
{
  title:`DI in Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Dependency Injection (DI) in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Dependency Injection (DI) is a core concept in the Spring Boot framework that helps manage dependencies between different components, making applications more modular, testable, and maintainable.
  </p>

  <h3 style="color: #16a085;">Why Use Dependency Injection?</h3>
  <p style="color: #2c3e50;">
    DI in Spring Boot provides several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduces Coupling</strong>: Makes components independent and easier to replace.</li>
    <li><strong>Improves Testability</strong>: Simplifies unit testing by allowing mock dependencies.</li>
    <li><strong>Enhances Maintainability</strong>: Centralized control over object creation and dependency management.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Dependency Injection in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot supports three types of DI:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Constructor Injection</strong>: Preferred for mandatory dependencies.</li>
    <li><strong>Setter Injection</strong>: Used for optional dependencies.</li>
    <li><strong>Field Injection</strong>: Uses <code>@Autowired</code> to inject dependencies directly into fields.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example of Dependency Injection in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class OrderService {
          private final PaymentService paymentService;

          @Autowired
          public OrderService(PaymentService paymentService) {
              this.paymentService = paymentService;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using Setter Injection</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class OrderService {
          private PaymentService paymentService;

          @Autowired
          public void setPaymentService(PaymentService paymentService) {
              this.paymentService = paymentService;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Dependency Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Prefer <strong>Constructor Injection</strong> for required dependencies.</li>
    <li>Use <strong>Setter Injection</strong> for optional dependencies.</li>
    <li>Avoid <strong>Field Injection</strong> unless necessary.</li>
    <li>Ensure <strong>Single Responsibility</strong> by injecting only necessary dependencies.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Dependency Injection is a fundamental feature of Spring Boot that simplifies component management, improves testability, and enhances application scalability. By following best practices, developers can build efficient and maintainable applications.
  </p>
</div>
`
},
{
  title:`Circular Dependencies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Circular Dependencies in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Circular dependencies occur when two or more Spring beans depend on each other, creating a loop that prevents proper initialization. This issue can lead to <strong>BeanCurrentlyInCreationException</strong> if not handled correctly.
  </p>

  <h3 style="color: #16a085;">Why Do Circular Dependencies Happen?</h3>
  <p style="color: #2c3e50;">
    Circular dependencies typically arise when:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Two beans inject each other using constructor injection.</li>
    <li>Multiple beans indirectly depend on each other.</li>
    <li>Field-based or setter-based injection forms a loop.</li>
  </ul>

  <h3 style="color: #e67e22;">Example of a Circular Dependency</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class AService {
          private final BService bService;

          public AService(BService bService) {
              this.bService = bService;
          }
      }

      @Service
      public class BService {
          private final AService aService;

          public BService(AService aService) {
              this.aService = aService;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">How to Resolve Circular Dependencies?</h3>
  <p style="color: #2c3e50;">
    There are multiple ways to resolve circular dependencies in Spring:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use Setter Injection</strong> instead of Constructor Injection.</li>
    <li><strong>Apply @Lazy Annotation</strong> to delay bean initialization.</li>
    <li><strong>Break the Dependency</strong> by restructuring the application logic.</li>
    <li><strong>Use @PostConstruct and @PreDestroy</strong> for managing dependencies manually.</li>
  </ul>

  <h3 style="color: #d35400;">Example: Using @Lazy to Break the Loop</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Lazy;
      import org.springframework.stereotype.Service;

      @Service
      public class AService {
          private final BService bService;

          public AService(@Lazy BService bService) {
              this.bService = bService;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Circular dependencies in Spring can cause initialization failures and make debugging difficult. By using setter injection, the @Lazy annotation, or restructuring dependencies, developers can avoid these issues and build more maintainable applications.
  </p>
</div>
`
},
{
  title:`Constructor Injection`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Constructor Injection in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Constructor Injection is one of the most recommended dependency injection techniques in Spring. It ensures that all required dependencies are provided at the time of object creation, making the application more stable and testable.
  </p>

  <h3 style="color: #16a085;">Why Use Constructor Injection?</h3>
  <p style="color: #2c3e50;">
    Constructor Injection provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Immutable Dependencies</strong>: Prevents accidental modification of dependencies.</li>
    <li><strong>Ensures Required Dependencies</strong>: Forces all required dependencies to be provided.</li>
    <li><strong>Better Testability</strong>: Makes unit testing easier by enabling dependency injection through constructors.</li>
    <li><strong>Avoids Circular Dependencies</strong>: Encourages proper design patterns that prevent cyclic dependencies.</li>
  </ul>

  <h3 style="color: #e67e22;">Example of Constructor Injection</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          private final ProductRepository productRepository;

          public ProductService(ProductRepository productRepository) {
              this.productRepository = productRepository;
          }

          public Product getProductById(Long id) {
              return productRepository.findById(id).orElse(null);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices for Constructor Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>final</strong> keyword to enforce immutability.</li>
    <li>Prefer constructor injection over field injection for mandatory dependencies.</li>
    <li>Use <strong>@Autowired</strong> on a single constructor (Spring automatically injects dependencies).</li>
    <li>Avoid too many dependencies in a single class to maintain clean architecture.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Constructor Injection is a best practice in Spring applications. It enforces immutability, improves testability, and ensures that required dependencies are always provided. By following best practices, developers can build more maintainable and robust applications.
  </p>
</div>
`
},
{
  title:`Setter Injection`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Setter Injection in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Setter Injection is another dependency injection technique in Spring. It allows dependencies to be injected into an object through setter methods, providing flexibility and better control over optional dependencies.
  </p>

  <h3 style="color: #16a085;">Why Use Setter Injection?</h3>
  <p style="color: #2c3e50;">
    Setter Injection provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Flexibility</strong>: Allows optional dependencies to be injected only when needed.</li>
    <li><strong>Easy Modification</strong>: Dependencies can be modified or replaced at runtime.</li>
    <li><strong>Better Readability</strong>: Improves code clarity by separating dependency injection from object construction.</li>
  </ul>

  <h3 style="color: #e67e22;">Example of Setter Injection</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          private ProductRepository productRepository;

          @Autowired
          public void setProductRepository(ProductRepository productRepository) {
              this.productRepository = productRepository;
          }

          public Product getProductById(Long id) {
              return productRepository.findById(id).orElse(null);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices for Setter Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use setter injection for <strong>optional dependencies</strong>.</li>
    <li>Mark setter methods with <strong>@Autowired</strong> for automatic injection.</li>
    <li>Ensure proper null checks to handle cases where dependencies may not be injected.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Setter Injection is a useful approach in Spring applications, particularly for optional dependencies. It provides flexibility and allows modifications at runtime. However, for mandatory dependencies, Constructor Injection is generally preferred to enforce consistency.
  </p>
</div>
`
},
{
  title:`Field Injection`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Field Injection in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Field Injection is a dependency injection technique in Spring where dependencies are injected directly into class fields using the <code>@Autowired</code> annotation. It simplifies dependency management by reducing boilerplate code.
  </p>

  <h3 style="color: #16a085;">Why Use Field Injection?</h3>
  <p style="color: #2c3e50;">
    Field Injection provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Simplicity</strong>: Eliminates the need for setter or constructor methods.</li>
    <li><strong>Less Boilerplate</strong>: Reduces code complexity by directly injecting dependencies.</li>
    <li><strong>Quick Implementation</strong>: Makes dependency injection straightforward.</li>
  </ul>

  <h3 style="color: #e67e22;">Example of Field Injection</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      @Service
      public class ProductService {
          @Autowired
          private ProductRepository productRepository;

          public Product getProductById(Long id) {
              return productRepository.findById(id).orElse(null);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices for Field Injection</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use field injection for <strong>small applications</strong> or prototyping.</li>
    <li>Avoid field injection in <strong>large applications</strong> to improve testability and maintainability.</li>
    <li>Prefer constructor injection for mandatory dependencies to ensure immutability.</li>
  </ul>

  <h3 style="color: #d35400;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Field Injection in Spring is an easy-to-use technique for dependency injection. While it reduces boilerplate code, it can make unit testing more difficult and tightly couple dependencies. For better maintainability, constructor injection is often recommended.
  </p>
</div>
`
},
{
  title:`DI with Profiles`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding DI with Profiles in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, Profiles are used to define different configurations for various environments such as development, testing, and production. Dependency Injection (DI) with Profiles allows the application to load specific beans based on the active profile.
  </p>

  <h3 style="color: #16a085;">Why Use Profiles in Dependency Injection?</h3>
  <p style="color: #2c3e50;">
    Profiles help in managing environment-specific configurations efficiently:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Environment-Specific Beans</strong>: Load different beans for development, testing, and production.</li>
    <li><strong>Improved Maintainability</strong>: Separates configuration logic based on deployment needs.</li>
    <li><strong>Flexibility</strong>: Enables switching between configurations without modifying the code.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use Profiles in Spring Boot?</h3>
  <p style="color: #2c3e50;">
    Define beans with the <code>@Profile</code> annotation and activate the profile using application properties.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Profile;
      import org.springframework.stereotype.Service;

      @Service
      @Profile("dev")
      public class DevDataService implements DataService {
          @Override
          public String getData() {
              return "Development Data";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Activating Profiles</h3>
  <p style="color: #2c3e50;">
    You can activate a profile in the <code>application.properties</code> file:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code>
      spring.profiles.active=dev
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Profiles</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use profiles to define <strong>environment-specific beans</strong> cleanly.</li>
    <li>Avoid hardcoding values; instead, use externalized configuration.</li>
    <li>Ensure the correct profile is active in production to avoid unintended behavior.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    DI with Profiles in Spring Boot is a powerful way to manage environment-specific configurations. By using <code>@Profile</code> annotations, you can seamlessly switch between different beans without modifying the core logic.
  </p>
</div>
`
},
{
  title:`DI and Lifecycle of Beans`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding DI and Lifecycle of Beans in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In the Spring Framework, Dependency Injection (DI) is a core concept that helps manage object dependencies. Along with DI, Spring also manages the lifecycle of beans, from creation to destruction, ensuring efficient resource management.
  </p>

  <h3 style="color: #16a085;">Understanding Dependency Injection (DI)</h3>
  <p style="color: #2c3e50;">
    DI in Spring allows objects to be injected into a class rather than the class creating the dependencies itself. This promotes loose coupling and enhances testability.
  </p>

  <h3 style="color: #e67e22;">Bean Lifecycle in Spring</h3>
  <p style="color: #2c3e50;">
    Spring manages the lifecycle of a bean from instantiation to destruction. The key phases of the bean lifecycle are:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Instantiation</strong>: Spring creates an instance of the bean.</li>
    <li><strong>Dependency Injection</strong>: Dependencies are injected into the bean.</li>
    <li><strong>Initialization</strong>: Custom initialization logic is executed.</li>
    <li><strong>Usage</strong>: The bean is ready for use.</li>
    <li><strong>Destruction</strong>: The bean is destroyed when the application context is closed.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Bean Lifecycle Methods</h3>
  <p style="color: #2c3e50;">
    Spring provides multiple ways to define custom initialization and destruction methods:
  </p>

  <h4 style="color: #16a085;">Using @PostConstruct and @PreDestroy</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.annotation.PostConstruct;
      import javax.annotation.PreDestroy;
      import org.springframework.stereotype.Component;
      
      @Component
      public class MyBean {
          @PostConstruct
          public void init() {
              System.out.println("Bean is initialized");
          }
          
          @PreDestroy
          public void destroy() {
              System.out.println("Bean is being destroyed");
          }
      }
    </code>
  </pre>

  <h4 style="color: #16a085;">Using InitializingBean and DisposableBean Interfaces</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.DisposableBean;
      import org.springframework.beans.factory.InitializingBean;
      import org.springframework.stereotype.Component;
      
      @Component
      public class MyBean implements InitializingBean, DisposableBean {
          @Override
          public void afterPropertiesSet() {
              System.out.println("Bean initialization using InitializingBean");
          }
          
          @Override
          public void destroy() {
              System.out.println("Bean destruction using DisposableBean");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Managing Bean Lifecycle</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@PostConstruct</strong> and <strong>@PreDestroy</strong> for clean lifecycle management.</li>
    <li>Ensure proper <strong>dependency injection</strong> to avoid circular dependencies.</li>
    <li>Use <strong>prototype scope</strong> for stateful beans and <strong>singleton scope</strong> for stateless beans.</li>
    <li>Monitor resource usage and clean up resources properly in destruction methods.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Understanding DI and the lifecycle of beans in Spring is crucial for building scalable and maintainable applications. By properly managing bean initialization and destruction, developers can ensure efficient resource utilization and application performance.
  </p>
</div>
`
},
{
  title:`Spring Bean Post-Processors`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Spring Bean Post-Processors</h2>
  <p style="font-size: 16px; color: #34495e;">
    In the Spring Framework, Bean Post-Processors allow developers to modify bean properties before and after initialization. This provides flexibility in managing bean behavior dynamically.
  </p>

  <h3 style="color: #16a085;">What are Bean Post-Processors?</h3>
  <p style="color: #2c3e50;">
    A Bean Post-Processor is an interface in Spring that enables modifying beans during their lifecycle. Spring provides two key methods:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>postProcessBeforeInitialization</strong>: Executes before a bean's initialization.</li>
    <li><strong>postProcessAfterInitialization</strong>: Executes after a bean's initialization.</li>
  </ul>

  <h3 style="color: #e67e22;">Implementing BeanPostProcessor</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.config.BeanPostProcessor;
      import org.springframework.stereotype.Component;

      @Component
      public class CustomBeanPostProcessor implements BeanPostProcessor {
          @Override
          public Object postProcessBeforeInitialization(Object bean, String beanName) {
              System.out.println("Before Initialization: " + beanName);
              return bean;
          }

          @Override
          public Object postProcessAfterInitialization(Object bean, String beanName) {
              System.out.println("After Initialization: " + beanName);
              return bean;
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Use Cases for Bean Post-Processors</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Modifying bean properties dynamically.</li>
    <li>Applying custom logic to all Spring beans.</li>
    <li>Enforcing security rules or logging.</li>
    <li>Injecting proxies for aspect-oriented programming (AOP).</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use BeanPostProcessor for cross-cutting concerns like logging and auditing.</li>
    <li>Minimize complex logic inside post-processing methods.</li>
    <li>Avoid modifying beans that could lead to circular dependencies.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Bean Post-Processors provide a powerful way to manage bean behavior before and after initialization. Understanding their usage helps in building robust and maintainable Spring applications.
  </p>
</div>
`
},
{
  title:`Testing DI`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing Dependency Injection in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring applications, testing Dependency Injection (DI) ensures that the configured beans work correctly in different environments. Spring provides various tools to test DI efficiently.
  </p>

  <h3 style="color: #16a085;">Why Test DI?</h3>
  <p style="color: #2c3e50;">
    Testing DI is essential for:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensuring correct wiring</strong>: Validates that beans are injected properly.</li>
    <li><strong>Detecting misconfigurations</strong>: Catches errors before deployment.</li>
    <li><strong>Maintaining modularity</strong>: Encourages loosely coupled, testable components.</li>
  </ul>

  <h3 style="color: #e67e22;">Testing DI with JUnit and Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot integrates well with JUnit to test DI. Use <code>@SpringBootTest</code> to load the application context.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import static org.junit.jupiter.api.Assertions.*;
      import org.junit.jupiter.api.Test;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.context.SpringBootTest;
      
      @SpringBootTest
      class DependencyInjectionTest {
          
          @Autowired
          private MyService myService;
          
          @Test
          void testBeanInjection() {
              assertNotNull(myService);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using @MockBean for Testing Dependencies</h3>
  <p style="color: #2c3e50;">
    The <code>@MockBean</code> annotation helps mock dependencies, isolating components for testing.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import static org.mockito.Mockito.*;
      import org.junit.jupiter.api.Test;
      import org.springframework.boot.test.context.SpringBootTest;
      import org.springframework.boot.test.mock.mockito.MockBean;
      import org.springframework.beans.factory.annotation.Autowired;
      
      @SpringBootTest
      class MockingDependencyTest {
          
          @MockBean
          private MyRepository myRepository;
          
          @Autowired
          private MyService myService;
          
          @Test
          void testMocking() {
              when(myRepository.getData()).thenReturn("Mock Data");
              assertEquals("Mock Data", myService.fetchData());
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Testing DI</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@SpringBootTest</strong> to load the full context.</li>
    <li>Use <strong>@MockBean</strong> to isolate components.</li>
    <li>Use <strong>@TestConfiguration</strong> for custom test beans.</li>
    <li>Keep unit tests independent and fast.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Testing DI in Spring ensures that beans are wired correctly and work as expected. Using Spring Boot test utilities and mocking techniques, developers can create reliable and maintainable applications.
  </p>
</div>
`
},
{
  title:`DI Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Dependency Injection Best Practices in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Dependency Injection (DI) in Spring allows for better modularity and testability. Following best practices ensures maintainability and efficiency.
  </p>

  <h3 style="color: #16a085;">Use Constructor Injection</h3>
  <p style="color: #2c3e50;">
    Constructor Injection is preferred over Field and Setter Injection as it ensures immutability and easier testing.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class MyService {
          private final MyRepository myRepository;
          
          @Autowired
          public MyService(MyRepository myRepository) {
              this.myRepository = myRepository;
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Avoid Field Injection</h3>
  <p style="color: #2c3e50;">
    Field Injection makes testing difficult and tightly couples components. Always prefer Constructor Injection.
  </p>

  <h3 style="color: #8e44ad;">Use @Qualifier for Ambiguous Dependencies</h3>
  <p style="color: #2c3e50;">
    When multiple beans of the same type exist, use <code>@Qualifier</code> to specify the correct one.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class MyService {
          private final MyRepository myRepository;
          
          @Autowired
          public MyService(@Qualifier("primaryRepo") MyRepository myRepository) {
              this.myRepository = myRepository;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Use Profiles for Environment-Specific Beans</h3>
  <p style="color: #2c3e50;">
    Use <code>@Profile</code> to define beans specific to development, testing, or production environments.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Profile("dev")
      @Bean
      public DataSource devDataSource() {
          return new H2DataSource();
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Following DI best practices improves code maintainability and testability. Using Constructor Injection, avoiding Field Injection, and leveraging profiles ensure a clean and scalable Spring application.
  </p>
</div>
`
},
{
  title:`ORM Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding ORM Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Object-Relational Mapping (ORM) is a programming technique that enables developers to interact with relational databases using object-oriented paradigms. ORM simplifies database interactions by abstracting SQL queries, allowing developers to manipulate database records as objects in their preferred programming language.
  </p>

  <h3 style="color: #16a085;">Why Use ORM?</h3>
  <p style="color: #2c3e50;">
    ORM frameworks offer several advantages over traditional SQL-based database management:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Abstraction from SQL</strong>: Developers work with objects instead of writing complex SQL queries.</li>
    <li><strong>Code Reusability</strong>: ORM promotes DRY (Don't Repeat Yourself) principles by managing database operations centrally.</li>
    <li><strong>Improved Maintainability</strong>: Changes in the database schema require minimal code adjustments.</li>
    <li><strong>Cross-Database Compatibility</strong>: ORM frameworks support multiple database engines, making migrations easier.</li>
  </ul>

  <h3 style="color: #e67e22;">How ORM Works?</h3>
  <p style="color: #2c3e50;">
    ORM frameworks map database tables to class definitions, where each row corresponds to an instance of a class. The ORM handles conversions between objects and database records.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Entity
      @Table(name = "users")
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Popular ORM Frameworks</h3>
  <p style="color: #2c3e50;">
    Several ORM frameworks are widely used across different programming languages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Hibernate</strong> (Java)</li>
    <li><strong>Entity Framework</strong> (.NET)</li>
    <li><strong>SQLAlchemy</strong> (Python)</li>
    <li><strong>Active Record</strong> (Ruby on Rails)</li>
  </ul>

  <h3 style="color: #8e44ad;">Basic CRUD Operations with ORM</h3>
  <p style="color: #2c3e50;">
    ORM frameworks simplify CRUD (Create, Read, Update, Delete) operations, reducing the need for raw SQL queries.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class UserService {
          @Autowired
          private UserRepository userRepository;

          public User createUser(User user) {
              return userRepository.save(user);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using ORM</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>lazy loading</strong> to optimize performance.</li>
    <li>Define proper indexes to improve query efficiency.</li>
    <li>Handle transactions properly to maintain data integrity.</li>
    <li>Monitor and tune ORM queries to avoid performance bottlenecks.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    ORM simplifies database interactions by bridging the gap between object-oriented programming and relational databases. By leveraging ORM frameworks effectively, developers can enhance productivity, maintainability, and scalability in their applications.
  </p>
</div>
`

},
{
  title:`JPA vs Hibernate`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA vs Hibernate: Understanding the Differences</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Persistence API (JPA) and Hibernate are two commonly used technologies in Java applications for database interaction. While JPA is a specification that defines how ORM frameworks should function, Hibernate is a specific implementation of JPA with additional features.
  </p>

  <h3 style="color: #16a085;">What is JPA?</h3>
  <p style="color: #2c3e50;">
    JPA (Java Persistence API) is a Java specification that provides a set of rules and guidelines for ORM (Object-Relational Mapping). It standardizes how Java applications should interact with relational databases.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>JPA is just a specification</strong>: It does not provide an actual implementation.</li>
    <li><strong>Defines API for ORM</strong>: It includes annotations like <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, etc.</li>
    <li><strong>Vendor-Neutral</strong>: Works with different ORM implementations like Hibernate, EclipseLink, and OpenJPA.</li>
  </ul>

  <h3 style="color: #e67e22;">What is Hibernate?</h3>
  <p style="color: #2c3e50;">
    Hibernate is an ORM framework that implements the JPA specification while also providing additional functionalities beyond JPA.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>JPA Implementation</strong>: Hibernate adheres to JPA standards but includes extra features.</li>
    <li><strong>Provides Caching</strong>: Supports first-level and second-level caching.</li>
    <li><strong>Supports Native Query and HQL</strong>: Allows the use of Hibernate Query Language (HQL) for powerful queries.</li>
  </ul>

  <h3 style="color: #8e44ad;">Key Differences Between JPA and Hibernate</h3>
  <table style="width:100%; border-collapse: collapse;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px;">Feature</th>
      <th style="padding: 10px;">JPA</th>
      <th style="padding: 10px;">Hibernate</th>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Type</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Specification</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Framework</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Caching</td>
      <td style="padding: 10px; border: 1px solid #ddd;">No built-in caching</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Supports first and second-level caching</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Query Language</td>
      <td style="padding: 10px; border: 1px solid #ddd;">JPQL</td>
      <td style="padding: 10px; border: 1px solid #ddd;">HQL & SQL</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Vendor Dependency</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Works with multiple vendors</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Specific to Hibernate</td>
    </tr>
  </table>

  <h3 style="color: #d35400;">When to Use JPA or Hibernate?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Use JPA</strong> if you need a standardized ORM approach that allows switching between different providers.</li>
    <li><strong>Use Hibernate</strong> if you need advanced features like caching, HQL, and better performance optimizations.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JPA and Hibernate both serve important roles in Java ORM. While JPA provides a standard interface for ORM operations, Hibernate extends these capabilities with additional features. Choosing between them depends on project requirements, scalability needs, and performance considerations.
  </p>
</div>
`
},
{
  title:`Entity Mapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Mapping in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity mapping is a crucial aspect of Object-Relational Mapping (ORM) in Java applications. JPA and Hibernate allow developers to map Java objects to database tables using annotations and XML configurations, making data persistence seamless and efficient.
  </p>

  <h3 style="color: #16a085;">What is Entity Mapping?</h3>
  <p style="color: #2c3e50;">
    Entity mapping is the process of linking Java objects (entities) to relational database tables. JPA and Hibernate use annotations such as <code>@Entity</code>, <code>@Table</code>, and <code>@Id</code> to define how objects should be stored and retrieved from the database.
  </p>

  <h3 style="color: #e67e22;">Basic Annotations for Entity Mapping</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>@Entity</strong>: Marks a class as an entity.</li>
    <li><strong>@Table(name = "table_name")</strong>: Specifies the table name for the entity.</li>
    <li><strong>@Id</strong>: Identifies the primary key field.</li>
    <li><strong>@GeneratedValue(strategy = GenerationType.IDENTITY)</strong>: Specifies how the primary key is generated.</li>
    <li><strong>@Column(name = "column_name")</strong>: Maps a field to a specific column in the database.</li>
  </ul>

  <h3 style="color: #8e44ad;">Types of Entity Relationships</h3>
  <p style="color: #2c3e50;">
    In JPA and Hibernate, entities can have different types of relationships:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>@OneToOne</strong>: Maps a one-to-one relationship between two entities.</li>
    <li><strong>@OneToMany</strong>: Represents a one-to-many relationship where one entity is related to multiple instances of another entity.</li>
    <li><strong>@ManyToOne</strong>: Defines a many-to-one relationship where multiple entities refer to a single parent entity.</li>
    <li><strong>@ManyToMany</strong>: Maps a many-to-many relationship with a join table.</li>
  </ul>

  <h3 style="color: #d35400;">Example of Entity Mapping</h3>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "users")
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      @Column(name = "username", nullable = false, unique = true)
      private String username;
      
      @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
      private List&lt;Order&gt; orders;
      
      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity mapping in JPA and Hibernate simplifies database interactions by allowing developers to work with Java objects instead of raw SQL queries. Understanding entity relationships and annotations is key to designing efficient and scalable applications.
  </p>
</div>
`
},
{
  title:`ORM Frameworks`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">ORM Frameworks</h2>
  <p style="font-size: 16px; color: #34495e;">
    Object-Relational Mapping (ORM) frameworks simplify database interactions by allowing developers to work with objects instead of writing complex SQL queries. These frameworks provide an abstraction layer that maps Java objects to database tables.
  </p>

  <h3 style="color: #16a085;">Why Use ORM Frameworks?</h3>
  <p style="color: #2c3e50;">
    ORM frameworks offer several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduces Boilerplate Code</strong>: Eliminates the need for writing repetitive SQL queries.</li>
    <li><strong>Improves Maintainability</strong>: Simplifies database interaction logic.</li>
    <li><strong>Enhances Performance</strong>: Provides caching and optimization techniques.</li>
    <li><strong>Supports Transaction Management</strong>: Ensures data consistency and integrity.</li>
  </ul>

  <h3 style="color: #e67e22;">Popular ORM Frameworks</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Hibernate</strong>: The most widely used ORM framework for Java, implementing JPA specifications.</li>
    <li><strong>JPA (Java Persistence API)</strong>: A standard specification for ORM in Java.</li>
    <li><strong>MyBatis</strong>: A lightweight ORM framework offering flexibility with SQL queries.</li>
    <li><strong>Doctrine</strong>: A popular ORM framework for PHP applications.</li>
    <li><strong>Entity Framework</strong>: Microsoft's ORM framework for .NET applications.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example of ORM in Hibernate</h3>
  <p style="color: #2c3e50;">
    Below is a simple example demonstrating ORM with Hibernate:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "users")
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      @Column(name = "username", nullable = false, unique = true)
      private String username;
      
      @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
      private List&lt;Order&gt; orders;
      
      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">Choosing the Right ORM Framework</h3>
  <p style="color: #2c3e50;">
    Selecting the right ORM framework depends on several factors:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Project requirements and complexity.</li>
    <li>Performance considerations.</li>
    <li>Database support and compatibility.</li>
    <li>Community support and documentation.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    ORM frameworks streamline database operations by providing a structured way to interact with databases using object-oriented principles. Choosing the right framework depends on project needs, scalability, and ease of integration.
  </p>
</div>
`
},
{
  title:`Primary Key Generation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Primary Key Generation</h2>
  <p style="font-size: 16px; color: #34495e;">
    In database design, a primary key is a unique identifier for a record in a table. In ORM frameworks, primary key generation is crucial for ensuring data integrity and uniqueness. Different strategies exist to generate primary keys automatically.
  </p>

  <h3 style="color: #16a085;">Why is Primary Key Generation Important?</h3>
  <p style="color: #2c3e50;">
    Primary key generation plays a vital role in database management:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensures Uniqueness</strong>: Guarantees that each record is uniquely identified.</li>
    <li><strong>Improves Performance</strong>: Optimizes indexing and query performance.</li>
    <li><strong>Automates Key Assignment</strong>: Reduces manual effort in assigning unique values.</li>
  </ul>

  <h3 style="color: #e67e22;">Primary Key Generation Strategies</h3>
  <p style="color: #2c3e50;">
    ORM frameworks provide different strategies for primary key generation. In JPA and Hibernate, these strategies are specified using the <code>@GeneratedValue</code> annotation.
  </p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      private String username;
      
      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Types of Primary Key Generation Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>IDENTITY</strong>: Uses auto-incremented values provided by the database.</li>
    <li><strong>SEQUENCE</strong>: Uses a database sequence to generate unique values.</li>
    <li><strong>TABLE</strong>: Uses a table to maintain primary key values.</li>
    <li><strong>AUTO</strong>: Chooses the best strategy based on the database provider.</li>
  </ul>

  <h3 style="color: #d35400;">Choosing the Right Primary Key Strategy</h3>
  <p style="color: #2c3e50;">
    Selecting the right primary key generation strategy depends on:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Database capabilities and support.</li>
    <li>Performance and scalability needs.</li>
    <li>Data consistency requirements.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Primary key generation is a fundamental aspect of database design in ORM frameworks. Choosing the appropriate strategy ensures efficient record management, improves query performance, and maintains data integrity.
  </p>
</div>
`
},
{
  title:`Lazy vs Eager Loading`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Lazy vs Eager Loading</h2>
  <p style="font-size: 16px; color: #34495e;">
    In ORM frameworks like JPA and Hibernate, lazy and eager loading determine how associated entities are fetched from the database. Choosing the right loading strategy impacts performance and memory management.
  </p>

  <h3 style="color: #16a085;">What is Lazy Loading?</h3>
  <p style="color: #2c3e50;">
    Lazy loading defers the retrieval of related entities until they are explicitly accessed in code. It helps optimize performance by loading only necessary data.
  </p>

  <h3 style="color: #e67e22;">Example of Lazy Loading</h3>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String username;
      
      @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
      private List&lt;Order&gt; orders;
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">What is Eager Loading?</h3>
  <p style="color: #2c3e50;">
    Eager loading retrieves related entities immediately along with the main entity. It simplifies data access but may lead to performance issues if too much data is loaded at once.
  </p>

  <h3 style="color: #e67e22;">Example of Eager Loading</h3>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String username;
      
      @OneToMany(mappedBy = "user", fetch = FetchType.EAGER)
      private List&lt;Order&gt; orders;
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">Lazy vs Eager Loading: Key Differences</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Performance</strong>: Lazy loading improves performance by fetching data only when needed, while eager loading may fetch unnecessary data.</li>
    <li><strong>Memory Usage</strong>: Lazy loading consumes less memory, whereas eager loading may increase memory consumption.</li>
    <li><strong>Code Complexity</strong>: Lazy loading requires additional handling for accessing related entities outside the transaction scope.</li>
    <li><strong>Database Queries</strong>: Lazy loading may lead to multiple queries (N+1 problem), whereas eager loading retrieves everything in a single query.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Choosing between lazy and eager loading depends on the use case. Lazy loading is preferred for performance optimization, whereas eager loading is useful when related entities are always needed. Proper configuration and tuning are essential to avoid performance bottlenecks`
},
{
  title:`Relationships (OneToOne, OneToMany, ManyToOne, ManyToMany)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Relationships in ORM (OneToOne, OneToMany, ManyToOne, ManyToMany)</h2>
  <p style="font-size: 16px; color: #34495e;">
    In ORM frameworks like JPA and Hibernate, relationships define how entities are associated with each other. The four main types of relationships are OneToOne, OneToMany, ManyToOne, and ManyToMany.
  </p>

  <h3 style="color: #16a085;">OneToOne Relationship</h3>
  <p style="color: #2c3e50;">
    A OneToOne relationship means each record in one entity corresponds to exactly one record in another entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String username;

      @OneToOne
      @JoinColumn(name = "profile_id")
      private UserProfile profile;
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">OneToMany Relationship</h3>
  <p style="color: #2c3e50;">
    A OneToMany relationship means one entity can have multiple related records in another entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String username;

      @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
      private List&lt;Order&gt; orders;
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">ManyToOne Relationship</h3>
  <p style="color: #2c3e50;">
    A ManyToOne relationship means multiple records in one entity can be associated with a single record in another entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Order {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String product;

      @ManyToOne
      @JoinColumn(name = "user_id")
      private User user;
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">ManyToMany Relationship</h3>
  <p style="color: #2c3e50;">
    A ManyToMany relationship means multiple records in one entity can be associated with multiple records in another entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Student {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;

      @ManyToMany
      @JoinTable(
          name = "student_course",
          joinColumns = @JoinColumn(name = "student_id"),
          inverseJoinColumns = @JoinColumn(name = "course_id")
      )
      private List&lt;Course&gt; courses;
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity relationships`
},
{
  title:`JPQL (Java Persistence Query Language)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPQL (Java Persistence Query Language)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Persistence Query Language (JPQL) is a query language used in JPA to interact with databases in an object-oriented manner. It allows developers to write queries using entity objects instead of database tables.
  </p>

  <h3 style="color: #16a085;">Why Use JPQL?</h3>
  <p style="color: #2c3e50;">
    JPQL offers several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Database Independence</strong>: Works across different database systems.</li>
    <li><strong>Object-Oriented Approach</strong>: Uses entity names and attributes instead of table names and columns.</li>
    <li><strong>Flexibility</strong>: Supports complex queries with joins, aggregations, and filtering.</li>
  </ul>

  <h3 style="color: #e67e22;">Basic JPQL Syntax</h3>
  <p style="color: #2c3e50;">
    JPQL queries resemble SQL but operate on entity objects.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT u FROM User u WHERE u.username = :username
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Example of JPQL Query in Java</h3>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @PersistenceContext
  private EntityManager entityManager;
  
  public User findUserByUsername(String username) {
      return entityManager.createQuery("SELECT u FROM User u WHERE u.username = :username", User.class)
                          .setParameter("username", username)
                          .getSingleResult();
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">JPQL Query Types</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>SELECT Queries</strong>: Retrieve data from entities.</li>
    <li><strong>UPDATE Queries</strong>: Modify existing records.</li>
    <li><strong>DELETE Queries</strong>: Remove records from the database.</li>
  </ul>

  <h3 style="color: #2c3e50;">Using JOINs in JPQL</h3>
  <p style="color: #2c3e50;">
    JPQL supports INNER JOIN, LEFT JOIN, and FETCH JOIN to retrieve related data efficiently.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT o FROM Order o JOIN o.user u WHERE u.username = :username
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JPQL simplifies database interactions by using entity objects instead of raw SQL queries. It provides a flexible and efficient way to manage persistent data while maintaining database independence.
  </p>
</div>
`
},
{
  title:`Criteria API`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Criteria API in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The Criteria API in JPA (Java Persistence API) is a type-safe and programmatic way to build dynamic queries for your database. Unlike JPQL (Java Persistence Query Language), which uses string-based queries, the Criteria API allows you to construct queries using Java objects and methods. This makes it easier to build complex, dynamic queries at runtime and reduces the risk of errors caused by typos or incorrect syntax. The Criteria API is particularly useful when the structure of the query depends on runtime conditions.
  </p>

  <h3 style="color: #16a085;">Why Use the Criteria API?</h3>
  <p style="color: #2c3e50;">
    The Criteria API offers several advantages for building dynamic queries:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Type Safety</strong>: Queries are built using Java objects, reducing the risk of runtime errors.</li>
    <li><strong>Dynamic Query Building</strong>: Easily construct queries based on runtime conditions.</li>
    <li><strong>Flexibility</strong>: Supports complex queries with joins, subqueries, and aggregations.</li>
    <li><strong>Code Maintainability</strong>: Makes queries easier to read, write, and maintain compared to string-based JPQL.</li>
    <li><strong>Integration</strong>: Works seamlessly with JPA and Hibernate.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of the Criteria API</h3>
  <p style="color: #2c3e50;">
    When working with the Criteria API, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>CriteriaBuilder</strong>: The main interface for constructing queries, predicates, and expressions.</li>
    <li><strong>CriteriaQuery</strong>: Represents a query that can be executed against the database.</li>
    <li><strong>Root</strong>: Represents the root entity in the query.</li>
    <li><strong>Predicate</strong>: Represents a condition in the query (e.g., WHERE clause).</li>
    <li><strong>Join</strong>: Represents a join between entities.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using the Criteria API in JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use the Criteria API in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity</h4>
  <p style="color: #2c3e50;">
    Create a JPA entity to represent a database table.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;
          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create a Repository with Criteria API</h4>
  <p style="color: #2c3e50;">
    Use the Criteria API to build dynamic queries in a repository.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.EntityManager;
      import jakarta.persistence.PersistenceContext;
      import jakarta.persistence.criteria.CriteriaBuilder;
      import jakarta.persistence.criteria.CriteriaQuery;
      import jakarta.persistence.criteria.Predicate;
      import jakarta.persistence.criteria.Root;
      import org.springframework.stereotype.Repository;

      import java.util.List;

      @Repository
      public class UserRepository {

          @PersistenceContext
          private EntityManager entityManager;

          public List&lt;User&gt; findUsersByNameAndEmail(String name, String email) {
              CriteriaBuilder cb = entityManager.getCriteriaBuilder();
              CriteriaQuery&lt;User&gt; cq = cb.createQuery(User.class);

              Root&lt;User&gt; user = cq.from(User.class);
              Predicate namePredicate = cb.equal(user.get("name"), name);
              Predicate emailPredicate = cb.equal(user.get("email"), email);
              cq.where(cb.and(namePredicate, emailPredicate));

              return entityManager.createQuery(cq).getResultList();
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use the Repository in a Service</h4>
  <p style="color: #2c3e50;">
    Use the repository methods in a service to fetch data using the Criteria API.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;

      import java.util.List;

      @Service
      public class UserService {

          @Autowired
          private UserRepository userRepository;

          public List&lt;User&gt; getUsersByNameAndEmail(String name, String email) {
              return userRepository.findUsersByNameAndEmail(name, email);
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Build Dynamic Queries</h4>
  <p style="color: #2c3e50;">
    Use the Criteria API to build dynamic queries based on runtime conditions.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      public List&lt;User&gt; findUsersByCriteria(String name, String email, Integer age) {
          CriteriaBuilder cb = entityManager.getCriteriaBuilder();
          CriteriaQuery&lt;User&gt; cq = cb.createQuery(User.class);

          Root&lt;User&gt; user = cq.from(User.class);
          Predicate predicate = cb.conjunction();

          if (name != null) {
              predicate = cb.and(predicate, cb.equal(user.get("name"), name));
          }
          if (email != null) {
              predicate = cb.and(predicate, cb.equal(user.get("email"), email));
          }
          if (age != null) {
              predicate = cb.and(predicate, cb.equal(user.get("age"), age));
          }

          cq.where(predicate);
          return entityManager.createQuery(cq).getResultList();
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using the Criteria API</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful variable names for <code>CriteriaBuilder</code>, <code>CriteriaQuery</code>, and <code>Root</code> to improve readability.</li>
    <li>Break down complex queries into smaller methods or predicates for better maintainability.</li>
    <li>Use dynamic query building for runtime conditions to avoid hardcoding queries.</li>
    <li>Test your queries thoroughly to ensure they work as expected.</li>
    <li>Combine the Criteria API with JPQL or native queries when necessary.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The Criteria API is a powerful tool for building type-safe and dynamic queries in JPA. By leveraging its programmatic approach, you can create complex queries that adapt to runtime conditions, improving the flexibility and maintainability of your application. Whether you're building simple or complex queries, the Criteria API provides the tools and features needed to interact with your database effectively and efficiently.
  </p>
</div>`
},
{
  title:`Native Queries`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Native Queries in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Native queries allow executing raw SQL queries in JPA. Unlike JPQL, which works with entities, native queries operate directly on database tables, providing more control and flexibility.
  </p>

  <h3 style="color: #16a085;">Why Use Native Queries?</h3>
  <p style="color: #2c3e50;">
    Native queries offer several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Full SQL Support</strong>: Leverage database-specific features.</li>
    <li><strong>Complex Queries</strong>: Useful for advanced joins, stored procedures, and aggregate functions.</li>
    <li><strong>Performance Optimization</strong>: Write optimized SQL for better performance.</li>
  </ul>

  <h3 style="color: #e67e22;">Basic Syntax</h3>
  <p style="color: #2c3e50;">
    Native queries use the <code>@Query</code> annotation with the <code>nativeQuery = true</code> flag in Spring Data JPA.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query(value = "SELECT * FROM users WHERE username = ?1", nativeQuery = true)
  User findByUsername(String username);
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Example Using EntityManager</h3>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @PersistenceContext
  private EntityManager entityManager;

  public List<User> getAllUsers() {
      return entityManager.createNativeQuery("SELECT * FROM users", User.class).getResultList();
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">Handling Parameters</h3>
  <p style="color: #2c3e50;">
    Parameters can be passed using placeholders or named parameters.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query(value = "SELECT * FROM users WHERE age > :age", nativeQuery = true)
  List<User> findUsersOlderThan(@Param("age") int age);
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Native queries in JPA provide powerful capabilities for working with raw SQL while still integrating with the JPA framework. They are useful for performance tuning, executing complex queries, and leveraging database-specific features.
  </p>
</div>`
},
{
  title:`Named Queries`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Named Queries in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Named queries in JPA allow predefining queries with a unique name, improving reusability and maintainability. They can be written using JPQL or Native SQL.
  </p>

  <h3 style="color: #16a085;">Why Use Named Queries?</h3>
  <p style="color: #2c3e50;">
    Named queries provide several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Code Reusability</strong>: Defined once and used multiple times.</li>
    <li><strong>Improved Performance</strong>: Precompiled queries optimize execution.</li>
    <li><strong>Readability & Maintainability</strong>: Separates queries from business logic.</li>
  </ul>

  <h3 style="color: #e67e22;">Defining Named Queries</h3>
  <p style="color: #2c3e50;">
    Named queries can be defined at the entity level using the <code>@NamedQuery</code> annotation.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @NamedQuery(name = "User.findByUsername", query = "SELECT u FROM User u WHERE u.username = :username")
  public class User {
      @Id
      private Long id;
      private String username;
      private String email;
      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Using Named Queries</h3>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @PersistenceContext
  private EntityManager entityManager;

  public User getUserByUsername(String username) {
      return entityManager.createNamedQuery("User.findByUsername", User.class)
                          .setParameter("username", username)
                          .getSingleResult();
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">Named Native Queries</h3>
  <p style="color: #2c3e50;">
    Native SQL queries can also be defined using <code>@NamedNativeQuery</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @NamedNativeQuery(
      name = "User.findAll",
      query = "SELECT * FROM users",
      resultClass = User.class
  )
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Named queries help in defining reusable and optimized queries, making database interaction more efficient and structured. They improve performance and maintainability while keeping the code clean.
  </p>
</div>
`
},
{
  title:`ORM Caching`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">ORM Caching</h2>
  <p style="font-size: 16px; color: #34495e;">
    ORM caching improves application performance by reducing the number of database queries. It stores frequently accessed data in memory, minimizing redundant database interactions.
  </p>

  <h3 style="color: #16a085;">Why Use ORM Caching?</h3>
  <p style="color: #2c3e50;">
    Caching provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Performance Boost</strong>: Reduces database queries, improving response time.</li>
    <li><strong>Scalability</strong>: Lowers database load, making the application more scalable.</li>
    <li><strong>Reduced Latency</strong>: Retrieves data faster from memory instead of querying the database.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of ORM Caching</h3>
  <p style="color: #2c3e50;">
    ORM frameworks like Hibernate provide different levels of caching:
  </p>

  <h4 style="color: #2980b9;">1. First-Level Cache</h4>
  <p style="color: #2c3e50;">
    Enabled by default, it stores entity objects within the same session. Once a session is closed, the cache is cleared.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  Session session = sessionFactory.openSession();
  User user1 = session.get(User.class, 1); // Fetched from DB
  User user2 = session.get(User.class, 1); // Retrieved from cache
  </code>
  </pre>

  <h4 style="color: #2980b9;">2. Second-Level Cache</h4>
  <p style="color: #2c3e50;">
    Stores entity data across multiple sessions. Needs to be explicitly enabled using providers like Ehcache, Hazelcast, or Infinispan.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Cacheable
  @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
  public class User {
      @Id
      private Long id;
      private String username;
  }
  </code>
  </pre>

  <h4 style="color: #2980b9;">3. Query Cache</h4>
  <p style="color: #2c3e50;">
    Caches the result of queries to avoid re-executing the same queries multiple times.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  Query query = session.createQuery("FROM User WHERE username = :username");
  query.setParameter("username", "JohnDoe");
  query.setCacheable(true);
  List&lt;User&gt; users = query.list();
  </code>
  </pre>

  <h3 style="color: #d35400;">Enabling Hibernate Caching</h3>
  <p style="color: #2c3e50;">
    To enable caching, configure the <code>hibernate.cfg.xml</code> file:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;property name="hibernate.cache.use_second_level_cache"&gt;true&lt;/property&gt;
  &lt;property name="hibernate.cache.region.factory_class"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt;
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    ORM caching significantly enhances application performance by minimizing database queries. Using first-level, second-level, and query caching effectively helps reduce latency and optimize data retrieval.
  </p>
</div>
`
},
{
  title:`Transaction Management`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Management</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction management ensures data consistency and integrity in applications by grouping multiple database operations into a single unit of work. If any operation in the transaction fails, all changes are rolled back.
  </p>

  <h3 style="color: #16a085;">Why is Transaction Management Important?</h3>
  <p style="color: #2c3e50;">
    Transaction management provides several key benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Atomicity</strong>: Ensures all operations within a transaction are completed successfully or rolled back.</li>
    <li><strong>Consistency</strong>: Keeps the database in a valid state before and after the transaction.</li>
    <li><strong>Isolation</strong>: Prevents transactions from interfering with each other.</li>
    <li><strong>Durability</strong>: Ensures committed transactions persist even in case of system failure.</li>
  </ul>

  <h3 style="color: #e67e22;">Transaction Management in Java</h3>
  <p style="color: #2c3e50;">
    Java provides transaction management using frameworks like Spring and JPA.
  </p>

  <h4 style="color: #2980b9;">1. Programmatic Transaction Management</h4>
  <p style="color: #2c3e50;">
    Explicitly managing transactions using <code>EntityManager</code> or <code>TransactionTemplate</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @PersistenceContext
  private EntityManager entityManager;

  public void performTransaction() {
      EntityTransaction transaction = entityManager.getTransaction();
      try {
          transaction.begin();
          User user = new User();
          user.setUsername("JohnDoe");
          entityManager.persist(user);
          transaction.commit();
      } catch (Exception e) {
          transaction.rollback();
      }
  }
  </code>
  </pre>

  <h4 style="color: #2980b9;">2. Declarative Transaction Management (Spring)</h4>
  <p style="color: #2c3e50;">
    Uses annotations to manage transactions automatically.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Service
  public class UserService {

      @Autowired
      private UserRepository userRepository;

      @Transactional
      public void saveUser(User user) {
          userRepository.save(user);
      }
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">Transaction Propagation Types</h3>
  <p style="color: #2c3e50;">
    Spring provides different propagation types to control transaction behavior:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>REQUIRED</strong>: Uses the existing transaction or creates a new one if none exists.</li>
    <li><strong>REQUIRES_NEW</strong>: Suspends the current transaction and creates a new one.</li>
    <li><strong>NESTED</strong>: Creates a nested transaction within the existing one.</li>
    <li><strong>MANDATORY</strong>: Throws an exception if no active transaction exists.</li>
  </ul>

  <h3 style="color: #2c3e50;">Rollback in Transactions</h3>
  <p style="color: #2c3e50;">
    By default, Spring rolls back transactions only for unchecked exceptions (<code>RuntimeException</code> or <code>Error</code>).
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Transactional(rollbackFor = Exception.class)
  public void updateUser(User user) throws Exception {
      userRepository.save(user);
      if (someCondition) {
          throw new Exception("Rollback triggered");
      }
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Transaction management is essential for maintaining data integrity in applications. Whether using programmatic or declarative approaches, effective handling of transactions ensures reliability and consistency in database operations.
  </p>
</div>
`
},
{
  title:`Query Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Query Optimization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Query optimization is the process of improving the efficiency of database queries to enhance performance and reduce execution time. Optimized queries consume fewer resources and provide faster results, making applications more scalable and responsive.
  </p>

  <h3 style="color: #16a085;">Why is Query Optimization Important?</h3>
  <p style="color: #2c3e50;">
    Optimized queries offer several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Faster Execution</strong>: Reduces the time taken to retrieve data.</li>
    <li><strong>Efficient Resource Usage</strong>: Uses CPU, memory, and disk I/O effectively.</li>
    <li><strong>Scalability</strong>: Supports high loads without degrading performance.</li>
    <li><strong>Cost Reduction</strong>: Lowers database infrastructure costs.</li>
  </ul>

  <h3 style="color: #e67e22;">Techniques for Query Optimization</h3>

  <h4 style="color: #2980b9;">1. Indexing</h4>
  <p style="color: #2c3e50;">
    Indexes speed up queries by allowing the database to find data without scanning the entire table.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  CREATE INDEX idx_user_name ON users (username);
  </code>
  </pre>

  <h4 style="color: #2980b9;">2. Use SELECT Fields Instead of SELECT *</h4>
  <p style="color: #2c3e50;">
    Fetching only the required columns reduces memory usage and execution time.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT id, username FROM users WHERE status = 'active';
  </code>
  </pre>

  <h4 style="color: #2980b9;">3. Avoiding N+1 Query Problem</h4>
  <p style="color: #2c3e50;">
    Fetch related entities efficiently using JOINs or batch fetching instead of multiple separate queries.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT u.name, o.order_date 
  FROM users u 
  JOIN orders o ON u.id = o.user_id;
  </code>
  </pre>

  <h4 style="color: #2980b9;">4. Using WHERE Instead of HAVING</h4>
  <p style="color: #2c3e50;">
    Use the <code>WHERE</code> clause for filtering records before aggregation instead of <code>HAVING</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  -- Inefficient
  SELECT status, COUNT(*) FROM users GROUP BY status HAVING status = 'active';

  -- Optimized
  SELECT status, COUNT(*) FROM users WHERE status = 'active' GROUP BY status;
  </code>
  </pre>

  <h4 style="color: #2980b9;">5. Query Caching</h4>
  <p style="color: #2c3e50;">
    Caching frequently executed queries improves response time and reduces database load.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT SQL_CACHE username FROM users WHERE id = 1;
  </code>
  </pre>

  <h4 style="color: #2980b9;">6. Using LIMIT for Large Datasets</h4>
  <p style="color: #2c3e50;">
    Use <code>LIMIT</code> and <code>OFFSET</code> for paginating large result sets instead of fetching all data at once.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;
  </code>
  </pre>

  <h3 style="color: #d35400;">Optimizing Queries in JPA</h3>
  <p style="color: #2c3e50;">
    In JPA, query optimization can be achieved using native queries, indexing, and batch fetching.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT u FROM User u WHERE u.status = :status")
  List<User> findActiveUsers(@Param("status") String status);
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Query optimization plays a crucial role in improving application performance. Techniques like indexing, reducing data retrieval, avoiding redundant queries, and using caching help in optimizing queries for efficient database interaction.
  </p>
</div>
`
},
{
  title:`Query Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Query Optimization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Query optimization is the process of improving the efficiency of database queries to enhance performance and reduce execution time. Optimized queries consume fewer resources and provide faster results, making applications more scalable and responsive.
  </p>

  <h3 style="color: #16a085;">Why is Query Optimization Important?</h3>
  <p style="color: #2c3e50;">
    Optimized queries offer several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Faster Execution</strong>: Reduces the time taken to retrieve data.</li>
    <li><strong>Efficient Resource Usage</strong>: Uses CPU, memory, and disk I/O effectively.</li>
    <li><strong>Scalability</strong>: Supports high loads without degrading performance.</li>
    <li><strong>Cost Reduction</strong>: Lowers database infrastructure costs.</li>
  </ul>

  <h3 style="color: #e67e22;">Techniques for Query Optimization</h3>

  <h4 style="color: #2980b9;">1. Indexing</h4>
  <p style="color: #2c3e50;">
    Indexes speed up queries by allowing the database to find data without scanning the entire table.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  CREATE INDEX idx_user_name ON users (username);
  </code>
  </pre>

  <h4 style="color: #2980b9;">2. Use SELECT Fields Instead of SELECT *</h4>
  <p style="color: #2c3e50;">
    Fetching only the required columns reduces memory usage and execution time.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT id, username FROM users WHERE status = 'active';
  </code>
  </pre>

  <h4 style="color: #2980b9;">3. Avoiding N+1 Query Problem</h4>
  <p style="color: #2c3e50;">
    Fetch related entities efficiently using JOINs or batch fetching instead of multiple separate queries.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT u.name, o.order_date 
  FROM users u 
  JOIN orders o ON u.id = o.user_id;
  </code>
  </pre>

  <h4 style="color: #2980b9;">4. Using WHERE Instead of HAVING</h4>
  <p style="color: #2c3e50;">
    Use the <code>WHERE</code> clause for filtering records before aggregation instead of <code>HAVING</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  -- Inefficient
  SELECT status, COUNT(*) FROM users GROUP BY status HAVING status = 'active';

  -- Optimized
  SELECT status, COUNT(*) FROM users WHERE status = 'active' GROUP BY status;
  </code>
  </pre>

  <h4 style="color: #2980b9;">5. Query Caching</h4>
  <p style="color: #2c3e50;">
    Caching frequently executed queries improves response time and reduces database load.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT SQL_CACHE username FROM users WHERE id = 1;
  </code>
  </pre>

  <h4 style="color: #2980b9;">6. Using LIMIT for Large Datasets</h4>
  <p style="color: #2c3e50;">
    Use <code>LIMIT</code> and <code>OFFSET</code> for paginating large result sets instead of fetching all data at once.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;
  </code>
  </pre>

  <h3 style="color: #d35400;">Optimizing Queries in JPA</h3>
  <p style="color: #2c3e50;">
    In JPA, query optimization can be achieved using native queries, indexing, and batch fetching.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT u FROM User u WHERE u.status = :status")
  List<User> findActiveUsers(@Param("status") String status);
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Query optimization plays a crucial role in improving application performance. Techniques like indexing, reducing data retrieval, avoiding redundant queries, and using caching help in optimizing queries for efficient database interaction.
  </p>
</div>
`
},
{
  title:`Inheritance Mapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Inheritance Mapping</h2>
  <p style="font-size: 16px; color: #34495e;">
    Inheritance Mapping is a technique in Object-Relational Mapping (ORM) that helps map Java class hierarchies to relational database tables. Since relational databases don’t support inheritance directly, JPA provides multiple strategies to handle inheritance efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use Inheritance Mapping?</h3>
  <p style="color: #2c3e50;">
    Inheritance mapping allows:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Code Reusability</strong>: Common fields can be shared among multiple entity classes.</li>
    <li><strong>Efficient Data Organization</strong>: Helps in structuring related entities in a meaningful way.</li>
    <li><strong>Flexible Storage Options</strong>: Different strategies allow performance optimization based on project needs.</li>
  </ul>

  <h3 style="color: #e67e22;">Inheritance Mapping Strategies</h3>

  <h4 style="color: #2980b9;">1. Single Table Strategy</h4>
  <p style="color: #2c3e50;">
    A single table is used to store all subclass data, with a discriminator column to differentiate between entity types.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
  @DiscriminatorColumn(name = "type", discriminatorType = DiscriminatorType.STRING)
  public class Employee {
      @Id @GeneratedValue
      private Long id;
      private String name;
  }

  @Entity
  @DiscriminatorValue("Manager")
  public class Manager extends Employee {
      private String department;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;">
    <strong>Advantages:</strong> Simple schema, efficient for queries.<br>
    <strong>Disadvantages:</strong> Wasted space due to unused columns in some rows.
  </p>

  <h4 style="color: #2980b9;">2. Table Per Class Strategy</h4>
  <p style="color: #2c3e50;">
    Each subclass has its own table, including inherited fields.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
  public class Employee {
      @Id @GeneratedValue
      private Long id;
      private String name;
  }

  @Entity
  public class Manager extends Employee {
      private String department;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;">
    <strong>Advantages:</strong> No null columns, efficient table structure.<br>
    <strong>Disadvantages:</strong> Queries involving superclass require UNION operations.
  </p>

  <h4 style="color: #2980b9;">3. Joined Table Strategy</h4>
  <p style="color: #2c3e50;">
    The parent class has a separate table, and each subclass has its own table storing additional fields. A foreign key links them.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Inheritance(strategy = InheritanceType.JOINED)
  public class Employee {
      @Id @GeneratedValue
      private Long id;
      private String name;
  }

  @Entity
  public class Manager extends Employee {
      private String department;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;">
    <strong>Advantages:</strong> Normalized structure, avoids redundant data.<br>
    <strong>Disadvantages:</strong> Joins are required for querying complete records.
  </p>

  <h3 style="color: #2c3e50;">Choosing the Right Strategy</h3>
  <p style="color: #2c3e50;">
    The choice of inheritance mapping strategy depends on factors like:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Performance</strong>: Single Table is faster for read-heavy operations.</li>
    <li><strong>Normalization</strong>: Joined Table is better if you prefer a structured schema.</li>
    <li><strong>Flexibility</strong>: Table Per Class avoids null columns but can be inefficient for queries.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Inheritance mapping is an essential part of ORM that helps in structuring object-oriented data effectively in relational databases. Understanding and choosing the right strategy ensures better performance and maintainability of the application.
  </p>
</div>
`
},
{
  title:`Entity Lifecycle`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Lifecycle in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    The Entity Lifecycle in JPA defines the different states an entity goes through while interacting with the persistence context. Understanding these states is essential for efficient database operations and transaction management.
  </p>

  <h3 style="color: #16a085;">Why Understand Entity Lifecycle?</h3>
  <p style="color: #2c3e50;">
    Managing entity lifecycle helps in:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Efficient Persistence</strong>: Reducing unnecessary database interactions.</li>
    <li><strong>Better Performance</strong>: Understanding when an entity is managed or detached improves query efficiency.</li>
    <li><strong>Proper Transaction Handling</strong>: Ensuring entities are persisted, updated, or removed correctly.</li>
  </ul>

  <h3 style="color: #e67e22;">JPA Entity Lifecycle States</h3>
  
  <h4 style="color: #2980b9;">1. Transient (New) State</h4>
  <p style="color: #2c3e50;">
    An entity is in a transient state when it is newly created but not yet associated with a persistence context. It is not stored in the database.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  Employee emp = new Employee(); // Transient state
  emp.setName("John Doe");
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Important:</strong> If the application stops, transient objects are lost.</p>

  <h4 style="color: #2980b9;">2. Managed (Persistent) State</h4>
  <p style="color: #2c3e50;">
    When an entity is associated with the persistence context, it becomes managed, and changes are automatically synchronized with the database.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  EntityManager em = entityManagerFactory.createEntityManager();
  em.getTransaction().begin();
  em.persist(emp); // Now the entity is managed
  em.getTransaction().commit();
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Note:</strong> Managed entities are tracked, so any changes to them will be updated in the database.</p>

  <h4 style="color: #2980b9;">3. Detached State</h4>
  <p style="color: #2c3e50;">
    When an entity is no longer associated with the persistence context, it becomes detached. Changes to a detached entity are not synchronized with the database.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  em.close(); // Persistence context is closed
  emp.setName("Updated Name"); // Change is not reflected in the database
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Reattaching:</strong> Use <code>merge()</code> to bring a detached entity back to the managed state.</p>

  <h4 style="color: #2980b9;">4. Removed State</h4>
  <p style="color: #2c3e50;">
    When an entity is marked for deletion, it enters the removed state. The entity is deleted when the transaction is committed.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  em.getTransaction().begin();
  em.remove(emp); // Entity is now in removed state
  em.getTransaction().commit();
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Important:</strong> After removal, the entity is no longer managed, but it still exists in memory.</p>

  <h3 style="color: #2c3e50;">State Transitions</h3>
  <p style="color: #2c3e50;">
    The following operations trigger state transitions:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>persist()</strong> → Moves an entity from Transient to Managed state.</li>
    <li><strong>merge()</strong> → Moves a Detached entity back to Managed state.</li>
    <li><strong>remove()</strong> → Moves a Managed entity to the Removed state.</li>
    <li><strong>clear(), close(), detach()</strong> → Moves a Managed entity to Detached state.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Understanding the JPA entity lifecycle is essential for effective data management. By leveraging different states, developers can optimize database interactions, improve perf
`
},
{
  title:`Fetching Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Fetching Strategies in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Fetching strategies in JPA determine how related entities are loaded from the database. Choosing the right strategy is essential for performance optimization and preventing unnecessary queries.
  </p>

  <h3 style="color: #16a085;">Why Are Fetching Strategies Important?</h3>
  <p style="color: #2c3e50;">
    Proper use of fetching strategies helps in:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reducing Database Queries</strong>: Avoiding unnecessary database hits.</li>
    <li><strong>Improving Performance</strong>: Fetching only the required data.</li>
    <li><strong>Managing Relationships Efficiently</strong>: Preventing issues like the N+1 problem.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Fetching Strategies</h3>

  <h4 style="color: #2980b9;">1. EAGER Fetching</h4>
  <p style="color: #2c3e50;">
    In EAGER fetching, related entities are fetched immediately along with the main entity, even if they are not needed.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @OneToMany(fetch = FetchType.EAGER)
      private List<Project> projects;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Drawback:</strong> Can lead to unnecessary joins, impacting performance.</p>

  <h4 style="color: #2980b9;">2. LAZY Fetching</h4>
  <p style="color: #2c3e50;">
    In LAZY fetching, related entities are loaded only when accessed, reducing initial load time.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @OneToMany(fetch = FetchType.LAZY)
      private List<Project> projects;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Benefit:</strong> Improves performance by delaying unnecessary loading.</p>

  <h3 style="color: #2c3e50;">Fetching Using JOIN FETCH</h3>
  <p style="color: #2c3e50;">
    The <code>JOIN FETCH</code> keyword in JPQL forces immediate loading of related entities, avoiding multiple queries.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  SELECT e FROM Employee e JOIN FETCH e.projects WHERE e.id = :id
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Use Case:</strong> Helps avoid the N+1 query problem.</p>

  <h3 style="color: #2c3e50;">Batch Fetching</h3>
  <p style="color: #2c3e50;">
    Instead of fetching one entity at a time, batch fetching loads multiple entities in a single query, reducing database calls.
  </p>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Choosing the right fetching strategy is crucial for optimizing performance. LAZY fetching is preferred for large datasets, while JOIN FETCH can be used to optimize related data retrieval.
  </p>
</div>
`
},
{
  title:`ORM with Spring Data`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">ORM with Spring Data</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Data provides an abstraction over ORM frameworks like Hibernate and JPA, simplifying database interactions and reducing boilerplate code. It enables developers to focus on business logic while handling database operations efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Data?</h3>
  <p style="color: #2c3e50;">
    Spring Data offers several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Less Boilerplate Code</strong>: Eliminates the need for writing repetitive queries.</li>
    <li><strong>Built-in CRUD Operations</strong>: Provides pre-defined methods like save(), findById(), and delete().</li>
    <li><strong>Pagination and Sorting</strong>: Supports automatic pagination and sorting.</li>
    <li><strong>Integration with JPA and Hibernate</strong>: Works seamlessly with ORM frameworks.</li>
  </ul>

  <h3 style="color: #e67e22;">Spring Data JPA Setup</h3>
  <p style="color: #2c3e50;">
    To use Spring Data JPA, add the required dependencies in your <code>pom.xml</code> (for Maven).
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.h2database&lt;/groupId&gt;
      &lt;artifactId&gt;h2&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
  &lt;/dependency&gt;
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Creating an Entity</h3>
  <p style="color: #2c3e50;">
    Define an entity class that represents a database table.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;
      private String department;
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">Creating a Spring Data Repository</h3>
  <p style="color: #2c3e50;">
    Spring Data JPA provides an interface to manage database operations without writing queries.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  public interface EmployeeRepository extends JpaRepository<Employee, Long> {
      List&lt;Employee&gt; findByDepartment(String department);
  }
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Benefits:</strong> JpaRepository provides built-in CRUD operations and custom query methods.</p>

  <h3 style="color: #2c3e50;">Using the Repository in a Service</h3>
  <p style="color: #2c3e50;">
    Inject the repository into a service to use database operations.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Service
  public class EmployeeService {
      @Autowired
      private EmployeeRepository repository;

      public List<Employee> getEmployeesByDepartment(String department) {
          return repository.findByDepartment(department);
      }
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Data JPA simplifies database interactions by reducing the need for manual query writing. It provides built-in CRUD methods, supports custom queries, and integrates seamlessly with Hibernate and JPA.
  </p>
</div>
`
},
{
  title:`ORM with Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">ORM with Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot simplifies the integration of ORM frameworks like Hibernate and JPA, enabling seamless database operations with minimal configuration. It eliminates boilerplate code, allowing developers to focus on business logic while handling persistence efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use ORM with Spring Boot?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Auto-Configuration</strong>: Spring Boot configures JPA and Hibernate automatically.</li>
    <li><strong>Less Boilerplate Code</strong>: Eliminates the need for manual session management.</li>
    <li><strong>Database Independence</strong>: Works with multiple databases like MySQL, PostgreSQL, and H2.</li>
    <li><strong>Integrated Transaction Management</strong>: Ensures data consistency.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up ORM in Spring Boot</h3>
  <p style="color: #2c3e50;">
    To enable ORM in Spring Boot, add the required dependencies in your <code>pom.xml</code> (for Maven).
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.h2database&lt;/groupId&gt;
      &lt;artifactId&gt;h2&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
  &lt;/dependency&gt;
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring Database in <code>application.properties</code></h3>
  <p style="color: #2c3e50;">Set up database properties in the <code>src/main/resources/application.properties</code> file.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  spring.datasource.url=jdbc:h2:mem:testdb
  spring.datasource.driverClassName=org.h2.Driver
  spring.datasource.username=sa
  spring.datasource.password=
  spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
  </code>
  </pre>

  <h3 style="color: #d35400;">Creating an Entity</h3>
  <p style="color: #2c3e50;">Define an entity class to represent a database table.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;
      private String department;
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Creating a Repository</h3>
  <p style="color: #2c3e50;">Spring Boot simplifies data access with JPA repositories.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  public interface EmployeeRepository extends JpaRepository<Employee, Long> {
      List&lt;Employee&gt; findByDepartment(String department);
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">Using ORM in a Service</h3>
  <p style="color: #2c3e50;">Inject the repository into a service class to handle business logic.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Service
  public class EmployeeService {
      @Autowired
      private EmployeeRepository repository;

      public List<Employee> getEmployeesByDepartment(String department) {
          return repository.findByDepartment(department);
      }
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Testing ORM with Spring Boot</h3>
  <p style="color: #2c3e50;">Spring Boot provides an in-memory H2 database for quick testing.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @SpringBootTest
  public class EmployeeServiceTest {

      @Autowired
      private EmployeeService employeeService;

      @Test
      public void testGetEmployeesByDepartment() {
          List<Employee> employees = employeeService.getEmployeesByDepartment("HR");
          assertEquals(1, employees.size());
      }
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    ORM with Spring Boot simplifies database operations, automating configuration and reducing boilerplate code. It integrates seamlessly with JPA and Hibernate, making database management efficient and developer-friendly.
  </p>
</div>
`
},
{
  title:`Spring Data JPA`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Data JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Data JPA is a part of the Spring Data project that simplifies database access using JPA (Java Persistence API). It reduces boilerplate code and provides an abstraction layer to work with relational databases efficiently.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Data JPA?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Less Boilerplate Code</strong>: Simplifies repository implementation.</li>
    <li><strong>Auto-Configuration</strong>: Spring Boot auto-configures JPA.</li>
    <li><strong>Powerful Query Methods</strong>: Supports derived queries and custom queries.</li>
    <li><strong>Transaction Management</strong>: Ensures data consistency.</li>
    <li><strong>Integration with Spring Boot</strong>: Works seamlessly with Spring Boot applications.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up Spring Data JPA</h3>
  <p style="color: #2c3e50;">
    To use Spring Data JPA, add the required dependencies in your <code>pom.xml</code> file.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.h2database&lt;/groupId&gt;
      &lt;artifactId&gt;h2&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
  &lt;/dependency&gt;
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring Database in <code>application.properties</code></h3>
  <p style="color: #2c3e50;">Define database properties in the <code>src/main/resources/application.properties</code> file.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  spring.datasource.url=jdbc:h2:mem:testdb
  spring.datasource.driverClassName=org.h2.Driver
  spring.datasource.username=sa
  spring.datasource.password=
  spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
  spring.jpa.hibernate.ddl-auto=update
  </code>
  </pre>

  <h3 style="color: #d35400;">Creating an Entity</h3>
  <p style="color: #2c3e50;">Define an entity class to represent a database table.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;
      private String department;

      // Getters and Setters
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Creating a Repository</h3>
  <p style="color: #2c3e50;">Spring Data JPA provides an interface to perform database operations.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  public interface EmployeeRepository extends JpaRepository<Employee, Long> {
      List&lt;Employee&gt; findByDepartment(String department);
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">Using the Repository in a Service</h3>
  <p style="color: #2c3e50;">Inject the repository into a service class to handle business logic.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Service
  public class EmployeeService {
      @Autowired
      private EmployeeRepository repository;

      public List<Employee> getEmployeesByDepartment(String department) {
          return repository.findByDepartment(department);
      }
  }
  </code>
  </pre>

  <h3 style="color: #e74c3c;">Executing Custom Queries</h3>
  <p style="color: #2c3e50;">Spring Data JPA supports custom JPQL and native SQL queries.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT e FROM Employee e WHERE e.name = ?1")
  Employee findByName(String name);
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Testing Spring Data JPA</h3>
  <p style="color: #2c3e50;">Spring Boot provides an in-memory H2 database for quick testing.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @SpringBootTest
  public class EmployeeServiceTest {

      @Autowired
      private EmployeeService employeeService;

      @Test
      public void testGetEmployeesByDepartment() {
          List<Employee> employees = employeeService.getEmployeesByDepartment("HR");
          assertEquals(1, employees.size());
      }
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Data JPA simplifies database interactions, eliminating the need for complex DAO implementations. It provides powerful query capabilities, automatic transaction management, and seamless integration with Spring Boot, making it the preferred choice for modern Java applications.
  </p>
</div>
`
},
{
  title:`Testing ORM`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing ORM</h2>
  <p style="font-size: 16px; color: #34495e;">
    Object-Relational Mapping (ORM) testing ensures that database interactions function correctly in an application. Testing ORM involves validating entity mappings, CRUD operations, and query execution while ensuring data integrity.
  </p>

  <h3 style="color: #16a085;">Why Test ORM?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Verify Database Interactions</strong>: Ensures correct entity persistence and retrieval.</li>
    <li><strong>Prevent Data Corruption</strong>: Detects incorrect mappings or failed transactions.</li>
    <li><strong>Ensure Performance</strong>: Identifies inefficient queries or caching issues.</li>
    <li><strong>Enhance Reliability</strong>: Improves the stability of database-driven applications.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up ORM Testing</h3>
  <p style="color: #2c3e50;">
    Before testing ORM, configure an in-memory database such as H2 to run tests without affecting the production database.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  spring.datasource.url=jdbc:h2:mem:testdb
  spring.datasource.driverClassName=org.h2.Driver
  spring.datasource.username=sa
  spring.datasource.password=
  spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
  spring.jpa.hibernate.ddl-auto=update
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Writing JPA Entity Tests</h3>
  <p style="color: #2c3e50;">A basic test ensures that entity mappings and database interactions work as expected.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @SpringBootTest
  @RunWith(SpringRunner.class)
  @DataJpaTest
  public class EmployeeRepositoryTest {

      @Autowired
      private TestEntityManager entityManager;

      @Autowired
      private EmployeeRepository employeeRepository;

      @Test
      public void testSaveEmployee() {
          Employee employee = new Employee("John Doe", "IT");
          Employee savedEmployee = entityManager.persistFlushFind(employee);
          assertNotNull(savedEmployee.getId());
          assertEquals("John Doe", savedEmployee.getName());
      }
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">Testing CRUD Operations</h3>
  <p style="color: #2c3e50;">Verifying basic create, read, update, and delete operations ensures database consistency.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Test
  public void testCRUDOperations() {
      // Create
      Employee emp = new Employee("Alice", "HR");
      employeeRepository.save(emp);

      // Read
      Employee fetchedEmp = employeeRepository.findById(emp.getId()).orElse(null);
      assertNotNull(fetchedEmp);
      assertEquals("Alice", fetchedEmp.getName());

      // Update
      fetchedEmp.setDepartment("Finance");
      employeeRepository.save(fetchedEmp);
      assertEquals("Finance", employeeRepository.findById(emp.getId()).get().getDepartment());

      // Delete
      employeeRepository.delete(fetchedEmp);
      assertFalse(employeeRepository.findById(emp.getId()).isPresent());
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Testing Custom Queries</h3>
  <p style="color: #2c3e50;">Custom queries need verification to ensure they fetch the expected results.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Test
  public void testFindByDepartment() {
      Employee emp1 = new Employee("Mark", "Sales");
      Employee emp2 = new Employee("Anna", "Sales");
      employeeRepository.saveAll(List.of(emp1, emp2));

      List<Employee> salesEmployees = employeeRepository.findByDepartment("Sales");
      assertEquals(2, salesEmployees.size());
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">Mocking ORM Tests with Mockito</h3>
  <p style="color: #2c3e50;">When testing services, we can mock ORM interactions to avoid hitting the actual database.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @ExtendWith(MockitoExtension.class)
  public class EmployeeServiceTest {

      @Mock
      private EmployeeRepository employeeRepository;

      @InjectMocks
      private EmployeeService employeeService;

      @Test
      public void testGetEmployeesByDepartment() {
          List<Employee> mockEmployees = List.of(new Employee("John", "IT"));
          when(employeeRepository.findByDepartment("IT")).thenReturn(mockEmployees);

          List<Employee> employees = employeeService.getEmployeesByDepartment("IT");
          assertEquals(1, employees.size());
      }
  }
  </code>
  </pre>

  <h3 style="color: #e74c3c;">Performance Testing ORM Queries</h3>
  <p style="color: #2c3e50;">Measuring execution time ensures queries are optimized.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Test
  public void testQueryPerformance() {
      long startTime = System.nanoTime();
      List<Employee> employees = employeeRepository.findByDepartment("IT");
      long duration = System.nanoTime() - startTime;

      System.out.println("Query Execution Time: " + duration + " ns");
      assertTrue(duration < 1000000); // Ensuring query executes under 1ms
  }
  </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Testing ORM is crucial for ensuring data consistency, performance, and query correctness. By using in-memory databases, CRUD tests, custom query validation, and Mockito for service layer testing, developers can build reliable and efficient database-driven applications.
  </p>
</div>
`
},
{
  title:`Performance Tuning in ORM`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Performance Tuning in ORM</h2>
  <p style="font-size: 16px; color: #34495e;">
    Object-Relational Mapping (ORM) simplifies database interactions, but improper usage can lead to performance bottlenecks. Performance tuning in ORM ensures efficient query execution, optimized memory usage, and faster data retrieval.
  </p>

  <h3 style="color: #16a085;">Why Optimize ORM Performance?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduce Query Execution Time</strong>: Avoids unnecessary database calls.</li>
    <li><strong>Improve Scalability</strong>: Handles large datasets efficiently.</li>
    <li><strong>Minimize Memory Usage</strong>: Prevents excessive data loading.</li>
    <li><strong>Enhance Application Responsiveness</strong>: Optimized ORM results in faster response times.</li>
  </ul>

  <h3 style="color: #e67e22;">1. Optimize Query Fetching Strategies</h3>
  <p style="color: #2c3e50;">Choosing the right fetching strategy prevents unnecessary data loading.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @OneToMany(fetch = FetchType.LAZY, mappedBy = "employee")
      private List&lt;Task&gt; tasks;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Lazy Loading</strong> loads related entities only when accessed, reducing unnecessary joins.</p>

  <h3 style="color: #8e44ad;">2. Use Indexing for Faster Lookups</h3>
  <p style="color: #2c3e50;">Adding indexes improves query performance, especially for search operations.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(indexes = {@Index(name = "idx_employee_name", columnList = "name")})
  public class Employee {
      @Column(name = "name")
      private String name;
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">3. Minimize N+1 Query Problems</h3>
  <p style="color: #2c3e50;">Fetching collections in a loop can cause multiple queries instead of one efficient query.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT e FROM Employee e JOIN FETCH e.tasks WHERE e.id = :id")
  Employee findByIdWithTasks(@Param("id") Long id);
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>JOIN FETCH</strong> ensures related entities are fetched in a single query.</p>

  <h3 style="color: #e74c3c;">4. Use Batching for Bulk Inserts and Updates</h3>
  <p style="color: #2c3e50;">Batch processing reduces the number of database round trips.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Transactional
  public void saveEmployees(List&lt;Employee&gt; employees) {
      entityManager.unwrap(Session.class)
                   .setJdbcBatchSize(20);
      for (int i = 0; i < employees.size(); i++) {
          entityManager.persist(employees.get(i));
          if (i % 20 == 0) {
              entityManager.flush();
              entityManager.clear();
          }
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">5. Enable Second-Level and Query Caching</h3>
  <p style="color: #2c3e50;">Hibernate supports caching mechanisms to reduce repeated queries.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Cacheable
  @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
  public class Employee { ... }
  </code>
  </pre>
  <p style="color: #2c3e50;"><strong>Second-level caching</strong> stores entities to avoid unnecessary database hits.</p>

  <h3 style="color: #d35400;">6. Optimize Pagination with Native Queries</h3>
  <p style="color: #2c3e50;">Using <strong>LIMIT</strong> and <strong>OFFSET</strong> improves pagination efficiency.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query(value = "SELECT * FROM employee ORDER BY name LIMIT :limit OFFSET :offset", nativeQuery = true)
  List&lt;Employee&gt; getEmployeesWithPagination(@Param("limit") int limit, @Param("offset") int offset);
  </code>
  </pre>

  <h3 style="color: #2c3e50;">7. Profile ORM Queries</h3>
  <p style="color: #2c3e50;">Enable query logging to analyze and optimize slow queries.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  spring.jpa.show-sql=true
  spring.jpa.properties.hibernate.format_sql=true
  spring.jpa.properties.hibernate.generate_statistics=true
  </code>
  </pre>

  <h3 style="color: #e67e22;">8. Use DTOs for Lightweight Data Transfer</h3>
  <p style="color: #2c3e50;">Fetching only necessary fields improves performance.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT new com.example.dto.EmployeeDTO(e.name, e.department) FROM Employee e WHERE e.id = :id")
  EmployeeDTO findEmployeeDTOById(@Param("id") Long id);
  </code>
  </pre>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    ORM performance tuning involves optimizing query fetching strategies, reducing database calls, and leveraging caching mechanisms. By implementing lazy loading, indexing, batch processing, and profiling queries, developers can enhance application speed and scalability.
  </p>
</div>
`
},
{
  title:`Entity Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Object-Relational Mapping (ORM), an entity represents a table in the database, and each instance of an entity corresponds to a row in that table. Entities are the foundation of ORM frameworks like Hibernate and JPA.
  </p>

  <h3 style="color: #16a085;">What is an Entity?</h3>
  <p style="color: #2c3e50;">
    An entity is a Java class that is mapped to a database table. It contains attributes representing columns and is typically annotated with <code>@Entity</code>.
  </p>

  <h3 style="color: #e67e22;">1. Defining an Entity</h3>
  <p style="color: #2c3e50;">A basic entity class should have:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>@Entity</strong> annotation to mark it as an entity.</li>
    <li><strong>@Table</strong> (optional) to specify the table name.</li>
    <li><strong>@Id</strong> annotation to mark the primary key.</li>
    <li>Attributes representing database columns.</li>
  </ul>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "employees")
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      @Column(name = "name")
      private String name;

      @Column(name = "department")
      private String department;

      // Getters and Setters
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">2. Primary Key Strategies</h3>
  <p style="color: #2c3e50;">Primary keys uniquely identify each row. Different strategies include:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>IDENTITY</strong>: Auto-increment in the database.</li>
    <li><strong>SEQUENCE</strong>: Uses a database sequence.</li>
    <li><strong>AUTO</strong>: Chooses strategy based on database.</li>
    <li><strong>TABLE</strong>: Uses a table to manage sequences.</li>
  </ul>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "emp_seq")
  @SequenceGenerator(name = "emp_seq", sequenceName = "employee_sequence", allocationSize = 1)
  private Long id;
  </code>
  </pre>

  <h3 style="color: #d35400;">3. Column Mapping</h3>
  <p style="color: #2c3e50;">By default, field names map to column names, but you can customize them.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Column(name = "emp_salary", nullable = false)
  private Double salary;
  </code>
  </pre>

  <h3 style="color: #e74c3c;">4. Relationships in Entities</h3>
  <p style="color: #2c3e50;">Entities can have relationships like One-to-Many, Many-to-One, and Many-to-Many.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL)
  private List&lt;Task&gt; tasks;
  </code>
  </pre>

  <h3 style="color: #16a085;">5. Entity Lifecycle</h3>
  <p style="color: #2c3e50;">Entities go through different states: Transient, Persistent, Detached, and Removed.</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Transient:</strong> New objects not yet persisted.</li>
    <li><strong>Persistent:</strong> Managed by the EntityManager.</li>
    <li><strong>Detached:</strong> No longer managed but still exists.</li>
    <li><strong>Removed:</strong> Marked for deletion.</li>
  </ul>

  <h3 style="color: #d35400;">6. Querying Entities</h3>
  <p style="color: #2c3e50;">Use JPQL or native queries to retrieve entities.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT e FROM Employee e WHERE e.department = :dept")
  List&lt;Employee&gt; findByDepartment(@Param("dept") String department);
  </code>
  </pre>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Entities form the foundation of ORM by mapping Java objects to database tables. By defining attributes, relationships, and primary keys properly, developers can efficiently interact with the database using ORM frameworks.
  </p>
</div>
`
},
{
  title:`Entity Mapping`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Mapping</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity Mapping is the process of defining how Java objects (entities) are mapped to database tables using Object-Relational Mapping (ORM) frameworks like JPA and Hibernate. It involves defining attributes, primary keys, relationships, and table configurations.
  </p>

  <h3 style="color: #16a085;">1. Basic Entity Mapping</h3>
  <p style="color: #2c3e50;">
    Each entity is represented as a Java class annotated with <code>@Entity</code>. The class attributes correspond to table columns.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "employees")
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      @Column(name = "name", nullable = false)
      private String name;

      @Column(name = "salary")
      private Double salary;

      // Getters and Setters
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">2. Primary Key Mapping</h3>
  <p style="color: #2c3e50;">Primary keys uniquely identify rows in a table. They are mapped using the <code>@Id</code> annotation.</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>IDENTITY</strong>: Auto-incremented by the database.</li>
    <li><strong>SEQUENCE</strong>: Uses a sequence generator.</li>
    <li><strong>AUTO</strong>: Chooses the strategy based on the database.</li>
    <li><strong>TABLE</strong>: Uses a table to manage sequences.</li>
  </ul>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "emp_seq")
  @SequenceGenerator(name = "emp_seq", sequenceName = "employee_sequence", allocationSize = 1)
  private Long id;
  </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Column Mapping</h3>
  <p style="color: #2c3e50;">Attributes are mapped to table columns using <code>@Column</code>. Constraints like <code>nullable</code> and <code>unique</code> can be applied.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Column(name = "emp_email", unique = true, nullable = false)
  private String email;
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Relationship Mapping</h3>
  <p style="color: #2c3e50;">Entities can have relationships such as:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>One-to-One:</strong> A single entity is associated with another entity.</li>
    <li><strong>One-to-Many:</strong> One entity is linked to multiple entities.</li>
    <li><strong>Many-to-One:</strong> Many entities link to a single entity.</li>
    <li><strong>Many-to-Many:</strong> Multiple entities link to multiple entities.</li>
  </ul>

  <h4 style="color: #16a085;">One-to-Many Example:</h4>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL)
  private List&lt;Task&gt; tasks;
  </code>
  </pre>

  <h3 style="color: #e74c3c;">5. Embedded and Embeddable Mapping</h3>
  <p style="color: #2c3e50;">To map reusable components, we use <code>@Embeddable</code> and <code>@Embedded</code>.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Embeddable
  public class Address {
      private String city;
      private String state;
  }

  @Entity
  public class Employee {
      @Embedded
      private Address address;
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Inheritance Mapping</h3>
  <p style="color: #2c3e50;">ORM frameworks support different inheritance strategies:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Single Table:</strong> Uses a single table for all subclasses.</li>
    <li><strong>Joined Table:</strong> Each subclass has its own table.</li>
    <li><strong>Table per Class:</strong> Each class has a separate table.</li>
  </ul>

  <h3 style="color: #d35400;">7. Fetching Strategies</h3>
  <p style="color: #2c3e50;">Defines how related entities are loaded:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Lazy Loading:</strong> Loads related entities on demand.</li>
    <li><strong>Eager Loading:</strong> Loads related entities immediately.</li>
  </ul>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @OneToMany(mappedBy = "employee", fetch = FetchType.LAZY)
  private List&lt;Task&gt; tasks;
  </code>
  </pre>

  <h3 style="color: #e67e22;">8. Querying Entities</h3>
  <p style="color: #2c3e50;">Entities can be queried using JPQL, Criteria API, or native SQL.</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT e FROM Employee e WHERE e.department = :dept")
  List&lt;Employee&gt; findByDepartment(@Param("dept") String department);
  </code>
  </pre>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity Mapping is a fundamental concept in ORM, allowing Java objects to seamlessly interact with database tables. Proper mapping techniques, relationship definitions, and fetching strategies ensure efficient and optimized database interactions.
  </p>
</div>
`
},
{
  title:`Primary Key Generation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Primary Key Generation in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Primary key generation is a fundamental aspect of database design and JPA (Java Persistence API) entity mapping. A primary key uniquely identifies each record in a database table, and JPA provides several strategies for generating primary keys automatically. These strategies ensure that each entity instance has a unique identifier, simplifying data management and improving performance. This article explores the different primary key generation strategies available in JPA and how to use them effectively in Spring Boot applications.
  </p>

  <h3 style="color: #16a085;">Why Use Primary Key Generation?</h3>
  <p style="color: #2c3e50;">
    Primary key generation is essential for several reasons:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Uniqueness</strong>: Ensures that each record in a table has a unique identifier.</li>
    <li><strong>Data Integrity</strong>: Prevents duplicate records and maintains consistency.</li>
    <li><strong>Performance</strong>: Optimizes database operations like indexing and searching.</li>
    <li><strong>Simplicity</strong>: Automates the process of assigning unique identifiers, reducing manual effort.</li>
    <li><strong>Scalability</strong>: Supports large datasets by generating unique keys efficiently.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Primary Key Generation</h3>
  <p style="color: #2c3e50;">
    When working with primary key generation in JPA, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>@Id</strong>: Marks a field as the primary key of an entity.</li>
    <li><strong>@GeneratedValue</strong>: Specifies the strategy for generating primary key values.</li>
    <li><strong>Generation Strategies</strong>: Includes <code>AUTO</code>, <code>IDENTITY</code>, <code>SEQUENCE</code>, and <code>TABLE</code>.</li>
    <li><strong>Custom Generators</strong>: Allows you to define custom primary key generation logic.</li>
    <li><strong>Database Compatibility</strong>: Different databases support different primary key generation strategies.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Primary Key Generation in JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to use primary key generation strategies in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity with Primary Key Generation</h4>
  <p style="color: #2c3e50;">
    Use the <code>@Id</code> and <code>@GeneratedValue</code> annotations to define primary key generation.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Use Different Generation Strategies</h4>
  <p style="color: #2c3e50;">
    JPA supports several primary key generation strategies:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      // IDENTITY: Relies on the database to generate the primary key (e.g., auto-increment in MySQL)
      @GeneratedValue(strategy = GenerationType.IDENTITY)

      // SEQUENCE: Uses a database sequence to generate the primary key
      @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
      @SequenceGenerator(name = "user_seq", sequenceName = "user_sequence", allocationSize = 1)

      // TABLE: Uses a database table to simulate a sequence
      @GeneratedValue(strategy = GenerationType.TABLE, generator = "user_table")
      @TableGenerator(name = "user_table", table = "id_generator", pkColumnName = "seq_name", valueColumnName = "seq_value", allocationSize = 1)

      // AUTO: Lets the JPA provider choose the appropriate strategy
      @GeneratedValue(strategy = GenerationType.AUTO)
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Custom Primary Key Generation</h4>
  <p style="color: #2c3e50;">
    Implement a custom primary key generator by extending <code>IdentifierGenerator</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.engine.spi.SharedSessionContractImplementor;
      import org.hibernate.id.IdentifierGenerator;

      import java.io.Serializable;
      import java.util.UUID;

      public class CustomIdGenerator implements IdentifierGenerator {
          @Override
          public Serializable generate(SharedSessionContractImplementor session, Object object) {
              return "USER_" + UUID.randomUUID().toString();
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Use the custom generator in your entity:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.hibernate.annotations.GenericGenerator;

      @Entity
      public class User {
          @Id
          @GeneratedValue(generator = "custom-id")
          @GenericGenerator(name = "custom-id", strategy = "com.example.CustomIdGenerator")
          private String id;

          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Primary Key Generation</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose the appropriate generation strategy based on your database and application requirements.</li>
    <li>Use <code>IDENTITY</code> for databases that support auto-increment columns (e.g., MySQL).</li>
    <li>Use <code>SEQUENCE</code> for databases that support sequences (e.g., PostgreSQL, Oracle).</li>
    <li>Use <code>TABLE</code> for databases that do not support sequences or auto-increment.</li>
    <li>Test your primary key generation strategy to ensure it works as expected in your environment.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Primary key generation is a critical aspect of database design and JPA entity mapping. By leveraging JPA's built-in strategies or implementing custom generators, you can ensure that each entity instance has a unique identifier, improving data integrity and performance. Whether you're working with auto-increment columns, sequences, or custom logic, understanding primary key generation strategies will help you build robust and scalable Spring Boot applications.
  </p>
</div>`
},
{
  title:`Entity Annotations (@Entity, @Table, @Id, @Column)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Annotations (@Entity, @Table, @Id, @Column)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity annotations in Java Persistence API (JPA) help map Java objects to database tables. These annotations define how objects are stored and retrieved from a relational database. The key annotations include <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, and <code>@Column</code>.
  </p>

  <h3 style="color: #16a085;">1. @Entity Annotation</h3>
  <p style="color: #2c3e50;">
    The <code>@Entity</code> annotation marks a class as a persistent entity. It tells the ORM framework that this class should be mapped to a database table.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      private String name;
      private Double salary;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;">
    Without <code>@Entity</code>, the class will not be recognized as a database entity.
  </p>

  <h3 style="color: #e67e22;">2. @Table Annotation</h3>
  <p style="color: #2c3e50;">
    The <code>@Table</code> annotation is used to specify the table name for an entity. If not provided, the table name defaults to the class name.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "employees")
  public class Employee {
      @Id
      private Long id;
      private String name;
      private Double salary;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;">
    The <code>@Table</code> annotation is optional but useful for customizing table names.
  </p>

  <h3 style="color: #8e44ad;">3. @Id Annotation</h3>
  <p style="color: #2c3e50;">
    The <code>@Id</code> annotation marks a field as the primary key of the entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  </code>
  </pre>
  <p style="color: #2c3e50;">
    The primary key is necessary for uniquely identifying records in the database.
  </p>

  <h3 style="color: #d35400;">4. @Column Annotation</h3>
  <p style="color: #2c3e50;">
    The <code>@Column</code> annotation specifies column details for a field. It allows customization such as column name, uniqueness, and nullability.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Column(name = "emp_name", nullable = false, unique = true)
  private String name;
  </code>
  </pre>
  <p style="color: #2c3e50;">
    If <code>@Column</code> is not provided, the field name is used as the column name by default.
  </p>

  <h3 style="color: #16a085;">5. Example: Using All Annotations</h3>
  <p style="color: #2c3e50;">The following example demonstrates how these annotations work together:</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "employees")
  public class Employee {
      
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      @Column(name = "emp_name", nullable = false, unique = true)
      private String name;
      
      @Column(name = "emp_salary")
      private Double salary;

      // Getters and Setters
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">6. Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity annotations like <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, and <code>@Column</code> are essential for mapping Java classes to database tables. Proper use of these annotations ensures effective ORM operations.
  </p>
</div>
`
},
{
  title:`Relationships (OneToOne, OneToMany, ManyToOne, ManyToMany)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Relationships in JPA (OneToOne, OneToMany, ManyToOne, ManyToMany)</h2>
  <p style="font-size: 16px; color: #34495e;">
    In JPA (Java Persistence API), entities can have relationships with each other, just like tables in a relational database. 
    JPA provides annotations to define these relationships efficiently.
  </p>

  <h3 style="color: #16a085;">1. One-to-One (@OneToOne)</h3>
  <p style="color: #2c3e50;">
    A one-to-one relationship means that one entity is associated with exactly one other entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;

      @OneToOne(cascade = CascadeType.ALL)
      @JoinColumn(name = "address_id", referencedColumnName = "id")
      private Address address;
  }

  @Entity
  public class Address {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String street;
      private String city;
  }
  </code>
  </pre>
  <p><strong>Explanation:</strong> Each employee has exactly one address, and the <code>@JoinColumn</code> specifies the foreign key.</p>

  <h3 style="color: #e67e22;">2. One-to-Many (@OneToMany)</h3>
  <p style="color: #2c3e50;">
    A one-to-many relationship means that one entity is related to multiple instances of another entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Department {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;

      @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
      private List<Employee> employees;
  }

  @Entity
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;

      @ManyToOne
      @JoinColumn(name = "department_id")
      private Department department;
  }
  </code>
  </pre>
  <p><strong>Explanation:</strong> A department has many employees, but each employee belongs to only one department.</p>

  <h3 style="color: #8e44ad;">3. Many-to-One (@ManyToOne)</h3>
  <p style="color: #2c3e50;">
    A many-to-one relationship is the inverse of one-to-many, where multiple entities are associated with a single entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;

      @ManyToOne
      @JoinColumn(name = "department_id")
      private Department department;
  }
  </code>
  </pre>
  <p><strong>Explanation:</strong> Many employees belong to one department.</p>

  <h3 style="color: #d35400;">4. Many-to-Many (@ManyToMany)</h3>
  <p style="color: #2c3e50;">
    A many-to-many relationship means that multiple entities are associated with multiple other entities.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Student {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;

      @ManyToMany
      @JoinTable(
          name = "student_course",
          joinColumns = @JoinColumn(name = "student_id"),
          inverseJoinColumns = @JoinColumn(name = "course_id")
      )
      private List<Course> courses;
  }

  @Entity
  public class Course {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String title;

      @ManyToMany(mappedBy = "courses")
      private List<Student> students;
  }
  </code>
  </pre>
  <p><strong>Explanation:</strong> A student can enroll in multiple courses, and a course can have multiple students.</p>

  <h3 style="color: #16a085;">5. Conclusion</h3>
  <p style="color: #2c3e50;">
    JPA relationships allow developers to model real-world entity associations efficiently. 
    Understanding these relationships helps in designing a structured and optimized database model.
  </p>
</div>
`
},
{
  title:`Entity Lifecycle`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Lifecycle in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Java Persistence API (JPA), an entity goes through different lifecycle states as it interacts with the persistence context. Understanding these states is crucial for effective database operations and ORM management.
  </p>

  <h3 style="color: #16a085;">1. Entity Lifecycle States</h3>
  <p style="color: #2c3e50;">
    JPA defines four main lifecycle states for an entity:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong>Transient</strong> - The entity is not yet associated with the database.</li>
    <li><strong>Persistent</strong> - The entity is managed by the persistence context.</li>
    <li><strong>Detached</strong> - The entity is no longer managed but still exists in the database.</li>
    <li><strong>Removed</strong> - The entity is marked for deletion.</li>
  </ul>

  <h3 style="color: #e67e22;">2. Transient State</h3>
  <p style="color: #2c3e50;">
    An entity is in the transient state when it is created using the <code>new</code> keyword but not yet associated with a persistence context.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  Employee emp = new Employee();
  emp.setName("John Doe");
  emp.setSalary(50000);
  // At this point, the entity is transient.
  </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Persistent State</h3>
  <p style="color: #2c3e50;">
    When an entity is managed by an <code>EntityManager</code>, it enters the persistent state.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  EntityManager em = entityManagerFactory.createEntityManager();
  em.getTransaction().begin();
  
  Employee emp = new Employee();
  emp.setName("John Doe");
  emp.setSalary(50000);
  
  em.persist(emp); // Now, the entity is in the persistent state.
  
  em.getTransaction().commit();
  em.close();
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Detached State</h3>
  <p style="color: #2c3e50;">
    When the persistence context is closed or an entity is manually detached, it enters the detached state. Any changes made to a detached entity will not be synchronized with the database unless explicitly merged.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  em.close(); // The persistence context is closed, and emp becomes detached.
  emp.setSalary(60000); // This change will not be persisted.
  </code>
  </pre>

  <h3 style="color: #16a085;">5. Merging a Detached Entity</h3>
  <p style="color: #2c3e50;">
    A detached entity can be re-attached to the persistence context using <code>merge()</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  EntityManager em2 = entityManagerFactory.createEntityManager();
  em2.getTransaction().begin();
  
  Employee managedEmp = em2.merge(emp); // Now the entity is persistent again.
  
  em2.getTransaction().commit();
  em2.close();
  </code>
  </pre>

  <h3 style="color: #e67e22;">6. Removed State</h3>
  <p style="color: #2c3e50;">
    When an entity is deleted using <code>remove()</code>, it enters the removed state and will be deleted from the database once the transaction is committed.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  EntityManager em = entityManagerFactory.createEntityManager();
  em.getTransaction().begin();
  
  Employee emp = em.find(Employee.class, 1L);
  em.remove(emp); // Entity is now in the removed state.
  
  em.getTransaction().commit();
  em.close();
  </code>
  </pre>

  <h3 style="color: #16a085;">7. Entity Lifecycle Callbacks</h3>
  <p style="color: #2c3e50;">
    JPA provides callback annotations to execute methods during the entity lifecycle transitions.
  </p>
  <ul style="color: #2c3e50;">
    <li><code>@PrePersist</code> - Before saving a new entity.</li>
    <li><code>@PostPersist</code> - After saving a new entity.</li>
    <li><code>@PreUpdate</code> - Before updating an entity.</li>
    <li><code>@PostUpdate</code> - After updating an entity.</li>
    <li><code>@PreRemove</code> - Before deleting an entity.</li>
    <li><code>@PostRemove</code> - After deleting an entity.</li>
  </ul>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;
      private Double salary;

      @PrePersist
      public void beforeSave() {
          System.out.println("Before persisting the entity");
      }

      @PostPersist
      public void afterSave() {
          System.out.println("Entity persisted successfully");
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">8. Conclusion</h3>
  <p style="color: #2c3e50;">
    Understanding the entity lifecycle is essential for efficient database management in JPA. Proper handling of transient, persistent, detached, and removed states ensures smooth data operations.
  </p>
</div>
`
},
{
  title:`JPA vs Hibernate Entities`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">JPA vs Hibernate Entities</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Persistence API (JPA) and Hibernate are widely used for object-relational mapping (ORM) in Java applications. 
    While JPA is a specification, Hibernate is an implementation of this specification. Understanding their differences in handling entities is crucial for making the right choice in ORM development.
  </p>

  <h3 style="color: #16a085;">1. What is JPA?</h3>
  <p style="color: #2c3e50;">
    JPA (Java Persistence API) is a specification that defines a set of rules for ORM in Java. It provides a standardized way to manage relational data using Java objects. However, JPA itself does not provide an implementation; it requires a provider such as Hibernate, EclipseLink, or OpenJPA.
  </p>

  <h3 style="color: #e67e22;">2. What is Hibernate?</h3>
  <p style="color: #2c3e50;">
    Hibernate is an ORM framework that provides an actual implementation of JPA. It extends JPA functionality with additional features like caching, lazy loading, and native SQL support.
  </p>

  <h3 style="color: #8e44ad;">3. Entity Definition in JPA</h3>
  <p style="color: #2c3e50;">
    In JPA, entities are defined using annotations that map Java classes to database tables.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.*;

  @Entity
  @Table(name = "employees")
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(name = "name", nullable = false)
      private String name;
  }
  </code>
  </pre>
  <p><strong>Explanation:</strong> The <code>@Entity</code> annotation marks the class as a JPA entity, and <code>@Table</code> specifies the table mapping.</p>

  <h3 style="color: #d35400;">4. Entity Definition in Hibernate</h3>
  <p style="color: #2c3e50;">
    Since Hibernate is a JPA implementation, it supports the same annotations. However, it also provides additional Hibernate-specific annotations.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.*;
  import org.hibernate.annotations.DynamicUpdate;

  @Entity
  @Table(name = "employees")
  @DynamicUpdate
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(name = "name", nullable = false)
      private String name;
  }
  </code>
  </pre>
  <p><strong>Explanation:</strong> The <code>@DynamicUpdate</code> annotation is Hibernate-specific and ensures only modified fields are updated.</p>

  <h3 style="color: #16a085;">5. Key Differences Between JPA and Hibernate Entities</h3>
  <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
    <tr style="background-color: #16a085; color: white;">
      <th style="padding: 10px; border: 1px solid #ddd;">Feature</th>
      <th style="padding: 10px; border: 1px solid #ddd;">JPA</th>
      <th style="padding: 10px; border: 1px solid #ddd;">Hibernate</th>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Type</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Specification</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Implementation</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Support for Query Language</td>
      <td style="padding: 10px; border: 1px solid #ddd;">JPQL (Java Persistence Query Language)</td>
      <td style="padding: 10px; border: 1px solid #ddd;">HQL (Hibernate Query Language) and Native SQL</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Vendor Dependency</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Works with multiple ORM providers</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Tied to Hibernate</td>
    </tr>
    <tr>
      <td style="padding: 10px; border: 1px solid #ddd;">Performance Features</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Standard ORM functionality</td>
      <td style="padding: 10px; border: 1px solid #ddd;">Extra features like caching and batch processing</td>
    </tr>
  </table>

  <h3 style="color: #e67e22;">6. When to Use JPA vs Hibernate?</h3>
  <ul style="color: #2c3e50;">
    <li><strong>Use JPA</strong> if you want a vendor-independent ORM solution that can work with different implementations (e.g., Hibernate, EclipseLink).</li>
    <li><strong>Use Hibernate</strong> if you need advanced ORM features like caching, custom SQL, or better query optimization.</li>
  </ul>

  <h3 style="color: #16a085;">7. Conclusion</h3>
  <p style="color: #2c3e50;">
    JPA provides a standardized approach to ORM, whereas Hibernate extends JPA with additional features. 
    While JPA ensures portability across ORM frameworks, Hibernate is widely used due to its robust performance enhancements.
  </p>
</div>
`
},
{
  title:`Cascade Operations`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cascade Operations in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cascade operations in JPA and Hibernate define how changes in one entity affect related entities. Cascading is primarily used in relationships such as <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, and <code>@ManyToMany</code>. It automates the propagation of operations like persist, merge, remove, detach, and refresh.
  </p>

  <h3 style="color: #16a085;">1. What is Cascade in JPA?</h3>
  <p style="color: #2c3e50;">
    In JPA, cascade operations are defined using the <code>cascade</code> attribute in annotations like <code>@OneToMany</code> and <code>@OneToOne</code>. It allows operations performed on a parent entity to be applied to child entities automatically.
  </p>

  <h3 style="color: #e67e22;">2. Cascade Types in JPA</h3>
  <p style="color: #2c3e50;">
    JPA provides several types of cascade operations:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong><code>CascadeType.PERSIST</code></strong> - When a parent entity is persisted, its associated child entities are also persisted.</li>
    <li><strong><code>CascadeType.MERGE</code></strong> - If a parent entity is merged, all child entities are also merged.</li>
    <li><strong><code>CascadeType.REMOVE</code></strong> - If a parent entity is removed, all related child entities are also deleted.</li>
    <li><strong><code>CascadeType.REFRESH</code></strong> - Refreshes all child entities when the parent is refreshed.</li>
    <li><strong><code>CascadeType.DETACH</code></strong> - When a parent entity is detached from the persistence context, all child entities are detached as well.</li>
    <li><strong><code>CascadeType.ALL</code></strong> - Applies all of the above cascade types.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Example of Cascade in JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of cascading in a <code>@OneToMany</code> relationship:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.*;
  import java.util.List;

  @Entity
  @Table(name = "departments")
  public class Department {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false)
      private String name;

      @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
      private List<Employee> employees;

      // Getters and setters
  }

  @Entity
  @Table(name = "employees")
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false)
      private String name;

      @ManyToOne
      @JoinColumn(name = "department_id")
      private Department department;

      // Getters and setters
  }
  </code>
  </pre>
  <p><strong>Explanation:</strong> When a <code>Department</code> entity is saved, updated, or deleted, the corresponding operations are automatically applied to its related <code>Employee</code> entities.</p>

  <h3 style="color: #d35400;">4. Cascading in Hibernate</h3>
  <p style="color: #2c3e50;">
    Hibernate supports JPA cascade types and also provides additional cascade options via the <code>org.hibernate.annotations.Cascade</code> annotation.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.hibernate.annotations.Cascade;
  import org.hibernate.annotations.CascadeType;
  
  @OneToMany(mappedBy = "department")
  @Cascade(CascadeType.SAVE_UPDATE)
  private List<Employee> employees;
  </code>
  </pre>
  <p><strong>Hibernate-Specific Cascade Types:</strong></p>
  <ul style="color: #2c3e50;">
    <li><strong><code>SAVE_UPDATE</code></strong> - Automatically saves or updates the child entities.</li>
    <li><strong><code>DELETE</code></strong> - Deletes child entities when the parent is deleted.</li>
    <li><strong><code>LOCK</code></strong> - Applies a lock to child entities when the parent entity is locked.</li>
  </ul>

  <h3 style="color: #16a085;">5. Orphan Removal</h3>
  <p style="color: #2c3e50;">
    The <code>orphanRemoval = true</code> option ensures that if an entity is removed from a collection, it is deleted from the database as well.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<Employee> employees;
  </code>
  </pre>

  <h3 style="color: #e67e22;">6. When to Use Cascade?</h3>
  <ul style="color: #2c3e50;">
    <li>Use <code>CascadeType.PERSIST</code> when child entities should be saved automatically with the parent.</li>
    <li>Use <code>CascadeType.REMOVE</code> when deleting a parent entity should also delete its children.</li>
    <li>Use <code>orphanRemoval = true</code> when removing a reference to a child entity should delete it from the database.</li>
    <li>Avoid <code>CascadeType.ALL</code> unless necessary, as it applies all operations without distinction.</li>
  </ul>

  <h3 style="color: #16a085;">7. Conclusion</h3>
  <p style="color: #2c3e50;">
    Cascade operations simplify entity management by propagating persistence actions to related entities. While JPA provides standard cascade types, Hibernate extends them with additional features for more control. Using cascading effectively improves code maintainability and reduces boilerplate code.
  </p>
</div>
`
},
{
  title:`Entity Validation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Validation in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity validation ensures that the data stored in the database follows specific constraints and business rules. JPA and Hibernate support validation using Java Bean Validation (JSR-380) and the <code>javax.validation</code> API, which integrates seamlessly with ORM frameworks.
  </p>

  <h3 style="color: #16a085;">1. What is Entity Validation?</h3>
  <p style="color: #2c3e50;">
    Entity validation is the process of checking whether entity attributes meet certain criteria before persisting them into the database. This can be done using annotations from the <code>javax.validation</code> package.
  </p>

  <h3 style="color: #e67e22;">2. Common Validation Annotations</h3>
  <p style="color: #2c3e50;">
    Java Bean Validation provides several built-in constraints to validate entity attributes:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong><code>@NotNull</code></strong> - Ensures that the field cannot be null.</li>
    <li><strong><code>@Size(min=, max=)</code></strong> - Restricts the length of a string.</li>
    <li><strong><code>@Min</code> / <code>@Max</code></strong> - Defines minimum and maximum values for numeric fields.</li>
    <li><strong><code>@Pattern</code></strong> - Validates a string against a regular expression.</li>
    <li><strong><code>@Email</code></strong> - Ensures the field contains a valid email address.</li>
    <li><strong><code>@Past</code> / <code>@Future</code></strong> - Ensures that a date is in the past or future.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Example of Entity Validation</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates entity validation using annotations:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.*;
  import jakarta.validation.constraints.*;

  @Entity
  @Table(name = "users")
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @NotNull
      @Size(min = 3, max = 50)
      private String name;

      @Email
      @NotNull
      private String email;

      @Min(18)
      @Max(100)
      private int age;

      @Pattern(regexp = "^(\\+\\d{1,3}[- ]?)?\\d{10}$")
      private String phone;

      @Past
      private LocalDate dateOfBirth;

      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Enabling Validation in Spring Boot</h3>
  <p style="color: #2c3e50;">
    In Spring Boot, validation is automatically supported if the <code>spring-boot-starter-validation</code> dependency is included in <code>pom.xml</code>:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
  &lt;/dependency&gt;
  </code>
  </pre>
  <p>
    In Spring Boot controllers, you can use <code>@Valid</code> to trigger validation:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.springframework.web.bind.annotation.*;
  import jakarta.validation.Valid;

  @RestController
  @RequestMapping("/users")
  public class UserController {
      @PostMapping("/create")
      public String createUser(@Valid @RequestBody User user) {
          return "User created successfully!";
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">5. Custom Validation</h3>
  <p style="color: #2c3e50;">
    If built-in constraints are not sufficient, custom validators can be created.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.validation.Constraint;
  import jakarta.validation.Payload;
  import java.lang.annotation.*;

  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = AgeValidator.class)
  public @interface ValidAge {
      String message() default "Invalid age!";
      Class&lt;?&gt;[] groups() default {};
      Class&lt;? extends Payload&gt;[] payload() default {};
  }
  </code>
  </pre>

  <p>
    The corresponding validator class:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.validation.ConstraintValidator;
  import jakarta.validation.ConstraintValidatorContext;

  public class AgeValidator implements ConstraintValidator&lt;ValidAge, Integer&gt; {
      @Override
      public boolean isValid(Integer age, ConstraintValidatorContext context) {
          return age != null && age >= 18 && age <= 100;
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">6. When to Use Entity Validation?</h3>
  <ul style="color: #2c3e50;">
    <li>To enforce database constraints at the application level.</li>
    <li>To prevent invalid data from being saved in the database.</li>
    <li>To simplify input validation in web applications.</li>
  </ul>

  <h3 style="color: #16a085;">7. Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity validation is crucial in ORM-based applications to ensure data integrity. Using JPA and Hibernate validation annotations, along with Spring Boot's built-in support, makes validation simple and efficient.
  </p>
</div>
`
},
{
  title:`Versioning (Optimistic Locking)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Versioning (Optimistic Locking) in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Optimistic Locking is a concurrency control mechanism that prevents conflicts when multiple transactions attempt to update the same entity in a database. JPA and Hibernate implement Optimistic Locking using a versioning mechanism with the <code>@Version</code> annotation.
  </p>

  <h3 style="color: #16a085;">1. What is Optimistic Locking?</h3>
  <p style="color: #2c3e50;">
    Optimistic Locking allows multiple users to read and update data concurrently. Instead of locking records, it detects conflicts when changes are persisted. If another transaction has modified the record, the update fails, and the application must handle the conflict.
  </p>

  <h3 style="color: #e67e22;">2. How Versioning Works</h3>
  <p style="color: #2c3e50;">
    - A special version field is added to an entity.<br>
    - Each update to the entity increments the version value.<br>
    - Before updating, Hibernate checks if the version in the database matches the entity’s version.<br>
    - If there is a mismatch, a <code>OptimisticLockException</code> is thrown, indicating a conflict.
  </p>

  <h3 style="color: #8e44ad;">3. Implementing Optimistic Locking with @Version</h3>
  <p style="color: #2c3e50;">
    The <code>@Version</code> annotation is used to enable versioning in an entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.*;

  @Entity
  @Table(name = "products")
  public class Product {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      private String name;
      private double price;

      @Version
      private int version;

      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Example Scenario</h3>
  <p style="color: #2c3e50;">
    - User A and User B fetch the same Product entity.<br>
    - User A updates the price and commits (version increments).<br>
    - User B tries to update the price but gets an exception because the version has changed.
  </p>

  <h3 style="color: #16a085;">5. Handling OptimisticLockException</h3>
  <p style="color: #2c3e50;">
    If an update fails due to version mismatch, the application should handle the <code>OptimisticLockException</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.OptimisticLockException;
  import org.springframework.transaction.annotation.Transactional;

  @Transactional
  public void updateProductPrice(Long productId, double newPrice) {
      try {
          Product product = entityManager.find(Product.class, productId);
          product.setPrice(newPrice);
          entityManager.merge(product);
      } catch (OptimisticLockException e) {
          System.out.println("Optimistic locking failed! Please try again.");
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">6. Benefits of Optimistic Locking</h3>
  <ul style="color: #2c3e50;">
    <li>Allows high concurrency without blocking reads.</li>
    <li>Detects conflicts only when an update occurs.</li>
    <li>Works well for applications with more reads than writes.</li>
  </ul>

  <h3 style="color: #16a085;">7. Conclusion</h3>
  <p style="color: #2c3e50;">
    Optimistic Locking with <code>@Version</code> is a powerful mechanism to handle concurrency in JPA and Hibernate. It is ideal for high-concurrency applications where conflicts are rare, ensuring data integrity while allowing multiple users to work simultaneously.
  </p>
</div>
`
},
{
  title:`Composite Keys`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Composite Keys in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    A composite key is a primary key that consists of multiple columns instead of a single column. In JPA and Hibernate, composite keys are implemented using <code>@EmbeddedId</code> or <code>@IdClass</code>.
  </p>

  <h3 style="color: #16a085;">1. What is a Composite Key?</h3>
  <p style="color: #2c3e50;">
    - A composite key uniquely identifies a record using multiple columns.<br>
    - It is commonly used in situations where a single column is not enough to ensure uniqueness.<br>
    - Example: A university enrollment system where <code>student_id</code> and <code>course_id</code> together form a primary key.
  </p>

  <h3 style="color: #e67e22;">2. Defining a Composite Key</h3>
  <p style="color: #2c3e50;">
    JPA provides two ways to define a composite key:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong>@EmbeddedId</strong>: Uses an embeddable class to represent the composite key.</li>
    <li><strong>@IdClass</strong>: Uses a separate class to define the composite key.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Using @EmbeddedId</h3>
  <p style="color: #2c3e50;">
    The <code>@EmbeddedId</code> annotation allows embedding a composite key object in an entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.*;
  import java.io.Serializable;
  
  @Embeddable
  public class EnrollmentId implements Serializable {
      private Long studentId;
      private Long courseId;
  
      // Default constructor, getters, setters, equals, and hashCode methods
  }
  </code>
  </pre>

  <p style="color: #2c3e50;">
    Now, we use this composite key in our entity:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Enrollment {
      @EmbeddedId
      private EnrollmentId id;
  
      private String semester;
  
      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Using @IdClass</h3>
  <p style="color: #2c3e50;">
    The <code>@IdClass</code> annotation maps an entity to a composite key using a separate key class.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import java.io.Serializable;

  public class EnrollmentId implements Serializable {
      private Long studentId;
      private Long courseId;

      // Default constructor, getters, setters, equals, and hashCode methods
  }
  </code>
  </pre>

  <p style="color: #2c3e50;">
    Now, we apply this in our entity:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @IdClass(EnrollmentId.class)
  public class Enrollment {
      @Id
      private Long studentId;
  
      @Id
      private Long courseId;
  
      private String semester;
  
      // Getters and setters
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">5. Choosing Between @EmbeddedId and @IdClass</h3>
  <ul style="color: #2c3e50;">
    <li><strong>@EmbeddedId</strong>: Preferred when the composite key is treated as a single unit.</li>
    <li><strong>@IdClass</strong>: Useful when working with legacy databases or when different entities share the same composite key structure.</li>
  </ul>

  <h3 style="color: #16a085;">6. Conclusion</h3>
  <p style="color: #2c3e50;">
    Composite keys ensure uniqueness using multiple columns. Both <code>@EmbeddedId</code> and <code>@IdClass</code> are effective ways to implement them in JPA and Hibernate, depending on the use case.
  </p>
</div>
`
},
{
  title:`Entity Manager`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Manager in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <code>EntityManager</code> is the core interface in JPA that manages the lifecycle of entities. It provides an API to perform database operations such as persisting, finding, updating, and removing entities.
  </p>

  <h3 style="color: #16a085;">1. What is an Entity Manager?</h3>
  <p style="color: #2c3e50;">
    - The <code>EntityManager</code> acts as a bridge between Java objects and the database.<br>
    - It manages entity states: Transient, Managed, Detached, and Removed.<br>
    - It interacts with the persistence context to track entity changes.
  </p>

  <h3 style="color: #e67e22;">2. Obtaining an Entity Manager</h3>
  <p style="color: #2c3e50;">
    The <code>EntityManager</code> can be obtained from an <code>EntityManagerFactory</code> in Java applications.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import jakarta.persistence.*;

  public class EntityManagerExample {
      public static void main(String[] args) {
          EntityManagerFactory emf = Persistence.createEntityManagerFactory("myPersistenceUnit");
          EntityManager em = emf.createEntityManager();

          em.getTransaction().begin();

          // Perform database operations here

          em.getTransaction().commit();
          em.close();
          emf.close();
      }
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Important Entity Manager Methods</h3>
  <p style="color: #2c3e50;">
    The <code>EntityManager</code> provides several key methods:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong>persist(entity)</strong>: Saves a new entity to the database.</li>
    <li><strong>find(entityClass, primaryKey)</strong>: Retrieves an entity by its ID.</li>
    <li><strong>merge(entity)</strong>: Updates an entity and returns a managed instance.</li>
    <li><strong>remove(entity)</strong>: Deletes an entity from the database.</li>
    <li><strong>createQuery(query)</strong>: Executes JPQL queries.</li>
  </ul>

  <h3 style="color: #d35400;">4. Entity States and Persistence Context</h3>
  <p style="color: #2c3e50;">
    Entities managed by <code>EntityManager</code> go through different states:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong>Transient</strong>: Not yet persisted.</li>
    <li><strong>Managed</strong>: Tracked by the <code>EntityManager</code>.</li>
    <li><strong>Detached</strong>: No longer tracked.</li>
    <li><strong>Removed</strong>: Marked for deletion.</li>
  </ul>

  <h3 style="color: #e67e22;">5. Example of Entity Operations</h3>
  <p style="color: #2c3e50;">
    Below is an example demonstrating entity management:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Student {
      @Id
      @GeneratedValue
      private Long id;
      private String name;
  
      // Getters and setters
  }

  // Using EntityManager
  em.getTransaction().begin();

  Student student = new Student();
  student.setName("John Doe");

  em.persist(student); // Save entity
  Student foundStudent = em.find(Student.class, student.getId()); // Retrieve entity
  foundStudent.setName("Updated Name");
  em.merge(foundStudent); // Update entity
  em.remove(foundStudent); // Delete entity

  em.getTransaction().commit();
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>EntityManager</code> is essential for handling database operations in JPA. It ensures entity lifecycle management, transaction control, and efficient database interactions.
  </p>
</div>
`
},
{
  title:`Entity Auditing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Auditing in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity Auditing is the process of tracking changes to database records. It helps maintain historical records of entity modifications such as insertions, updates, and deletions. JPA and Hibernate provide built-in support for auditing using various strategies.
  </p>

  <h3 style="color: #16a085;">1. Why Entity Auditing?</h3>
  <p style="color: #2c3e50;">
    - Helps track changes made to records.<br>
    - Maintains a history of updates for compliance and debugging.<br>
    - Enables rollback or recovery of data.<br>
    - Improves accountability in applications.
  </p>

  <h3 style="color: #e67e22;">2. Approaches to Entity Auditing</h3>
  <p style="color: #2c3e50;">
    There are multiple ways to implement entity auditing in JPA and Hibernate:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong>Manual Auditing</strong>: Using timestamps and user tracking fields.</li>
    <li><strong>JPA Lifecycle Callbacks</strong>: Using <code>@PrePersist</code> and <code>@PreUpdate</code> annotations.</li>
    <li><strong>Hibernate Envers</strong>: A dedicated auditing framework.</li>
    <li><strong>Spring Data JPA Auditing</strong>: A Spring Boot-based approach.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Manual Auditing Using Timestamp Fields</h3>
  <p style="color: #2c3e50;">
    A simple way to track entity modifications is by adding timestamp columns:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class User {
      @Id
      @GeneratedValue
      private Long id;
      private String name;

      @Column(nullable = false, updatable = false)
      private LocalDateTime createdAt;

      @Column(nullable = false)
      private LocalDateTime updatedAt;

      @PrePersist
      protected void onCreate() {
          createdAt = updatedAt = LocalDateTime.now();
      }

      @PreUpdate
      protected void onUpdate() {
          updatedAt = LocalDateTime.now();
      }
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Using Hibernate Envers for Auditing</h3>
  <p style="color: #2c3e50;">
    Hibernate Envers provides an automatic way to maintain a history of entity changes.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.hibernate.envers.Audited;

  @Entity
  @Audited
  public class Employee {
      @Id
      @GeneratedValue
      private Long id;
      private String name;
      private String department;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;">
    Hibernate Envers automatically stores history in a separate audit table.
  </p>

  <h3 style="color: #e67e22;">5. Spring Data JPA Auditing</h3>
  <p style="color: #2c3e50;">
    Spring Data JPA provides annotations to enable auditing automatically.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @EntityListeners(AuditingEntityListener.class)
  public class Order {
      @Id
      @GeneratedValue
      private Long id;

      @CreatedDate
      private LocalDateTime createdDate;

      @LastModifiedDate
      private LocalDateTime lastModifiedDate;
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity auditing is a crucial feature for tracking data modifications in JPA and Hibernate. Whether using manual timestamp fields, lifecycle callbacks, Hibernate Envers, or Spring Data JPA, auditing ensures better data integrity, security, and compliance.
  </p>
</div>
`
},
{
  title:`Entity Performance Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Performance Optimization in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Optimizing entity performance in JPA and Hibernate is essential for ensuring efficient database interactions. Poorly optimized entities can lead to slow queries, memory issues, and unnecessary database load. By following best practices, we can significantly enhance application performance.
  </p>

  <h3 style="color: #16a085;">1. Key Challenges in Entity Performance</h3>
  <p style="color: #2c3e50;">
    - **N+1 Query Problem**: Too many queries due to lazy loading.<br>
    - **Unoptimized Fetch Strategies**: Inefficient fetching of related entities.<br>
    - **Excessive Data Loading**: Fetching unnecessary columns or records.<br>
    - **Inefficient Caching**: Overloading the database with redundant queries.<br>
    - **Poor Indexing**: Missing indexes on frequently searched columns.
  </p>

  <h3 style="color: #e67e22;">2. Strategies for Optimizing Entity Performance</h3>
  <p style="color: #2c3e50;">
    The following techniques can help improve performance:
  </p>
  <ul style="color: #2c3e50;">
    <li><strong>Use Fetch Strategies Wisely</strong>: Choose between lazy and eager loading carefully.</li>
    <li><strong>Batch Processing</strong>: Minimize the number of queries for bulk operations.</li>
    <li><strong>Second-Level Cache</strong>: Reduce database load using caching.</li>
    <li><strong>Indexing</strong>: Improve query performance by indexing relevant columns.</li>
    <li><strong>Projection Queries</strong>: Fetch only necessary fields instead of entire entities.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Avoiding the N+1 Query Problem</h3>
  <p style="color: #2c3e50;">
    The N+1 problem occurs when a query loads an entity and then fetches related entities in multiple separate queries.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
  private List<OrderItem> items;
  </code>
  </pre>
  <p style="color: #2c3e50;">
    Solution: Use <code>JOIN FETCH</code> to load related entities efficiently.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Query("SELECT o FROM Order o JOIN FETCH o.items WHERE o.id = :id")
  Order findOrderWithItems(@Param("id") Long id);
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Using Second-Level Caching</h3>
  <p style="color: #2c3e50;">
    Hibernate’s second-level cache helps reduce redundant queries.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Cacheable
  @Entity
  public class Product {
      @Id
      @GeneratedValue
      private Long id;
      private String name;
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">5. Using Indexed Columns</h3>
  <p style="color: #2c3e50;">
    Indexing frequently searched fields improves query performance.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(indexes = @Index(name = "idx_name", columnList = "name"))
  public class Employee {
      @Id
      @GeneratedValue
      private Long id;
      private String name;
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Conclusion</h3>
  <p style="color: #2c3e50;">
    Optimizing entity performance in JPA and Hibernate is crucial for efficient applications. By using proper fetch strategies, caching, indexing, and projection queries, we can significantly enhance database performance and reduce unnecessary overhead.
  </p>
</div>
`
},
{
  title:`Entity Listeners`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Introduction to Entity Listeners in JPA</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entity Listeners in JPA (Java Persistence API) are a powerful feature that allows you to define callback methods for lifecycle events of an entity. These events include actions like persisting, updating, removing, and loading entities. By using entity listeners, you can decouple business logic from entity classes and centralize common functionality, such as auditing, logging, or validation. This article explores how to implement and use entity listeners in a Spring Boot application.
  </p>

  <h3 style="color: #16a085;">Why Use Entity Listeners?</h3>
  <p style="color: #2c3e50;">
    Entity listeners offer several benefits for managing entity lifecycle events:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Separation of Concerns</strong>: Keeps business logic separate from entity classes.</li>
    <li><strong>Reusability</strong>: Allows you to reuse listener logic across multiple entities.</li>
    <li><strong>Centralized Logic</strong>: Provides a single place to handle common tasks like auditing or logging.</li>
    <li><strong>Flexibility</strong>: Supports custom logic for different lifecycle events.</li>
    <li><strong>Integration</strong>: Works seamlessly with JPA and Spring Data.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Concepts of Entity Listeners</h3>
  <p style="color: #2c3e50;">
    When working with entity listeners, it is important to understand the following concepts:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Callback Methods</strong>: Methods annotated with <code>@PrePersist</code>, <code>@PostPersist</code>, <code>@PreUpdate</code>, <code>@PostUpdate</code>, <code>@PreRemove</code>, <code>@PostRemove</code>, and <code>@PostLoad</code>.</li>
    <li><strong>Entity Listener Class</strong>: A class annotated with <code>@EntityListeners</code> that contains callback methods.</li>
    <li><strong>Lifecycle Events</strong>: Events triggered during the lifecycle of an entity, such as creation, update, or deletion.</li>
    <li><strong>Multiple Listeners</strong>: You can assign multiple listeners to a single entity.</li>
    <li><strong>Spring Integration</strong>: Use Spring-managed beans as entity listeners for dependency injection.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Using Entity Listeners in JPA</h3>
  <p style="color: #2c3e50;">
    Below is an example of how to implement and use entity listeners in a Spring Boot application.
  </p>

  <h4 style="color: #8e44ad;">1. Define an Entity</h4>
  <p style="color: #2c3e50;">
    Create a JPA entity and associate it with an entity listener.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.EntityListeners;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      @EntityListeners(UserAuditListener.class)
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;
          private String email;

          // Getters and Setters
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Create an Entity Listener</h4>
  <p style="color: #2c3e50;">
    Define an entity listener class with callback methods for lifecycle events.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.PrePersist;
      import jakarta.persistence.PreUpdate;
      import java.time.LocalDateTime;

      public class UserAuditListener {

          @PrePersist
          public void beforePersist(User user) {
              System.out.println("Before persisting user: " + user.getName());
              user.setCreatedAt(LocalDateTime.now());
          }

          @PreUpdate
          public void beforeUpdate(User user) {
              System.out.println("Before updating user: " + user.getName());
              user.setUpdatedAt(LocalDateTime.now());
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">3. Use Spring-Managed Entity Listeners</h4>
  <p style="color: #2c3e50;">
    Use Spring-managed beans as entity listeners to enable dependency injection.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Component;
      import jakarta.persistence.PrePersist;
      import jakarta.persistence.PreUpdate;
      import java.time.LocalDateTime;

      @Component
      public class UserAuditListener {

          @PrePersist
          public void beforePersist(User user) {
              System.out.println("Before persisting user: " + user.getName());
              user.setCreatedAt(LocalDateTime.now());
          }

          @PreUpdate
          public void beforeUpdate(User user) {
              System.out.println("Before updating user: " + user.getName());
              user.setUpdatedAt(LocalDateTime.now());
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Register the Listener with the Entity</h4>
  <p style="color: #2c3e50;">
    Use the <code>@EntityListeners</code> annotation to register the listener with the entity.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import jakarta.persistence.Entity;
      import jakarta.persistence.EntityListeners;
      import jakarta.persistence.GeneratedValue;
      import jakarta.persistence.GenerationType;
      import jakarta.persistence.Id;

      @Entity
      @EntityListeners(UserAuditListener.class)
      public class User {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          private String name;
          private String email;
          private LocalDateTime createdAt;
          private LocalDateTime updatedAt;

          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Entity Listeners</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use entity listeners for cross-cutting concerns like auditing, logging, and validation.</li>
    <li>Keep listener logic simple and focused on a single responsibility.</li>
    <li>Use Spring-managed beans as listeners to enable dependency injection.</li>
    <li>Avoid performing heavy operations in callback methods to minimize performance impact.</li>
    <li>Test your listeners thoroughly to ensure they work as expected.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Entity listeners are a powerful feature in JPA that allow you to handle entity lifecycle events in a clean and reusable way. By decoupling business logic from entity classes, you can centralize common functionality and improve the maintainability of your application. Whether you're implementing auditing, logging, or validation, entity listeners provide the flexibility and control needed to manage entity lifecycle events effectively in Spring Boot applications.
  </p>
</div>`
},
{
  title:`Testing Entities`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing Entities in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Testing entities in JPA and Hibernate ensures that database interactions function correctly and efficiently. Proper testing prevents issues like incorrect mappings, transactional failures, and performance bottlenecks.
  </p>

  <h3 style="color: #16a085;">1. Why Test Entities?</h3>
  <p style="color: #2c3e50;">
    - **Validate Mappings**: Ensure correct database relationships.<br>
    - **Check Constraints**: Test validation rules like <code>@NotNull</code>, <code>@Size</code>, etc.<br>
    - **Verify Transactions**: Ensure commit and rollback operations work as expected.<br>
    - **Optimize Queries**: Validate custom queries for correctness and efficiency.<br>
  </p>

  <h3 style="color: #e67e22;">2. Setting Up an In-Memory Database</h3>
  <p style="color: #2c3e50;">
    For unit testing, we use **H2** or **HSQLDB**, which provides an in-memory database environment.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  spring.datasource.url=jdbc:h2:mem:testdb
  spring.datasource.driverClassName=org.h2.Driver
  spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
  </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Unit Testing with JUnit and Spring Boot</h3>
  <p style="color: #2c3e50;">
    We use **JUnit 5** and **Spring Boot Test** for testing.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @SpringBootTest
  @RunWith(SpringRunner.class)
  @DataJpaTest
  public class EmployeeRepositoryTest {
      
      @Autowired
      private TestEntityManager entityManager;
      
      @Autowired
      private EmployeeRepository employeeRepository;

      @Test
      public void testSaveEmployee() {
          Employee emp = new Employee("John Doe", "Engineering");
          Employee savedEmp = entityManager.persistAndFlush(emp);
          assertNotNull(savedEmp.getId());
      }
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Testing Entity Constraints</h3>
  <p style="color: #2c3e50;">
    We can use **Bean Validation (JSR-303)** and **Hibernate Validator** to test entity constraints.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  public class Employee {
      @Id
      @GeneratedValue
      private Long id;

      @NotNull
      private String name;

      @Size(min = 3, max = 50)
      private String department;
  }
  </code>
  </pre>
  <p style="color: #2c3e50;">
    Testing constraints using **Validator API**:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Test
  public void testInvalidEmployee() {
      Employee emp = new Employee();
      Set<ConstraintViolation<Employee>> violations = validator.validate(emp);
      assertFalse(violations.isEmpty());
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">5. Testing Entity Relationships</h3>
  <p style="color: #2c3e50;">
    If an entity has relationships (OneToMany, ManyToOne), we should test the associations.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Test
  public void testEmployeeWithProjects() {
      Employee emp = new Employee("Alice", "IT");
      Project project = new Project("Project X");
      emp.addProject(project);
      
      entityManager.persistAndFlush(emp);
      assertEquals(1, emp.getProjects().size());
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Conclusion</h3>
  <p style="color: #2c3e50;">
    Properly testing JPA and Hibernate entities ensures correctness, performance, and data integrity. Using **JUnit, H2 Database, and validation APIs**, we can create robust entity tests that prevent runtime failures.
  </p>
</div>
`
},
{
  title:`Entity Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Entity Best Practices in JPA and Hibernate</h2>
  <p style="font-size: 16px; color: #34495e;">
    Entities are the backbone of any ORM-based application. Writing efficient, maintainable, and optimized entity classes ensures better performance, scalability, and readability. Here are some best practices to follow when designing entities in JPA and Hibernate.
  </p>

  <h3 style="color: #16a085;">1. Use Proper Annotations</h3>
  <p style="color: #2c3e50;">
    Always use the correct JPA annotations like <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, and <code>@Column</code> to map entities properly.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "employees")
  public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false, length = 100)
      private String name;

      @Column(nullable = false)
      private String department;
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">2. Define a Meaningful Primary Key</h3>
  <p style="color: #2c3e50;">
    - Use <code>@GeneratedValue</code> with **IDENTITY or SEQUENCE** for auto-generated IDs.<br>
    - Avoid **business keys** (like email or username) as primary keys.<br>
  </p>

  <h3 style="color: #8e44ad;">3. Use Proper Relationships</h3>
  <p style="color: #2c3e50;">
    When dealing with relationships, always choose the correct **fetch type** and avoid unnecessary bidirectional mappings.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
  private List&lt;Project&gt; projects = new ArrayList<>();
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Avoid Eager Fetching</h3>
  <p style="color: #2c3e50;">
    - **Use Lazy Loading** (fetch  FetchType LAZY) for collections.<br>
    - Eager fetching loads all related data immediately, causing performance issues.<br>
  </p>

  <h3 style="color: #e67e22;">5. Use DTOs for Data Transfer</h3>
  <p style="color: #2c3e50;">
    - **Never expose entities directly in APIs**.<br>
    - Use **DTO (Data Transfer Object)** to return data instead of full entities.<br>
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  public class EmployeeDTO {
      private String name;
      private String department;
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Implement Equals and HashCode Correctly</h3>
  <p style="color: #2c3e50;">
    - Use **only the primary key** for equals and hashCode.<br>
    - Avoid using **collections** in these methods.<br>
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Override
  public boolean equals(Object o) {
      if (this == o) return true;
      if (!(o instanceof Employee)) return false;
      Employee employee = (Employee) o;
      return Objects.equals(id, employee.id);
  }

  @Override
  public int hashCode() {
      return Objects.hash(id);
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">7. Use Caching Wisely</h3>
  <p style="color: #2c3e50;">
    - Use **Hibernate Second-Level Cache** to reduce database hits.<br>
    - Mark frequently used entities with **@Cacheable**.<br>
  </p>

  <h3 style="color: #d35400;">8. Avoid Business Logic in Entities</h3>
  <p style="color: #2c3e50;">
    - Entities should represent **data**, not contain business logic.<br>
    - Use **Service Layer** for business operations.<br>
  </p>

  <h3 style="color: #16a085;">9. Optimize Queries</h3>
  <p style="color: #2c3e50;">
    - Use **JPQL or Criteria API** for complex queries.<br>
    - Optimize queries using **indexes and proper joins**.<br>
  </p>

  <h3 style="color: #e67e22;">10. Validate Data with Annotations</h3>
  <p style="color: #2c3e50;">
    - Use **@NotNull, @Size, @Pattern** for entity validation.<br>
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Column(nullable = false)
  @NotNull
  @Size(min = 3, max = 50)
  private String name;
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Following these **best practices** ensures that JPA and Hibernate entities remain efficient, maintainable, and optimized for performance. Proper design leads to a robust and scalable application.
  </p>
</div>
`
},
{
  title:`Validation Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Validation Basics in JPA and Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Data validation is a crucial aspect of any application to ensure data integrity and correctness. In JPA and Spring Boot, validation can be implemented using **Java Bean Validation API (JSR-303/JSR-380)**. Annotations provided by **Jakarta Validation (formerly javax.validation)** help in enforcing constraints on entity fields.
  </p>

  <h3 style="color: #16a085;">1. Adding Validation Dependencies</h3>
  <p style="color: #2c3e50;">
    To use validation in a Spring Boot application, add the **Hibernate Validator** dependency, which is the reference implementation of the Java Bean Validation API.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
  &lt;/dependency&gt;
  </code>
  </pre>

  <h3 style="color: #e67e22;">2. Common Validation Annotations</h3>
  <p style="color: #2c3e50;">
    Here are some frequently used annotations for field validation in JPA entities:
  </p>
  <ul>
    <li><code>@NotNull</code> - Ensures that the field cannot be null.</li>
    <li><code>@Size(min=, max=)</code> - Restricts the length of a string or collection.</li>
    <li><code>@Min(value=)</code> - Sets the minimum numeric value.</li>
    <li><code>@Max(value=)</code> - Sets the maximum numeric value.</li>
    <li><code>@Pattern(regex="")</code> - Ensures the field matches a given regex pattern.</li>
    <li><code>@Email</code> - Validates if the field contains a valid email format.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Applying Validation Annotations</h3>
  <p style="color: #2c3e50;">
    Let's see how validation annotations are used in a JPA entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "users")
  public class User {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @NotNull
      @Size(min = 3, max = 50)
      @Column(nullable = false)
      private String name;

      @Email
      @NotNull
      @Column(unique = true, nullable = false)
      private String email;

      @Min(18)
      @Max(100)
      @Column(nullable = false)
      private int age;
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Validating User Input in REST Controllers</h3>
  <p style="color: #2c3e50;">
    In Spring Boot, you can enforce validation in REST controllers using the <code>@Valid</code> annotation.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @RestController
  @RequestMapping("/users")
  public class UserController {

      @PostMapping
      public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody User user) {
          return ResponseEntity.ok("User is valid and saved successfully");
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">5. Custom Validation</h3>
  <p style="color: #2c3e50;">
    You can create custom validators by implementing **ConstraintValidator**.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = PhoneNumberValidator.class)
  public @interface ValidPhoneNumber {
      String message() default "Invalid phone number";
      Class&lt;?&gt;[] groups() default {};
      Class&lt;? extends Payload&gt;[] payload() default {};
  }

  public class PhoneNumberValidator implements ConstraintValidator&lt;ValidPhoneNumber, String&gt; {
      private static final String PHONE_PATTERN = "\\d{10}";

      @Override
      public boolean isValid(String value, ConstraintValidatorContext context) {
          return value != null && value.matches(PHONE_PATTERN);
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Handling Validation Errors</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides an easy way to handle validation errors using **@ExceptionHandler**.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @RestControllerAdvice
  public class GlobalExceptionHandler {

      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
          Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
          ex.getBindingResult().getFieldErrors().forEach(error -> 
              errors.put(error.getField(), error.getDefaultMessage()));
          return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">7. Validation in Spring Boot Services</h3>
  <p style="color: #2c3e50;">
    You can also validate input data in service methods using <code>@Valid</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Service
  public class UserService {

      public void registerUser(@Valid User user) {
          // Business logic for saving user
      }
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Using validation ensures data integrity and improves security. Spring Boot and JPA provide a powerful validation mechanism with built-in and custom constraints. Implement these techniques to ensure your application processes only valid data.
  </p>
</div>
`
},
{
  title:`Bean Validation (JSR 303/380)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Bean Validation (JSR 303/380) in Java</h2>
  <p style="font-size: 16px; color: #34495e;">
    Bean Validation is a Java specification that provides a standard way to validate objects using annotations. JSR 303 introduced the first version, and JSR 380 (Jakarta Validation) is an improved version with additional features. Spring Boot supports **Hibernate Validator**, the reference implementation of the Bean Validation API, to enforce validation constraints in Java applications.
  </p>

  <h3 style="color: #16a085;">1. Adding Bean Validation Dependencies</h3>
  <p style="color: #2c3e50;">
    If you are using Spring Boot, add the **Hibernate Validator** dependency in your <code>pom.xml</code> file.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
  &lt;/dependency&gt;
  </code>
  </pre>

  <h3 style="color: #e67e22;">2. Common Validation Annotations</h3>
  <p style="color: #2c3e50;">
    The Bean Validation API provides various annotations to enforce constraints on entity fields:
  </p>
  <ul>
    <li><code>@NotNull</code> - Ensures the field cannot be null.</li>
    <li><code>@Size(min=, max=)</code> - Restricts the length of a string or collection.</li>
    <li><code>@Min(value=)</code> - Specifies the minimum numeric value.</li>
    <li><code>@Max(value=)</code> - Specifies the maximum numeric value.</li>
    <li><code>@Pattern(regex="")</code> - Validates the field against a regex pattern.</li>
    <li><code>@Email</code> - Validates an email format.</li>
    <li><code>@Past</code> - Ensures the date is in the past.</li>
    <li><code>@Future</code> - Ensures the date is in the future.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Applying Bean Validation in a JPA Entity</h3>
  <p style="color: #2c3e50;">
    Let's see how to use validation annotations in a JPA entity.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "users")
  public class User {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @NotNull
      @Size(min = 3, max = 50)
      @Column(nullable = false)
      private String name;

      @Email
      @NotNull
      @Column(unique = true, nullable = false)
      private String email;

      @Min(18)
      @Max(100)
      @Column(nullable = false)
      private int age;

      @Pattern(regexp = "\\d{10}")
      @Column(nullable = false)
      private String phoneNumber;
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Validating Data in REST Controllers</h3>
  <p style="color: #2c3e50;">
    In Spring Boot, you can validate request data in REST controllers using the <code>@Valid</code> annotation.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @RestController
  @RequestMapping("/users")
  public class UserController {

      @PostMapping
      public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody User user) {
          return ResponseEntity.ok("User is valid and saved successfully");
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">5. Creating Custom Validation Constraints</h3>
  <p style="color: #2c3e50;">
    You can create custom validators using **ConstraintValidator**.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = PhoneNumberValidator.class)
  public @interface ValidPhoneNumber {
      String message() default "Invalid phone number";
      Class&lt;?&gt;[] groups() default {};
      Class&lt;? extends Payload&gt;[] payload() default {};
  }

  public class PhoneNumberValidator implements ConstraintValidator&lt;ValidPhoneNumber, String&gt; {
      private static final String PHONE_PATTERN = "\\d{10}";

      @Override
      public boolean isValid(String value, ConstraintValidatorContext context) {
          return value != null && value.matches(PHONE_PATTERN);
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Handling Validation Errors</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides a simple way to handle validation errors using **@ExceptionHandler**.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @RestControllerAdvice
  public class GlobalExceptionHandler {

      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
          Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
          ex.getBindingResult().getFieldErrors().forEach(error -> 
              errors.put(error.getField(), error.getDefaultMessage()));
          return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">7. Validation in Spring Boot Services</h3>
  <p style="color: #2c3e50;">
    You can also validate input data in service methods using <code>@Valid</code>.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Service
  public class UserService {

      public void registerUser(@Valid User user) {
          // Business logic for saving user
      }
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Bean Validation (JSR 303/380) provides a robust and flexible way to enforce constraints on Java objects. Using **Hibernate Validator** in Spring Boot applications ensures data integrity and simplifies error handling. By leveraging built-in annotations and custom constraints, you can create high-quality, error-free applications.
  </p>
</div>
` 
},
{
  title:`Validation Annotations (@NotNull, @Size, @Email, etc.)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Validation Annotations in Java (@NotNull, @Size, @Email, etc.)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Bean Validation (JSR 303/380) provides a set of built-in annotations to enforce constraints on Java objects.
    These annotations help validate user input, ensuring data integrity in applications. The **Hibernate Validator**
    is the most commonly used implementation in **Spring Boot and JPA-based applications**.
  </p>

  <h3 style="color: #16a085;">1. Adding Bean Validation Dependency</h3>
  <p style="color: #2c3e50;">
    To use validation annotations in a Spring Boot project, add the following dependency to your <code>pom.xml</code> file:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
  &lt;/dependency&gt;
  </code>
  </pre>

  <h3 style="color: #e67e22;">2. Common Validation Annotations</h3>
  <p style="color: #2c3e50;">
    Java Bean Validation API provides several built-in annotations to enforce validation constraints on entity fields.
  </p>

  <ul>
    <li><code>@NotNull</code> - Ensures that a field cannot be <code>null</code>, but it allows empty values.</li>
    <li><code>@NotEmpty</code> - Ensures that a field cannot be <code>null</code> or empty.</li>
    <li><code>@NotBlank</code> - Ensures that a string is not <code>null</code> and contains at least one non-whitespace character.</li>
    <li><code>@Size(min=, max=)</code> - Restricts the length of a string, array, or collection.</li>
    <li><code>@Min(value=)</code> - Specifies the minimum value for numeric fields.</li>
    <li><code>@Max(value=)</code> - Specifies the maximum value for numeric fields.</li>
    <li><code>@Positive</code> - Ensures the number is strictly greater than zero.</li>
    <li><code>@Negative</code> - Ensures the number is strictly less than zero.</li>
    <li><code>@Email</code> - Ensures a valid email format.</li>
    <li><code>@Pattern(regex="")</code> - Validates a field against a regular expression.</li>
    <li><code>@Past</code> - Ensures the date is in the past.</li>
    <li><code>@Future</code> - Ensures the date is in the future.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Using Validation Annotations in a JPA Entity</h3>
  <p style="color: #2c3e50;">
    Below is an example of a **User** entity with validation constraints:
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Entity
  @Table(name = "users")
  public class User {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @NotBlank(message = "Name is required")
      @Size(min = 3, max = 50, message = "Name must be between 3 and 50 characters")
      @Column(nullable = false)
      private String name;

      @Email(message = "Invalid email format")
      @NotBlank(message = "Email is required")
      @Column(unique = true, nullable = false)
      private String email;

      @Min(value = 18, message = "Age must be at least 18")
      @Max(value = 100, message = "Age must be at most 100")
      @Column(nullable = false)
      private int age;

      @Pattern(regexp = "\\d{10}", message = "Phone number must be 10 digits")
      @Column(nullable = false)
      private String phoneNumber;

      @Past(message = "Date of birth must be in the past")
      private LocalDate dob;
  }
  </code>
  </pre>

  <h3 style="color: #d35400;">4. Validating Input in REST Controllers</h3>
  <p style="color: #2c3e50;">
    In Spring Boot, you can validate request data using the <code>@Valid</code> annotation in **REST controllers**.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @RestController
  @RequestMapping("/users")
  public class UserController {

      @PostMapping
      public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody User user) {
          return ResponseEntity.ok("User is valid and saved successfully");
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">5. Custom Validation with @Constraint</h3>
  <p style="color: #2c3e50;">
    You can create custom validators using **@Constraint** and **ConstraintValidator**.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = PhoneNumberValidator.class)
  public @interface ValidPhoneNumber {
      String message() default "Invalid phone number";
      Class&lt;?&gt;[] groups() default {};
      Class&lt;? extends Payload&gt;[] payload() default {};
  }

  public class PhoneNumberValidator implements ConstraintValidator&lt;ValidPhoneNumber, String&gt; {
      private static final String PHONE_PATTERN = "\\d{10}";

      @Override
      public boolean isValid(String value, ConstraintValidatorContext context) {
          return value != null && value.matches(PHONE_PATTERN);
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">6. Handling Validation Errors</h3>
  <p style="color: #2c3e50;">
    Use <code>@ExceptionHandler</code> to catch validation errors in **Spring Boot**.
  </p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @RestControllerAdvice
  public class GlobalExceptionHandler {

      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
          Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
          ex.getBindingResult().getFieldErrors().forEach(error -> 
              errors.put(error.getField(), error.getDefaultMessage()));
          return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);
      }
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Validation annotations play a crucial role in ensuring data consistency and integrity in Java applications.
    Using built-in **JSR 303/380** annotations and custom validations, developers can enforce strict constraints
    and improve application security. Spring Boot simplifies validation integration with Hibernate Validator.
  </p>
</div>
` 
},
{
  title:`Custom Validation Annotations`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Custom Validation Annotations in Java</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Bean Validation (JSR 303/380) provides built-in annotations like <code>@NotNull</code>, <code>@Size</code>, and <code>@Email</code>.
    However, in real-world applications, we often need **custom validation** rules. Spring Boot and Hibernate Validator allow developers to create 
    **custom validation annotations** to handle complex validation scenarios.
  </p>

  <h3 style="color: #16a085;">1. Why Use Custom Validation Annotations?</h3>
  <p style="color: #2c3e50;">
    Built-in annotations cover common constraints, but when we need:
  </p>
  <ul>
    <li>Domain-specific rules (e.g., password complexity).</li>
    <li>Validation based on multiple fields.</li>
    <li>Custom error messages.</li>
  </ul>

  <h3 style="color: #e67e22;">2. Steps to Create a Custom Validation Annotation</h3>
  <p style="color: #2c3e50;">
    A custom validation annotation requires:
  </p>
  <ul>
    <li>Annotation definition using <code>@Constraint</code>.</li>
    <li>A validator class implementing <code>ConstraintValidator</code>.</li>
    <li>Applying the custom annotation.</li>
  </ul>

  <h3 style="color: #8e44ad;">3. Example: Custom Phone Number Validation</h3>
  <p style="color: #2c3e50;">
    Let’s create a custom annotation to validate **phone numbers** (must be exactly 10 digits).
  </p>

  <h4 style="color: #d35400;">Step 1: Define the Annotation</h4>
  <p>Create a new annotation <code>@ValidPhoneNumber</code>:</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import javax.validation.Constraint;
  import javax.validation.Payload;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;

  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = PhoneNumberValidator.class)
  public @interface ValidPhoneNumber {
      String message() default "Invalid phone number. Must be 10 digits.";
      Class&lt;?&gt;[] groups() default {};
      Class&lt;? extends Payload&gt;[] payload() default {};
  }
  </code>
  </pre>

  <h4 style="color: #d35400;">Step 2: Implement the Validator Class</h4>
  <p>Create <code>PhoneNumberValidator</code> to implement validation logic:</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import javax.validation.ConstraintValidator;
  import javax.validation.ConstraintValidatorContext;

  public class PhoneNumberValidator implements ConstraintValidator&lt;ValidPhoneNumber, String&gt; {
      
      private static final String PHONE_PATTERN = "\\d{10}";

      @Override
      public boolean isValid(String value, ConstraintValidatorContext context) {
          return value != null && value.matches(PHONE_PATTERN);
      }
  }
  </code>
  </pre>

  <h4 style="color: #d35400;">Step 3: Apply Custom Annotation</h4>
  <p>Use the annotation in an entity class:</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import javax.persistence.Entity;
  import javax.persistence.GeneratedValue;
  import javax.persistence.GenerationType;
  import javax.persistence.Id;
  import javax.persistence.Table;
  import javax.validation.constraints.NotBlank;

  @Entity
  @Table(name = "users")
  public class User {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @NotBlank(message = "Name cannot be blank")
      private String name;

      @ValidPhoneNumber
      private String phoneNumber;
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">4. Using Custom Validation in Spring Boot REST API</h3>
  <p>In a Spring Boot controller, we validate the request body using <code>@Valid</code>:</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.springframework.http.ResponseEntity;
  import org.springframework.web.bind.annotation.*;

  import javax.validation.Valid;

  @RestController
  @RequestMapping("/users")
  public class UserController {

      @PostMapping
      public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody User user) {
          return ResponseEntity.ok("User is valid and saved successfully.");
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">5. Handling Validation Errors</h3>
  <p>Use a global exception handler to capture validation failures:</p>
  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.springframework.http.HttpStatus;
  import org.springframework.http.ResponseEntity;
  import org.springframework.web.bind.MethodArgumentNotValidException;
  import org.springframework.web.bind.annotation.ExceptionHandler;
  import org.springframework.web.bind.annotation.RestControllerAdvice;

  import java.util.HashMap;
  import java.util.Map;

  @RestControllerAdvice
  public class GlobalExceptionHandler {

      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
          Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
          ex.getBindingResult().getFieldErrors().forEach(error ->
              errors.put(error.getField(), error.getDefaultMessage()));
          return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);
      }
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">6. Another Example: Custom Password Validation</h3>
  <p>Let’s create a password validator that requires:</p>
  <ul>
    <li>At least 8 characters.</li>
    <li>At least one uppercase letter.</li>
    <li>At least one number.</li>
  </ul>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = PasswordValidator.class)
  public @interface ValidPassword {
      String message() default "Password must be at least 8 characters long, contain one uppercase letter and one number.";
      Class&lt;?&gt;[] groups() default {};
      Class&lt;? extends Payload&gt;[] payload() default {};
  }

  public class PasswordValidator implements ConstraintValidator&lt;ValidPassword, String&gt; {

      private static final String PASSWORD_PATTERN = "^(?=.*[A-Z])(?=.*\\d).{8,}$";

      @Override
      public boolean isValid(String value, ConstraintValidatorContext context) {
          return value != null && value.matches(PASSWORD_PATTERN);
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Custom validation annotations in Java help enforce complex business rules that built-in annotations cannot handle.
    By using **@Constraint** and **ConstraintValidator**, we can create reusable and maintainable validation rules.
    This approach improves data consistency and enhances the overall security of an application.
  </p>
</div>
` 
},
{
  title:`Group Validation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Group Validation in Java</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Java Bean Validation (JSR 303/380), **group validation** allows us to apply different validation rules based on specific scenarios.
    This is useful when an entity has multiple validation requirements depending on the context (e.g., user registration vs. user update).
  </p>

  <h3 style="color: #16a085;">1. Why Use Group Validation?</h3>
  <p style="color: #2c3e50;">
    By default, all validation constraints are applied together. However, in real-world applications, we often need:
  </p>
  <ul>
    <li>Different validation rules for different **operations** (e.g., Create vs. Update).</li>
    <li>Flexible validation execution based on **user role or state**.</li>
    <li>Selective validation of **fields** instead of validating the entire object.</li>
  </ul>

  <h3 style="color: #e67e22;">2. Defining Validation Groups</h3>
  <p style="color: #2c3e50;">
    We first define **marker interfaces** to represent different validation groups.
  </p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  public interface CreateGroup {}
  public interface UpdateGroup {}
  </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Applying Groups to Entity Fields</h3>
  <p style="color: #2c3e50;">
    Next, we specify which constraints should be validated for each group.
  </p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import javax.validation.constraints.*;

  public class User {

      @Null(groups = UpdateGroup.class)  // ID should be null when creating a new user
      @NotNull(groups = UpdateGroup.class) // ID is required when updating a user
      private Long id;

      @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
      private String name;

      @Email(groups = CreateGroup.class)
      @NotBlank(groups = CreateGroup.class)
      private String email;

      @Size(min = 8, groups = CreateGroup.class)
      private String password;
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">4. Using Group Validation in a Spring Boot Controller</h3>
  <p>We specify the validation group in the **@Validated** annotation in our controller.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.springframework.http.ResponseEntity;
  import org.springframework.validation.annotation.Validated;
  import org.springframework.web.bind.annotation.*;

  import javax.validation.Valid;

  @RestController
  @RequestMapping("/users")
  public class UserController {

      @PostMapping
      public ResponseEntity&lt;String&gt; createUser(@Validated(CreateGroup.class) @RequestBody User user) {
          return ResponseEntity.ok("User created successfully.");
      }

      @PutMapping("/{id}")
      public ResponseEntity&lt;String&gt; updateUser(@Validated(UpdateGroup.class) @RequestBody User user) {
          return ResponseEntity.ok("User updated successfully.");
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">5. Validating Groups Programmatically</h3>
  <p>Sometimes, we may need to manually trigger validation in a service layer using **Validator**.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import javax.validation.ConstraintViolation;
  import javax.validation.Validation;
  import javax.validation.Validator;
  import java.util.Set;

  public class UserService {

      private final Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

      public void validateUser(User user, Class&lt;?&gt; group) {
          Set&lt;ConstraintViolation&lt;User&gt;&gt; violations = validator.validate(user, group);
          for (ConstraintViolation&lt;User&gt; violation : violations) {
              System.out.println(violation.getMessage());
          }
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">6. Combining Multiple Groups</h3>
  <p>We can validate multiple groups together by specifying multiple interfaces.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @PostMapping("/validate-multiple")
  public ResponseEntity&lt;String&gt; validateMultiple(@Validated({CreateGroup.class, UpdateGroup.class}) @RequestBody User user) {
      return ResponseEntity.ok("Validated multiple groups successfully.");
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">7. Default Group Validation</h3>
  <p>By default, constraints without an explicit **groups** attribute belong to the **Default group**.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  @NotNull // This belongs to Default group
  private String address;
  </code>
  </pre>

  <h3 style="color: #16a085;">8. Conclusion</h3>
  <p style="color: #2c3e50;">
    Group validation allows us to apply **different validation rules** based on context (e.g., create vs. update).
    By defining **marker interfaces** and applying them selectively, we can achieve more **flexible and maintainable validation logic**.
  </p>
</div>
` 
},
{
  title:`Validation in Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Validation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Validation is an essential part of any application to ensure data integrity and prevent invalid data from being processed.
    In **Spring Boot**, we can use **JSR 303/380 Bean Validation** with **Hibernate Validator** (the default implementation) to handle validation effortlessly.
  </p>

  <h3 style="color: #16a085;">1. Why Use Validation in Spring Boot?</h3>
  <p style="color: #2c3e50;">
    Proper validation ensures:
  </p>
  <ul>
    <li>Data is **accurate, complete, and follows business rules**.</li>
    <li>Reduces **errors and exceptions** during processing.</li>
    <li>Enhances **security** by preventing invalid data inputs.</li>
  </ul>

  <h3 style="color: #e67e22;">2. Adding Validation Dependencies</h3>
  <p>To enable validation in a Spring Boot project, include the following Maven dependency:</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
  &lt;/dependency&gt;
  </code>
  </pre>

  <h3 style="color: #8e44ad;">3. Using Validation Annotations</h3>
  <p>Spring Boot supports standard **JSR 303/380** validation annotations such as:</p>

  <ul>
    <li><code>@NotNull</code> – Field cannot be null.</li>
    <li><code>@NotEmpty</code> – Field cannot be empty.</li>
    <li><code>@NotBlank</code> – Field cannot be blank.</li>
    <li><code>@Size(min=, max=)</code> – Limits field length.</li>
    <li><code>@Email</code> – Ensures a valid email format.</li>
    <li><code>@Pattern</code> – Validates against regex patterns.</li>
  </ul>

  <h3 style="color: #e67e22;">4. Example: Validating a User Entity</h3>
  <p>Let's create a **User** model with validation constraints:</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import javax.validation.constraints.*;

  public class User {

      @NotNull(message = "ID cannot be null")
      private Long id;

      @NotBlank(message = "Name is required")
      @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
      private String name;

      @Email(message = "Invalid email format")
      @NotBlank(message = "Email is required")
      private String email;

      @Size(min = 8, message = "Password must be at least 8 characters long")
      private String password;
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">5. Validating Requests in Spring Boot Controller</h3>
  <p>To enable validation, use the <code>@Valid</code> annotation in the controller method:</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.springframework.http.ResponseEntity;
  import org.springframework.validation.annotation.Validated;
  import org.springframework.web.bind.annotation.*;

  import javax.validation.Valid;

  @RestController
  @RequestMapping("/users")
  public class UserController {

      @PostMapping
      public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody User user) {
          return ResponseEntity.ok("User created successfully!");
      }
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">6. Handling Validation Errors with @ExceptionHandler</h3>
  <p>When validation fails, Spring Boot returns a default error response. We can customize this using <code>@ExceptionHandler</code>.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import org.springframework.http.HttpStatus;
  import org.springframework.http.ResponseEntity;
  import org.springframework.web.bind.MethodArgumentNotValidException;
  import org.springframework.web.bind.annotation.ExceptionHandler;
  import org.springframework.web.bind.annotation.RestControllerAdvice;

  import java.util.HashMap;
  import java.util.Map;

  @RestControllerAdvice
  public class GlobalExceptionHandler {

      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
          Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
          ex.getBindingResult().getFieldErrors().forEach(error -> 
              errors.put(error.getField(), error.getDefaultMessage()));
          return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);
      }
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">7. Group Validation</h3>
  <p>We can use **Group Validation** to apply different validation rules for different use cases.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  public interface CreateGroup {}
  public interface UpdateGroup {}

  public class User {

      @NotNull(groups = UpdateGroup.class)
      private Long id;

      @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
      private String name;

      @Email(groups = CreateGroup.class)
      @NotBlank(groups = CreateGroup.class)
      private String email;
  }
  </code>
  </pre>

  <h3 style="color: #e67e22;">8. Custom Validation Annotation</h3>
  <p>Spring Boot allows us to create **custom validation annotations**.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  import javax.validation.Constraint;
  import javax.validation.Payload;
  import java.lang.annotation.*;

  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = StrongPasswordValidator.class)
  public @interface StrongPassword {
      String message() default "Weak password";
      Class&lt;?&gt;[] groups() default {};
      Class&lt;? extends Payload&gt;[] payload() default {};
  }
  </code>
  </pre>

  <h3 style="color: #8e44ad;">9. Validating DTOs in Spring Boot</h3>
  <p>We can validate **DTOs** instead of validating entity objects directly.</p>

  <pre style="background-color: #ecf0f1; padding: 10px; border-radius: 5px; overflow-x: auto;">
  <code>
  public class UserDTO {

      @NotBlank
      private String name;

      @Email
      private String email;
  }

  @PostMapping("/validate-dto")
  public ResponseEntity&lt;String&gt; validateUserDTO(@Valid @RequestBody UserDTO userDTO) {
      return ResponseEntity.ok("DTO validated successfully.");
  }
  </code>
  </pre>

  <h3 style="color: #16a085;">10. Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides powerful **JSR 303/380 validation** capabilities to enforce data constraints efficiently.
    Using **annotations, exception handling, and custom validators**, we can build **robust and secure** applications.
  </p>
</div>
` 
},
{
  title:`Validator Interface`, content:`<div style="font-family: Arial, sans-serif; padding: 
  20px; line-height: 1.6;"> <h2 style="color: #2c3e50;">Introduction to the Validator Interface in Spring</h2>
   <p style="font-size: 16px; color: #34495e;"> The Validator interface in Spring is a fundamental component used for validating objects in a Spring application. 
   It provides a flexible and reusable way to enforce validation rules on data objects, ensuring that they meet specific criteria before being processed further. 
   This article explores the Validator interface in detail, including its purpose, implementation, and best practices for using it effectively in a Spring application. 
   </p> <h3 style="color: #16a085;">Why Use the Validator Interface?</h3> <p style="color: #2c3e50;"> The Validator interface offers several advantages:
    </p> <ul style="color: #2c3e50; padding-left: 20px;"> <li><strong>Data Integrity</strong>: Ensures that data objects adhere to predefined rules, 
    preventing invalid data from being processed.</li> <li><strong>Reusability</strong>: Validation logic can be reused across different parts of the application.</li> 
    <li><strong>Separation of Concerns</strong>: Keeps validation logic separate from business logic, improving code maintainability.</li> <li><strong>Customizability</strong>: 
    Allows developers to define custom validation rules tailored to specific requirements.</li> <li><strong>Integration with Spring</strong>: Seamlessly integrates with other 
    Spring features like data binding and form handling.</li> </ul> <h3 style="color: #e67e22;">Key Concepts of the Validator Interface</h3> <p style="color: #2c3e50;"> 
    To effectively use the Validator interface, it is important to understand the following concepts: </p> <ul style="color: #2c3e50; padding-left: 20px;"> <li>
    <strong>Validator Interface</strong>: A core interface in Spring that defines two methods: <code>supports()</code> and <code>validate()</code>.</li>
     <li><strong>supports() Method</strong>: Determines whether the validator can validate a given object type.</li> <li><strong>validate() Method</strong>:
      Performs the actual validation and populates errors if any validation rules are violated.</li> <li><strong>Errors Object</strong>: Used to collect and
       report validation errors.</li> <li><strong>ValidationUtils</strong>: A utility class that simplifies common validation tasks.</li> </ul> <h3 style="color:
        #2980b9;">Example: Implementing the Validator Interface</h3> <p style="color: #2c3e50;"> Below is an example of how to implement and use the Validator interface in a Spring application.
         </p> <h4 style="color: #8e44ad;">1. Create a Data Object</h4> <p style="color: #2c3e50;"> Define a simple data object that will be validated. </p> <pre style="background:rgb(1, 16, 20);
          color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;"> <code codeHighlight class="language-java"> public class User 
          { private String name; private int age; // Getters and setters public String getName() { return name; } public void setName(String name) { this.name = name; }
          //  public int getAge() { return age; } public void setAge(int age) { this.age = age; } } </code> </pre> <h4 style="color: #8e44ad;">2. Implement the Validator Interface</h4>
          //  <p style="color: #2c3e50;"> Create a custom validator for the <code>User</code> class. </p> <pre style="background:rgb(1, 16, 20); 
          // color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;"> <code codeHighlight class="language-java">
          //  import org.springframework.validation.Errors; import org.springframework.validation.ValidationUtils; import org.springframework.validation.Validator;
          //  public class UserValidator implements Validator { @Override public boolean supports(Class<?> clazz) { return User.class.equals(clazz); } 
          // @Override public void validate(Object target, Errors errors) { ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", "field.required", 
          // "Name is required."); User user = (User) target; if (user.getAge() < 18) { errors.rejectValue("age", "field.min.value", "Age must be at least 18."); } } } 
          // </code> </pre> <h4 style="color: #8e44ad;">3. Use the Validator in a Spring Controller</h4> <p style="color: #2c3e50;"> Integrate the validator 
          // into a Spring controller to validate incoming data. </p> <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; 
          // overflow-x: auto;"> <code codeHighlight class="language-java"> import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.
          // Controller; import org.springframework.validation.BindingResult; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.
          // RequestBody; @Controller public class UserController { @Autowired private UserValidator userValidator; @PostMapping("/user") 
          // public String createUser(@RequestBody User user, BindingResult result) { userValidator.validate(user, result); if (result.hasErrors()) 
          // { return "validationError"; } // Process the user object return "success"; } } </code> </pre> <h4 style="color: #8e44ad;">4. Handle Validation Errors</h4> 
          // <p style="color: #2c3e50;"> Handle validation errors gracefully in your application. </p> <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px;
          //  border-radius: 5px; font-size: 14px; overflow-x: auto;"> <code codeHighlight class="language-java"> import org.springframework.ui.Model; import org.springframework.
          // validation.FieldError; @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(MethodArgumentNotValidException.class) public String handleValidationErrors
          // (MethodArgumentNotValidException ex, Model model) { BindingResult result = ex.getBindingResult(); for (FieldError error : result.getFieldErrors())
          //  { model.addAttribute(error.getField(), error.getDefaultMessage()); } return "validationError"; } } </code> </pre> <h3 style="color: #d35400;">
          // Best Practices for Using the Validator Interface</h3> <ul style="color: #2c3e50; padding-left: 20px;"> <li>Use meaningful error codes and messages 
          // for better debugging and user feedback.</li> <li>Keep validation logic simple and focused on a single responsibility.</li> <li>Reuse validators 
          // across different parts of the application to avoid duplication.</li> <li>Combine the Validator interface with annotations like <code>@Valid</code> 
          // for comprehensive validation.</li> <li>Test validators thoroughly to ensure they handle all edge cases.</li> </ul> <h3 style="color: #2c3e50;">Conclusion
          // </h3> <p style="color: #2c3e50;"> The Validator interface in Spring is a powerful tool for enforcing data validation rules in a structured and reusable manner. 
          // By implementing custom validators and integrating them into your application, you can ensure data integrity and improve the overall quality of your application.
          //  Whether you're validating user input, API requests, or business objects, the Validator interface provides the flexibility and control needed to handle validation effectively.
  //  By following best practices, you can create robust and maintainable validation logic that scales with your application's needs. </p> </div>` 
},
{
  title:`ConstraintValidator`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding ConstraintValidator in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, the <code>ConstraintValidator</code> interface is used for implementing custom validation logic.
     It allows developers to create custom constraints beyond the built-in validation annotations provided by the Java Bean Validation API (JSR 380).
  </p>

  <h3 style="color: #16a085;">Why Use ConstraintValidator?</h3>
  <p style="color: #2c3e50;">
    The <code>ConstraintValidator</code> interface is useful when built-in validation annotations like <code>@NotNull</code>, 
    <code>@Size</code>, and <code>@Pattern</code> do not meet specific validation requirements.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Custom Validation Logic</strong>: Define specific validation rules tailored to application needs.</li>
    <li><strong>Reusability</strong>: Create reusable annotations with validation logic.</li>
    <li><strong>Separation of Concerns</strong>: Keeps validation logic separate from business logic.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use ConstraintValidator?</h3>
  <p style="color: #2c3e50;">
    To create a custom validator, follow these steps:
  </p>
  <ol style="color: #2c3e50; padding-left: 20px;">
    <li>Create a custom annotation.</li>
    <li>Implement <code>ConstraintValidator</code>.</li>
    <li>Apply the annotation to model fields.</li>
  </ol>

  <h3 style="color: #8e44ad;">Step 1: Define a Custom Annotation</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.Constraint;
      import javax.validation.Payload;
      import java.lang.annotation.ElementType;
      import java.lang.annotation.Retention;
      import java.lang.annotation.RetentionPolicy;
      import java.lang.annotation.Target;
      
      @Target({ElementType.FIELD})
      @Retention(RetentionPolicy.RUNTIME)
      @Constraint(validatedBy = CustomValidator.class)
      public @interface ValidCustomField {
          String message() default "Invalid field value";
          Class<?>[] groups() default {};
          Class<? extends Payload>[] payload() default {};
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 2: Implement ConstraintValidator</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.ConstraintValidator;
      import javax.validation.ConstraintValidatorContext;
      
      public class CustomValidator implements ConstraintValidator<ValidCustomField, String> {
          @Override
          public void initialize(ValidCustomField constraintAnnotation) {
          }
          
          @Override
          public boolean isValid(String value, ConstraintValidatorContext context) {
              return value != null && value.matches("^[A-Za-z0-9]+$"); // Allows only alphanumeric values
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 3: Apply Custom Validation to a Model Class</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.constraints.NotNull;
      
      public class User {
          @NotNull
          @ValidCustomField
          private String username;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using ConstraintValidator</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure custom validators are stateless for thread safety.</li>
    <li>Use meaningful error messages for better user experience.</li>
    <li>Combine multiple validations where necessary.</li>
    <li>Test validators thoroughly to handle edge cases.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <code>ConstraintValidator</code> interface in Spring Boot allows developers to implement custom validation logic efficiently. By following best practices and separating validation logic, applications can ensure data integrity while maintaining clean and maintainable code.
  </p>
</div>` 

},

{
  title:`Message Interpolation`, content:`div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;"> <h2 style="color: #2c3e50;">Understanding Message Interpolation in Spring</h2> <p style="font-size: 16px; color: #34495e;"> Message interpolation is a powerful feature in Spring that allows you to dynamically insert values into messages or templates. It is commonly used in internationalization (i18n) and validation error messages to provide context-specific information. This article explores the concept of message interpolation, its use cases, and how to implement it effectively in a Spring application. </p> <h3 style="color: #16a085;">Why Use Message Interpolation?</h3> <p style="color: #2c3e50;"> Message interpolation offers several benefits: </p> <ul style="color: #2c3e50; padding-left: 20px;"> <li><strong>Dynamic Content</strong>: Enables the insertion of dynamic values into static messages.</li> <li><strong>Internationalization</strong>: Supports localized messages by replacing placeholders with language-specific values.</li> <li><strong>Customizable Error Messages</strong>: Provides detailed and context-aware validation error messages.</li> <li><strong>Code Reusability</strong>: Allows reuse of message templates across the application.</li> <li><strong>Improved User Experience</strong>: Delivers clear and informative messages to users.</li> </ul> <h3 style="color: #e67e22;">Key Concepts of Message Interpolation</h3> <p style="color: #2c3e50;"> To effectively use message interpolation, it is important to understand the following concepts: </p> <ul style="color: #2c3e50; padding-left: 20px;"> <li><strong>Message Source</strong>: A mechanism in Spring to resolve messages from property files or other sources.</li> <li><strong>Placeholders</strong>: Markers in messages that are replaced with actual values during interpolation.</li> <li><strong>Message Format</strong>: The syntax used to define placeholders and their corresponding values.</li> <li><strong>Locale Support</strong>: The ability to resolve messages based on the user's locale for internationalization.</li> <li><strong>Validation Messages</strong>: Custom error messages that use interpolation to include dynamic values.</li> </ul> <h3 style="color: #2980b9;">Example: Implementing Message Interpolation</h3> <p style="color: #2c3e50;"> Below is an example of how to implement message interpolation in a Spring application. </p> <h4 style="color: #8e44ad;">1. Define Message Properties</h4> <p style="color: #2c3e50;"> Create a <code>messages.properties</code> file to store your messages with placeholders. </p> <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;"> <code class="language-properties"> # messages.properties greeting.message=Hello, {0}! Welcome to {1}. validation.error=The field {0} must be at least {1} characters long. </code> </pre> <h4 style="color: #8e44ad;">2. Configure Message Source</h4> <p style="color: #2c3e50;"> Configure the <code>MessageSource</code> bean in your Spring configuration. </p> <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;"> <code class="language-java"> import org.springframework.context.MessageSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.support.ReloadableResourceBundleMessageSource; @Configuration public class AppConfig { @Bean public MessageSource messageSource() { ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasename("classpath:messages"); messageSource.setDefaultEncoding("UTF-8"); return messageSource; } } </code> </pre> <h4 style="color: #8e44ad;">3. Use Message Interpolation in a Service</h4> <p style="color: #2c3e50;"> Use the <code>MessageSource</code> to resolve and interpolate messages in your application. </p> <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;"> <code class="language-java"> import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.MessageSource; import org.springframework.stereotype.Service; import java.util.Locale; @Service public class GreetingService { @Autowired private MessageSource messageSource; public String getGreetingMessage(String name, String appName, Locale locale) { return messageSource.getMessage("greeting.message", new Object[]{name, appName}, locale); } } </code> </pre> <h4 style="color: #8e44ad;">4. Use Message Interpolation in Validation</h4> <p style="color: #2c3e50;"> Customize validation error messages using message interpolation. </p> <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;"> <code class="language-java"> import javax.validation.constraints.Size; public class User { @Size(min = 5, message = "{validation.error}") private String username; // Getters and setters public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } </code> </pre> <h3 style="color: #d35400;">Best Practices for Using Message Interpolation</h3> <ul style="color: #2c3e50; padding-left: 20px;"> <li>Use meaningful placeholder names for better readability and maintainability.</li> <li>Externalize messages into property files for easy localization and updates.</li> <li>Test interpolated messages with different locales to ensure correctness.</li> <li>Avoid hardcoding messages in code; always use the <code>MessageSource</code>.</li> <li>Use consistent message formats across the application.</li> </ul> <h3 style="color: #2c3e50;">Conclusion</h3> <p style="color: #2c3e50;"> Message interpolation is a versatile feature in Spring that enhances the flexibility and usability of messages in your application. By leveraging placeholders and the <code>MessageSource</code>, you can create dynamic, localized, and context-aware messages for various use cases, including validation errors and user notifications. Following best practices ensures that your application remains maintainable, scalable, and user-friendly. </p> </div>`
},
{
  title:`Cross-field Validation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Cross-field Validation in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cross-field validation is a powerful technique in Spring Boot that allows developers to validate multiple fields in a Java class together. It ensures that related fields follow specific rules and constraints, improving data consistency and integrity.
  </p>

  <h3 style="color: #16a085;">Why Use Cross-field Validation?</h3>
  <p style="color: #2c3e50;">
    Cross-field validation is essential when field values are interdependent. Some common scenarios include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Password Confirmation</strong>: Ensuring a 'password' and 'confirm password' field match.</li>
    <li><strong>Date Range Validation</strong>: Checking that a start date is before an end date.</li>
    <li><strong>Logical Field Dependencies</strong>: Ensuring that one field is required only if another field has a specific value.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Cross-field Validation?</h3>
  <p style="color: #2c3e50;">
    To implement cross-field validation, you need to create a custom annotation and a corresponding validator class using the <code>ConstraintValidator</code> interface.
  </p>

  <h3 style="color: #8e44ad;">Step 1: Create a Custom Annotation</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.Constraint;
      import javax.validation.Payload;
      import java.lang.annotation.ElementType;
      import java.lang.annotation.Retention;
      import java.lang.annotation.RetentionPolicy;
      import java.lang.annotation.Target;

      @Target(ElementType.TYPE)
      @Retention(RetentionPolicy.RUNTIME)
      @Constraint(validatedBy = CrossFieldValidator.class)
      public @interface CrossFieldConstraint {
          String message() default "Invalid field values";
          Class<?>[] groups() default {};
          Class<? extends Payload>[] payload() default {};
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 2: Create the Validator Class</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.ConstraintValidator;
      import javax.validation.ConstraintValidatorContext;

      public class CrossFieldValidator implements ConstraintValidator<CrossFieldConstraint, MyDTO> {

          @Override
          public boolean isValid(MyDTO dto, ConstraintValidatorContext context) {
              if (dto.getStartDate() != null && dto.getEndDate() != null) {
                  return dto.getStartDate().isBefore(dto.getEndDate());
              }
              return true;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Step 3: Apply the Annotation to a DTO</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @CrossFieldConstraint
      public class MyDTO {
          private LocalDate startDate;
          private LocalDate endDate;
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Cross-field Validation</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful validation messages for better user feedback.</li>
    <li>Ensure the validator class is stateless to maintain efficiency.</li>
    <li>Combine cross-field validation with other constraints for robust validation.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Cross-field validation is an essential feature in Spring Boot that allows developers to ensure field consistency within a DTO. By implementing custom annotations and validators, you can enforce complex validation rules and maintain data integrity effectively.
  </p>
</div>`
},
{
  title:`Validation with DTOs`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Validation with DTOs in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    DTO (Data Transfer Object) validation is essential in Spring Boot applications to ensure that incoming data meets the required constraints before processing. This helps maintain data integrity and security while reducing errors.
  </p>

  <h3 style="color: #16a085;">Why Use Validation with DTOs?</h3>
  <p style="color: #2c3e50;">
    Validating DTOs helps to:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensure Data Consistency</strong>: Prevents invalid data from propagating through the system.</li>
    <li><strong>Improve Application Security</strong>: Guards against malicious or incorrect inputs.</li>
    <li><strong>Enhance API Usability</strong>: Provides clear error messages to clients.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement DTO Validation?</h3>
  <p style="color: #2c3e50;">
    Spring Boot supports validation through the <code>javax.validation</code> API and Hibernate Validator.
  </p>

  <h3 style="color: #8e44ad;">Step 1: Add Validation Dependencies</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 2: Define a DTO with Validation Annotations</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.constraints.*;

      public class UserDTO {
          @NotNull(message = "Name cannot be null")
          @Size(min = 3, message = "Name must have at least 3 characters")
          private String name;

          @Email(message = "Invalid email format")
          private String email;

          @Min(value = 18, message = "Age must be at least 18")
          private int age;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Step 3: Validate DTOs in Controller</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.validation.annotation.Validated;
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          @PostMapping
          public String createUser(@Valid @RequestBody UserDTO user) {
              return "User created successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Handling Validation Errors</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestControllerAdvice;
      import java.util.HashMap;
      import java.util.Map;

      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ResponseStatus(HttpStatus.BAD_REQUEST)
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map<String, String> errors = new HashMap<>();
              ex.getBindingResult().getFieldErrors().forEach(error -> 
                  errors.put(error.getField(), error.getDefaultMessage()));
              return errors;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for DTO Validation</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use specific validation annotations for better accuracy.</li>
    <li>Provide user-friendly error messages.</li>
    <li>Use exception handling for structured error reporting.</li>
    <li>Keep DTOs lightweight and focused on validation.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Validating DTOs in Spring Boot applications is a powerful way to ensure data correctness and security. By leveraging annotation-based validation and global exception handling, developers can create robust and user-friendly APIs.
  </p>
</div>`
},

{
  title:`Validation in REST APIs`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Validation in REST APIs with Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Validation is a critical aspect of building RESTful APIs in Spring Boot. It ensures that the data sent by clients meets the required format and constraints before processing, improving data integrity and security.
  </p>

  <h3 style="color: #16a085;">Why is Validation Important?</h3>
  <p style="color: #2c3e50;">
    Validation in REST APIs helps to:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensure Data Integrity</strong>: Prevents incorrect or malformed data from being processed.</li>
    <li><strong>Improve API Reliability</strong>: Reduces errors by validating input before executing business logic.</li>
    <li><strong>Enhance Security</strong>: Protects against injection attacks by sanitizing input.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Validation in REST APIs?</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides built-in support for validation using the <code>javax.validation</code> API and Hibernate Validator.
  </p>

  <h3 style="color: #8e44ad;">Step 1: Add Validation Dependencies</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 2: Apply Validation Annotations</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.constraints.*;

      public class UserDTO {
          @NotNull(message = "Name cannot be null")
          @Size(min = 3, message = "Name must have at least 3 characters")
          private String name;

          @Email(message = "Invalid email format")
          private String email;

          @Min(value = 18, message = "Age must be at least 18")
          private int age;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Step 3: Validate Input in Controller</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.validation.annotation.Validated;
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          @PostMapping
          public String createUser(@Valid @RequestBody UserDTO user) {
              return "User created successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Handling Validation Errors</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestControllerAdvice;
      import java.util.HashMap;
      import java.util.Map;

      @RestControllerAdvice
      public class GlobalExceptionHandler {

          @ResponseStatus(HttpStatus.BAD_REQUEST)
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map<String, String> errors = new HashMap<>();
              ex.getBindingResult().getFieldErrors().forEach(error -> 
                  errors.put(error.getField(), error.getDefaultMessage()));
              return errors;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for API Validation</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful validation messages for clear client feedback.</li>
    <li>Handle validation errors gracefully using exception handlers.</li>
    <li>Combine different validation constraints to enforce strict data validation.</li>
    <li>Use global exception handling for better error management.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Validation is a crucial part of building robust REST APIs in Spring Boot. By leveraging annotation-based validation, exception handling, and best practices, 
    developers can ensure data integrity and enhance the API's reliability and security.
  </p>
</div>
`
},

{
  title:`Global Validation (@Valid, @Validated)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Global Validation in Spring Boot (@Valid, @Validated)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Global validation ensures that data across multiple layers in a Spring Boot application meets the required constraints. Using <code>@Valid</code> and <code>@Validated</code>, we can enforce validation at the service level, controller level, and even in nested objects.
  </p>

  <h3 style="color: #16a085;">Why Use Global Validation?</h3>
  <p style="color: #2c3e50;">
    Global validation helps to:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensure Consistency</strong>: Applies uniform validation rules throughout the application.</li>
    <li><strong>Reduce Boilerplate Code</strong>: Centralizes validation logic.</li>
    <li><strong>Improve Code Maintainability</strong>: Easier debugging and updates.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Global Validation?</h3>
  <p style="color: #2c3e50;">
    Spring Boot supports validation via <code>@Valid</code> (from <code>javax.validation</code>) and <code>@Validated</code> (from <code>org.springframework.validation.annotation</code>).
  </p>

  <h3 style="color: #8e44ad;">Step 1: Add Validation Dependencies</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 2: Use @Valid in DTOs</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.constraints.*;

      public class UserDTO {
          @NotNull(message = "Name cannot be null")
          @Size(min = 3, message = "Name must have at least 3 characters")
          private String name;

          @Email(message = "Invalid email format")
          private String email;

          @Min(value = 18, message = "Age must be at least 18")
          private int age;
          
          // Getters and Setters
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Step 3: Apply @Valid in Controller</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          @PostMapping
          public String createUser(@Valid @RequestBody UserDTO user) {
              return "User created successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 4: Use @Validated in Service Layer</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.validation.annotation.Validated;

      @Service
      @Validated
      public class UserService {
          public void processUser(@Valid UserDTO user) {
              // Business logic
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Step 5: Handle Global Validation Errors</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestControllerAdvice;
      import java.util.HashMap;
      import java.util.Map;

      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ResponseStatus(HttpStatus.BAD_REQUEST)
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map<String, String> errors = new HashMap<>();
              ex.getBindingResult().getFieldErrors().forEach(error -> 
                  errors.put(error.getField(), error.getDefaultMessage()));
              return errors;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Global validation using <code>@Valid</code> and <code>@Validated</code> enhances data integrity and consistency in Spring Boot applications. By leveraging annotation-based validation and centralized exception handling, developers can ensure robust and error-free data processing.
  </p>
</div>`
},

{
  title:`Custom Error Messages`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Custom Error Messages in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Custom error messages in Spring Boot improve user experience by providing meaningful validation messages instead of generic errors. By leveraging <code>@Valid</code> and <code>@Validated</code> along with custom messages, developers can ensure clear feedback to users.
  </p>

  <h3 style="color: #16a085;">Why Use Custom Error Messages?</h3>
  <p style="color: #2c3e50;">
    Custom error messages help to:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improve User Experience</strong>: Provide meaningful feedback.</li>
    <li><strong>Ensure Clarity</strong>: Avoid ambiguous or technical messages.</li>
    <li><strong>Enhance Readability</strong>: Simplify debugging and logging.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Custom Error Messages?</h3>
  <p style="color: #2c3e50;">
    Spring Boot allows setting custom validation messages via annotations or message properties.
  </p>

  <h3 style="color: #8e44ad;">Step 1: Define Custom Messages in DTO</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.constraints.*;

      public class UserDTO {
          @NotNull(message = "Please provide a name.")
          @Size(min = 3, message = "Name must be at least 3 characters long.")
          private String name;

          @Email(message = "Please enter a valid email address.")
          private String email;

          @Min(value = 18, message = "Age should be 18 or above.")
          private int age;
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Step 2: Handle Custom Errors in Controller</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          @PostMapping
          public String createUser(@Valid @RequestBody UserDTO user) {
              return "User registered successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 3: Centralized Exception Handling</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestControllerAdvice;
      import java.util.HashMap;
      import java.util.Map;

      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ResponseStatus(HttpStatus.BAD_REQUEST)
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map<String, String> errors = new HashMap<>();
              ex.getBindingResult().getFieldErrors().forEach(error -> 
                  errors.put(error.getField(), error.getDefaultMessage()));
              return errors;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Custom error messages in Spring Boot provide clear, user-friendly validation feedback. By defining specific messages in DTOs and centralizing exception handling, we can ensure a seamless experience for users.
  </p>
</div>`

},

{
  title:`Validation on Method Parameters`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Custom Error Messages in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Custom error messages in Spring Boot improve user experience by providing meaningful validation messages instead of generic errors. By leveraging <code>@Valid</code> and <code>@Validated</code> along with custom messages, developers can ensure clear feedback to users.
  </p>

  <h3 style="color: #16a085;">Why Use Custom Error Messages?</h3>
  <p style="color: #2c3e50;">
    Custom error messages help to:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improve User Experience</strong>: Provide meaningful feedback.</li>
    <li><strong>Ensure Clarity</strong>: Avoid ambiguous or technical messages.</li>
    <li><strong>Enhance Readability</strong>: Simplify debugging and logging.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Custom Error Messages?</h3>
  <p style="color: #2c3e50;">
    Spring Boot allows setting custom validation messages via annotations or message properties.
  </p>

  <h3 style="color: #8e44ad;">Step 1: Define Custom Messages in DTO</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.constraints.*;

      public class UserDTO {
          @NotNull(message = "Please provide a name.")
          @Size(min = 3, message = "Name must be at least 3 characters long.")
          private String name;

          @Email(message = "Please enter a valid email address.")
          private String email;

          @Min(value = 18, message = "Age should be 18 or above.")
          private int age;
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Step 2: Handle Custom Errors in Controller</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          @PostMapping
          public String createUser(@Valid @RequestBody UserDTO user) {
              return "User registered successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Step 3: Centralized Exception Handling</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.http.HttpStatus;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.bind.annotation.ResponseStatus;
      import org.springframework.web.bind.annotation.RestControllerAdvice;
      import java.util.HashMap;
      import java.util.Map;

      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ResponseStatus(HttpStatus.BAD_REQUEST)
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
              Map<String, String> errors = new HashMap<>();
              ex.getBindingResult().getFieldErrors().forEach(error -> 
                  errors.put(error.getField(), error.getDefaultMessage()));
              return errors;
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Custom error messages in Spring Boot provide clear, user-friendly validation feedback. By defining specific messages in DTOs and centralizing exception handling, we can ensure a seamless experience for users.
  </p>
</div>
`
},
{
  title:`Validation on Method Parameters`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Validation on Method Parameters in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring Boot, method parameter validation ensures that input data meets specific constraints before processing. This helps in maintaining data integrity, reducing errors, and improving application security.
  </p>

  <h3 style="color: #16a085;">Why Use Method Parameter Validation?</h3>
  <p style="color: #2c3e50;">
    Implementing validation on method parameters offers multiple benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Ensures Data Integrity</strong>: Prevents invalid data from being processed.</li>
    <li><strong>Enhances Security</strong>: Protects against malformed or malicious input.</li>
    <li><strong>Reduces Redundant Checks</strong>: Centralizes validation logic, improving maintainability.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Enable Validation in Spring Boot?</h3>
  <p style="color: #2c3e50;">
    To enable validation, you need to include the <code>spring-boot-starter-validation</code> dependency in your <code>pom.xml</code> file.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using @Valid and @Validated Annotations</h3>
  <p style="color: #2c3e50;">
    The <code>@Valid</code> and <code>@Validated</code> annotations are used to trigger validation on method parameters in Spring Boot.
  </p>
  
  <h4 style="color: #d35400;">Example: Validating a Request Body</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.validation.constraints.*;

      public class UserRequest {
          @NotNull(message = "Name cannot be null")
          @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
          private String name;

          @Email(message = "Invalid email format")
          private String email;

          @Min(value = 18, message = "Age must be at least 18")
          private int age;
      }
    </code>
  </pre>

  <h4 style="color: #d35400;">Validating Parameters in Controller Methods</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;
      import javax.validation.Valid;

      @RestController
      @RequestMapping("/users")
      public class UserController {
          
          @PostMapping("/create")
          public String createUser(@Valid @RequestBody UserRequest userRequest) {
              return "User created successfully!";
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Validating Method Parameters with @Validated</h3>
  <p style="color: #2c3e50;">
    The <code>@Validated</code> annotation is used to validate method parameters in service layer components.
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.validation.annotation.Validated;
      import javax.validation.constraints.*;

      @Service
      @Validated
      public class UserService {
          
          public void registerUser(@NotNull @Size(min = 2, message = "Name must have at least 2 characters") String name) {
              System.out.println("User registered: " + name);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Handling Validation Exceptions</h3>
  <p style="color: #2c3e50;">
    When validation fails, Spring Boot throws a <code>MethodArgumentNotValidException</code>. You can handle these exceptions using <code>@ExceptionHandler</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.bind.annotation.*;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import java.util.stream.Collectors;

      @RestControllerAdvice
      public class GlobalExceptionHandler {
          
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public ResponseEntity&lt;String&gt; handleValidationException(MethodArgumentNotValidException ex) {
              String errors = ex.getBindingResult().getFieldErrors()
                                .stream()
                                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                                .collect(Collectors.joining(", "));
              return ResponseEntity.badRequest().body(errors);
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Validating method parameters in Spring Boot enhances data quality, application security, and maintainability. By leveraging <code>@Valid</code> and <code>@Validated</code> annotations, you can enforce validation rules seamlessly, ensuring robust and error-free applications.
  </p>
</div>
`
},

{
  title:`Hibernate Validator`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Hibernate Validator in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Hibernate Validator is the reference implementation of Bean Validation (JSR 380) and is used in Spring Boot applications for validating user input. It ensures that method parameters and class properties meet predefined constraints, improving application robustness.
  </p>

  <h3 style="color: #16a085;">Why Use Hibernate Validator?</h3>
  <p style="color: #2c3e50;">
    Hibernate Validator provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures that input data conforms to business rules.</li>
    <li><strong>Reduced Boilerplate Code</strong>: Annotations simplify validation logic.</li>
    <li><strong>Improved Security</strong>: Prevents invalid or harmful data from entering the system.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use Hibernate Validator?</h3>
  <p style="color: #2c3e50;">
    To use Hibernate Validator in Spring Boot, add the necessary dependency to your <code>pom.xml</code> file:
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Applying Validation Annotations</h3>
  <p style="color: #2c3e50;">
    Use validation annotations on model fields to enforce constraints.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import jakarta.validation.constraints.NotNull;
      import jakarta.validation.constraints.Size;
      
      public class User {
          
          @NotNull(message = "Name cannot be null")
          @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
          private String name;
          
          @NotNull(message = "Email is required")
          private String email;
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Validating Method Parameters</h3>
  <p style="color: #2c3e50;">
    You can also validate method parameters using Hibernate Validator.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import jakarta.validation.Valid;
      import org.springframework.web.bind.annotation.*;
      
      @RestController
      public class UserController {
          
          @PostMapping("/users")
          public String createUser(@Valid @RequestBody User user) {
              return "User is valid";
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Hibernate Validator</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@Valid</strong> to validate nested objects.</li>
    <li>Define custom validation messages for better user experience.</li>
    <li>Use <strong>@Validated</strong> on service layer methods for method-level validation.</li>
    <li>Handle validation exceptions using <strong>@ControllerAdvice</strong> to return meaningful error messages.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Hibernate Validator is a powerful tool for enforcing data validation in Spring Boot applications. By leveraging annotations, developers can ensure data consistency and security with minimal effort.
  </p>
</div>
`
},
{
  title:`Validation in Spring Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Validation in Spring Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Validation in Spring Security ensures that user inputs are checked for correctness and security vulnerabilities. It plays a crucial role in preventing common security threats such as SQL injection, cross-site scripting (XSS), and unauthorized access.
  </p>

  <h3 style="color: #16a085;">Why Validate Inputs in Spring Security?</h3>
  <p style="color: #2c3e50;">
    Validation in Spring Security provides multiple benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Preventing Security Threats</strong>: Guards against SQL injection, XSS, and other attacks.</li>
    <li><strong>Ensuring Data Integrity</strong>: Ensures that inputs conform to expected formats.</li>
    <li><strong>Enhancing Application Stability</strong>: Prevents unexpected errors due to invalid data.</li>
  </ul>

  <h3 style="color: #e67e22;">Using Validation in Spring Security</h3>
  <p style="color: #2c3e50;">
    Spring Security provides built-in mechanisms to validate user credentials and inputs. These can be enhanced using custom validators and security filters.
  </p>
  
  <h3 style="color: #8e44ad;">Example: Validating User Login</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates how to validate login inputs using Spring Security and Hibernate Validator.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import jakarta.validation.constraints.NotBlank;
      
      public class LoginRequest {
          @NotBlank(message = "Username is required")
          private String username;
          
          @NotBlank(message = "Password is required")
          private String password;
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Customizing Authentication with Validation</h3>
  <p style="color: #2c3e50;">
    We can integrate validation within Spring Security’s authentication process using custom validators.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
      import org.springframework.security.core.Authentication;
      import org.springframework.security.core.AuthenticationException;
      import org.springframework.security.authentication.AuthenticationManager;
      
      public class CustomAuthenticationProvider implements AuthenticationManager {
          @Override
          public Authentication authenticate(Authentication authentication) throws AuthenticationException {
              String username = authentication.getName();
              String password = authentication.getCredentials().toString();
              
              if (username == null || username.isEmpty() || password == null || password.isEmpty()) {
                  throw new AuthenticationException("Invalid username or password") {};
              }
              
              return new UsernamePasswordAuthenticationToken(username, password);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Secure Validation</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@Valid</strong> to validate request objects.</li>
    <li>Enable input sanitization to prevent XSS attacks.</li>
    <li>Use strong password policies and validation rules.</li>
    <li>Ensure proper error handling to avoid exposing sensitive information.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Validation in Spring Security is essential for protecting applications from security vulnerabilities. By integrating proper input validation techniques, we can ensure a safer and more reliable authentication system.
  </p>
</div>
`
},
{
   title:`Validation in Microservices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Validation in Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Validation in microservices ensures data integrity, security, and consistency across distributed systems. Since microservices communicate over networks and interact with multiple services, robust validation mechanisms are crucial to prevent data corruption and security vulnerabilities.
  </p>

  <h3 style="color: #16a085;">Why Validate Data in Microservices?</h3>
  <p style="color: #2c3e50;">
    Validation in microservices provides several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures data consistency across different services.</li>
    <li><strong>Security</strong>: Prevents malicious data injection and security vulnerabilities.</li>
    <li><strong>Fault Tolerance</strong>: Reduces system failures due to invalid or missing data.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Validation in Microservices</h3>
  <p style="color: #2c3e50;">
    Microservices validation can be implemented at different levels:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Request Validation</strong>: Validates incoming API requests.</li>
    <li><strong>Business Logic Validation</strong>: Ensures compliance with business rules.</li>
    <li><strong>Inter-Service Validation</strong>: Ensures consistency across microservices.</li>
  </ul>
  
  <h3 style="color: #8e44ad;">Example: Validating API Requests</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates request validation in a microservice using Spring Boot and Hibernate Validator.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import jakarta.validation.constraints.NotNull;
      import jakarta.validation.constraints.Size;

      public class OrderRequest {
          @NotNull(message = "Product ID is required")
          private Long productId;

          @NotNull(message = "Quantity is required")
          @Size(min = 1, message = "Quantity must be at least 1")
          private Integer quantity;
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Inter-Service Validation</h3>
  <p style="color: #2c3e50;">
    Microservices often need to validate data exchanged between services. This can be achieved using API contracts and schema validation tools like JSON Schema.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.web.client.RestTemplate;
      import org.springframework.http.ResponseEntity;
      
      public class InventoryService {
          private final RestTemplate restTemplate = new RestTemplate();
          
          public boolean isProductAvailable(Long productId) {
              ResponseEntity<Boolean> response = restTemplate.getForEntity(
                  "http://inventory-service/api/checkAvailability/" + productId, Boolean.class);
              return response.getBody();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Validation in Microservices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@Valid</strong> annotations for request validation.</li>
    <li>Ensure inter-service validation using API contracts.</li>
    <li>Implement error handling to return meaningful validation errors.</li>
    <li>Use event-driven validation for asynchronous communication.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Validation in microservices ensures data consistency, security, and robustness across distributed systems. By implementing proper validation techniques, microservices can maintain reliable and secure communication while preventing errors and vulnerabilities.
  </p>
</div>
`
},
{
   title:`Validation Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Validation Best Practices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Effective validation is crucial for ensuring data integrity, security, and reliability in software applications. Following best practices for validation helps prevent errors, enhances user experience, and strengthens system security.
  </p>

  <h3 style="color: #16a085;">Why Follow Validation Best Practices?</h3>
  <p style="color: #2c3e50;">
    Implementing validation best practices provides several key benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Integrity</strong>: Ensures accurate and consistent data storage and processing.</li>
    <li><strong>Security</strong>: Prevents common vulnerabilities such as SQL injection and XSS attacks.</li>
    <li><strong>Performance</strong>: Reduces unnecessary processing caused by invalid data.</li>
    <li><strong>User Experience</strong>: Provides clear and helpful validation feedback to users.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Validation Best Practices</h3>
  <p style="color: #2c3e50;">
    To ensure robust validation, follow these best practices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Validate at Multiple Layers</strong>: Apply validation at the front-end, back-end, and database levels.</li>
    <li><strong>Use Strong Data Types</strong>: Define strict data types to prevent incorrect data entry.</li>
    <li><strong>Implement Input Sanitization</strong>: Remove or escape harmful characters to prevent attacks.</li>
    <li><strong>Provide Meaningful Error Messages</strong>: Offer clear and specific validation feedback to users.</li>
    <li><strong>Use Annotations for Simplicity</strong>: Utilize built-in validation annotations in frameworks like Spring Boot and Hibernate Validator.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Implementing Validation in Spring Boot</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates how to apply validation to a user registration request using Hibernate Validator.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import jakarta.validation.constraints.Email;
      import jakarta.validation.constraints.NotBlank;
      import jakarta.validation.constraints.Size;

      public class UserRegistrationRequest {
          @NotBlank(message = "Username is required")
          @Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
          private String username;

          @NotBlank(message = "Email is required")
          @Email(message = "Invalid email format")
          private String email;

          @NotBlank(message = "Password is required")
          @Size(min = 6, message = "Password must be at least 6 characters long")
          private String password;
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Validating at Multiple Layers</h3>
  <p style="color: #2c3e50;">
    A comprehensive validation strategy includes validation at different layers:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Client-Side Validation</strong>: Improves user experience and reduces server load.</li>
    <li><strong>Server-Side Validation</strong>: Ensures data consistency and prevents malicious inputs.</li>
    <li><strong>Database Constraints</strong>: Enforces strict rules at the database level (e.g., unique constraints, foreign keys).</li>
  </ul>

  <h3 style="color: #d35400;">Common Validation Mistakes to Avoid</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Relying only on front-end validation (always validate on the server as well).</li>
    <li>Ignoring security-related validations (e.g., escaping inputs to prevent injection attacks).</li>
    <li>Providing vague error messages that confuse users.</li>
    <li>Skipping validation for API requests and inter-service communication.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Following validation best practices ensures data accuracy, system security, and improved user experience. Implementing multi-layered validation, using meaningful error messages, and leveraging built-in validation frameworks help maintain a reliable and secure application.
  </p>
</div>
`
},
{
  title:`Caching Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Caching Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching is an essential optimization technique that helps improve application performance by storing frequently accessed data in memory. It reduces database queries, minimizes latency, and enhances scalability.
  </p>

  <h3 style="color: #16a085;">Why Use Caching?</h3>
  <p style="color: #2c3e50;">
    Implementing caching offers several key benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improved Performance</strong>: Reduces data retrieval time by serving cached data.</li>
    <li><strong>Reduced Server Load</strong>: Minimizes expensive computations and database queries.</li>
    <li><strong>Scalability</strong>: Helps handle high traffic by reducing backend dependency.</li>
    <li><strong>Cost Efficiency</strong>: Lowers infrastructure costs by optimizing resource utilization.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Caching</h3>
  <p style="color: #2c3e50;">
    Different caching strategies serve various use cases:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>In-Memory Caching</strong>: Stores data in RAM for fast access (e.g., Redis, Memcached).</li>
    <li><strong>Database Caching</strong>: Caches query results to optimize database performance.</li>
    <li><strong>Application-Level Caching</strong>: Stores computed results to reduce processing time.</li>
    <li><strong>Content Delivery Network (CDN)</strong>: Caches static assets (e.g., images, scripts) closer to users.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Implementing Caching in Spring Boot</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates how to use caching in a Spring Boot application with Redis.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cache.annotation.Cacheable;
      import org.springframework.stereotype.Service;
      
      @Service
      public class ProductService {
          @Cacheable("products")
          public Product getProductById(Long id) {
              // Simulate database access
              return database.findProductById(id);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices for Caching</h3>
  <p style="color: #2c3e50;">
    To use caching effectively, follow these best practices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Choose the Right Cache Strategy</strong>: Select in-memory, database, or distributed caching based on needs.</li>
    <li><strong>Set Expiry Policies</strong>: Define time-to-live (TTL) for cache entries to avoid stale data.</li>
    <li><strong>Monitor Cache Performance</strong>: Track hit/miss ratios to optimize caching efficiency.</li>
    <li><strong>Use Cache Invalidation</strong>: Implement strategies to refresh outdated cache data.</li>
  </ul>

  <h3 style="color: #d35400;">Common Caching Pitfalls to Avoid</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Overcaching, which may lead to outdated data issues.</li>
    <li>Not setting proper eviction policies, causing memory overflow.</li>
    <li>Ignoring security considerations for sensitive cached data.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Caching is a powerful technique that significantly improves application speed and efficiency. Choosing the right caching strategy, setting appropriate expiration policies, and monitoring cache performance are crucial for maintaining a responsive and scalable system.
  </p>
</div>
`
},
{
  title:`Cache Annotations (@Cacheable, @CacheEvict, @CachePut)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">C Cache Annotations (@Cacheable, @CacheEvict, @CachePut)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring provides caching annotations to manage cache operations efficiently. These annotations help store, update, and remove cached data dynamically.
  </p>

  <h3 style="color: #16a085;">@Cacheable</h3>
  <p style="color: #2c3e50;">
    The <strong>@Cacheable</strong> annotation is used to cache method results. If the result is already cached, the method execution is skipped.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class ProductService {
          @Cacheable("products")
          public Product getProductById(Long id) {
              return database.findProductById(id);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">@CacheEvict</h3>
  <p style="color: #2c3e50;">
    The <strong>@CacheEvict</strong> annotation removes entries from the cache when data needs to be updated or deleted.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class ProductService {
          @CacheEvict(value = "products", key = "#id")
          public void deleteProduct(Long id) {
              database.deleteProductById(id);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">@CachePut</h3>
  <p style="color: #2c3e50;">
    The <strong>@CachePut</strong> annotation updates the cache with new method results while still executing the method.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class ProductService {
          @CachePut(value = "products", key = "#product.id")
          public Product updateProduct(Product product) {
              return database.save(product);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@Cacheable</strong> for frequently accessed data to improve performance.</li>
    <li>Implement <strong>@CacheEvict</strong> to remove stale data when necessary.</li>
    <li>Use <strong>@CachePut</strong> to ensure cache consistency after updates.</li>
    <li>Monitor cache usage to prevent excessive memory consumption.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Caching annotations in Spring help improve application efficiency by reducing redundant computations. Using @Cacheable, @CacheEvict, and @CachePut effectively ensures optimal cache management and data consistency.
  </p>
</div>
`
},
{
  title:`Cache Managers`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Managers</h2>
  <p style="font-size: 16px; color: #34495e;">
    A <strong>Cache Manager</strong> in Spring Boot is responsible for managing cache operations such as storing, retrieving, and evicting cached data. It provides an abstraction over different caching implementations.
  </p>

  <h3 style="color: #16a085;">Enabling Cache Manager</h3>
  <p style="color: #2c3e50;">
    To enable caching in a Spring Boot application, use the <strong>@EnableCaching</strong> annotation in the main class.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @SpringBootApplication
      @EnableCaching
      public class CacheApplication {
          public static void main(String[] args) {
              SpringApplication.run(CacheApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using Cache Manager</h3>
  <p style="color: #2c3e50;">
    The <strong>CacheManager</strong> interface in Spring provides various caching mechanisms, such as ConcurrentMapCacheManager, EhCacheCacheManager, and RedisCacheManager.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class CacheConfig {
          @Bean
          public CacheManager cacheManager() {
              return new ConcurrentMapCacheManager("products");
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Customizing Cache Manager</h3>
  <p style="color: #2c3e50;">
    You can customize the cache manager to use other caching solutions like Redis or EhCache.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class RedisCacheConfig {
          @Bean
          public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
              return RedisCacheManager.builder(factory).build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose a caching solution that fits your application’s needs (e.g., Redis for distributed caching).</li>
    <li>Monitor cache performance and memory usage.</li>
    <li>Set appropriate expiration policies to prevent stale data.</li>
    <li>Use <strong>CacheManager</strong> to handle multiple cache implementations efficiently.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <strong>Cache Manager</strong> in Spring Boot helps optimize performance by managing cached data effectively. Choosing the right cache implementation and configuring it properly can significantly enhance application efficiency.
  </p>
</div>
`
},
{
  title:`Cache Providers (EhCache, Redis, etc.)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Providers (EhCache, Redis, etc.)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Different <strong>cache providers</strong> are available in Spring Boot, offering various caching mechanisms. The most commonly used cache providers include EhCache, Redis, Caffeine, and Hazelcast.
  </p>

  <h3 style="color: #16a085;">EhCache</h3>
  <p style="color: #2c3e50;">
    EhCache is a widely used Java-based cache provider that supports in-memory caching with optional disk persistence.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      @EnableCaching
      public class EhCacheConfig {
          @Bean
          public CacheManager cacheManager() {
              return new EhCacheCacheManager(CacheManager.newInstance("ehcache.xml"));
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Redis</h3>
  <p style="color: #2c3e50;">
    Redis is an in-memory data store that provides fast caching and supports distributed caching.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class RedisCacheConfig {
          @Bean
          public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
              return RedisCacheManager.builder(factory).build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Caffeine</h3>
  <p style="color: #2c3e50;">
    Caffeine is a high-performance Java-based caching library.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class CaffeineCacheConfig {
          @Bean
          public CacheManager cacheManager() {
              return new CaffeineCacheManager("products");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Hazelcast</h3>
  <p style="color: #2c3e50;">
    Hazelcast is a distributed caching solution that supports clustering.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class HazelcastCacheConfig {
          @Bean
          public CacheManager cacheManager() {
              Config config = new Config();
              return new HazelcastCacheManager(Hazelcast.newHazelcastInstance(config));
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose a cache provider based on your application requirements.</li>
    <li>Monitor cache performance and adjust expiration policies accordingly.</li>
    <li>Use distributed caching for scalability in microservices.</li>
    <li>Optimize cache configurations to balance memory usage and speed.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Boot supports multiple <strong>cache providers</strong> such as EhCache, Redis, Caffeine, and Hazelcast. Choosing the right cache provider can enhance performance, scalability, and efficiency in an application.
  </p>
</div>
`
},
{
  title:`Spring Cache Abstraction`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Cache Abstraction</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <strong>Spring Cache Abstraction</strong> provides a unified approach to integrating various caching solutions in Spring applications. It allows developers to apply caching in a consistent manner without tightly coupling to a specific caching provider.
  </p>

  <h3 style="color: #16a085;">Enabling Spring Cache</h3>
  <p style="color: #2c3e50;">
    To enable caching in a Spring Boot application, use the <strong>@EnableCaching</strong> annotation in the main class.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @SpringBootApplication
      @EnableCaching
      public class CacheApplication {
          public static void main(String[] args) {
              SpringApplication.run(CacheApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Using Spring Cache Abstraction</h3>
  <p style="color: #2c3e50;">
    The <strong>Spring Cache Abstraction</strong> supports annotations such as <strong>@Cacheable</strong>, <strong>@CachePut</strong>, and <strong>@CacheEvict</strong> to manage cache operations efficiently.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class ProductService {
          
          @Cacheable("products")
          public Product getProductById(Long id) {
              return new Product(id, "Sample Product");
          }
          
          @CachePut(value = "products", key = "#product.id")
          public Product updateProduct(Product product) {
              return product;
          }
          
          @CacheEvict(value = "products", key = "#id")
          public void deleteProduct(Long id) {
              // Remove from cache
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Supported Cache Providers</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>ConcurrentMapCacheManager (Default in Spring Boot)</li>
    <li>EhCache</li>
    <li>Redis</li>
    <li>Caffeine</li>
    <li>Hazelcast</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose an appropriate caching provider based on application needs.</li>
    <li>Use <strong>@CacheEvict</strong> to avoid stale data.</li>
    <li>Ensure proper cache key management to prevent conflicts.</li>
    <li>Monitor cache hit rates and eviction policies for optimal performance.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <strong>Spring Cache Abstraction</strong> provides a flexible and unified caching mechanism in Spring Boot applications. By leveraging different caching providers and annotations, developers can optimize performance efficiently.
  </p>
</div>
`
},
{
  
  title:`Caching Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Caching Strategies</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching strategies play a crucial role in optimizing application performance by reducing redundant computations and database queries. Different strategies cater to various use cases, balancing speed, consistency, and freshness of data.
  </p>

  <h3 style="color: #16a085;">Common Caching Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Write-Through</strong>: Data is written to both the cache and the database simultaneously.</li>
    <li><strong>Write-Behind (Write-Back)</strong>: Data is written to the cache first and asynchronously updated in the database.</li>
    <li><strong>Read-Through</strong>: Data is fetched from the database via the cache, ensuring updated values.</li>
    <li><strong>Cache-Aside (Lazy Loading)</strong>: The application fetches data from the database and stores it in the cache.</li>
    <li><strong>Time-To-Live (TTL) & Expiry</strong>: Cached data is invalidated after a set duration.</li>
  </ul>

  <h3 style="color: #e67e22;">Choosing the Right Caching Strategy</h3>
  <p style="color: #2c3e50;">
    The choice of caching strategy depends on application requirements:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>write-through</strong> for real-time consistency needs.</li>
    <li>Use <strong>write-behind</strong> when performance is a priority and slight data lag is acceptable.</li>
    <li>Use <strong>cache-aside</strong> for flexible cache control.</li>
    <li>Apply <strong>TTL & expiry</strong> to prevent stale data accumulation.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Caching Strategies in Spring</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides robust caching mechanisms to support various strategies using annotations like <code>@Cacheable</code>, <code>@CacheEvict</code>, and <code>@CachePut</code>.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class ProductService {

          @Cacheable(value = "products", key = "#id")
          public Product getProductById(Long id) {
              return new Product(id, "Sample Product");
          }
          
          @CachePut(value = "products", key = "#product.id")
          public Product updateProduct(Product product) {
              return product;
          }
          
          @CacheEvict(value = "products", key = "#id")
          public void deleteProduct(Long id) {
              // Remove from cache
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Monitor cache performance and adjust eviction policies accordingly.</li>
    <li>Use <strong>cache partitioning</strong> to reduce contention.</li>
    <li>Combine caching strategies for an optimal balance of performance and consistency.</li>
    <li>Leverage distributed caching solutions like Redis for scalability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Selecting the right caching strategy is crucial for improving application performance and efficiency. By implementing Spring’s caching capabilities effectively, developers can achieve a balance between speed and data accuracy.
  </p>
</div>
`
},
{
  title:`Cache Configurations`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Configurations</h2>
  <p style="font-size: 16px; color: #34495e;">
    Proper cache configuration is essential for optimizing application performance. Configuring caches correctly ensures efficient memory usage, improved response times, and enhanced scalability.
  </p>

  <h3 style="color: #16a085;">Common Cache Configuration Options</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Cache Size Limits</strong>: Defines the maximum number of entries the cache can hold.</li>
    <li><strong>Time-to-Live (TTL)</strong>: Determines how long an entry remains in the cache before being invalidated.</li>
    <li><strong>Eviction Policies</strong>: Strategies like Least Recently Used (LRU), Least Frequently Used (LFU), and First-In-First-Out (FIFO).</li>
    <li><strong>Concurrency Controls</strong>: Ensures data consistency when multiple threads access the cache.</li>
    <li><strong>Persistence</strong>: Enables storing cache data to disk for recovery after restarts.</li>
  </ul>

  <h3 style="color: #e67e22;">Configuring Cache in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides flexible caching configurations using properties and Java-based configuration.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      @EnableCaching
      public class CacheConfig {
          @Bean
          public CacheManager cacheManager() {
              return new ConcurrentMapCacheManager("products");
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Cache Configuration Properties</h3>
  <p style="color: #2c3e50;">
    Cache settings can also be managed through <code>application.properties</code>:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-properties">
      spring.cache.type=redis
      spring.cache.redis.time-to-live=60000
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose an appropriate cache provider based on application needs.</li>
    <li>Set optimal TTL and eviction policies to balance freshness and memory usage.</li>
    <li>Monitor cache performance using metrics and logging.</li>
    <li>Leverage distributed caches for scalability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Proper cache configuration ensures an efficient caching system that improves application responsiveness and scalability. By leveraging Spring Boot’s caching capabilities, developers can fine-tune cache behavior to suit application requirements.
  </p>
</div>
`
},
{
  title:`Cache Key Generation`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Key Generation</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cache key generation is a critical aspect of caching strategies, ensuring efficient data retrieval and preventing unnecessary computations. Proper key management avoids cache collisions and optimizes performance.
  </p>

  <h3 style="color: #16a085;">Why is Cache Key Generation Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Avoids Redundant Data</strong>: Ensures only unique data is stored in the cache.</li>
    <li><strong>Prevents Cache Collisions</strong>: Avoids overwriting unrelated cache entries.</li>
    <li><strong>Improves Performance</strong>: Faster lookups with well-defined keys.</li>
    <li><strong>Supports Cache Invalidation</strong>: Helps in proper cache evictions and updates.</li>
  </ul>

  <h3 style="color: #e67e22;">Cache Key Generation in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot provides flexibility in cache key generation using <code>@Cacheable</code> with custom key definitions.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Cacheable(value = "products", key = "#id")
      public Product getProductById(Long id) {
          return new Product(id, "Sample Product");
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Custom Key Generators</h3>
  <p style="color: #2c3e50;">
    Custom key generators can be implemented using <code>KeyGenerator</code>.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Component
      public class CustomKeyGenerator implements KeyGenerator {
          @Override
          public Object generate(Object target, Method method, Object... params) {
              return method.getName() + "_" + Arrays.toString(params);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use meaningful and unique keys to prevent conflicts.</li>
    <li>Avoid using complex objects as keys unless properly serialized.</li>
    <li>Consider cache eviction strategies to manage stale data.</li>
    <li>Monitor cache efficiency to refine key strategies.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Effective cache key generation is essential for an optimized caching system. By leveraging custom key generators and best practices, developers can improve cache performance, ensuring accurate and efficient data retrieval.
  </p>
</div>
`
},
{
  title:`Cache Eviction Strategies`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Eviction Strategies</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cache eviction strategies determine how and when cached data is removed to maintain efficiency and prevent stale data. Proper eviction policies help optimize memory usage and ensure up-to-date information retrieval.
  </p>

  <h3 style="color: #16a085;">Why is Cache Eviction Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Prevents Stale Data</strong>: Ensures outdated or irrelevant data is removed.</li>
    <li><strong>Optimizes Memory Usage</strong>: Frees up space for new cache entries.</li>
    <li><strong>Improves Performance</strong>: Reduces unnecessary cache lookups and storage overhead.</li>
    <li><strong>Maintains Data Consistency</strong>: Synchronizes cached data with the latest database updates.</li>
  </ul>

  <h3 style="color: #e67e22;">Cache Eviction Strategies in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Spring Boot supports various cache eviction mechanisms using the <code>@CacheEvict</code> annotation.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @CacheEvict(value = "products", key = "#id")
      public void deleteProduct(Long id) {
          productRepository.deleteById(id);
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Types of Cache Eviction Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Manual Eviction</strong>: Explicitly removes cache entries using <code>@CacheEvict</code>.</li>
    <li><strong>Time-Based Expiry</strong>: Automatically removes entries after a defined time interval.</li>
    <li><strong>Least Recently Used (LRU)</strong>: Discards the least accessed data to make space.</li>
    <li><strong>Least Frequently Used (LFU)</strong>: Removes items accessed the least number of times.</li>
    <li><strong>Write-Through and Write-Behind</strong>: Ensures data synchronization between cache and database.</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices for Cache Eviction</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose an eviction policy based on application needs.</li>
    <li>Combine cache eviction with monitoring tools for better performance insights.</li>
    <li>Use <strong>conditional eviction</strong> to fine-tune when cache should be cleared.</li>
    <li>Test eviction strategies in staging before deploying to production.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Implementing efficient cache eviction strategies is crucial for maintaining application performance and data accuracy. By choosing the right eviction policy and combining it with best practices, developers can ensure a balanced and optimized caching system.
  </p>
</div>
`
},
{
  title:`Cache TTL (Time to Live)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache TTL (Time to Live)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cache TTL (Time to Live) defines the duration for which cached data remains valid before it is automatically removed. Setting an appropriate TTL helps balance performance, memory usage, and data freshness.
  </p>

  <h3 style="color: #16a085;">Why is Cache TTL Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Prevents Stale Data</strong>: Ensures cached information remains fresh and relevant.</li>
    <li><strong>Optimizes Memory Usage</strong>: Automatically removes expired data to free up resources.</li>
    <li><strong>Enhances Performance</strong>: Reduces unnecessary database queries by keeping frequently accessed data available.</li>
    <li><strong>Controls Cache Bloat</strong>: Avoids excessive memory consumption by discarding outdated entries.</li>
  </ul>

  <h3 style="color: #e67e22;">Configuring Cache TTL in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Cache TTL can be configured using cache providers like Redis, EhCache, and Caffeine.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      public class CacheConfig {
          @Bean
          public CacheManager cacheManager() {
              return new ConcurrentMapCacheManager("products") {
                  @Override
                  protected Cache createConcurrentMapCache(String name) {
                      return new ConcurrentMapCache(name, CacheBuilder.newBuilder()
                          .expireAfterWrite(10, TimeUnit.MINUTES)
                          .build().asMap(), false);
                  }
              };
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Cache TTL Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Fixed TTL</strong>: Cache entries expire after a pre-set duration.</li>
    <li><strong>Sliding TTL</strong>: Resets TTL upon access to extend data lifespan.</li>
    <li><strong>Custom Expiration</strong>: TTL varies based on application logic.</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices for Cache TTL</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Set TTL based on data volatility and access frequency.</li>
    <li>Use a combination of <strong>short-lived</strong> and <strong>long-lived</strong> caches to optimize performance.</li>
    <li>Monitor cache hit/miss ratios to fine-tune TTL settings.</li>
    <li>Consider invalidation mechanisms to force cache updates when necessary.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Configuring an appropriate Cache TTL helps maintain an efficient caching system. By selecting the right expiration strategy and continuously monitoring performance, developers can optimize cache effectiveness while ensuring data accuracy.
  </p>
</div>
`
},
{
  title:`Cache Synchronization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Synchronization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cache synchronization ensures that data stored in the cache remains consistent with the underlying data source. This is crucial in distributed systems where multiple instances of an application may read and write data simultaneously.
  </p>

  <h3 style="color: #16a085;">Why is Cache Synchronization Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Maintains Data Consistency</strong>: Ensures that cached data does not become outdated or incorrect.</li>
    <li><strong>Reduces Stale Data</strong>: Updates or invalidates cache when the underlying data changes.</li>
    <li><strong>Improves Performance</strong>: Allows applications to use cached data confidently without frequent database queries.</li>
    <li><strong>Ensures High Availability</strong>: Supports distributed caching systems in multi-node environments.</li>
  </ul>

  <h3 style="color: #e67e22;">Strategies for Cache Synchronization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Write-Through</strong>: Data is written to both the cache and database simultaneously.</li>
    <li><strong>Write-Behind</strong>: Data is first written to the cache and asynchronously persisted to the database.</li>
    <li><strong>Cache Invalidation</strong>: The cache entry is removed or updated when the corresponding data changes.</li>
    <li><strong>Event-Based Synchronization</strong>: Listeners monitor changes and update cache accordingly.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Cache Synchronization in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class ProductService {
          @Cacheable("products")
          public Product getProductById(Long id) {
              return productRepository.findById(id).orElse(null);
          }

          @CachePut(value = "products", key = "#product.id")
          public Product updateProduct(Product product) {
              return productRepository.save(product);
          }

          @CacheEvict(value = "products", key = "#id")
          public void deleteProduct(Long id) {
              productRepository.deleteById(id);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Cache Synchronization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose a synchronization strategy based on application requirements.</li>
    <li>Use event-driven mechanisms like <strong>Redis Pub/Sub</strong> or <strong>Kafka</strong> for distributed cache updates.</li>
    <li>Regularly monitor and fine-tune cache invalidation policies.</li>
    <li>Leverage database triggers to notify cache changes where applicable.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Effective cache synchronization ensures high application performance while maintaining data accuracy. By selecting the right strategy and implementing proper invalidation mechanisms, developers can keep cached data up to date without compromising efficiency.
  </p>
</div>
`
},
{
  title:`Distributed Caching`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Distributed Caching</h2>
  <p style="font-size: 16px; color: #34495e;">
    Distributed caching is a technique used to store and manage cached data across multiple servers or nodes. It enhances application scalability, performance, and availability by ensuring that frequently accessed data is available closer to the users.
  </p>

  <h3 style="color: #16a085;">Why is Distributed Caching Important?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improves Performance</strong>: Reduces database load and speeds up data retrieval.</li>
    <li><strong>Enhances Scalability</strong>: Supports high-traffic applications by distributing cache across multiple nodes.</li>
    <li><strong>Ensures High Availability</strong>: Provides redundancy, reducing the risk of cache failures.</li>
    <li><strong>Minimizes Latency</strong>: Delivers cached data from the nearest available node.</li>
  </ul>

  <h3 style="color: #e67e22;">Popular Distributed Caching Solutions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Redis</strong>: In-memory key-value store, supports replication and persistence.</li>
    <li><strong>Memcached</strong>: Simple, high-performance caching system.</li>
    <li><strong>EhCache</strong>: Java-based caching solution with strong integration in Spring Boot.</li>
    <li><strong>Hazelcast</strong>: In-memory data grid offering distributed caching capabilities.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Distributed Caching in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      @EnableCaching
      public class CacheConfig {
          @Bean
          public CacheManager cacheManager() {
              RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
              return RedisCacheManager.builder(RedisConnectionFactory()).cacheDefaults(config).build();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Distributed Caching</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use appropriate eviction policies like <strong>LRU</strong> (Least Recently Used) to optimize cache utilization.</li>
    <li>Ensure data consistency using cache synchronization techniques.</li>
    <li>Leverage partitioning to distribute cache load effectively.</li>
    <li>Monitor and optimize cache size to avoid memory overflow.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Distributed caching is a crucial component in building scalable and high-performance applications. By leveraging distributed cache solutions and best practices, developers can optimize response times, reduce database load, and enhance system resilience.
  </p>
</div>
`
},
{
  title:`Caching in Microservices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Caching in Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching in microservices helps improve performance, reduce latency, and minimize database load by storing frequently accessed data closer to the application. Since microservices are distributed, caching strategies need to be carefully designed to ensure consistency and scalability.
  </p>

  <h3 style="color: #16a085;">Why is Caching Important in Microservices?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduces Database Load</strong>: Minimizes direct database queries, improving efficiency.</li>
    <li><strong>Enhances Performance</strong>: Speeds up response times by retrieving cached data.</li>
    <li><strong>Improves Scalability</strong>: Handles increased traffic by reducing bottlenecks.</li>
    <li><strong>Supports Fault Tolerance</strong>: Cached data can serve as a backup in case of service failures.</li>
  </ul>

  <h3 style="color: #e67e22;">Caching Strategies in Microservices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Local Cache</strong>: Each microservice maintains its own cache.</li>
    <li><strong>Distributed Cache</strong>: A shared caching layer (e.g., Redis, Hazelcast) is used across services.</li>
    <li><strong>Hybrid Cache</strong>: Combination of local and distributed caching for optimal performance.</li>
    <li><strong>Read-Through & Write-Through</strong>: Ensures consistency by automatically updating cache during database operations.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Caching in Spring Boot Microservices</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      @EnableCaching
      public class CacheConfig {
          @Bean
          public CacheManager cacheManager() {
              return new ConcurrentMapCacheManager("items");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Caching in Microservices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Choose an appropriate caching strategy based on use cases.</li>
    <li>Use cache expiration and eviction policies to avoid stale data.</li>
    <li>Ensure consistency using cache synchronization mechanisms.</li>
    <li>Monitor cache performance and fine-tune configurations.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Caching plays a vital role in optimizing microservices architecture. By adopting the right caching strategies and best practices, applications can achieve higher scalability, better performance, and improved resilience in distributed environments.
  </p>
</div>
`
},
{
  title:`Cache & Performance Optimization`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache & Performance Optimization</h2>
  <p style="font-size: 16px; color: #34495e;">
    Efficient caching strategies play a crucial role in optimizing application performance. By reducing database calls and improving response times, caching enhances scalability and ensures smooth user experiences. 
  </p>

  <h3 style="color: #16a085;">Why is Cache Important for Performance Optimization?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reduces Latency</strong>: Serves data faster by avoiding repeated computations or database hits.</li>
    <li><strong>Minimizes Database Load</strong>: Decreases database stress by storing frequently accessed data.</li>
    <li><strong>Enhances Scalability</strong>: Supports high-traffic applications by reducing backend dependencies.</li>
    <li><strong>Improves User Experience</strong>: Provides quick responses for a seamless user experience.</li>
  </ul>

  <h3 style="color: #e67e22;">Effective Caching Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Local Caching</strong>: Stores cache within the application to reduce external calls.</li>
    <li><strong>Distributed Caching</strong>: Uses external services like Redis or Memcached for scalability.</li>
    <li><strong>Write-Through & Read-Through</strong>: Ensures data consistency with automatic updates.</li>
    <li><strong>Cache Expiry & Eviction Policies</strong>: Removes stale data to maintain relevance.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Caching in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Configuration
      @EnableCaching
      public class CacheConfig {
          @Bean
          public CacheManager cacheManager() {
              return new ConcurrentMapCacheManager("products");
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Cache Optimization</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use the right cache type (local, distributed, hybrid) based on needs.</li>
    <li>Set expiration times to avoid stale data issues.</li>
    <li>Leverage cache warming techniques for better startup performance.</li>
    <li>Monitor and tune cache settings for optimal efficiency.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Caching is a vital component of performance optimization. By strategically implementing caching mechanisms, applications can significantly enhance speed, scalability, and user experience while maintaining consistency and reliability.
  </p>
</div>
`
},
{
  title:`Cache Monitoring`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Monitoring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Cache monitoring is essential to ensure optimal cache performance, prevent stale data issues, and detect inefficiencies in caching mechanisms. Proper monitoring helps maintain system reliability and performance.
  </p>

  <h3 style="color: #16a085;">Why Monitor Caches?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Detect Cache Misses</strong>: Identify when requests bypass the cache, leading to unnecessary database queries.</li>
    <li><strong>Analyze Hit Ratios</strong>: Monitor cache efficiency by tracking the ratio of cache hits to misses.</li>
    <li><strong>Prevent Stale Data</strong>: Ensure data consistency by tracking cache expiry and eviction patterns.</li>
    <li><strong>Optimize Cache Size</strong>: Adjust cache size based on real-time usage metrics to prevent memory overflows.</li>
  </ul>

  <h3 style="color: #e67e22;">Cache Monitoring Tools</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Spring Boot Actuator</strong>: Provides cache metrics via endpoints like <code>/actuator/caches</code>.</li>
    <li><strong>Redis CLI & Dashboard</strong>: Offers insights into cache operations and memory usage.</li>
    <li><strong>EhCache Monitoring</strong>: Uses JMX (Java Management Extensions) for cache metrics.</li>
    <li><strong>Prometheus & Grafana</strong>: Visualizes cache performance trends with real-time monitoring.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Cache Monitoring in Spring Boot</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @RestController
      @RequestMapping("/cache")
      public class CacheController {
          @Autowired
          private CacheManager cacheManager;
          
          @GetMapping("/stats")
          public Collection&lt;String&gt; getCacheNames() {
              return cacheManager.getCacheNames();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Cache Monitoring</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Set up alerts for high cache miss rates.</li>
    <li>Monitor cache eviction and TTL expiration patterns.</li>
    <li>Regularly analyze cache metrics to fine-tune performance.</li>
    <li>Use distributed tracing to correlate cache performance with application behavior.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Monitoring caching mechanisms is crucial for maintaining application efficiency and ensuring that caching strategies align with performance goals. By leveraging proper tools and best practices, applications can maximize caching benefits while avoiding potential pitfalls.
  </p>
</div>
`
},
{
  title:`Caching with Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Caching with Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching in Spring Boot enhances application performance by reducing database load and response time. Spring Boot provides built-in support for caching through annotations and cache managers.
  </p>

  <h3 style="color: #16a085;">Why Use Caching in Spring Boot?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Improves Performance</strong>: Reduces redundant database queries, enhancing application speed.</li>
    <li><strong>Optimizes Resource Usage</strong>: Decreases server load and improves response time.</li>
    <li><strong>Enhances Scalability</strong>: Helps applications handle more users efficiently.</li>
  </ul>

  <h3 style="color: #e67e22;">Enabling Caching in Spring Boot</h3>
  <p style="color: #2c3e50;">To enable caching, annotate the main application class with <code>@EnableCaching</code>.</p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @SpringBootApplication
      @EnableCaching
      public class CachingApplication {
          public static void main(String[] args) {
              SpringApplication.run(CachingApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using Cache Annotations</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><code>@Cacheable</code>: Caches method results to improve performance.</li>
    <li><code>@CacheEvict</code>: Removes outdated cache entries.</li>
    <li><code>@CachePut</code>: Updates the cache with the latest data.</li>
  </ul>

  <h3 style="color: #d35400;">Example: Implementing Caching</h3>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class ProductService {
          private final ProductRepository repository;
          
          @Autowired
          public ProductService(ProductRepository repository) {
              this.repository = repository;
          }
          
          @Cacheable("products")
          public List<Product> getAllProducts() {
              return repository.findAll();
          }
      }
    </code>
  </pre>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Caching in Spring Boot is a powerful way to enhance application performance. By leveraging cache annotations and cache managers, developers can optimize resource usage and improve response times effectively.
  </p>
</div>
`
},
{
  title:`Cache Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache Best Practices</h2>
  <p style="font-size: 16px; color: #34495e;">
    Implementing caching effectively requires adherence to best practices to ensure optimal performance and data consistency. Below are some key strategies for caching in applications.
  </p>

  <h3 style="color: #16a085;">1. Choose the Right Caching Strategy</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>In-Memory Caching</strong>: Use for fast access with limited data (e.g., EhCache, Caffeine).</li>
    <li><strong>Distributed Caching</strong>: Required for microservices and large-scale applications (e.g., Redis, Memcached).</li>
  </ul>

  <h3 style="color: #e67e22;">2. Use Proper Expiration Policies</h3>
  <p style="color: #2c3e50;">Set appropriate Time-to-Live (TTL) for cache entries to avoid stale data issues.</p>

  <h3 style="color: #8e44ad;">3. Implement Cache Eviction Strategies</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>LRU (Least Recently Used)</strong>: Removes the least accessed data first.</li>
    <li><strong>LFU (Least Frequently Used)</strong>: Removes the least frequently used items.</li>
    <li><strong>FIFO (First In, First Out)</strong>: Evicts the oldest cached items.</li>
  </ul>

  <h3 style="color: #d35400;">4. Use Cache Warming and Preloading</h3>
  <p style="color: #2c3e50;">Preload critical data into the cache to reduce response times during high traffic.</p>

  <h3 style="color: #16a085;">5. Implement Proper Cache Invalidation</h3>
  <p style="color: #2c3e50;">Ensure cached data is refreshed appropriately using <code>@CacheEvict</code> and other invalidation techniques.</p>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Following caching best practices ensures efficient resource utilization, improves application performance, and maintains data integrity. Choose the right cache strategy and manage expiration wisely for optimal results.
  </p>
</div>
`
},
{
  title:`Testing Caching`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing Caching</h2>
  <p style="font-size: 16px; color: #34495e;">
    Testing caching ensures that the cache behaves as expected, improving performance while maintaining data consistency. Below are key techniques for effectively testing caching mechanisms.
  </p>

  <h3 style="color: #16a085;">1. Unit Testing with Mocks</h3>
  <p style="color: #2c3e50;">Use mocking frameworks like Mockito to simulate caching behavior and verify method calls.</p>
  
  <h3 style="color: #e67e22;">2. Integration Testing</h3>
  <p style="color: #2c3e50;">Test cache interactions with actual data sources to validate caching logic in a real environment.</p>

  <h3 style="color: #8e44ad;">3. Load and Performance Testing</h3>
  <p style="color: #2c3e50;">Simulate high traffic to measure cache hit/miss ratios and assess cache efficiency.</p>

  <h3 style="color: #d35400;">4. Cache Eviction Testing</h3>
  <p style="color: #2c3e50;">Ensure that cache eviction policies (TTL, LRU, etc.) work correctly and prevent stale data issues.</p>

  <h3 style="color: #16a085;">5. Consistency and Data Integrity Testing</h3>
  <p style="color: #2c3e50;">Verify that cached data remains synchronized with the underlying data store.</p>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Properly testing caching mechanisms helps maintain application stability, ensures expected performance improvements, and prevents data inconsistencies. Use unit, integration, and performance tests to validate cache behavior effectively.
  </p>
</div>
`
},
{
  title:`Conditional Caching`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Conditional Caching</h2>
  <p style="font-size: 16px; color: #34495e;">
    Conditional caching enables dynamic control over cache storage based on specific conditions. It helps optimize resource usage by caching only relevant data.
  </p>

  <h3 style="color: #16a085;">1. Using Conditions in @Cacheable</h3>
  <p style="color: #2c3e50;">Spring's <code>@Cacheable</code> annotation allows conditional caching with the <code>condition</code> and <code>unless</code> attributes.</p>
  
  <h3 style="color: #e67e22;">2. condition Attribute</h3>
  <p style="color: #2c3e50;">Cache only when a certain condition is met, e.g., caching only when the input ID is greater than 10.</p>

  <h3 style="color: #8e44ad;">3. unless Attribute</h3>
  <p style="color: #2c3e50;">Prevent caching based on result conditions, e.g., avoiding caching null or empty results.</p>

  <h3 style="color: #d35400;">4. Conditional Eviction</h3>
  <p style="color: #2c3e50;">Use <code>@CacheEvict</code> with conditions to remove cached data dynamically.</p>

  <h3 style="color: #16a085;">5. Performance Considerations</h3>
  <p style="color: #2c3e50;">Ensure that condition evaluation does not introduce significant overhead, negating caching benefits.</p>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Conditional caching enhances caching efficiency by allowing selective storage of results. Properly defining conditions helps maintain performance and optimize resource utilization.
  </p>
</div>
`
},
{
  title:`Cache & Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Cache & Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    Caching and security go hand in hand to ensure data integrity and prevent unauthorized access to sensitive information stored in caches.
  </p>

  <h3 style="color: #16a085;">1. Risks of Caching Sensitive Data</h3>
  <p style="color: #2c3e50;">Storing sensitive data like user credentials, tokens, or personal information in cache can lead to security vulnerabilities.</p>
  
  <h3 style="color: #e67e22;">2. Secure Cache Storage</h3>
  <p style="color: #2c3e50;">Use encrypted caches and configure cache providers to prevent unauthorized access.</p>

  <h3 style="color: #8e44ad;">3. Cache Expiration Policies</h3>
  <p style="color: #2c3e50;">Implement short TTL (Time-To-Live) for sensitive data to minimize security risks.</p>

  <h3 style="color: #d35400;">4. Role-Based Cache Access</h3>
  <p style="color: #2c3e50;">Restrict access to cached data based on user roles and permissions.</p>

  <h3 style="color: #16a085;">5. Preventing Cache Poisoning</h3>
  <p style="color: #2c3e50;">Validate inputs and sanitize data before storing them in the cache to prevent malicious injections.</p>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Properly securing caches helps prevent data leaks, unauthorized access, and cache poisoning attacks. Implementing encryption, access controls, and expiration policies is crucial for a secure caching strategy.
  </p>
</div>
`
},
{
  title:`Transaction Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transactions are fundamental units of work in database systems, ensuring data consistency, integrity, 
    and reliability. A transaction groups multiple operations into a single logical unit, which must either 
    be fully completed or entirely rolled back in case of failure.
  </p>

  <h3 style="color: #16a085;">Key Properties of Transactions (ACID):</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Atomicity:</b> Ensures that all operations within a transaction are completed successfully, 
        or none are applied.</li>
    <li><b>Consistency:</b> Guarantees that the database remains in a valid state before and after the transaction.</li>
    <li><b>Isolation:</b> Ensures transactions execute independently without interference from others.</li>
    <li><b>Durability:</b> Ensures that once a transaction is committed, it remains permanently stored.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Transactions</h3>
  <p style="color: #2c3e50;">
    Transactions can be classified into various types based on their execution:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Read-Only Transactions:</b> Used for retrieving data without modifying it.</li>
    <li><b>Read-Write Transactions:</b> Involves reading and modifying data, requiring commit or rollback.</li>
    <li><b>Distributed Transactions:</b> Spans multiple databases or systems and requires coordination.</li>
    <li><b>Nested Transactions:</b> Contains sub-transactions that depend on the parent transaction.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Transactions in Java (Spring Boot)</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class TransactionService {

          @Transactional
          public void performTransaction() {
              // Database operations like insert, update, delete
              // If any operation fails, rollback occurs automatically
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In the above example, the <code>@Transactional</code> annotation ensures that all operations inside 
    <code>performTransaction()</code> execute as a single unit, maintaining ACID properties.
  </p>
</div>
`
},
{
  title:`ACID Properties`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">ACID Properties</h2>
  <p style="font-size: 16px; color: #34495e;">
    ACID properties define the key characteristics that ensure the reliability of database transactions. 
    These properties—Atomicity, Consistency, Isolation, and Durability—help maintain data integrity even 
    in cases of system failures or concurrent transactions.
  </p>

  <h3 style="color: #16a085;">Understanding ACID Properties:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Atomicity:</b> Ensures that a transaction is treated as a single unit, meaning it either completes fully or not at all.</li>
    <li><b>Consistency:</b> Guarantees that the database transitions from one valid state to another, maintaining integrity constraints.</li>
    <li><b>Isolation:</b> Ensures that concurrent transactions do not interfere with each other, preventing data anomalies.</li>
    <li><b>Durability:</b> Ensures that once a transaction is committed, the changes are permanently recorded, even in case of failures.</li>
  </ul>

  <h3 style="color: #e67e22;">Why ACID Properties Are Important?</h3>
  <p style="color: #2c3e50;">
    ACID properties play a critical role in database management by ensuring data accuracy and consistency. 
    They help prevent issues like lost updates, dirty reads, and partial transactions.
  </p>

  <h3 style="color: #2980b9;">Example: Implementing ACID Transactions in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class ACIDTransactionService {

          @Transactional
          public void executeTransaction() {
              // Perform multiple database operations
              // If any operation fails, rollback ensures atomicity
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The <code>@Transactional</code> annotation in the above example ensures that all operations inside 
    <code>executeTransaction()</code> adhere to ACID properties, maintaining database reliability.
  </p>
</div>
`
},
{
  title:`Transaction Management in Spring`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Management in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction management in Spring ensures data consistency and integrity by handling transactions efficiently. 
    Spring provides declarative and programmatic transaction management, allowing developers to control 
    transactional behavior with minimal effort.
  </p>

  <h3 style="color: #16a085;">Key Features of Spring Transaction Management:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Declarative Transaction Management:</b> Uses annotations like <code>@Transactional</code> to manage transactions automatically.</li>
    <li><b>Programmatic Transaction Management:</b> Provides finer control using the <code>TransactionTemplate</code> API or <code>PlatformTransactionManager</code>.</li>
    <li><b>Rollback and Commit:</b> Supports automatic rollback on exceptions and commit on successful execution.</li>
    <li><b>Propagation Behavior:</b> Defines how transactions interact with existing transactions.</li>
    <li><b>Isolation Levels:</b> Controls the visibility of transaction changes to other concurrent transactions.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Transaction Management?</h3>
  <p style="color: #2c3e50;">
    Transaction management ensures data consistency, prevents corruption, and supports concurrent data access in a reliable manner. 
    It is essential for enterprise applications that involve multiple database operations.
  </p>

  <h3 style="color: #2980b9;">Example: Implementing Transaction Management in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class TransactionService {

          @Transactional
          public void processTransaction() {
              // Perform database operations
              // If an exception occurs, rollback ensures data consistency
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The <code>@Transactional</code> annotation in the above example ensures that all operations inside 
    <code>processTransaction()</code> are executed as a single transaction, maintaining database integrity.
  </p>
</div>
`
},
{
  title:`Declarative Transactions (@Transactional)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Declarative Transactions (@Transactional)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Declarative transaction management in Spring simplifies transaction handling by using the <code>@Transactional</code> annotation. 
    This eliminates the need for manual transaction handling, allowing developers to focus on business logic while Spring manages 
    transaction boundaries automatically.
  </p>

  <h3 style="color: #16a085;">Key Features of @Transactional:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Simplifies transaction management:</b> No need for manual transaction handling with <code>begin</code> and <code>commit</code>.</li>
    <li><b>Automatic rollback:</b> Transactions roll back on runtime exceptions by default.</li>
    <li><b>Supports propagation:</b> Defines how transactions behave when called within another transaction.</li>
    <li><b>Custom isolation levels:</b> Controls visibility of transaction changes to concurrent transactions.</li>
    <li><b>Read-only transactions:</b> Optimizes performance for non-modifying database operations.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Declarative Transactions?</h3>
  <p style="color: #2c3e50;">
    Declarative transactions provide a clean and maintainable way to manage transactions without cluttering the code with boilerplate logic. 
    It ensures data integrity while reducing the risk of transaction-related bugs.
  </p>

  <h3 style="color: #2980b9;">Example: Using @Transactional in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class AccountService {

          @Transactional
          public void transferFunds(Account fromAccount, Account toAccount, double amount) {
              fromAccount.withdraw(amount);
              toAccount.deposit(amount);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, <code>@Transactional</code> ensures that both <code>withdraw()</code> and <code>deposit()</code> 
    operations are treated as a single transaction. If any exception occurs, all changes are rolled back to maintain consistency.
  </p>
</div>`
},
{
  title:`Programmatic Transactions`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Programmatic Transactions</h2>
  <p style="font-size: 16px; color: #34495e;">
    Programmatic transaction management in Spring provides fine-grained control over transactions using the <code>TransactionTemplate</code> 
    or <code>PlatformTransactionManager</code>. Unlike declarative transactions, where Spring handles transaction boundaries automatically, 
    programmatic transactions allow developers to start, commit, and roll back transactions manually.
  </p>

  <h3 style="color: #16a085;">Key Features of Programmatic Transactions:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Explicit transaction management:</b> Developers manually control transaction boundaries.</li>
    <li><b>More flexibility:</b> Suitable for complex transactional logic requiring conditional commit or rollback.</li>
    <li><b>Works without annotations:</b> No need for <code>@Transactional</code>, making it useful for non-Spring-managed classes.</li>
    <li><b>Supports custom rollback conditions:</b> Allows rollback based on custom logic, not just exceptions.</li>
    <li><b>Uses TransactionTemplate or PlatformTransactionManager:</b> Provides a structured way to manage transactions.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Programmatic Transactions?</h3>
  <p style="color: #2c3e50;">
    While declarative transactions simplify development, programmatic transactions are useful when transactions need to be controlled 
    dynamically based on complex conditions. It provides greater flexibility but requires more code to manage.
  </p>

  <h3 style="color: #2980b9;">Example: Using TransactionTemplate in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.support.TransactionTemplate;
      import org.springframework.beans.factory.annotation.Autowired;

      @Service
      public class AccountService {

          @Autowired
          private TransactionTemplate transactionTemplate;

          public void transferFunds(Account fromAccount, Account toAccount, double amount) {
              transactionTemplate.execute(status -> {
                  fromAccount.withdraw(amount);
                  toAccount.deposit(amount);
                  return null;
              });
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, <code>transactionTemplate.execute()</code> wraps the fund transfer logic within a transaction. 
    If an exception occurs, the transaction is rolled back automatically.
  </p>
</div>`
},
{
  title:`Propagation Types (REQUIRED, REQUIRES_NEW, etc.)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Propagation Types in Spring Transactions</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, transaction propagation determines how a method should run within an existing transaction. 
    Different propagation types allow developers to control whether a new transaction is created or if an existing transaction is used.
  </p>

  <h3 style="color: #16a085;">Key Propagation Types:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>REQUIRED:</b> Uses an existing transaction if available; otherwise, creates a new one.</li>
    <li><b>REQUIRES_NEW:</b> Always creates a new transaction, suspending any existing one.</li>
    <li><b>SUPPORTS:</b> Runs within a transaction if available; otherwise, executes non-transactionally.</li>
    <li><b>NOT_SUPPORTED:</b> Always runs outside of a transaction, suspending any existing one.</li>
    <li><b>MANDATORY:</b> Requires an existing transaction; throws an exception if none exists.</li>
    <li><b>NEVER:</b> Always runs outside of a transaction and throws an exception if a transaction exists.</li>
    <li><b>NESTED:</b> Runs within a nested transaction inside an existing one.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Propagation Types?</h3>
  <p style="color: #2c3e50;">
    Propagation settings allow developers to control transaction behavior for complex scenarios. 
    For example, <code>REQUIRES_NEW</code> ensures an independent transaction, whereas <code>NESTED</code> allows partial rollbacks.
  </p>

  <h3 style="color: #2980b9;">Example: Using Propagation Types in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Propagation;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class TransactionService {

          @Transactional(propagation = Propagation.REQUIRED)
          public void methodA() {
              // Runs within an existing transaction or creates a new one
          }

          @Transactional(propagation = Propagation.REQUIRES_NEW)
          public void methodB() {
              // Always starts a new transaction
          }

          @Transactional(propagation = Propagation.NESTED)
          public void methodC() {
              // Runs within a nested transaction
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, <code>methodA()</code> uses an existing transaction or creates a new one, 
    <code>methodB()</code> always creates a new transaction, and <code>methodC()</code> runs within a nested transaction.
  </p>
</div>
`
},
{
  title:`Isolation Levels`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Isolation Levels in Spring Transactions</h2>
  <p style="font-size: 16px; color: #34495e;">
    Isolation levels define how concurrent transactions interact with each other. In Spring, these levels help prevent issues like dirty reads, non-repeatable reads, and phantom reads.
  </p>

  <h3 style="color: #16a085;">Key Isolation Levels:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>DEFAULT:</b> Uses the default isolation level of the underlying database.</li>
    <li><b>READ_UNCOMMITTED:</b> Allows reading uncommitted changes, leading to dirty reads.</li>
    <li><b>READ_COMMITTED:</b> Ensures only committed data is read, preventing dirty reads.</li>
    <li><b>REPEATABLE_READ:</b> Prevents non-repeatable reads by ensuring data remains unchanged during a transaction.</li>
    <li><b>SERIALIZABLE:</b> The highest level, ensuring full isolation by locking rows, preventing all concurrency issues.</li>
  </ul>

  <h3 style="color: #e67e22;">Why Use Isolation Levels?</h3>
  <p style="color: #2c3e50;">
    Choosing the right isolation level balances performance and consistency. For example, <code>READ_COMMITTED</code> is commonly used to prevent dirty reads, while <code>SERIALIZABLE</code> ensures strict data integrity at the cost of performance.
  </p>

  <h3 style="color: #2980b9;">Example: Setting Isolation Levels in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Isolation;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class TransactionService {

          @Transactional(isolation = Isolation.READ_COMMITTED)
          public void methodA() {
              // Ensures only committed data is read
          }

          @Transactional(isolation = Isolation.REPEATABLE_READ)
          public void methodB() {
              // Prevents non-repeatable reads
          }

          @Transactional(isolation = Isolation.SERIALIZABLE)
          public void methodC() {
              // Ensures full isolation by locking rows
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, <code>methodA()</code> ensures only committed data is read, <code>methodB()</code> prevents non-repeatable reads, and <code>methodC()</code> ensures full isolation.
  </p>
</div>
`
},
{
  title:`Transaction Rollback`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Rollback in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction rollback is a mechanism used to revert a transaction in case of failure or exceptions. In Spring, rollback behavior can be controlled using the <code>@Transactional</code> annotation.
  </p>

  <h3 style="color: #16a085;">Key Aspects of Transaction Rollback:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Rollback on Runtime Exceptions:</b> By default, transactions are rolled back only for unchecked exceptions (subclasses of <code>RuntimeException</code>).</li>
    <li><b>Rollback on Checked Exceptions:</b> Spring does not roll back on checked exceptions unless explicitly specified.</li>
    <li><b>Programmatic Rollback:</b> Transactions can be manually rolled back using <code>TransactionStatus</code>.</li>
    <li><b>Selective Rollback Control:</b> Developers can configure rollback behavior for specific exception types.</li>
  </ul>

  <h3 style="color: #e67e22;">Configuring Rollback Behavior</h3>
  <p style="color: #2c3e50;">
    The <code>@Transactional</code> annotation provides options to specify rollback conditions. For example:
  </p>

  <h3 style="color: #2980b9;">Example: Rollback in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class TransactionService {

          @Transactional(rollbackFor = Exception.class)
          public void methodA() throws Exception {
              // Transaction will roll back for any exception
              throw new Exception("Checked exception, but rollback enabled");
          }

          @Transactional(noRollbackFor = IllegalArgumentException.class)
          public void methodB() {
              // Transaction will NOT roll back for IllegalArgumentException
              throw new IllegalArgumentException("No rollback for this exception");
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, <code>methodA()</code> rolls back for all exceptions, including checked exceptions, while <code>methodB()</code> prevents rollback for <code>IllegalArgumentException</code>.
  </p>
</div>`
},
{
  title:`Transaction Timeout`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Timeout in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction timeout is a mechanism that limits the maximum duration a transaction can run. If a transaction exceeds the specified time limit, it will be automatically rolled back. Spring provides transaction timeout control using the <code>@Transactional</code> annotation.
  </p>

  <h3 style="color: #16a085;">Key Aspects of Transaction Timeout:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Preventing Long-Running Transactions:</b> Timeout settings help avoid database locks and performance issues.</li>
    <li><b>Global vs. Local Timeout:</b> Timeout can be set globally in configuration or per method using annotations.</li>
    <li><b>Rollback on Timeout:</b> If a transaction times out, it is automatically rolled back.</li>
    <li><b>Custom Timeout Values:</b> Developers can specify timeout values based on business requirements.</li>
  </ul>

  <h3 style="color: #e67e22;">Configuring Transaction Timeout</h3>
  <p style="color: #2c3e50;">
    The <code>@Transactional</code> annotation provides an option to specify timeout in seconds. For example:
  </p>

  <h3 style="color: #2980b9;">Example: Transaction Timeout in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class TransactionService {

          @Transactional(timeout = 5)
          public void processTransaction() {
              try {
                  Thread.sleep(6000); // Simulating long processing time
              } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
              }
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, the transaction will be rolled back if it runs longer than 5 seconds due to the timeout setting.
  </p>
</div>
`
},
{
  title:`Transaction Management in Microservices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction Management in Microservices</h2>
  <p style="font-size: 16px; color: #34495e;">
    In a microservices architecture, transaction management becomes complex due to the distributed nature of services. Unlike monolithic applications, microservices require specialized techniques to maintain data consistency across multiple services.
  </p>

  <h3 style="color: #16a085;">Challenges in Microservices Transactions:</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Distributed Transactions:</b> Data is spread across multiple services and databases.</li>
    <li><b>Network Latency:</b> Transactions need to account for network delays.</li>
    <li><b>Failure Handling:</b> Partial failures can cause data inconsistency.</li>
    <li><b>Scalability:</b> Transaction handling should not degrade performance.</li>
  </ul>

  <h3 style="color: #e67e22;">Approaches to Transaction Management in Microservices</h3>
  <p style="color: #2c3e50;">
    There are two common approaches to managing transactions in microservices:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Two-Phase Commit (2PC):</b> Ensures atomic transactions but can be slow and complex.</li>
    <li><b>Saga Pattern:</b> A sequence of compensating transactions ensures eventual consistency.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Saga Pattern Implementation</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {

          @Transactional
          public void createOrder() {
              // Step 1: Create Order
              // Step 2: Deduct Inventory
              // Step 3: Process Payment
              // Step 4: Handle failure with compensating transactions
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    The Saga pattern breaks a transaction into smaller steps, each with a compensating transaction to maintain consistency in case of failures.
  </p>
</div>
`
},
{
  title:`Nested Transactions`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Nested Transactions</h2>
  <p style="font-size: 16px; color: #34495e;">
    Nested transactions allow transactions to be structured hierarchically. When a nested transaction occurs within a parent transaction, it either commits or rolls back independently while maintaining consistency with the main transaction.
  </p>

  <h3 style="color: #16a085;">Why Use Nested Transactions?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Modular Transaction Handling:</b> Each sub-transaction can be managed separately.</li>
    <li><b>Rollback Control:</b> A failure in a nested transaction does not necessarily abort the entire parent transaction.</li>
    <li><b>Improved Maintainability:</b> Code is more structured with clear transactional boundaries.</li>
  </ul>

  <h3 style="color: #e67e22;">Nested Transactions in Spring</h3>
  <p style="color: #2c3e50;">
    Spring provides nested transactions through <code>PROPAGATION_NESTED</code>. This allows a sub-transaction to be executed within a parent transaction.
  </p>

  <h3 style="color: #2980b9;">Example: Implementing Nested Transactions</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Propagation;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class PaymentService {

          @Transactional(propagation = Propagation.REQUIRED)
          public void processPayment() {
              // Parent transaction
              deductAmount();
              saveTransactionRecord();
          }

          @Transactional(propagation = Propagation.NESTED)
          public void saveTransactionRecord() {
              // Nested transaction
              // Save transaction details
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this example, if <code>saveTransactionRecord()</code> fails, it will roll back without affecting <code>processPayment()</code>, maintaining a level of isolation.
  </p>
</div>
`
},
{
  title:`Transaction in Spring Boot`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Spring Boot</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transaction management in Spring Boot ensures data consistency by handling commit and rollback operations effectively. 
    Spring Boot provides built-in support for transactions using the Spring Framework's declarative and programmatic transaction management features.
  </p>

  <h3 style="color: #16a085;">Why Use Transactions in Spring Boot?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Ensures Data Integrity:</b> Transactions help maintain consistency across multiple database operations.</li>
    <li><b>Automatic Rollback:</b> If an operation fails, changes are undone to prevent partial updates.</li>
    <li><b>Simplified Management:</b> Spring Boot offers annotations like <code>@Transactional</code> to manage transactions easily.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Transaction Management in Spring Boot</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Declarative Transactions:</b> Uses annotations like <code>@Transactional</code> to manage transactions automatically.</li>
    <li><b>Programmatic Transactions:</b> Gives manual control over transactions using <code>TransactionTemplate</code> or <code>PlatformTransactionManager</code>.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Declarative Transaction Management</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {

          @Transactional
          public void placeOrder() {
              // Transaction starts
              processPayment();
              saveOrderDetails();
              // Transaction commits automatically
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Example: Programmatic Transaction Management</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.PlatformTransactionManager;
      import org.springframework.transaction.TransactionDefinition;
      import org.springframework.transaction.TransactionStatus;
      import org.springframework.transaction.support.DefaultTransactionDefinition;

      @Service
      public class PaymentService {
          
          @Autowired
          private PlatformTransactionManager transactionManager;

          public void processPayment() {
              TransactionDefinition def = new DefaultTransactionDefinition();
              TransactionStatus status = transactionManager.getTransaction(def);
              
              try {
                  // Perform transactional operations
                  transactionManager.commit(status);
              } catch (Exception e) {
                  transactionManager.rollback(status);
              }
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    Using transaction management in Spring Boot ensures data integrity and helps prevent inconsistencies in applications handling multiple database operations.
  </p>
</div>
`
},
{
  title:`Database Transaction Support (JPA, JDBC)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Database Transaction Support (JPA, JDBC)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Boot provides robust support for database transactions using JPA (Java Persistence API) and JDBC (Java Database Connectivity). 
    These approaches ensure consistency and integrity of data across multiple operations.
  </p>

  <h3 style="color: #16a085;">Transaction Management with JPA</h3>
  <p style="color: #2c3e50;">
    JPA, commonly used with Hibernate, simplifies database interactions with an object-relational mapping (ORM) approach. 
    Spring Boot supports JPA transactions using the <code>@Transactional</code> annotation.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class UserService {
          
          @Transactional
          public void registerUser() {
              // Perform multiple database operations
              saveUserDetails();
              sendConfirmationEmail();
          }
      }
    </code>
  </pre>

  <h3 style="color: #e67e22;">Transaction Management with JDBC</h3>
  <p style="color: #2c3e50;">
    JDBC provides a lower-level approach for managing transactions, typically using the <code>PlatformTransactionManager</code> interface.
  </p>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.jdbc.core.JdbcTemplate;
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.PlatformTransactionManager;
      import org.springframework.transaction.TransactionDefinition;
      import org.springframework.transaction.TransactionStatus;
      import org.springframework.transaction.support.DefaultTransactionDefinition;

      @Service
      public class BankService {
          
          @Autowired
          private PlatformTransactionManager transactionManager;
          
          @Autowired
          private JdbcTemplate jdbcTemplate;

          public void transferMoney() {
              TransactionDefinition def = new DefaultTransactionDefinition();
              TransactionStatus status = transactionManager.getTransaction(def);

              try {
                  jdbcTemplate.update("UPDATE accounts SET balance = balance - ? WHERE id = ?", 100, 1);
                  jdbcTemplate.update("UPDATE accounts SET balance = balance + ? WHERE id = ?", 100, 2);
                  transactionManager.commit(status);
              } catch (Exception e) {
                  transactionManager.rollback(status);
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #2980b9;">Choosing Between JPA and JDBC</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Use JPA:</b> When working with ORM frameworks like Hibernate for simplified database interaction.</li>
    <li><b>Use JDBC:</b> When performance is critical, and direct database queries are preferred.</li>
  </ul>

  <p style="color: #2c3e50;">
    Both JPA and JDBC offer powerful transaction management in Spring Boot, enabling robust and consistent data operations.
  </p>
</div>
`
},
{
  title:`Transaction in Distributed Systems`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Distributed Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, transactions span multiple databases, services, or microservices, making consistency and reliability crucial. 
    Traditional ACID transactions may not be feasible, leading to alternative approaches like the Two-Phase Commit (2PC) and Saga Pattern.
  </p>

  <h3 style="color: #16a085;">Two-Phase Commit (2PC)</h3>
  <p style="color: #2c3e50;">
    The Two-Phase Commit protocol ensures consistency in distributed transactions by coordinating multiple resource managers.
    It consists of two phases: 
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Prepare Phase:</b> The coordinator asks all participants if they can commit.</li>
    <li><b>Commit Phase:</b> If all agree, the transaction is committed; otherwise, it is rolled back.</li>
  </ul>

  <h3 style="color: #e67e22;">Saga Pattern</h3>
  <p style="color: #2c3e50;">
    The Saga Pattern divides a large transaction into smaller, independent transactions with compensating actions to handle failures.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Choreography:</b> Each service triggers the next step in the saga.</li>
    <li><b>Orchestration:</b> A central coordinator manages the transaction steps.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Saga Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {
          @Transactional
          public void createOrder() {
              processPayment();
              reserveInventory();
              confirmOrder();
          }

          private void processPayment() { /* Payment logic */ }
          private void reserveInventory() { /* Inventory logic */ }
          private void confirmOrder() { /* Order confirmation */ }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Challenges in Distributed Transactions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Network latency and service failures.</li>
    <li>Handling data consistency across services.</li>
    <li>Compensating failed transactions in the Saga Pattern.</li>
  </ul>

  <p style="color: #2c3e50;">
    Distributed transaction management is crucial for modern microservices architectures. 
    Choosing between 2PC and Saga depends on performance, consistency needs, and system design.
  </p>
</div>
`
},
{
  title:`Transaction Best Practices`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Distributed Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, transactions span multiple databases, services, or microservices, making consistency and reliability crucial. 
    Traditional ACID transactions may not be feasible, leading to alternative approaches like the Two-Phase Commit (2PC) and Saga Pattern.
  </p>

  <h3 style="color: #16a085;">Two-Phase Commit (2PC)</h3>
  <p style="color: #2c3e50;">
    The Two-Phase Commit protocol ensures consistency in distributed transactions by coordinating multiple resource managers.
    It consists of two phases: 
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Prepare Phase:</b> The coordinator asks all participants if they can commit.</li>
    <li><b>Commit Phase:</b> If all agree, the transaction is committed; otherwise, it is rolled back.</li>
  </ul>

  <h3 style="color: #e67e22;">Saga Pattern</h3>
  <p style="color: #2c3e50;">
    The Saga Pattern divides a large transaction into smaller, independent transactions with compensating actions to handle failures.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Choreography:</b> Each service triggers the next step in the saga.</li>
    <li><b>Orchestration:</b> A central coordinator manages the transaction steps.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Saga Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {
          @Transactional
          public void createOrder() {
              processPayment();
              reserveInventory();
              confirmOrder();
          }

          private void processPayment() { /* Payment logic */ }
          private void reserveInventory() { /* Inventory logic */ }
          private void confirmOrder() { /* Order confirmation */ }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Challenges in Distributed Transactions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Network latency and service failures.</li>
    <li>Handling data consistency across services.</li>
    <li>Compensating failed transactions in the Saga Pattern.</li>
  </ul>

  <p style="color: #2c3e50;">
    Distributed transaction management is crucial for modern microservices architectures. 
    Choosing between 2PC and Saga depends on performance, consistency needs, and system design.
  </p>
</div>
`
},
{
  title:`Transaction Error Handling`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Distributed Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, transactions span multiple databases, services, or microservices, making consistency and reliability crucial. 
    Traditional ACID transactions may not be feasible, leading to alternative approaches like the Two-Phase Commit (2PC) and Saga Pattern.
  </p>

  <h3 style="color: #16a085;">Two-Phase Commit (2PC)</h3>
  <p style="color: #2c3e50;">
    The Two-Phase Commit protocol ensures consistency in distributed transactions by coordinating multiple resource managers.
    It consists of two phases: 
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Prepare Phase:</b> The coordinator asks all participants if they can commit.</li>
    <li><b>Commit Phase:</b> If all agree, the transaction is committed; otherwise, it is rolled back.</li>
  </ul>

  <h3 style="color: #e67e22;">Saga Pattern</h3>
  <p style="color: #2c3e50;">
    The Saga Pattern divides a large transaction into smaller, independent transactions with compensating actions to handle failures.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Choreography:</b> Each service triggers the next step in the saga.</li>
    <li><b>Orchestration:</b> A central coordinator manages the transaction steps.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Saga Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {
          @Transactional
          public void createOrder() {
              processPayment();
              reserveInventory();
              confirmOrder();
          }

          private void processPayment() { /* Payment logic */ }
          private void reserveInventory() { /* Inventory logic */ }
          private void confirmOrder() { /* Order confirmation */ }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Challenges in Distributed Transactions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Network latency and service failures.</li>
    <li>Handling data consistency across services.</li>
    <li>Compensating failed transactions in the Saga Pattern.</li>
  </ul>

  <p style="color: #2c3e50;">
    Distributed transaction management is crucial for modern microservices architectures. 
    Choosing between 2PC and Saga depends on performance, consistency needs, and system design.
  </p>
</div> `
},
{
  title:`Transaction with Multiple Data Sources`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Distributed Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, transactions span multiple databases, services, or microservices, making consistency and reliability crucial. 
    Traditional ACID transactions may not be feasible, leading to alternative approaches like the Two-Phase Commit (2PC) and Saga Pattern.
  </p>

  <h3 style="color: #16a085;">Two-Phase Commit (2PC)</h3>
  <p style="color: #2c3e50;">
    The Two-Phase Commit protocol ensures consistency in distributed transactions by coordinating multiple resource managers.
    It consists of two phases: 
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Prepare Phase:</b> The coordinator asks all participants if they can commit.</li>
    <li><b>Commit Phase:</b> If all agree, the transaction is committed; otherwise, it is rolled back.</li>
  </ul>

  <h3 style="color: #e67e22;">Saga Pattern</h3>
  <p style="color: #2c3e50;">
    The Saga Pattern divides a large transaction into smaller, independent transactions with compensating actions to handle failures.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Choreography:</b> Each service triggers the next step in the saga.</li>
    <li><b>Orchestration:</b> A central coordinator manages the transaction steps.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Saga Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {
          @Transactional
          public void createOrder() {
              processPayment();
              reserveInventory();
              confirmOrder();
          }

          private void processPayment() { /* Payment logic */ }
          private void reserveInventory() { /* Inventory logic */ }
          private void confirmOrder() { /* Order confirmation */ }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Challenges in Distributed Transactions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Network latency and service failures.</li>
    <li>Handling data consistency across services.</li>
    <li>Compensating failed transactions in the Saga Pattern.</li>
  </ul>

  <p style="color: #2c3e50;">
    Distributed transaction management is crucial for modern microservices architectures. 
    Choosing between 2PC and Saga depends on performance, consistency needs, and system design.
  </p>
</div>
`
},
{
  title:`Testing Transactions`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Distributed Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, transactions span multiple databases, services, or microservices, making consistency and reliability crucial. 
    Traditional ACID transactions may not be feasible, leading to alternative approaches like the Two-Phase Commit (2PC) and Saga Pattern.
  </p>

  <h3 style="color: #16a085;">Two-Phase Commit (2PC)</h3>
  <p style="color: #2c3e50;">
    The Two-Phase Commit protocol ensures consistency in distributed transactions by coordinating multiple resource managers.
    It consists of two phases: 
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Prepare Phase:</b> The coordinator asks all participants if they can commit.</li>
    <li><b>Commit Phase:</b> If all agree, the transaction is committed; otherwise, it is rolled back.</li>
  </ul>

  <h3 style="color: #e67e22;">Saga Pattern</h3>
  <p style="color: #2c3e50;">
    The Saga Pattern divides a large transaction into smaller, independent transactions with compensating actions to handle failures.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Choreography:</b> Each service triggers the next step in the saga.</li>
    <li><b>Orchestration:</b> A central coordinator manages the transaction steps.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Saga Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {
          @Transactional
          public void createOrder() {
              processPayment();
              reserveInventory();
              confirmOrder();
          }

          private void processPayment() { /* Payment logic */ }
          private void reserveInventory() { /* Inventory logic */ }
          private void confirmOrder() { /* Order confirmation */ }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Challenges in Distributed Transactions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Network latency and service failures.</li>
    <li>Handling data consistency across services.</li>
    <li>Compensating failed transactions in the Saga Pattern.</li>
  </ul>

  <p style="color: #2c3e50;">
    Distributed transaction management is crucial for modern microservices architectures. 
    Choosing between 2PC and Saga depends on performance, consistency needs, and system design.
  </p>
</div>
`
},
{
  title:`Event-Driven Transactions`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Distributed Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, transactions span multiple databases, services, or microservices, making consistency and reliability crucial. 
    Traditional ACID transactions may not be feasible, leading to alternative approaches like the Two-Phase Commit (2PC) and Saga Pattern.
  </p>

  <h3 style="color: #16a085;">Two-Phase Commit (2PC)</h3>
  <p style="color: #2c3e50;">
    The Two-Phase Commit protocol ensures consistency in distributed transactions by coordinating multiple resource managers.
    It consists of two phases: 
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Prepare Phase:</b> The coordinator asks all participants if they can commit.</li>
    <li><b>Commit Phase:</b> If all agree, the transaction is committed; otherwise, it is rolled back.</li>
  </ul>

  <h3 style="color: #e67e22;">Saga Pattern</h3>
  <p style="color: #2c3e50;">
    The Saga Pattern divides a large transaction into smaller, independent transactions with compensating actions to handle failures.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Choreography:</b> Each service triggers the next step in the saga.</li>
    <li><b>Orchestration:</b> A central coordinator manages the transaction steps.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Saga Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {
          @Transactional
          public void createOrder() {
              processPayment();
              reserveInventory();
              confirmOrder();
          }

          private void processPayment() { /* Payment logic */ }
          private void reserveInventory() { /* Inventory logic */ }
          private void confirmOrder() { /* Order confirmation */ }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Challenges in Distributed Transactions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Network latency and service failures.</li>
    <li>Handling data consistency across services.</li>
    <li>Compensating failed transactions in the Saga Pattern.</li>
  </ul>

  <p style="color: #2c3e50;">
    Distributed transaction management is crucial for modern microservices architectures. 
    Choosing between 2PC and Saga depends on performance, consistency needs, and system design.
  </p>
</div>
`
},
{
  title:`Optimistic vs Pessimistic Locking`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Transaction in Distributed Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, transactions span multiple databases, services, or microservices, making consistency and reliability crucial. 
    Traditional ACID transactions may not be feasible, leading to alternative approaches like the Two-Phase Commit (2PC) and Saga Pattern.
  </p>

  <h3 style="color: #16a085;">Two-Phase Commit (2PC)</h3>
  <p style="color: #2c3e50;">
    The Two-Phase Commit protocol ensures consistency in distributed transactions by coordinating multiple resource managers.
    It consists of two phases: 
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Prepare Phase:</b> The coordinator asks all participants if they can commit.</li>
    <li><b>Commit Phase:</b> If all agree, the transaction is committed; otherwise, it is rolled back.</li>
  </ul>

  <h3 style="color: #e67e22;">Saga Pattern</h3>
  <p style="color: #2c3e50;">
    The Saga Pattern divides a large transaction into smaller, independent transactions with compensating actions to handle failures.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><b>Choreography:</b> Each service triggers the next step in the saga.</li>
    <li><b>Orchestration:</b> A central coordinator manages the transaction steps.</li>
  </ul>

  <h3 style="color: #2980b9;">Example: Implementing Saga Pattern in Spring Boot</h3>
  <pre style="background: rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code codeHighlight class="language-java">
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;

      @Service
      public class OrderService {
          @Transactional
          public void createOrder() {
              processPayment();
              reserveInventory();
              confirmOrder();
          }

          private void processPayment() { /* Payment logic */ }
          private void reserveInventory() { /* Inventory logic */ }
          private void confirmOrder() { /* Order confirmation */ }
      }
    </code>
  </pre>

  <h3 style="color: #e74c3c;">Challenges in Distributed Transactions</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Network latency and service failures.</li>
    <li>Handling data consistency across services.</li>
    <li>Compensating failed transactions in the Saga Pattern.</li>
  </ul>

  <p style="color: #2c3e50;">
    Distributed transaction management is crucial for modern microservices architectures. 
    Choosing between 2PC and Saga depends on performance, consistency needs, and system design.
  </p>
</div> `
},
{
  title:`Messaging Basics`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Messaging Basics</h2>
  <p style="font-size: 16px; color: #34495e;">
    Messaging is a fundamental concept in distributed systems that enables communication between different components or applications asynchronously. It facilitates decoupling, scalability, and reliability in modern software architectures.
  </p>

  <h3 style="color: #16a085;">What is Messaging?</h3>
  <p style="color: #2c3e50;">
    Messaging refers to the process of exchanging data between applications or services using message queues, topics, or streams. Messages can be textual, binary, or structured data, and they are typically used to ensure smooth communication in event-driven systems.
  </p>

  <h3 style="color: #e67e22;">Key Components of Messaging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Message</strong>: A unit of data sent from one system to another.</li>
    <li><strong>Producer</strong>: The sender that generates and sends messages.</li>
    <li><strong>Consumer</strong>: The receiver that processes incoming messages.</li>
    <li><strong>Message Queue</strong>: A middleware that holds messages until they are processed.</li>
    <li><strong>Message Broker</strong>: A service that routes messages between producers and consumers.</li>
  </ul>

  <h3 style="color: #8e44ad;">Types of Messaging Systems</h3>
  <p style="color: #2c3e50;">
    Messaging systems can be classified into different types based on how they handle message delivery and communication patterns.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Point-to-Point Messaging</strong>: A direct communication model where one producer sends a message to one consumer via a queue.</li>
    <li><strong>Publish-Subscribe Messaging</strong>: A broadcasting model where messages are published to a topic, and multiple consumers subscribe to receive them.</li>
    <li><strong>Request-Response Messaging</strong>: A synchronous communication model where a producer sends a request and waits for a response from the consumer.</li>
  </ul>

  <h3 style="color: #d35400;">Example: Implementing Messaging with RabbitMQ</h3>
  <p style="color: #2c3e50;">
    RabbitMQ is a popular message broker used to implement messaging systems. Below is an example of sending and receiving messages using Spring Boot with RabbitMQ.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.rabbit.core.RabbitTemplate;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      
      @Service
      public class MessageProducer {
          @Autowired
          private RabbitTemplate rabbitTemplate;
          
          public void sendMessage(String message) {
              rabbitTemplate.convertAndSend("myQueue", message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices for Messaging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>durable queues</strong> to ensure message persistence.</li>
    <li>Implement <strong>message retries</strong> and dead-letter queues for fault tolerance.</li>
    <li>Use <strong>message compression</strong> to optimize bandwidth usage.</li>
    <li>Monitor and log message processing for debugging and performance tuning.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Messaging is an essential component of modern distributed systems, enabling asynchronous communication, load balancing, and fault tolerance. Understanding messaging patterns and best practices helps in building efficient and scalable applications.
  </p>
</div>
`
},

{
  title:`Message Queues (RabbitMQ, ActiveMQ)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Message Queues (RabbitMQ, ActiveMQ)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Message queues are an essential component of distributed systems, enabling asynchronous communication between services. They improve system scalability, reliability, and decoupling by ensuring messages are delivered even if the receiver is unavailable.
  </p>

  <h3 style="color: #16a085;">What are Message Queues?</h3>
  <p style="color: #2c3e50;">
    A message queue is a middleware that temporarily stores messages until they are retrieved and processed by consumers. This mechanism ensures smooth data flow between applications, even during network failures or system crashes.
  </p>

  <h3 style="color: #e67e22;">Key Benefits of Message Queues</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Decoupling</strong>: Enables independent development of producer and consumer services.</li>
    <li><strong>Scalability</strong>: Supports load balancing by distributing messages among multiple consumers.</li>
    <li><strong>Reliability</strong>: Ensures message persistence and delivery even in case of system failures.</li>
    <li><strong>Asynchronous Processing</strong>: Improves system efficiency by allowing non-blocking message exchange.</li>
  </ul>

  <h3 style="color: #8e44ad;">Popular Message Queues</h3>
  <p style="color: #2c3e50;">
    Two widely used message queues are <strong>RabbitMQ</strong> and <strong>ActiveMQ</strong>. Both offer robust messaging capabilities but cater to different needs.
  </p>

  <h4 style="color: #2980b9;">RabbitMQ</h4>
  <p style="color: #2c3e50;">
    RabbitMQ is a lightweight, high-performance message broker that supports various messaging patterns and ensures reliable delivery using the AMQP (Advanced Message Queuing Protocol).
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Supports multiple messaging protocols (AMQP, MQTT, STOMP, etc.).</li>
    <li>Ensures message durability using persistent queues.</li>
    <li>Provides flexible routing mechanisms with exchanges.</li>
  </ul>

  <h4 style="color: #c0392b;">ActiveMQ</h4>
  <p style="color: #2c3e50;">
    ActiveMQ is an open-source message broker developed by Apache, supporting JMS (Java Message Service) and various communication models.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Supports both point-to-point and publish-subscribe messaging models.</li>
    <li>Offers message persistence with database and file storage options.</li>
    <li>Provides robust clustering and failover mechanisms.</li>
  </ul>

  <h3 style="color: #d35400;">Example: Using RabbitMQ in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Below is a simple example of integrating RabbitMQ with Spring Boot.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.rabbit.core.RabbitTemplate;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      
      @Service
      public class RabbitMQProducer {
          @Autowired
          private RabbitTemplate rabbitTemplate;
          
          public void sendMessage(String message) {
              rabbitTemplate.convertAndSend("myQueue", message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Best Practices for Using Message Queues</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>durable queues</strong> to prevent message loss.</li>
    <li>Implement <strong>dead-letter queues</strong> to handle failed messages.</li>
    <li>Monitor queue performance and optimize resource allocation.</li>
    <li>Use <strong>message acknowledgments</strong> to ensure reliable processing.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message queues like RabbitMQ and ActiveMQ play a crucial role in modern distributed systems by enabling reliable, asynchronous communication. Choosing the right message broker depends on factors such as performance requirements, scalability, and protocol support.
  </p>
</div>
`
},

{
  title:`Publish-Subscribe Pattern`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding the Publish-Subscribe Pattern</h2>
  <p style="font-size: 16px; color: #34495e;">
    The <strong>Publish-Subscribe (Pub/Sub) Pattern</strong> is a messaging architecture that enables the asynchronous exchange of messages between different components of a system. This pattern enhances scalability and decoupling by allowing publishers to send messages without knowing which subscribers will receive them.
  </p>

  <h3 style="color: #16a085;">Why Use the Publish-Subscribe Pattern?</h3>
  <p style="color: #2c3e50;">
    The Pub/Sub pattern offers several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Decoupling</strong>: Publishers and subscribers are independent, leading to flexible and scalable systems.</li>
    <li><strong>Asynchronous Communication</strong>: Improves responsiveness by enabling non-blocking message delivery.</li>
    <li><strong>Scalability</strong>: Supports dynamic addition or removal of subscribers without affecting publishers.</li>
    <li><strong>Multiple Subscribers</strong>: A single message can reach multiple subscribers, promoting efficient communication.</li>
  </ul>

  <h3 style="color: #e67e22;">How the Publish-Subscribe Pattern Works</h3>
  <p style="color: #2c3e50;">
    The Pub/Sub model involves three main components:
  </p>
  <ol style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Publisher</strong>: Sends messages (events) without concern for who receives them.</li>
    <li><strong>Subscriber</strong>: Listens for specific messages and processes them accordingly.</li>
    <li><strong>Message Broker</strong>: Routes messages from publishers to appropriate subscribers.</li>
  </ol>

  <h3 style="color: #8e44ad;">Example Implementation with RabbitMQ</h3>
  <p style="color: #2c3e50;">
    RabbitMQ is a popular message broker that supports the Publish-Subscribe pattern. Below is a simple example using Spring Boot.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.rabbit.core.RabbitTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class PublisherService {
          private final RabbitTemplate rabbitTemplate;

          public PublisherService(RabbitTemplate rabbitTemplate) {
              this.rabbitTemplate = rabbitTemplate;
          }

          public void publishMessage(String message) {
              rabbitTemplate.convertAndSend("exchangeName", "routingKey", message);
              System.out.println("Message Published: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Subscriber Implementation</h3>
  <p style="color: #2c3e50;">
    The subscriber listens for messages from the broker and processes them.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.rabbit.annotation.RabbitListener;
      import org.springframework.stereotype.Service;

      @Service
      public class SubscriberService {
          @RabbitListener(queues = "queueName")
          public void receiveMessage(String message) {
              System.out.println("Received Message: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using the Publish-Subscribe Pattern</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use message brokers like <strong>RabbitMQ, Apache Kafka, or Redis</strong> for reliable message delivery.</li>
    <li>Ensure proper <strong>error handling</strong> to avoid message loss.</li>
    <li>Use <strong>durable queues</strong> for persistent message storage.</li>
    <li>Implement <strong>dead-letter queues</strong> to handle failed messages.</li>
    <li>Monitor system performance and optimize message throughput.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    The <strong>Publish-Subscribe Pattern</strong> is an essential design model for building scalable, decoupled, and asynchronous applications. By using message brokers like RabbitMQ or Kafka, developers can efficiently distribute messages across multiple subscribers, improving system flexibility and performance.
  </p>
</div>
`
},

{
  title:`Message Brokers`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Message Brokers</h2>
  <p style="font-size: 16px; color: #34495e;">
    A <strong>Message Broker</strong> is a middleware system that enables communication between different applications, services, or systems. It helps in transmitting messages asynchronously, ensuring reliability, scalability, and decoupling between components.
  </p>

  <h3 style="color: #16a085;">Why Use a Message Broker?</h3>
  <p style="color: #2c3e50;">
    Message brokers offer several advantages, making them essential for modern distributed systems:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Asynchronous Communication</strong>: Enables decoupling between producers and consumers.</li>
    <li><strong>Scalability</strong>: Handles high loads efficiently by distributing messages.</li>
    <li><strong>Reliability</strong>: Ensures message delivery even if some services are temporarily unavailable.</li>
    <li><strong>Load Balancing</strong>: Distributes workload among multiple consumers.</li>
    <li><strong>Fault Tolerance</strong>: Prevents data loss through persistent storage and retry mechanisms.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Message Brokers</h3>
  <p style="color: #2c3e50;">
    There are different types of message brokers, including:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Queue-Based Brokers</strong>: Messages are stored in a queue and processed by consumers (e.g., RabbitMQ, ActiveMQ).</li>
    <li><strong>Publish-Subscribe Brokers</strong>: Messages are broadcast to multiple subscribers (e.g., Kafka, Redis Pub/Sub).</li>
    <li><strong>Hybrid Brokers</strong>: Combine queue-based and pub-sub messaging (e.g., Azure Service Bus, Amazon SQS).</li>
  </ul>

  <h3 style="color: #8e44ad;">Popular Message Brokers</h3>
  <p style="color: #2c3e50;">Here are some widely used message brokers:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>RabbitMQ</strong>: Open-source, queue-based broker with support for complex routing.</li>
    <li><strong>Apache Kafka</strong>: Distributed event streaming platform designed for high throughput.</li>
    <li><strong>ActiveMQ</strong>: Java-based message broker supporting multiple protocols.</li>
    <li><strong>Redis Pub/Sub</strong>: Lightweight broker supporting real-time message delivery.</li>
    <li><strong>Amazon SQS</strong>: Fully managed message queuing service by AWS.</li>
  </ul>

  <h3 style="color: #d35400;">Example: Using RabbitMQ in Spring Boot</h3>
  <p style="color: #2c3e50;">Below is an example of how to use RabbitMQ in a Spring Boot application.</p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.rabbit.annotation.RabbitListener;
      import org.springframework.amqp.rabbit.core.RabbitTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class MessageService {
          private final RabbitTemplate rabbitTemplate;

          public MessageService(RabbitTemplate rabbitTemplate) {
              this.rabbitTemplate = rabbitTemplate;
          }

          public void sendMessage(String message) {
              rabbitTemplate.convertAndSend("queue_name", message);
          }

          @RabbitListener(queues = "queue_name")
          public void receiveMessage(String message) {
              System.out.println("Received message: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Message Brokers</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use appropriate message acknowledgment strategies.</li>
    <li>Optimize message size to reduce latency.</li>
    <li>Ensure message persistence for reliability.</li>
    <li>Monitor broker performance and configure retry policies.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message brokers play a crucial role in modern distributed architectures by enabling reliable and scalable message communication. Choosing the right broker depends on the use case, performance requirements, and scalability needs.
  </p>
</div>
`
},

{
  title:`JMS (Java Message Service)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding JMS (Java Message Service)</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Message Service (JMS) is a Java API that allows applications to create, send, receive, and read messages asynchronously. It is widely used for reliable, loosely coupled communication in distributed systems.
  </p>

  <h3 style="color: #16a085;">Why Use JMS?</h3>
  <p style="color: #2c3e50;">
    JMS provides several advantages for enterprise applications:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Asynchronous Communication</strong>: Enables message-driven architecture.</li>
    <li><strong>Reliability</strong>: Supports durable messaging for guaranteed delivery.</li>
    <li><strong>Scalability</strong>: Decouples components, allowing them to scale independently.</li>
    <li><strong>Interoperability</strong>: Works with different messaging systems.</li>
  </ul>

  <h3 style="color: #e67e22;">JMS Messaging Models</h3>
  <p style="color: #2c3e50;">
    JMS supports two primary messaging models:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Point-to-Point (Queue-Based Messaging)</strong>: Messages are sent to a queue and consumed by a single receiver.</li>
    <li><strong>Publish-Subscribe (Topic-Based Messaging)</strong>: Messages are sent to a topic and received by multiple subscribers.</li>
  </ul>

  <h3 style="color: #8e44ad;">How to Use JMS in Java</h3>
  <p style="color: #2c3e50;">
    A basic example of sending and receiving messages using JMS.
  </p>

  <h4 style="color: #2c3e50;">1. Configure JMS Connection Factory</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Bean
      public ConnectionFactory connectionFactory() {
          return new ActiveMQConnectionFactory("tcp://localhost:61616");
      }
    </code>
  </pre>

  <h4 style="color: #2c3e50;">2. Sending a JMS Message</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class JmsProducer {
          @Autowired
          private JmsTemplate jmsTemplate;
          
          public void sendMessage(String destination, String message) {
              jmsTemplate.convertAndSend(destination, message);
          }
      }
    </code>
  </pre>

  <h4 style="color: #2c3e50;">3. Receiving a JMS Message</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      @JmsListener(destination = "testQueue")
      public class JmsConsumer {
          public void receiveMessage(String message) {
              System.out.println("Received: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using JMS</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>connection pooling</strong> to improve performance.</li>
    <li>Implement <strong>error handling</strong> for message failures.</li>
    <li>Use <strong>durable subscriptions</strong> for reliable message consumption.</li>
    <li>Monitor message queues to prevent bottlenecks.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    JMS is a robust messaging framework that enables scalable and reliable communication in distributed systems. By leveraging JMS effectively, applications can ensure efficient message processing and decoupled service interactions.
  </p>
</div>
`
},

{
  title:`Spring JMS Integration`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Spring JMS Integration</h2>
  <p style="font-size: 16px; color: #34495e;">
    Java Message Service (JMS) is a messaging API that allows communication between different components of a distributed application. 
    Spring provides seamless integration with JMS to simplify messaging and event-driven applications.
  </p>

  <h3 style="color: #16a085;">Why Use Spring JMS?</h3>
  <p style="color: #2c3e50;">
    The integration of JMS with Spring brings several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Abstraction</strong>: Simplifies JMS API usage and exception handling.</li>
    <li><strong>Declarative Messaging</strong>: Uses annotations and configurations to handle messaging.</li>
    <li><strong>Integration with Spring Boot</strong>: Enables quick setup with minimal configuration.</li>
  </ul>

  <h3 style="color: #e67e22;">Setting Up Spring JMS</h3>
  <p style="color: #2c3e50;">
    To enable JMS in a Spring Boot application, add the necessary dependencies and annotate the main class with <code>@EnableJms</code>.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.jms.annotation.EnableJms;

      @SpringBootApplication
      @EnableJms
      public class JmsApplication {
          public static void main(String[] args) {
              SpringApplication.run(JmsApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring JMS Listener</h3>
  <p style="color: #2c3e50;">
    The <code>@JmsListener</code> annotation listens for incoming messages on a specified destination queue.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.jms.annotation.JmsListener;
      import org.springframework.stereotype.Component;

      @Component
      public class MessageReceiver {
          @JmsListener(destination = "orderQueue")
          public void receiveMessage(String message) {
              System.out.println("Received message: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Sending Messages with JmsTemplate</h3>
  <p style="color: #2c3e50;">
    Spring provides <code>JmsTemplate</code> to send messages easily to a JMS destination.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.jms.core.JmsTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class MessageSender {
          @Autowired
          private JmsTemplate jmsTemplate;

          public void sendMessage(String destination, String message) {
              jmsTemplate.convertAndSend(destination, message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Spring JMS</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@EnableJms</strong> to activate JMS support.</li>
    <li>Handle exceptions properly when consuming messages.</li>
    <li>Use a persistent message broker like ActiveMQ for reliability.</li>
    <li>Monitor queues for performance optimization.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring JMS simplifies messaging in enterprise applications by integrating seamlessly with message brokers. 
    With declarative configurations and annotation-based listeners, it enables robust communication between distributed services.
  </p>
</div>
`
},

{
  title:`Message Producers & Consumers`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Message Producers & Consumers</h2>
  <p style="font-size: 16px; color: #34495e;">
    In messaging systems, <strong>Message Producers</strong> and <strong>Message Consumers</strong> play vital roles in enabling asynchronous communication between different components of an application. This model is widely used in message-oriented middleware (MOM) such as JMS, Apache Kafka, RabbitMQ, and ActiveMQ.
  </p>

  <h3 style="color: #16a085;">What is a Message Producer?</h3>
  <p style="color: #2c3e50;">
    A <strong>Message Producer</strong> is responsible for creating and sending messages to a destination (queue or topic). Producers are typically part of the event-driven architecture, ensuring that data is sent reliably to consumers.
  </p>

  <h3 style="color: #16a085;">What is a Message Consumer?</h3>
  <p style="color: #2c3e50;">
    A <strong>Message Consumer</strong> retrieves messages from a destination and processes them accordingly. Consumers can be designed to work synchronously or asynchronously, depending on the application requirements.
  </p>

  <h3 style="color: #e67e22;">Message Flow in a Messaging System</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Producer:</strong> Sends messages to a queue or topic.</li>
    <li><strong>Message Broker:</strong> Routes and stores messages.</li>
    <li><strong>Consumer:</strong> Retrieves and processes messages.</li>
  </ul>

  <h3 style="color: #8e44ad;">Example: Message Producer & Consumer using JMS</h3>
  <p style="color: #2c3e50;">
    Below is an example of how a message producer and consumer can be implemented using Java Message Service (JMS) with Spring Boot.
  </p>

  <h4 style="color: #d35400;">Message Producer</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.jms.core.JmsTemplate;
      import org.springframework.stereotype.Service;

      @Service
      public class MessageProducer {
          private final JmsTemplate jmsTemplate;

          public MessageProducer(JmsTemplate jmsTemplate) {
              this.jmsTemplate = jmsTemplate;
          }

          public void sendMessage(String destination, String message) {
              jmsTemplate.convertAndSend(destination, message);
              System.out.println("Message sent: " + message);
          }
      }
    </code>
  </pre>

  <h4 style="color: #d35400;">Message Consumer</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.jms.annotation.JmsListener;
      import org.springframework.stereotype.Component;

      @Component
      public class MessageConsumer {

          @JmsListener(destination = "testQueue")
          public void receiveMessage(String message) {
              System.out.println("Received message: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Message Producers & Consumers</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use durable messaging queues to prevent message loss.</li>
    <li>Ensure message ordering using FIFO (First In, First Out) when necessary.</li>
    <li>Implement retry mechanisms for failed message processing.</li>
    <li>Monitor and scale message consumers to handle increased loads.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message Producers and Consumers form the backbone of asynchronous messaging systems. They enhance scalability, decouple services, and improve application resilience. By leveraging message brokers like JMS, RabbitMQ, or Kafka, applications can efficiently process and distribute messages.
  </p>
</div>
`
},

{
  title:`Spring Integration for Messaging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Spring Integration for Messaging</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Integration is a powerful framework within the Spring ecosystem designed to facilitate messaging-based communication
    between components. It supports various messaging protocols and enables seamless integration between different systems
    using an enterprise integration pattern.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Integration?</h3>
  <p style="color: #2c3e50;">Spring Integration offers several advantages:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Decoupled Architecture</strong>: Enables communication between components without tight coupling.</li>
    <li><strong>Support for Multiple Messaging Systems</strong>: Works with JMS, Kafka, RabbitMQ, WebSockets, and more.</li>
    <li><strong>Enterprise Integration Patterns</strong>: Provides built-in support for common patterns like message channels, transformers, and routers.</li>
    <li><strong>Declarative and Configurable</strong>: Allows easy configuration through XML or Java-based annotations.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use Spring Integration?</h3>
  <p style="color: #2c3e50;">
    To start with Spring Integration, include the necessary dependencies in your <code>pom.xml</code>:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
        &lt;artifactId&gt;spring-integration-core&lt;/artifactId&gt;
        &lt;version&gt;5.5.0&lt;/version&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Basic Example: Message Flow</h3>
  <p style="color: #2c3e50;">
    Here is a simple example demonstrating a message flow using Spring Integration components.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.integration.channel.DirectChannel;
      import org.springframework.messaging.MessageChannel;

      @Configuration
      public class IntegrationConfig {

          @Bean
          public MessageChannel inputChannel() {
              return new DirectChannel();
          }

          @Bean
          public MessageChannel outputChannel() {
              return new DirectChannel();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using Transformers and Routers</h3>
  <p style="color: #2c3e50;">
    Spring Integration allows transformation of messages and routing based on content or headers.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.integration.annotation.Transformer;
      import org.springframework.stereotype.Component;

      @Component
      public class MessageTransformer {
          @Transformer(inputChannel = "inputChannel", outputChannel = "outputChannel")
          public String transform(String message) {
              return message.toUpperCase();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Spring Integration</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>message channels</strong> to decouple message producers and consumers.</li>
    <li>Utilize <strong>error handling</strong> mechanisms to manage failures effectively.</li>
    <li>Monitor integration flows using <strong>Spring Actuator</strong>.</li>
    <li>Choose the right messaging protocol (JMS, Kafka, RabbitMQ) based on your use case.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Integration provides a robust framework for handling messaging-based communication. It simplifies integration
    with various messaging systems and supports enterprise integration patterns, making it an excellent choice for
    scalable and maintainable applications.
  </p>
</div>
`
},

{
  title:`Message Listeners`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Message Listeners</h2>
  <p style="font-size: 16px; color: #34495e;">
    In message-driven applications, <strong>Message Listeners</strong> play a crucial role in processing incoming messages asynchronously. 
    They are used in various messaging frameworks, including JMS (Java Message Service) and Spring Boot, to listen for messages from a queue or topic.
  </p>

  <h3 style="color: #16a085;">Why Use Message Listeners?</h3>
  <p style="color: #2c3e50;">
    Message Listeners provide several advantages:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Asynchronous Processing</strong>: Allows background message consumption without blocking application threads.</li>
    <li><strong>Scalability</strong>: Supports concurrent message processing, making applications more scalable.</li>
    <li><strong>Reliability</strong>: Ensures messages are processed even if the producer is unavailable.</li>
  </ul>

  <h3 style="color: #e67e22;">Message Listener in JMS</h3>
  <p style="color: #2c3e50;">
    In JMS, a Message Listener is an interface that allows objects to asynchronously receive messages.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.jms.Message;
      import javax.jms.MessageListener;
      import javax.jms.TextMessage;

      public class MyMessageListener implements MessageListener {
          @Override
          public void onMessage(Message message) {
              if (message instanceof TextMessage) {
                  try {
                      System.out.println("Received: " + ((TextMessage) message).getText());
                  } catch (Exception e) {
                      e.printStackTrace();
                  }
              }
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Message Listener in Spring Boot</h3>
  <p style="color: #2c3e50;">
    In Spring Boot, we can use <code>@JmsListener</code> or <code>@RabbitListener</code> for handling messages from queues.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.jms.annotation.JmsListener;
      import org.springframework.stereotype.Component;

      @Component
      public class MessageConsumer {

          @JmsListener(destination = "testQueue")
          public void receiveMessage(String message) {
              System.out.println("Received message: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Message Listeners</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use proper <strong>error handling</strong> to prevent message loss.</li>
    <li>Ensure message <strong>acknowledgment</strong> is configured correctly.</li>
    <li>Optimize the listener for <strong>high throughput</strong> by enabling concurrency settings.</li>
    <li>Use <strong>retry mechanisms</strong> to handle transient failures.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message Listeners are essential for building efficient and scalable message-driven applications. Whether using JMS or Spring Boot, 
    implementing a well-structured listener ensures smooth communication between producers and consumers.
  </p>
</div>
`
},

{
  title:`Message Conversion`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Message Conversion in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Message conversion in Spring enables the transformation of messages between different formats, such as JSON, XML, or custom formats, making it easier to integrate with various messaging systems.
  </p>

  <h3 style="color: #16a085;">Why Use Message Conversion?</h3>
  <p style="color: #2c3e50;">
    Message conversion provides several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Seamless Data Transformation</strong>: Converts messages between different formats automatically.</li>
    <li><strong>Integration with Various Protocols</strong>: Supports JSON, XML, and custom serialization formats.</li>
    <li><strong>Reduces Boilerplate Code</strong>: Simplifies message handling by automating conversions.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Use Message Converters?</h3>
  <p style="color: #2c3e50;">
    Spring provides built-in message converters like <code>MappingJackson2MessageConverter</code> for JSON and <code>SimpleMessageConverter</code> for basic types.
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.messaging.converter.MappingJackson2MessageConverter;
      
      @Configuration
      public class MessageConverterConfig {
          @Bean
          public MappingJackson2MessageConverter messageConverter() {
              return new MappingJackson2MessageConverter();
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Example of Message Conversion</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates how a message listener automatically converts a JSON message into a Java object.
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.jms.annotation.JmsListener;
      import org.springframework.stereotype.Component;

      @Component
      public class OrderListener {
          @JmsListener(destination = "order.queue")
          public void receiveMessage(Order order) {
              System.out.println("Received order: " + order);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Custom Message Converters</h3>
  <p style="color: #2c3e50;">
    If built-in converters don’t meet your needs, you can create a custom message converter.
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.messaging.converter.AbstractMessageConverter;
      import org.springframework.messaging.Message;
      import org.springframework.util.MimeType;

      public class CustomMessageConverter extends AbstractMessageConverter {
          protected CustomMessageConverter() {
              super(new MimeType("application", "custom"));
          }

          @Override
          protected boolean supports(Class<?> clazz) {
              return CustomMessage.class.isAssignableFrom(clazz);
          }

          @Override
          protected Object convertFromInternal(Message<?> message, Class<?> targetClass, Object conversionHint) {
              // Custom conversion logic here
              return new CustomMessage(new String((byte[]) message.getPayload()));
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Message Conversion</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>MappingJackson2MessageConverter</strong> for JSON-based messaging.</li>
    <li>Leverage <strong>custom converters</strong> for proprietary formats.</li>
    <li>Ensure message format consistency across systems.</li>
    <li>Monitor message conversions for performance optimization.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message conversion in Spring simplifies message handling by transforming data formats automatically. By using built-in converters or defining custom ones, developers can integrate messaging systems efficiently.
  </p>
</div>
`
},

{
  title:`Asynchronous Messaging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Asynchronous Messaging in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Asynchronous messaging is a communication pattern where messages are sent and received independently of time, allowing the sender and receiver to process data at different rates without waiting for an immediate response.
  </p>

  <h3 style="color: #16a085;">Why Use Asynchronous Messaging?</h3>
  <p style="color: #2c3e50;">Asynchronous messaging offers several advantages:</p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Decoupling</strong>: The sender and receiver do not need to be available at the same time.</li>
    <li><strong>Scalability</strong>: Enables handling large workloads without blocking operations.</li>
    <li><strong>Fault Tolerance</strong>: Ensures message delivery even if the receiver is temporarily unavailable.</li>
  </ul>

  <h3 style="color: #e67e22;">Enabling Asynchronous Messaging in Spring</h3>
  <p style="color: #2c3e50;">To use asynchronous messaging, enable it using <code>@EnableAsync</code> in your Spring Boot application.</p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.scheduling.annotation.EnableAsync;

      @SpringBootApplication
      @EnableAsync
      public class AsyncApplication {
          public static void main(String[] args) {
              SpringApplication.run(AsyncApplication.class, args);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Example: Implementing Asynchronous Messaging</h3>
  <p style="color: #2c3e50;">You can use <code>@Async</code> to execute methods asynchronously.</p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.scheduling.annotation.Async;
      import org.springframework.stereotype.Service;

      @Service
      public class NotificationService {

          @Async
          public void sendEmail(String recipient) {
              try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); }
              System.out.println("Email sent to: " + recipient);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Asynchronous Messaging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>@EnableAsync</strong> to activate async processing.</li>
    <li>Ensure thread pool configuration to handle multiple async tasks efficiently.</li>
    <li>Use error handling to manage failures in async tasks.</li>
    <li>Monitor performance and optimize resource usage.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Asynchronous messaging improves system efficiency by decoupling operations and allowing background processing. By implementing <code>@Async</code> and configuring appropriate thread pools, applications can achieve better scalability and responsiveness.
  </p>
</div>
`
},

{
  title:`Transactional Messaging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Transactional Messaging in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    Transactional Messaging ensures that messages are reliably delivered as part of a transaction. It helps maintain data consistency across distributed systems by ensuring messages are sent only when a transaction is successfully committed.
  </p>

  <h3 style="color: #16a085;">Why Use Transactional Messaging?</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Data Consistency</strong>: Ensures messages are delivered only if the transaction succeeds.</li>
    <li><strong>Reliability</strong>: Prevents message loss or duplication.</li>
    <li><strong>Atomicity</strong>: Links message sending with database operations.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Transactional Messaging?</h3>
  <p style="color: #2c3e50;">
    Spring supports transactional messaging using <code>@Transactional</code> along with messaging frameworks like Kafka, RabbitMQ, or JMS.
  </p>

  <h3 style="color: #8e44ad;">Example Implementation</h3>
  <p style="color: #2c3e50;">
    Below is an example using Spring Boot and Kafka to achieve transactional messaging:
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.kafka.annotation.EnableKafka;
      import org.springframework.kafka.core.KafkaTemplate;
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;
      
      @Service
      public class TransactionalMessageService {
          private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;
      
          public TransactionalMessageService(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
              this.kafkaTemplate = kafkaTemplate;
          }
      
          @Transactional
          public void sendMessage(String topic, String message) {
              kafkaTemplate.send(topic, message);
              // Other database operations within the same transaction
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensure database operations and messaging are part of the same transaction.</li>
    <li>Use <strong>idempotent processing</strong> to prevent duplicate messages.</li>
    <li>Implement <strong>retry mechanisms</strong> for message delivery failures.</li>
    <li>Leverage <strong>Outbox Patterns</strong> for reliable event-driven messaging.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Transactional Messaging is crucial for ensuring reliable communication in distributed systems. By integrating messaging within transactions, we can maintain data integrity and prevent inconsistencies in microservices architectures.
  </p>
</div>
`
},

{
  title:`Message Acknowledgement`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Message Acknowledgement</h2>
  <p style="font-size: 16px; color: #34495e;">
    In messaging systems, <strong>Message Acknowledgement</strong> is a crucial mechanism that ensures messages are received and processed correctly. It helps maintain reliability by preventing message loss and ensuring that messages are not duplicated or ignored.
  </p>

  <h3 style="color: #16a085;">Why is Message Acknowledgement Important?</h3>
  <p style="color: #2c3e50;">
    Message acknowledgement plays a key role in messaging protocols by providing the following benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reliability</strong>: Ensures messages are delivered and processed successfully.</li>
    <li><strong>Data Integrity</strong>: Prevents message duplication and loss.</li>
    <li><strong>Efficient Resource Management</strong>: Frees up system resources by confirming message processing.</li>
    <li><strong>Error Handling</strong>: Helps identify and handle failed deliveries.</li>
  </ul>

  <h3 style="color: #e67e22;">Types of Message Acknowledgement</h3>
  <p style="color: #2c3e50;">
    Different messaging systems use various types of acknowledgements based on their reliability requirements.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Automatic Acknowledgement (AUTO_ACK)</strong>: Messages are automatically acknowledged upon receipt.</li>
    <li><strong>Manual Acknowledgement</strong>: The consumer explicitly acknowledges message processing.</li>
    <li><strong>Negative Acknowledgement (NACK)</strong>: Indicates message processing failure and requests re-delivery.</li>
    <li><strong>Batch Acknowledgement</strong>: Acknowledges multiple messages at once to improve efficiency.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Message Acknowledgement in Java</h3>
  <p style="color: #2c3e50;">
    Below is an example of implementing message acknowledgement in Java using a message queue system like RabbitMQ.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import com.rabbitmq.client.*;
      
      public class Consumer {
          private final static String QUEUE_NAME = "task_queue";
          
          public static void main(String[] argv) throws Exception {
              ConnectionFactory factory = new ConnectionFactory();
              factory.setHost("localhost");
              Connection connection = factory.newConnection();
              Channel channel = connection.createChannel();
              
              channel.queueDeclare(QUEUE_NAME, true, false, false, null);
              System.out.println("[*] Waiting for messages...");
              
              DeliverCallback deliverCallback = (consumerTag, delivery) -> {
                  String message = new String(delivery.getBody(), "UTF-8");
                  System.out.println("[x] Received '" + message + "'");
                  
                  // Simulating processing time
                  try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); }
                  
                  // Manually acknowledge message
                  channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
              };
              
              boolean autoAck = false;
              channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, consumerTag -> {});
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Message Acknowledgement</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use manual acknowledgement for critical applications to prevent data loss.</li>
    <li>Implement <strong>dead-letter queues</strong> for handling failed message deliveries.</li>
    <li>Optimize batch acknowledgements for high-throughput systems.</li>
    <li>Monitor message queues to detect and resolve processing issues.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message Acknowledgement is essential for building reliable and robust messaging systems. By implementing proper acknowledgement mechanisms, developers can ensure message integrity, prevent data loss, and enhance overall system efficiency.
  </p>
</div>
`
},

{
  title:`Messaging with Kafka`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Messaging with Kafka</h2>
  <p style="font-size: 16px; color: #34495e;">
    Apache Kafka is a distributed event streaming platform used for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications. It enables the exchange of messages between producers and consumers in a fault-tolerant and scalable manner.
  </p>

  <h3 style="color: #16a085;">Why Use Kafka for Messaging?</h3>
  <p style="color: #2c3e50;">
    Kafka is widely used in messaging systems due to its benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>High Throughput</strong>: Kafka can handle large volumes of messages efficiently.</li>
    <li><strong>Scalability</strong>: It scales horizontally by adding more brokers to the cluster.</li>
    <li><strong>Fault Tolerance</strong>: Ensures data durability and reliability.</li>
    <li><strong>Real-time Processing</strong>: Supports real-time event-driven architectures.</li>
  </ul>

  <h3 style="color: #e67e22;">Core Components of Kafka Messaging</h3>
  <p style="color: #2c3e50;">
    Kafka consists of the following key components:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Producers</strong>: Send messages to Kafka topics.</li>
    <li><strong>Topics</strong>: Logical channels where messages are stored.</li>
    <li><strong>Brokers</strong>: Kafka servers that handle messages.</li>
    <li><strong>Consumers</strong>: Read messages from topics.</li>
  </ul>

  <h3 style="color: #8e44ad;">Kafka Messaging Workflow</h3>
  <p style="color: #2c3e50;">
    Kafka follows a publish-subscribe model where producers publish messages to topics, and consumers subscribe to topics to retrieve messages.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.apache.kafka.clients.producer.KafkaProducer;
      import org.apache.kafka.clients.producer.ProducerRecord;
      import java.util.Properties;

      public class KafkaMessageProducer {
          public static void main(String[] args) {
              Properties props = new Properties();
              props.put("bootstrap.servers", "localhost:9092");
              props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
              props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

              KafkaProducer<String, String> producer = new KafkaProducer<>(props);
              ProducerRecord<String, String> record = new ProducerRecord<>("test-topic", "Hello, Kafka!");
              producer.send(record);
              producer.close();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Kafka Messaging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use proper topic partitioning to distribute load effectively.</li>
    <li>Enable replication for high availability.</li>
    <li>Optimize batch sizes for improved throughput.</li>
    <li>Monitor Kafka metrics for performance tuning.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Kafka is a powerful messaging system designed for high-performance event streaming. Its scalability, durability, and real-time processing capabilities make it ideal for modern applications that require efficient data exchange.
  </p>
</div>
`
},

{
  title:`Spring Cloud Stream`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Spring Cloud Stream</h2>
  <p style="font-size: 16px; color: #34495e;">
    Spring Cloud Stream is a framework that simplifies event-driven microservices communication using messaging platforms like Apache Kafka and RabbitMQ. It abstracts messaging complexities and provides a declarative programming model.
  </p>

  <h3 style="color: #16a085;">Why Use Spring Cloud Stream?</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Stream offers several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Decoupled Architecture</strong>: Enables loose coupling between microservices.</li>
    <li><strong>Declarative Messaging</strong>: Uses annotations and configuration-based approach.</li>
    <li><strong>Scalability</strong>: Supports horizontal scaling with partitioned data processing.</li>
    <li><strong>Multi-Broker Support</strong>: Works with Kafka, RabbitMQ, and other brokers.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Configure Spring Cloud Stream?</h3>
  <p style="color: #2c3e50;">
    To enable Spring Cloud Stream, add the necessary dependencies and configure a message broker.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-xml">
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
      &lt;/dependency&gt;
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Spring Cloud Stream Example</h3>
  <p style="color: #2c3e50;">
    The following example demonstrates a producer sending messages and a consumer receiving them using Spring Cloud Stream.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.cloud.stream.function.StreamBridge;
      import org.springframework.stereotype.Service;

      @Service
      public class MessageProducer {
          private final StreamBridge streamBridge;

          public MessageProducer(StreamBridge streamBridge) {
              this.streamBridge = streamBridge;
          }

          public void sendMessage(String message) {
              streamBridge.send("message-out", message);
          }
      }
    </code>
  </pre>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.stereotype.Component;
      import java.util.function.Consumer;

      @Component
      public class MessageConsumer {
          @Bean
          public Consumer<String> messageIn() {
              return message -> System.out.println("Received: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Spring Cloud Stream</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>Spring Cloud Function</strong> for a functional approach to messaging.</li>
    <li>Configure proper <strong>retry mechanisms</strong> to handle failures.</li>
    <li>Leverage <strong>partitioning</strong> to distribute workload efficiently.</li>
    <li>Monitor <strong>broker health</strong> and optimize resource allocation.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Spring Cloud Stream simplifies microservices messaging by providing an abstraction over message brokers. It enables seamless integration, scalability, and event-driven architectures, making it a powerful tool for modern applications.
  </p>
</div>
`
},

{
  title:`Message-Driven POJOs (MDP)`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Understanding Message-Driven POJOs (MDP) in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In Spring, Message-Driven POJOs (MDP) are a key component of the messaging system, allowing Java objects (Plain Old Java Objects) to asynchronously process messages. Unlike traditional EJB-based message-driven beans (MDBs), MDPs are lightweight, loosely coupled, and can be easily integrated into Spring applications.
  </p>

  <h3 style="color: #16a085;">Why Use Message-Driven POJOs?</h3>
  <p style="color: #2c3e50;">
    The use of MDPs in a Spring application provides several benefits:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Decoupled Architecture</strong>: Helps separate business logic from messaging infrastructure.</li>
    <li><strong>Asynchronous Processing</strong>: Enables handling of messages without blocking other operations.</li>
    <li><strong>Flexibility</strong>: Can be configured with different messaging platforms like JMS, RabbitMQ, or Kafka.</li>
    <li><strong>Easy Integration</strong>: Works seamlessly with Spring’s dependency injection and transaction management.</li>
  </ul>

  <h3 style="color: #e67e22;">How to Implement Message-Driven POJOs?</h3>
  <p style="color: #2c3e50;">
    Spring provides built-in support for MDPs using the <code>JmsListener</code> annotation and <code>DefaultMessageListenerContainer</code>. Below is an example demonstrating an MDP in Spring with JMS.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.jms.annotation.JmsListener;
      import org.springframework.stereotype.Component;

      @Component
      public class MessageReceiver {

          @JmsListener(destination = "order.queue")
          public void receiveMessage(String message) {
              System.out.println("Received message: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Configuring Message Listener Container</h3>
  <p style="color: #2c3e50;">
    To enable message-driven POJOs, configure a <code>DefaultJmsListenerContainerFactory</code> in your application.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.jms.ConnectionFactory;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
      
      @Configuration
      public class JmsConfig {

          @Bean
          public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(ConnectionFactory connectionFactory) {
              DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
              factory.setConnectionFactory(connectionFactory);
              factory.setConcurrency("1-5");
              return factory;
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Using Message-Driven POJOs</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use proper **error handling** to manage message failures gracefully.</li>
    <li>Configure **concurrency settings** to optimize message processing efficiency.</li>
    <li>Ensure **transactional messaging** for consistency in processing messages.</li>
    <li>Monitor **message queues** to prevent backlog and optimize performance.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message-Driven POJOs (MDP) provide a lightweight, flexible way to process messages asynchronously in Spring applications. They improve scalability and maintainability while allowing seamless integration with various messaging systems like JMS and RabbitMQ.
  </p>
</div>
`
},

{
  title:`Message Filtering & Routing`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Message Filtering & Routing in Spring</h2>
  <p style="font-size: 16px; color: #34495e;">
    In enterprise applications, message filtering and routing are essential techniques for managing the flow of messages between different components. Spring Integration provides robust support for filtering messages based on specific criteria and routing them to the appropriate destination dynamically.
  </p>

  <h3 style="color: #16a085;">What is Message Filtering?</h3>
  <p style="color: #2c3e50;">
    Message filtering ensures that only relevant messages are processed while unwanted or unnecessary messages are discarded. This is useful in event-driven systems where multiple components subscribe to message events.
  </p>

  <h4 style="color: #e74c3c;">Example of Message Filtering in Spring Integration</h4>
  <p style="color: #2c3e50;">
    Spring provides the <code>MessageFilter</code> component, which can be used to filter messages based on custom conditions.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.integration.core.MessageSelector;
      import org.springframework.messaging.Message;
      import org.springframework.stereotype.Component;

      @Component
      public class CustomMessageFilter implements MessageSelector {

          @Override
          public boolean accept(Message<?> message) {
              // Filter messages containing "valid" keyword
              return message.getPayload().toString().contains("valid");
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">What is Message Routing?</h3>
  <p style="color: #2c3e50;">
    Message routing involves directing messages to different endpoints based on message headers, content, or external conditions. Spring provides several routing mechanisms, including **Content-Based Routing, Header-Based Routing, and Recipient List Routing**.
  </p>

  <h4 style="color: #e67e22;">Example of Content-Based Routing</h4>
  <p style="color: #2c3e50;">
    In content-based routing, messages are routed based on the message payload.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.integration.annotation.Router;
      import org.springframework.stereotype.Component;

      @Component
      public class OrderRouter {

          @Router
          public String routeOrder(String order) {
              if (order.contains("electronics")) {
                  return "electronicsChannel";
              } else if (order.contains("grocery")) {
                  return "groceryChannel";
              }
              return "defaultChannel";
          }
      }
    </code>
  </pre>

  <h4 style="color: #d35400;">Example of Header-Based Routing</h4>
  <p style="color: #2c3e50;">
    Header-based routing directs messages based on metadata present in message headers.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.integration.annotation.Router;
      import org.springframework.messaging.Message;
      import org.springframework.stereotype.Component;

      @Component
      public class HeaderBasedRouter {

          @Router
          public String routeBasedOnHeader(Message<String> message) {
              String department = message.getHeaders().get("department", String.class);
              return department != null && department.equals("HR") ? "hrChannel" : "defaultChannel";
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for Message Filtering & Routing</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **message selectors** to filter unnecessary messages before processing.</li>
    <li>Ensure **dynamic routing rules** to adapt to changing business requirements.</li>
    <li>Implement **logging and monitoring** to track message flow and debugging.</li>
    <li>Use **Spring Integration Patterns** for better scalability and maintainability.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message filtering and routing are critical in event-driven and microservices architectures. Spring Integration makes it easier to handle these operations efficiently, ensuring that messages are processed by the right consumers while reducing system load.
  </p>
</div>
`
},

{
  title:`Message Priority`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Message Priority in Spring Integration</h2>
  <p style="font-size: 16px; color: #34495e;">
    In message-driven architectures, certain messages need to be processed before others. **Message Priority** helps in prioritizing messages to ensure that critical tasks are executed first. 
    Spring Integration provides built-in support for message priority through **priority channels** and **message headers**.
  </p>

  <h3 style="color: #16a085;">What is Message Priority?</h3>
  <p style="color: #2c3e50;">
    Message priority is a mechanism that allows messages to be processed in order of their importance. 
    This is especially useful in systems where urgent messages (e.g., error alerts, high-priority orders) must be handled before lower-priority ones.
  </p>

  <h4 style="color: #e74c3c;">How Message Priority Works in Spring</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Spring Integration allows messages to carry a **priority header**.</li>
    <li>Messages with higher priority values are processed before lower-priority messages.</li>
    <li>The **PriorityChannel** in Spring Integration ensures ordered message processing.</li>
  </ul>

  <h3 style="color: #8e44ad;">Using Priority Channels</h3>
  <p style="color: #2c3e50;">
    A **PriorityChannel** is a special type of message channel that sorts messages based on their priority. 
    Messages with higher priority are dequeued first.
  </p>

  <h4 style="color: #e67e22;">Example: Configuring a Priority Channel</h4>
  <p style="color: #2c3e50;">
    Below is an example of how to configure and use a PriorityChannel in Spring Integration.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.integration.channel.PriorityChannel;
      import org.springframework.messaging.Message;
      import org.springframework.messaging.support.MessageBuilder;

      @Configuration
      public class PriorityConfig {

          @Bean
          public PriorityChannel priorityChannel() {
              return new PriorityChannel();
          }

          public static void main(String[] args) {
              PriorityChannel channel = new PriorityChannel();

              // Creating messages with priority headers
              Message<String> highPriorityMsg = MessageBuilder.withPayload("High Priority Task")
                      .setHeader("priority", 10).build();
              Message<String> lowPriorityMsg = MessageBuilder.withPayload("Low Priority Task")
                      .setHeader("priority", 1).build();

              // Sending messages to the channel
              channel.send(lowPriorityMsg);
              channel.send(highPriorityMsg);

              // Receiving messages (High Priority comes first)
              System.out.println(channel.receive().getPayload()); // High Priority Task
              System.out.println(channel.receive().getPayload()); // Low Priority Task
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Priority Queue in Message Brokers (RabbitMQ/Kafka)</h3>
  <p style="color: #2c3e50;">
    When integrating with message brokers like **RabbitMQ or Kafka**, priority-based message processing can be implemented using priority queues.
  </p>

  <h4 style="color: #e74c3c;">RabbitMQ Example</h4>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.core.Queue;
      import org.springframework.amqp.rabbit.annotation.RabbitListener;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class RabbitMQConfig {

          @Bean
          public Queue priorityQueue() {
              return new Queue("priority-queue", true, false, false, Map.of("x-max-priority", 10));
          }

          @RabbitListener(queues = "priority-queue")
          public void receiveMessage(String message) {
              System.out.println("Received: " + message);
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for Message Priority</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Define clear priority levels (e.g., **HIGH = 10, MEDIUM = 5, LOW = 1**).</li>
    <li>Use **PriorityChannel** for in-memory prioritization.</li>
    <li>When using message brokers, configure **priority queues** for efficient processing.</li>
    <li>Log and monitor priority-based processing to ensure fairness.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message Priority ensures that critical messages are processed first, improving system responsiveness. 
    Spring Integration provides built-in support for **priority channels** and integrates well with message brokers like RabbitMQ and Kafka for priority-based messaging.
  </p>
</div>
`
},
{
  title:`Message Acknowledgement`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Message Persistence in Spring Integration</h2>
  <p style="font-size: 16px; color: #34495e;">
    In message-driven architectures, ensuring that messages are not lost due to system failures or crashes is crucial. 
    **Message Persistence** allows messages to be stored in a durable medium, ensuring reliable message delivery even in case of unexpected failures. 
    Spring Integration provides various mechanisms to achieve this.
  </p>

  <h3 style="color: #16a085;">What is Message Persistence?</h3>
  <p style="color: #2c3e50;">
    Message Persistence refers to storing messages so that they remain available even if the system crashes or restarts. 
    Unlike in-memory messaging, where messages are lost when the system shuts down, persistent messages are saved to a database, file system, or message broker.
  </p>

  <h4 style="color: #e74c3c;">Why is Message Persistence Important?</h4>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Ensures **reliable message delivery** in case of system crashes.</li>
    <li>Supports **asynchronous communication** between distributed components.</li>
    <li>Prevents **data loss** and ensures messages are processed in order.</li>
    <li>Works well with **message queues (RabbitMQ, Kafka, ActiveMQ)** for durable messaging.</li>
  </ul>

  <h3 style="color: #8e44ad;">Message Persistence with Spring Integration</h3>
  <p style="color: #2c3e50;">
    Spring Integration supports message persistence using **Persistent Message Stores** and **Message Brokers**.
  </p>

  <h4 style="color: #e67e22;">1. Using a JDBC Message Store</h4>
  <p style="color: #2c3e50;">
    Spring Integration provides a **JDBC-based message store** to persist messages in a relational database.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.integration.store.JdbcMessageStore;
      import javax.sql.DataSource;

      @Configuration
      public class MessagePersistenceConfig {

          @Bean
          public JdbcMessageStore jdbcMessageStore(DataSource dataSource) {
              return new JdbcMessageStore(dataSource);
          }
      }
    </code>
  </pre>

  <p style="color: #2c3e50;">
    In this setup, messages are stored in a database table and can be retrieved later for processing.
  </p>

  <h4 style="color: #e67e22;">2. Using a File-Based Message Store</h4>
  <p style="color: #2c3e50;">
    Messages can also be stored in files instead of a database using **SimpleMessageStore**.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.integration.store.SimpleMessageStore;

      @Configuration
      public class FileMessageStoreConfig {

          @Bean
          public SimpleMessageStore simpleMessageStore() {
              return new SimpleMessageStore();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Message Persistence in Message Brokers</h3>
  <p style="color: #2c3e50;">
    Many enterprise messaging systems support **persistent queues** to store messages until they are successfully processed.
  </p>

  <h4 style="color: #e74c3c;">RabbitMQ Example</h4>
  <p style="color: #2c3e50;">
    RabbitMQ provides **durable queues** to ensure messages are not lost if the broker restarts.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.springframework.amqp.core.Queue;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;

      @Configuration
      public class RabbitMQConfig {

          @Bean
          public Queue durableQueue() {
              return new Queue("persistent-queue", true);
          }
      }
    </code>
  </pre>

  <h4 style="color: #e74c3c;">Kafka Example</h4>
  <p style="color: #2c3e50;">
    Kafka stores messages in a distributed log, ensuring they are **persisted across multiple brokers**.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.apache.kafka.clients.producer.ProducerConfig;
      import org.apache.kafka.clients.producer.KafkaProducer;
      import org.apache.kafka.clients.producer.ProducerRecord;
      import java.util.Properties;

      public class KafkaPersistenceExample {
          public static void main(String[] args) {
              Properties props = new Properties();
              props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
              props.put(ProducerConfig.ACKS_CONFIG, "all");
              props.put(ProducerConfig.RETRIES_CONFIG, 3);
              props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer");
              props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer");

              KafkaProducer<String, String> producer = new KafkaProducer<>(props);
              ProducerRecord<String, String> record = new ProducerRecord<>("persistent-topic", "Persistent Message");
              producer.send(record);
              producer.close();
          }
      }
    </code>
  </pre>

  <h3 style="color: #27ae60;">Best Practices for Message Persistence</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use **JDBC or File-Based Message Stores** for in-memory messaging systems.</li>
    <li>For high-availability, use **message brokers with persistence enabled**.</li>
    <li>Enable **retry mechanisms** to ensure message delivery.</li>
    <li>Use **message acknowledgment** in RabbitMQ/Kafka to avoid message loss.</li>
    <li>Monitor and clean up old messages from the persistence store.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Message Persistence is crucial for ensuring reliable message delivery in distributed systems. 
    Spring Integration provides built-in support for **JDBC and File-based storage**, while external message brokers like **RabbitMQ and Kafka** handle persistence efficiently.
  </p>
</div>
`
},
{
  title:`Error Handling in Messaging`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Error Handling in Messaging</h2>
  <p style="font-size: 16px; color: #34495e;">
    In distributed systems, messaging plays a crucial role in enabling communication between microservices and applications. However, errors can occur due to network failures, processing issues, or unexpected payloads. Proper error handling ensures message reliability and system stability.
  </p>

  <h3 style="color: #16a085;">Why is Error Handling Important?</h3>
  <p style="color: #2c3e50;">
    Implementing error handling in messaging systems helps achieve:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Reliability</strong>: Ensures messages are not lost due to failures.</li>
    <li><strong>Scalability</strong>: Prevents cascading failures in microservices.</li>
    <li><strong>Fault Tolerance</strong>: Allows graceful recovery from errors.</li>
    <li><strong>Data Integrity</strong>: Prevents duplicate or corrupted messages.</li>
  </ul>

  <h3 style="color: #e67e22;">Common Error Handling Strategies</h3>
  <p style="color: #2c3e50;">
    Various techniques can be used to handle errors in messaging systems:
  </p>
  
  <h4 style="color: #8e44ad;">1. Retry Mechanism</h4>
  <p style="color: #2c3e50;">
    Automatic retries help recover from transient failures. Implement exponential backoff to prevent system overload.
  </p>

  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @Service
      public class MessageService {
          @Retryable(value = MessagingException.class, maxAttempts = 3, backoff = @Backoff(delay = 2000))
          public void processMessage(String message) {
              // Process message logic
          }
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">2. Dead Letter Queue (DLQ)</h4>
  <p style="color: #2c3e50;">
    Messages that fail multiple times can be sent to a DLQ for manual inspection or automated resolution.
  </p>
  
  <h4 style="color: #8e44ad;">3. Circuit Breaker Pattern</h4>
  <p style="color: #2c3e50;">
    If a service repeatedly fails, the circuit breaker opens to prevent further processing until stability is restored.
  </p>
  
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      @CircuitBreaker(name = "messageService", fallbackMethod = "fallbackMessageHandler")
      public void processMessage(String message) {
          // Process logic
      }
    </code>
  </pre>

  <h4 style="color: #8e44ad;">4. Idempotency</h4>
  <p style="color: #2c3e50;">
    Ensure messages have a unique identifier to prevent duplicate processing.
  </p>

  <h3 style="color: #d35400;">Best Practices for Error Handling</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Implement retry with exponential backoff.</li>
    <li>Use Dead Letter Queues for persistent errors.</li>
    <li>Log and monitor errors for proactive resolution.</li>
    <li>Design messages to be idempotent.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Effective error handling in messaging ensures system reliability, prevents message loss, and enhances fault tolerance. By applying best practices such as retries, DLQs, circuit breakers, and idempotency, distributed systems can maintain seamless communication even in failure scenarios.
  </p>
</div>
`
},
{
  title:`Message Security`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Message Security</h2>
  <p style="font-size: 16px; color: #34495e;">
    In modern applications, ensuring the security of messages during transmission and storage is crucial. Message security protects against threats such as eavesdropping, tampering, and unauthorized access, ensuring data integrity and confidentiality.
  </p>

  <h3 style="color: #16a085;">Common Security Threats in Messaging</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Eavesdropping</strong>: Intercepting messages during transmission.</li>
    <li><strong>Message Tampering</strong>: Unauthorized modification of messages.</li>
    <li><strong>Replay Attacks</strong>: Resending intercepted messages to manipulate systems.</li>
    <li><strong>Unauthorized Access</strong>: Gaining access to messages without proper authentication.</li>
    <li><strong>Denial of Service (DoS) Attacks</strong>: Overloading the system with excessive messages.</li>
  </ul>

  <h3 style="color: #e67e22;">Key Message Security Techniques</h3>
  <p style="color: #2c3e50;">
    Implementing strong security measures helps prevent these threats. Some key techniques include:
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Encryption</strong>: Secure messages using encryption protocols like AES, RSA, or TLS.</li>
    <li><strong>Authentication</strong>: Verify sender and receiver identities using authentication mechanisms.</li>
    <li><strong>Message Integrity Checks</strong>: Use digital signatures and checksums to detect tampering.</li>
    <li><strong>Access Control</strong>: Restrict message access based on user roles and permissions.</li>
    <li><strong>Secure Message Queues</strong>: Implement security measures in message brokers like RabbitMQ, Kafka, or AWS SQS.</li>
  </ul>

  <h3 style="color: #8e44ad;">Implementing Message Encryption in Spring Boot</h3>
  <p style="color: #2c3e50;">
    Encryption ensures that messages remain confidential during transmission. Below is an example of encrypting messages using AES in Spring Boot:
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import javax.crypto.Cipher;
      import javax.crypto.KeyGenerator;
      import javax.crypto.SecretKey;
      import java.util.Base64;

      public class MessageSecurity {
          private SecretKey secretKey;

          public MessageSecurity() throws Exception {
              KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
              keyGenerator.init(256);
              secretKey = keyGenerator.generateKey();
          }

          public String encryptMessage(String message) throws Exception {
              Cipher cipher = Cipher.getInstance("AES");
              cipher.init(Cipher.ENCRYPT_MODE, secretKey);
              return Base64.getEncoder().encodeToString(cipher.doFinal(message.getBytes()));
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Using JWT for Secure Message Authentication</h3>
  <p style="color: #2c3e50;">
    JSON Web Tokens (JWT) provide a secure way to authenticate and validate message senders.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import io.jsonwebtoken.Jwts;
      import io.jsonwebtoken.SignatureAlgorithm;
      import java.util.Date;

      public class JwtUtil {
          private static final String SECRET_KEY = "mySecretKey";

          public static String generateToken(String user) {
              return Jwts.builder()
                      .setSubject(user)
                      .setIssuedAt(new Date())
                      .setExpiration(new Date(System.currentTimeMillis() + 600000))
                      .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                      .compact();
          }
      }
    </code>
  </pre>

  <h3 style="color: #d35400;">Best Practices for Message Security</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>end-to-end encryption</strong> for secure message transmission.</li>
    <li>Implement <strong>authentication and authorization</strong> to restrict access.</li>
    <li>Regularly <strong>rotate encryption keys</strong> to maintain security.</li>
    <li>Use <strong>secure protocols</strong> like TLS to encrypt network communication.</li>
    <li>Monitor and log security events for threat detection and auditing.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Securing messages is a critical aspect of modern applications. By implementing encryption, authentication, and access control mechanisms, organizations can protect sensitive data and prevent security threats. Adopting best practices ensures that messaging systems remain secure, reliable, and trustworthy.
  </p>
</div>
`
},
{
  title:`Testing Messaging Systems`, content:`<div style="font-family: Arial, sans-serif; padding: 20px; line-height: 1.6;">
  <h2 style="color: #2c3e50;">Testing Messaging Systems</h2>
  <p style="font-size: 16px; color: #34495e;">
    Testing messaging systems is crucial to ensure reliability, performance, and security. Messaging systems, such as RabbitMQ, Kafka, and ActiveMQ, require rigorous testing to verify message delivery, ordering, duplication handling, and fault tolerance.
  </p>

  <h3 style="color: #16a085;">Key Areas of Testing</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li><strong>Functional Testing</strong>: Ensures messages are correctly sent, received, and processed.</li>
    <li><strong>Performance Testing</strong>: Evaluates message throughput, latency, and scalability.</li>
    <li><strong>Reliability Testing</strong>: Tests system resilience against failures and recovery mechanisms.</li>
    <li><strong>Security Testing</strong>: Ensures authentication, authorization, and encryption measures are intact.</li>
    <li><strong>Integration Testing</strong>: Verifies communication between different components using messaging.</li>
  </ul>

  <h3 style="color: #e67e22;">Writing Unit Tests for Messaging</h3>
  <p style="color: #2c3e50;">
    In Spring Boot, you can write unit tests for messaging components using JUnit and Mockito.
  </p>
  <pre style="background:rgb(1, 16, 20); color: #ecf0f1; padding: 10px; border-radius: 5px; font-size: 14px; overflow-x: auto;">
    <code class="language-java">
      import org.junit.jupiter.api.Test;
      import org.mockito.Mockito;
      import org.springframework.boot.test.context.SpringBootTest;
      import org.springframework.amqp.rabbit.core.RabbitTemplate;

      @SpringBootTest
      public class MessagingTest {
          private RabbitTemplate rabbitTemplate = Mockito.mock(RabbitTemplate.class);

          @Test
          void testMessageSending() {
              Mockito.doNothing().when(rabbitTemplate).convertAndSend("queue", "Test Message");
              rabbitTemplate.convertAndSend("queue", "Test Message");
              Mockito.verify(rabbitTemplate, Mockito.times(1)).convertAndSend("queue", "Test Message");
          }
      }
    </code>
  </pre>

  <h3 style="color: #8e44ad;">Performance Testing Messaging Systems</h3>
  <p style="color: #2c3e50;">
    Performance testing ensures that the messaging system can handle high loads efficiently. Tools like JMeter and Gatling can be used to simulate thousands of concurrent messages.
  </p>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Measure <strong>latency</strong> (time taken to deliver a message).</li>
    <li>Analyze <strong>throughput</strong> (messages processed per second).</li>
    <li>Test system behavior under <strong>high load</strong> conditions.</li>
    <li>Monitor resource usage (CPU, memory, network).</li>
  </ul>

  <h3 style="color: #d35400;">Best Practices for Testing Messaging Systems</h3>
  <ul style="color: #2c3e50; padding-left: 20px;">
    <li>Use <strong>mock messaging brokers</strong> in unit tests to isolate logic.</li>
    <li>Ensure <strong>idempotency</strong> to prevent duplicate message processing.</li>
    <li>Simulate <strong>network failures</strong> to test fault tolerance.</li>
    <li>Monitor message queues for <strong>unexpected delays</strong>.</li>
    <li>Log message flow for debugging and auditing.</li>
  </ul>

  <h3 style="color: #2c3e50;">Conclusion</h3>
  <p style="color: #2c3e50;">
    Testing messaging systems is essential for ensuring robustness, scalability, and security. By implementing functional, performance, and integration tests, developers can detect issues early and improve system reliability. Following best practices guarantees a resilient messaging infrastructure.
  </p>
</div>
`
},
     ]

}